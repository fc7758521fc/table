/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/
(function(global, factory) { /* global define, require, module */

    /* AMD */ if (typeof define === 'function' && define.amd)
        define(["protobufjs/minimal"], factory);

    /* CommonJS */ else if (typeof require === 'function' && typeof module === 'object' && module && module.exports)
        module.exports = factory(require("protobufjs/minimal"));

})(this, function($protobuf) {
    "use strict";

    // Common aliases
    var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;
    
    // Exported root namespace
    var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});
    
    $root.pb_player = (function() {
    
        /**
         * Properties of a pb_player.
         * @exports Ipb_player
         * @interface Ipb_player
         * @property {string} name pb_player name
         * @property {number} logo pb_player logo
         * @property {number|null} [gid] pb_player gid
         * @property {string|null} [gname] pb_player gname
         * @property {number|null} [border] pb_player border
         * @property {number|null} [glv] pb_player glv
         * @property {string|null} [country] pb_player country
         * @property {string|null} [sds] pb_player sds
         * @property {string|null} [city] pb_player city
         */
    
        /**
         * Constructs a new pb_player.
         * @exports pb_player
         * @classdesc Represents a pb_player.
         * @implements Ipb_player
         * @constructor
         * @param {Ipb_player=} [properties] Properties to set
         */
        function pb_player(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_player name.
         * @member {string} name
         * @memberof pb_player
         * @instance
         */
        pb_player.prototype.name = "";
    
        /**
         * pb_player logo.
         * @member {number} logo
         * @memberof pb_player
         * @instance
         */
        pb_player.prototype.logo = 0;
    
        /**
         * pb_player gid.
         * @member {number} gid
         * @memberof pb_player
         * @instance
         */
        pb_player.prototype.gid = 0;
    
        /**
         * pb_player gname.
         * @member {string} gname
         * @memberof pb_player
         * @instance
         */
        pb_player.prototype.gname = "";
    
        /**
         * pb_player border.
         * @member {number} border
         * @memberof pb_player
         * @instance
         */
        pb_player.prototype.border = 0;
    
        /**
         * pb_player glv.
         * @member {number} glv
         * @memberof pb_player
         * @instance
         */
        pb_player.prototype.glv = 0;
    
        /**
         * pb_player country.
         * @member {string} country
         * @memberof pb_player
         * @instance
         */
        pb_player.prototype.country = "";
    
        /**
         * pb_player sds.
         * @member {string} sds
         * @memberof pb_player
         * @instance
         */
        pb_player.prototype.sds = "";
    
        /**
         * pb_player city.
         * @member {string} city
         * @memberof pb_player
         * @instance
         */
        pb_player.prototype.city = "";
    
        /**
         * Creates a new pb_player instance using the specified properties.
         * @function create
         * @memberof pb_player
         * @static
         * @param {Ipb_player=} [properties] Properties to set
         * @returns {pb_player} pb_player instance
         */
        pb_player.create = function create(properties) {
            return new pb_player(properties);
        };
    
        /**
         * Encodes the specified pb_player message. Does not implicitly {@link pb_player.verify|verify} messages.
         * @function encode
         * @memberof pb_player
         * @static
         * @param {Ipb_player} message pb_player message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_player.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.logo);
            if (message.gid != null && Object.hasOwnProperty.call(message, "gid"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.gid);
            if (message.gname != null && Object.hasOwnProperty.call(message, "gname"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.gname);
            if (message.border != null && Object.hasOwnProperty.call(message, "border"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.border);
            if (message.glv != null && Object.hasOwnProperty.call(message, "glv"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.glv);
            if (message.country != null && Object.hasOwnProperty.call(message, "country"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.country);
            if (message.sds != null && Object.hasOwnProperty.call(message, "sds"))
                writer.uint32(/* id 8, wireType 2 =*/66).string(message.sds);
            if (message.city != null && Object.hasOwnProperty.call(message, "city"))
                writer.uint32(/* id 9, wireType 2 =*/74).string(message.city);
            return writer;
        };
    
        /**
         * Encodes the specified pb_player message, length delimited. Does not implicitly {@link pb_player.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_player
         * @static
         * @param {Ipb_player} message pb_player message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_player.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_player message from the specified reader or buffer.
         * @function decode
         * @memberof pb_player
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_player} pb_player
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_player.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_player();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.name = reader.string();
                        break;
                    }
                case 2: {
                        message.logo = reader.int32();
                        break;
                    }
                case 3: {
                        message.gid = reader.int32();
                        break;
                    }
                case 4: {
                        message.gname = reader.string();
                        break;
                    }
                case 5: {
                        message.border = reader.int32();
                        break;
                    }
                case 6: {
                        message.glv = reader.int32();
                        break;
                    }
                case 7: {
                        message.country = reader.string();
                        break;
                    }
                case 8: {
                        message.sds = reader.string();
                        break;
                    }
                case 9: {
                        message.city = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("name"))
                throw $util.ProtocolError("missing required 'name'", { instance: message });
            if (!message.hasOwnProperty("logo"))
                throw $util.ProtocolError("missing required 'logo'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a pb_player message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_player
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_player} pb_player
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_player.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_player message.
         * @function verify
         * @memberof pb_player
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_player.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isString(message.name))
                return "name: string expected";
            if (!$util.isInteger(message.logo))
                return "logo: integer expected";
            if (message.gid != null && message.hasOwnProperty("gid"))
                if (!$util.isInteger(message.gid))
                    return "gid: integer expected";
            if (message.gname != null && message.hasOwnProperty("gname"))
                if (!$util.isString(message.gname))
                    return "gname: string expected";
            if (message.border != null && message.hasOwnProperty("border"))
                if (!$util.isInteger(message.border))
                    return "border: integer expected";
            if (message.glv != null && message.hasOwnProperty("glv"))
                if (!$util.isInteger(message.glv))
                    return "glv: integer expected";
            if (message.country != null && message.hasOwnProperty("country"))
                if (!$util.isString(message.country))
                    return "country: string expected";
            if (message.sds != null && message.hasOwnProperty("sds"))
                if (!$util.isString(message.sds))
                    return "sds: string expected";
            if (message.city != null && message.hasOwnProperty("city"))
                if (!$util.isString(message.city))
                    return "city: string expected";
            return null;
        };
    
        /**
         * Creates a pb_player message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_player
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_player} pb_player
         */
        pb_player.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_player)
                return object;
            var message = new $root.pb_player();
            if (object.name != null)
                message.name = String(object.name);
            if (object.logo != null)
                message.logo = object.logo | 0;
            if (object.gid != null)
                message.gid = object.gid | 0;
            if (object.gname != null)
                message.gname = String(object.gname);
            if (object.border != null)
                message.border = object.border | 0;
            if (object.glv != null)
                message.glv = object.glv | 0;
            if (object.country != null)
                message.country = String(object.country);
            if (object.sds != null)
                message.sds = String(object.sds);
            if (object.city != null)
                message.city = String(object.city);
            return message;
        };
    
        /**
         * Creates a plain object from a pb_player message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_player
         * @static
         * @param {pb_player} message pb_player
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_player.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.name = "";
                object.logo = 0;
                object.gid = 0;
                object.gname = "";
                object.border = 0;
                object.glv = 0;
                object.country = "";
                object.sds = "";
                object.city = "";
            }
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.logo != null && message.hasOwnProperty("logo"))
                object.logo = message.logo;
            if (message.gid != null && message.hasOwnProperty("gid"))
                object.gid = message.gid;
            if (message.gname != null && message.hasOwnProperty("gname"))
                object.gname = message.gname;
            if (message.border != null && message.hasOwnProperty("border"))
                object.border = message.border;
            if (message.glv != null && message.hasOwnProperty("glv"))
                object.glv = message.glv;
            if (message.country != null && message.hasOwnProperty("country"))
                object.country = message.country;
            if (message.sds != null && message.hasOwnProperty("sds"))
                object.sds = message.sds;
            if (message.city != null && message.hasOwnProperty("city"))
                object.city = message.city;
            return object;
        };
    
        /**
         * Converts this pb_player to JSON.
         * @function toJSON
         * @memberof pb_player
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_player.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_player
         * @function getTypeUrl
         * @memberof pb_player
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_player.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_player";
        };
    
        return pb_player;
    })();
    
    $root.pb_server = (function() {
    
        /**
         * Properties of a pb_server.
         * @exports Ipb_server
         * @interface Ipb_server
         * @property {number} sid pb_server sid
         * @property {string} sname pb_server sname
         * @property {string|null} [pname] pb_server pname
         * @property {number|null} [plogo] pb_server plogo
         * @property {number|null} [plv] pb_server plv
         * @property {number|null} [flag] pb_server flag
         * @property {number|null} [uid] pb_server uid
         * @property {number|null} [border] pb_server border
         * @property {number|null} [loginCd] pb_server loginCd
         */
    
        /**
         * Constructs a new pb_server.
         * @exports pb_server
         * @classdesc Represents a pb_server.
         * @implements Ipb_server
         * @constructor
         * @param {Ipb_server=} [properties] Properties to set
         */
        function pb_server(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_server sid.
         * @member {number} sid
         * @memberof pb_server
         * @instance
         */
        pb_server.prototype.sid = 0;
    
        /**
         * pb_server sname.
         * @member {string} sname
         * @memberof pb_server
         * @instance
         */
        pb_server.prototype.sname = "";
    
        /**
         * pb_server pname.
         * @member {string} pname
         * @memberof pb_server
         * @instance
         */
        pb_server.prototype.pname = "";
    
        /**
         * pb_server plogo.
         * @member {number} plogo
         * @memberof pb_server
         * @instance
         */
        pb_server.prototype.plogo = 0;
    
        /**
         * pb_server plv.
         * @member {number} plv
         * @memberof pb_server
         * @instance
         */
        pb_server.prototype.plv = 0;
    
        /**
         * pb_server flag.
         * @member {number} flag
         * @memberof pb_server
         * @instance
         */
        pb_server.prototype.flag = 0;
    
        /**
         * pb_server uid.
         * @member {number} uid
         * @memberof pb_server
         * @instance
         */
        pb_server.prototype.uid = 0;
    
        /**
         * pb_server border.
         * @member {number} border
         * @memberof pb_server
         * @instance
         */
        pb_server.prototype.border = 0;
    
        /**
         * pb_server loginCd.
         * @member {number} loginCd
         * @memberof pb_server
         * @instance
         */
        pb_server.prototype.loginCd = 0;
    
        /**
         * Creates a new pb_server instance using the specified properties.
         * @function create
         * @memberof pb_server
         * @static
         * @param {Ipb_server=} [properties] Properties to set
         * @returns {pb_server} pb_server instance
         */
        pb_server.create = function create(properties) {
            return new pb_server(properties);
        };
    
        /**
         * Encodes the specified pb_server message. Does not implicitly {@link pb_server.verify|verify} messages.
         * @function encode
         * @memberof pb_server
         * @static
         * @param {Ipb_server} message pb_server message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_server.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.sid);
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.sname);
            if (message.pname != null && Object.hasOwnProperty.call(message, "pname"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.pname);
            if (message.plogo != null && Object.hasOwnProperty.call(message, "plogo"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.plogo);
            if (message.plv != null && Object.hasOwnProperty.call(message, "plv"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.plv);
            if (message.flag != null && Object.hasOwnProperty.call(message, "flag"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.flag);
            if (message.uid != null && Object.hasOwnProperty.call(message, "uid"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.uid);
            if (message.border != null && Object.hasOwnProperty.call(message, "border"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.border);
            if (message.loginCd != null && Object.hasOwnProperty.call(message, "loginCd"))
                writer.uint32(/* id 9, wireType 0 =*/72).int32(message.loginCd);
            return writer;
        };
    
        /**
         * Encodes the specified pb_server message, length delimited. Does not implicitly {@link pb_server.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_server
         * @static
         * @param {Ipb_server} message pb_server message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_server.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_server message from the specified reader or buffer.
         * @function decode
         * @memberof pb_server
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_server} pb_server
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_server.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_server();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.sid = reader.int32();
                        break;
                    }
                case 2: {
                        message.sname = reader.string();
                        break;
                    }
                case 3: {
                        message.pname = reader.string();
                        break;
                    }
                case 4: {
                        message.plogo = reader.int32();
                        break;
                    }
                case 5: {
                        message.plv = reader.int32();
                        break;
                    }
                case 6: {
                        message.flag = reader.int32();
                        break;
                    }
                case 7: {
                        message.uid = reader.int32();
                        break;
                    }
                case 8: {
                        message.border = reader.int32();
                        break;
                    }
                case 9: {
                        message.loginCd = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("sid"))
                throw $util.ProtocolError("missing required 'sid'", { instance: message });
            if (!message.hasOwnProperty("sname"))
                throw $util.ProtocolError("missing required 'sname'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a pb_server message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_server
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_server} pb_server
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_server.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_server message.
         * @function verify
         * @memberof pb_server
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_server.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.sid))
                return "sid: integer expected";
            if (!$util.isString(message.sname))
                return "sname: string expected";
            if (message.pname != null && message.hasOwnProperty("pname"))
                if (!$util.isString(message.pname))
                    return "pname: string expected";
            if (message.plogo != null && message.hasOwnProperty("plogo"))
                if (!$util.isInteger(message.plogo))
                    return "plogo: integer expected";
            if (message.plv != null && message.hasOwnProperty("plv"))
                if (!$util.isInteger(message.plv))
                    return "plv: integer expected";
            if (message.flag != null && message.hasOwnProperty("flag"))
                if (!$util.isInteger(message.flag))
                    return "flag: integer expected";
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (!$util.isInteger(message.uid))
                    return "uid: integer expected";
            if (message.border != null && message.hasOwnProperty("border"))
                if (!$util.isInteger(message.border))
                    return "border: integer expected";
            if (message.loginCd != null && message.hasOwnProperty("loginCd"))
                if (!$util.isInteger(message.loginCd))
                    return "loginCd: integer expected";
            return null;
        };
    
        /**
         * Creates a pb_server message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_server
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_server} pb_server
         */
        pb_server.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_server)
                return object;
            var message = new $root.pb_server();
            if (object.sid != null)
                message.sid = object.sid | 0;
            if (object.sname != null)
                message.sname = String(object.sname);
            if (object.pname != null)
                message.pname = String(object.pname);
            if (object.plogo != null)
                message.plogo = object.plogo | 0;
            if (object.plv != null)
                message.plv = object.plv | 0;
            if (object.flag != null)
                message.flag = object.flag | 0;
            if (object.uid != null)
                message.uid = object.uid | 0;
            if (object.border != null)
                message.border = object.border | 0;
            if (object.loginCd != null)
                message.loginCd = object.loginCd | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a pb_server message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_server
         * @static
         * @param {pb_server} message pb_server
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_server.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.sid = 0;
                object.sname = "";
                object.pname = "";
                object.plogo = 0;
                object.plv = 0;
                object.flag = 0;
                object.uid = 0;
                object.border = 0;
                object.loginCd = 0;
            }
            if (message.sid != null && message.hasOwnProperty("sid"))
                object.sid = message.sid;
            if (message.sname != null && message.hasOwnProperty("sname"))
                object.sname = message.sname;
            if (message.pname != null && message.hasOwnProperty("pname"))
                object.pname = message.pname;
            if (message.plogo != null && message.hasOwnProperty("plogo"))
                object.plogo = message.plogo;
            if (message.plv != null && message.hasOwnProperty("plv"))
                object.plv = message.plv;
            if (message.flag != null && message.hasOwnProperty("flag"))
                object.flag = message.flag;
            if (message.uid != null && message.hasOwnProperty("uid"))
                object.uid = message.uid;
            if (message.border != null && message.hasOwnProperty("border"))
                object.border = message.border;
            if (message.loginCd != null && message.hasOwnProperty("loginCd"))
                object.loginCd = message.loginCd;
            return object;
        };
    
        /**
         * Converts this pb_server to JSON.
         * @function toJSON
         * @memberof pb_server
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_server.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_server
         * @function getTypeUrl
         * @memberof pb_server
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_server.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_server";
        };
    
        return pb_server;
    })();
    
    $root.pb_item = (function() {
    
        /**
         * Properties of a pb_item.
         * @exports Ipb_item
         * @interface Ipb_item
         * @property {number} id pb_item id
         * @property {number|Long} num pb_item num
         */
    
        /**
         * Constructs a new pb_item.
         * @exports pb_item
         * @classdesc Represents a pb_item.
         * @implements Ipb_item
         * @constructor
         * @param {Ipb_item=} [properties] Properties to set
         */
        function pb_item(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_item id.
         * @member {number} id
         * @memberof pb_item
         * @instance
         */
        pb_item.prototype.id = 0;
    
        /**
         * pb_item num.
         * @member {number|Long} num
         * @memberof pb_item
         * @instance
         */
        pb_item.prototype.num = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * Creates a new pb_item instance using the specified properties.
         * @function create
         * @memberof pb_item
         * @static
         * @param {Ipb_item=} [properties] Properties to set
         * @returns {pb_item} pb_item instance
         */
        pb_item.create = function create(properties) {
            return new pb_item(properties);
        };
    
        /**
         * Encodes the specified pb_item message. Does not implicitly {@link pb_item.verify|verify} messages.
         * @function encode
         * @memberof pb_item
         * @static
         * @param {Ipb_item} message pb_item message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_item.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.id);
            writer.uint32(/* id 2, wireType 0 =*/16).int64(message.num);
            return writer;
        };
    
        /**
         * Encodes the specified pb_item message, length delimited. Does not implicitly {@link pb_item.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_item
         * @static
         * @param {Ipb_item} message pb_item message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_item.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_item message from the specified reader or buffer.
         * @function decode
         * @memberof pb_item
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_item} pb_item
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_item.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_item();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.id = reader.int32();
                        break;
                    }
                case 2: {
                        message.num = reader.int64();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("id"))
                throw $util.ProtocolError("missing required 'id'", { instance: message });
            if (!message.hasOwnProperty("num"))
                throw $util.ProtocolError("missing required 'num'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a pb_item message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_item
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_item} pb_item
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_item.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_item message.
         * @function verify
         * @memberof pb_item
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_item.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.id))
                return "id: integer expected";
            if (!$util.isInteger(message.num) && !(message.num && $util.isInteger(message.num.low) && $util.isInteger(message.num.high)))
                return "num: integer|Long expected";
            return null;
        };
    
        /**
         * Creates a pb_item message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_item
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_item} pb_item
         */
        pb_item.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_item)
                return object;
            var message = new $root.pb_item();
            if (object.id != null)
                message.id = object.id | 0;
            if (object.num != null)
                if ($util.Long)
                    (message.num = $util.Long.fromValue(object.num)).unsigned = false;
                else if (typeof object.num === "string")
                    message.num = parseInt(object.num, 10);
                else if (typeof object.num === "number")
                    message.num = object.num;
                else if (typeof object.num === "object")
                    message.num = new $util.LongBits(object.num.low >>> 0, object.num.high >>> 0).toNumber();
            return message;
        };
    
        /**
         * Creates a plain object from a pb_item message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_item
         * @static
         * @param {pb_item} message pb_item
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_item.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.num = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.num = options.longs === String ? "0" : 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.num != null && message.hasOwnProperty("num"))
                if (typeof message.num === "number")
                    object.num = options.longs === String ? String(message.num) : message.num;
                else
                    object.num = options.longs === String ? $util.Long.prototype.toString.call(message.num) : options.longs === Number ? new $util.LongBits(message.num.low >>> 0, message.num.high >>> 0).toNumber() : message.num;
            return object;
        };
    
        /**
         * Converts this pb_item to JSON.
         * @function toJSON
         * @memberof pb_item
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_item.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_item
         * @function getTypeUrl
         * @memberof pb_item
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_item.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_item";
        };
    
        return pb_item;
    })();
    
    $root.pb_equip = (function() {
    
        /**
         * Properties of a pb_equip.
         * @exports Ipb_equip
         * @interface Ipb_equip
         * @property {number} id pb_equip id
         * @property {number} num pb_equip num
         * @property {number|null} [eid] pb_equip eid
         * @property {number|null} [hid] pb_equip hid
         */
    
        /**
         * Constructs a new pb_equip.
         * @exports pb_equip
         * @classdesc Represents a pb_equip.
         * @implements Ipb_equip
         * @constructor
         * @param {Ipb_equip=} [properties] Properties to set
         */
        function pb_equip(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_equip id.
         * @member {number} id
         * @memberof pb_equip
         * @instance
         */
        pb_equip.prototype.id = 0;
    
        /**
         * pb_equip num.
         * @member {number} num
         * @memberof pb_equip
         * @instance
         */
        pb_equip.prototype.num = 0;
    
        /**
         * pb_equip eid.
         * @member {number} eid
         * @memberof pb_equip
         * @instance
         */
        pb_equip.prototype.eid = 0;
    
        /**
         * pb_equip hid.
         * @member {number} hid
         * @memberof pb_equip
         * @instance
         */
        pb_equip.prototype.hid = 0;
    
        /**
         * Creates a new pb_equip instance using the specified properties.
         * @function create
         * @memberof pb_equip
         * @static
         * @param {Ipb_equip=} [properties] Properties to set
         * @returns {pb_equip} pb_equip instance
         */
        pb_equip.create = function create(properties) {
            return new pb_equip(properties);
        };
    
        /**
         * Encodes the specified pb_equip message. Does not implicitly {@link pb_equip.verify|verify} messages.
         * @function encode
         * @memberof pb_equip
         * @static
         * @param {Ipb_equip} message pb_equip message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_equip.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.id);
            writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.num);
            if (message.eid != null && Object.hasOwnProperty.call(message, "eid"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.eid);
            if (message.hid != null && Object.hasOwnProperty.call(message, "hid"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.hid);
            return writer;
        };
    
        /**
         * Encodes the specified pb_equip message, length delimited. Does not implicitly {@link pb_equip.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_equip
         * @static
         * @param {Ipb_equip} message pb_equip message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_equip.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_equip message from the specified reader or buffer.
         * @function decode
         * @memberof pb_equip
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_equip} pb_equip
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_equip.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_equip();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.id = reader.int32();
                        break;
                    }
                case 2: {
                        message.num = reader.uint32();
                        break;
                    }
                case 3: {
                        message.eid = reader.int32();
                        break;
                    }
                case 4: {
                        message.hid = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("id"))
                throw $util.ProtocolError("missing required 'id'", { instance: message });
            if (!message.hasOwnProperty("num"))
                throw $util.ProtocolError("missing required 'num'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a pb_equip message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_equip
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_equip} pb_equip
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_equip.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_equip message.
         * @function verify
         * @memberof pb_equip
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_equip.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.id))
                return "id: integer expected";
            if (!$util.isInteger(message.num))
                return "num: integer expected";
            if (message.eid != null && message.hasOwnProperty("eid"))
                if (!$util.isInteger(message.eid))
                    return "eid: integer expected";
            if (message.hid != null && message.hasOwnProperty("hid"))
                if (!$util.isInteger(message.hid))
                    return "hid: integer expected";
            return null;
        };
    
        /**
         * Creates a pb_equip message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_equip
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_equip} pb_equip
         */
        pb_equip.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_equip)
                return object;
            var message = new $root.pb_equip();
            if (object.id != null)
                message.id = object.id | 0;
            if (object.num != null)
                message.num = object.num >>> 0;
            if (object.eid != null)
                message.eid = object.eid | 0;
            if (object.hid != null)
                message.hid = object.hid | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a pb_equip message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_equip
         * @static
         * @param {pb_equip} message pb_equip
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_equip.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = 0;
                object.num = 0;
                object.eid = 0;
                object.hid = 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.num != null && message.hasOwnProperty("num"))
                object.num = message.num;
            if (message.eid != null && message.hasOwnProperty("eid"))
                object.eid = message.eid;
            if (message.hid != null && message.hasOwnProperty("hid"))
                object.hid = message.hid;
            return object;
        };
    
        /**
         * Converts this pb_equip to JSON.
         * @function toJSON
         * @memberof pb_equip
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_equip.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_equip
         * @function getTypeUrl
         * @memberof pb_equip
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_equip.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_equip";
        };
    
        return pb_equip;
    })();
    
    $root.pb_bag = (function() {
    
        /**
         * Properties of a pb_bag.
         * @exports Ipb_bag
         * @interface Ipb_bag
         * @property {Array.<Ipb_item>|null} [items] pb_bag items
         * @property {Array.<Ipb_equip>|null} [equips] pb_bag equips
         */
    
        /**
         * Constructs a new pb_bag.
         * @exports pb_bag
         * @classdesc Represents a pb_bag.
         * @implements Ipb_bag
         * @constructor
         * @param {Ipb_bag=} [properties] Properties to set
         */
        function pb_bag(properties) {
            this.items = [];
            this.equips = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_bag items.
         * @member {Array.<Ipb_item>} items
         * @memberof pb_bag
         * @instance
         */
        pb_bag.prototype.items = $util.emptyArray;
    
        /**
         * pb_bag equips.
         * @member {Array.<Ipb_equip>} equips
         * @memberof pb_bag
         * @instance
         */
        pb_bag.prototype.equips = $util.emptyArray;
    
        /**
         * Creates a new pb_bag instance using the specified properties.
         * @function create
         * @memberof pb_bag
         * @static
         * @param {Ipb_bag=} [properties] Properties to set
         * @returns {pb_bag} pb_bag instance
         */
        pb_bag.create = function create(properties) {
            return new pb_bag(properties);
        };
    
        /**
         * Encodes the specified pb_bag message. Does not implicitly {@link pb_bag.verify|verify} messages.
         * @function encode
         * @memberof pb_bag
         * @static
         * @param {Ipb_bag} message pb_bag message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_bag.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.items != null && message.items.length)
                for (var i = 0; i < message.items.length; ++i)
                    $root.pb_item.encode(message.items[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.equips != null && message.equips.length)
                for (var i = 0; i < message.equips.length; ++i)
                    $root.pb_equip.encode(message.equips[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified pb_bag message, length delimited. Does not implicitly {@link pb_bag.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_bag
         * @static
         * @param {Ipb_bag} message pb_bag message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_bag.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_bag message from the specified reader or buffer.
         * @function decode
         * @memberof pb_bag
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_bag} pb_bag
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_bag.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_bag();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.items && message.items.length))
                            message.items = [];
                        message.items.push($root.pb_item.decode(reader, reader.uint32()));
                        break;
                    }
                case 2: {
                        if (!(message.equips && message.equips.length))
                            message.equips = [];
                        message.equips.push($root.pb_equip.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a pb_bag message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_bag
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_bag} pb_bag
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_bag.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_bag message.
         * @function verify
         * @memberof pb_bag
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_bag.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.items != null && message.hasOwnProperty("items")) {
                if (!Array.isArray(message.items))
                    return "items: array expected";
                for (var i = 0; i < message.items.length; ++i) {
                    var error = $root.pb_item.verify(message.items[i]);
                    if (error)
                        return "items." + error;
                }
            }
            if (message.equips != null && message.hasOwnProperty("equips")) {
                if (!Array.isArray(message.equips))
                    return "equips: array expected";
                for (var i = 0; i < message.equips.length; ++i) {
                    var error = $root.pb_equip.verify(message.equips[i]);
                    if (error)
                        return "equips." + error;
                }
            }
            return null;
        };
    
        /**
         * Creates a pb_bag message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_bag
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_bag} pb_bag
         */
        pb_bag.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_bag)
                return object;
            var message = new $root.pb_bag();
            if (object.items) {
                if (!Array.isArray(object.items))
                    throw TypeError(".pb_bag.items: array expected");
                message.items = [];
                for (var i = 0; i < object.items.length; ++i) {
                    if (typeof object.items[i] !== "object")
                        throw TypeError(".pb_bag.items: object expected");
                    message.items[i] = $root.pb_item.fromObject(object.items[i]);
                }
            }
            if (object.equips) {
                if (!Array.isArray(object.equips))
                    throw TypeError(".pb_bag.equips: array expected");
                message.equips = [];
                for (var i = 0; i < object.equips.length; ++i) {
                    if (typeof object.equips[i] !== "object")
                        throw TypeError(".pb_bag.equips: object expected");
                    message.equips[i] = $root.pb_equip.fromObject(object.equips[i]);
                }
            }
            return message;
        };
    
        /**
         * Creates a plain object from a pb_bag message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_bag
         * @static
         * @param {pb_bag} message pb_bag
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_bag.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.items = [];
                object.equips = [];
            }
            if (message.items && message.items.length) {
                object.items = [];
                for (var j = 0; j < message.items.length; ++j)
                    object.items[j] = $root.pb_item.toObject(message.items[j], options);
            }
            if (message.equips && message.equips.length) {
                object.equips = [];
                for (var j = 0; j < message.equips.length; ++j)
                    object.equips[j] = $root.pb_equip.toObject(message.equips[j], options);
            }
            return object;
        };
    
        /**
         * Converts this pb_bag to JSON.
         * @function toJSON
         * @memberof pb_bag
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_bag.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_bag
         * @function getTypeUrl
         * @memberof pb_bag
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_bag.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_bag";
        };
    
        return pb_bag;
    })();
    
    $root.pb_hero_qlc = (function() {
    
        /**
         * Properties of a pb_hero_qlc.
         * @exports Ipb_hero_qlc
         * @interface Ipb_hero_qlc
         * @property {number|null} [lv] pb_hero_qlc lv
         * @property {number|null} [atk] pb_hero_qlc atk
         * @property {number|null} [hp] pb_hero_qlc hp
         * @property {number|null} [spd] pb_hero_qlc spd
         * @property {number|Long|null} [attrIdx] pb_hero_qlc attrIdx
         * @property {number|null} [time] pb_hero_qlc time
         * @property {number|null} [cd] pb_hero_qlc cd
         */
    
        /**
         * Constructs a new pb_hero_qlc.
         * @exports pb_hero_qlc
         * @classdesc Represents a pb_hero_qlc.
         * @implements Ipb_hero_qlc
         * @constructor
         * @param {Ipb_hero_qlc=} [properties] Properties to set
         */
        function pb_hero_qlc(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_hero_qlc lv.
         * @member {number} lv
         * @memberof pb_hero_qlc
         * @instance
         */
        pb_hero_qlc.prototype.lv = 0;
    
        /**
         * pb_hero_qlc atk.
         * @member {number} atk
         * @memberof pb_hero_qlc
         * @instance
         */
        pb_hero_qlc.prototype.atk = 0;
    
        /**
         * pb_hero_qlc hp.
         * @member {number} hp
         * @memberof pb_hero_qlc
         * @instance
         */
        pb_hero_qlc.prototype.hp = 0;
    
        /**
         * pb_hero_qlc spd.
         * @member {number} spd
         * @memberof pb_hero_qlc
         * @instance
         */
        pb_hero_qlc.prototype.spd = 0;
    
        /**
         * pb_hero_qlc attrIdx.
         * @member {number|Long} attrIdx
         * @memberof pb_hero_qlc
         * @instance
         */
        pb_hero_qlc.prototype.attrIdx = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * pb_hero_qlc time.
         * @member {number} time
         * @memberof pb_hero_qlc
         * @instance
         */
        pb_hero_qlc.prototype.time = 0;
    
        /**
         * pb_hero_qlc cd.
         * @member {number} cd
         * @memberof pb_hero_qlc
         * @instance
         */
        pb_hero_qlc.prototype.cd = 0;
    
        /**
         * Creates a new pb_hero_qlc instance using the specified properties.
         * @function create
         * @memberof pb_hero_qlc
         * @static
         * @param {Ipb_hero_qlc=} [properties] Properties to set
         * @returns {pb_hero_qlc} pb_hero_qlc instance
         */
        pb_hero_qlc.create = function create(properties) {
            return new pb_hero_qlc(properties);
        };
    
        /**
         * Encodes the specified pb_hero_qlc message. Does not implicitly {@link pb_hero_qlc.verify|verify} messages.
         * @function encode
         * @memberof pb_hero_qlc
         * @static
         * @param {Ipb_hero_qlc} message pb_hero_qlc message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_hero_qlc.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.lv != null && Object.hasOwnProperty.call(message, "lv"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.lv);
            if (message.atk != null && Object.hasOwnProperty.call(message, "atk"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.atk);
            if (message.hp != null && Object.hasOwnProperty.call(message, "hp"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.hp);
            if (message.spd != null && Object.hasOwnProperty.call(message, "spd"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.spd);
            if (message.attrIdx != null && Object.hasOwnProperty.call(message, "attrIdx"))
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.attrIdx);
            if (message.time != null && Object.hasOwnProperty.call(message, "time"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.time);
            if (message.cd != null && Object.hasOwnProperty.call(message, "cd"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.cd);
            return writer;
        };
    
        /**
         * Encodes the specified pb_hero_qlc message, length delimited. Does not implicitly {@link pb_hero_qlc.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_hero_qlc
         * @static
         * @param {Ipb_hero_qlc} message pb_hero_qlc message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_hero_qlc.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_hero_qlc message from the specified reader or buffer.
         * @function decode
         * @memberof pb_hero_qlc
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_hero_qlc} pb_hero_qlc
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_hero_qlc.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_hero_qlc();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.lv = reader.int32();
                        break;
                    }
                case 2: {
                        message.atk = reader.int32();
                        break;
                    }
                case 3: {
                        message.hp = reader.int32();
                        break;
                    }
                case 4: {
                        message.spd = reader.int32();
                        break;
                    }
                case 5: {
                        message.attrIdx = reader.int64();
                        break;
                    }
                case 6: {
                        message.time = reader.int32();
                        break;
                    }
                case 7: {
                        message.cd = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a pb_hero_qlc message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_hero_qlc
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_hero_qlc} pb_hero_qlc
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_hero_qlc.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_hero_qlc message.
         * @function verify
         * @memberof pb_hero_qlc
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_hero_qlc.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.lv != null && message.hasOwnProperty("lv"))
                if (!$util.isInteger(message.lv))
                    return "lv: integer expected";
            if (message.atk != null && message.hasOwnProperty("atk"))
                if (!$util.isInteger(message.atk))
                    return "atk: integer expected";
            if (message.hp != null && message.hasOwnProperty("hp"))
                if (!$util.isInteger(message.hp))
                    return "hp: integer expected";
            if (message.spd != null && message.hasOwnProperty("spd"))
                if (!$util.isInteger(message.spd))
                    return "spd: integer expected";
            if (message.attrIdx != null && message.hasOwnProperty("attrIdx"))
                if (!$util.isInteger(message.attrIdx) && !(message.attrIdx && $util.isInteger(message.attrIdx.low) && $util.isInteger(message.attrIdx.high)))
                    return "attrIdx: integer|Long expected";
            if (message.time != null && message.hasOwnProperty("time"))
                if (!$util.isInteger(message.time))
                    return "time: integer expected";
            if (message.cd != null && message.hasOwnProperty("cd"))
                if (!$util.isInteger(message.cd))
                    return "cd: integer expected";
            return null;
        };
    
        /**
         * Creates a pb_hero_qlc message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_hero_qlc
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_hero_qlc} pb_hero_qlc
         */
        pb_hero_qlc.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_hero_qlc)
                return object;
            var message = new $root.pb_hero_qlc();
            if (object.lv != null)
                message.lv = object.lv | 0;
            if (object.atk != null)
                message.atk = object.atk | 0;
            if (object.hp != null)
                message.hp = object.hp | 0;
            if (object.spd != null)
                message.spd = object.spd | 0;
            if (object.attrIdx != null)
                if ($util.Long)
                    (message.attrIdx = $util.Long.fromValue(object.attrIdx)).unsigned = false;
                else if (typeof object.attrIdx === "string")
                    message.attrIdx = parseInt(object.attrIdx, 10);
                else if (typeof object.attrIdx === "number")
                    message.attrIdx = object.attrIdx;
                else if (typeof object.attrIdx === "object")
                    message.attrIdx = new $util.LongBits(object.attrIdx.low >>> 0, object.attrIdx.high >>> 0).toNumber();
            if (object.time != null)
                message.time = object.time | 0;
            if (object.cd != null)
                message.cd = object.cd | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a pb_hero_qlc message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_hero_qlc
         * @static
         * @param {pb_hero_qlc} message pb_hero_qlc
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_hero_qlc.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.lv = 0;
                object.atk = 0;
                object.hp = 0;
                object.spd = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.attrIdx = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.attrIdx = options.longs === String ? "0" : 0;
                object.time = 0;
                object.cd = 0;
            }
            if (message.lv != null && message.hasOwnProperty("lv"))
                object.lv = message.lv;
            if (message.atk != null && message.hasOwnProperty("atk"))
                object.atk = message.atk;
            if (message.hp != null && message.hasOwnProperty("hp"))
                object.hp = message.hp;
            if (message.spd != null && message.hasOwnProperty("spd"))
                object.spd = message.spd;
            if (message.attrIdx != null && message.hasOwnProperty("attrIdx"))
                if (typeof message.attrIdx === "number")
                    object.attrIdx = options.longs === String ? String(message.attrIdx) : message.attrIdx;
                else
                    object.attrIdx = options.longs === String ? $util.Long.prototype.toString.call(message.attrIdx) : options.longs === Number ? new $util.LongBits(message.attrIdx.low >>> 0, message.attrIdx.high >>> 0).toNumber() : message.attrIdx;
            if (message.time != null && message.hasOwnProperty("time"))
                object.time = message.time;
            if (message.cd != null && message.hasOwnProperty("cd"))
                object.cd = message.cd;
            return object;
        };
    
        /**
         * Converts this pb_hero_qlc to JSON.
         * @function toJSON
         * @memberof pb_hero_qlc
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_hero_qlc.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_hero_qlc
         * @function getTypeUrl
         * @memberof pb_hero_qlc
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_hero_qlc.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_hero_qlc";
        };
    
        return pb_hero_qlc;
    })();
    
    $root.pb_hero_qlt = (function() {
    
        /**
         * Properties of a pb_hero_qlt.
         * @exports Ipb_hero_qlt
         * @interface Ipb_hero_qlt
         * @property {Ipb_hero_qlc|null} [qlc] pb_hero_qlt qlc
         * @property {Array.<Ipb_hero_qlc>|null} [qlcs] pb_hero_qlt qlcs
         * @property {number|Long|null} [attrIdx] pb_hero_qlt attrIdx
         */
    
        /**
         * Constructs a new pb_hero_qlt.
         * @exports pb_hero_qlt
         * @classdesc Represents a pb_hero_qlt.
         * @implements Ipb_hero_qlt
         * @constructor
         * @param {Ipb_hero_qlt=} [properties] Properties to set
         */
        function pb_hero_qlt(properties) {
            this.qlcs = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_hero_qlt qlc.
         * @member {Ipb_hero_qlc|null|undefined} qlc
         * @memberof pb_hero_qlt
         * @instance
         */
        pb_hero_qlt.prototype.qlc = null;
    
        /**
         * pb_hero_qlt qlcs.
         * @member {Array.<Ipb_hero_qlc>} qlcs
         * @memberof pb_hero_qlt
         * @instance
         */
        pb_hero_qlt.prototype.qlcs = $util.emptyArray;
    
        /**
         * pb_hero_qlt attrIdx.
         * @member {number|Long} attrIdx
         * @memberof pb_hero_qlt
         * @instance
         */
        pb_hero_qlt.prototype.attrIdx = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * Creates a new pb_hero_qlt instance using the specified properties.
         * @function create
         * @memberof pb_hero_qlt
         * @static
         * @param {Ipb_hero_qlt=} [properties] Properties to set
         * @returns {pb_hero_qlt} pb_hero_qlt instance
         */
        pb_hero_qlt.create = function create(properties) {
            return new pb_hero_qlt(properties);
        };
    
        /**
         * Encodes the specified pb_hero_qlt message. Does not implicitly {@link pb_hero_qlt.verify|verify} messages.
         * @function encode
         * @memberof pb_hero_qlt
         * @static
         * @param {Ipb_hero_qlt} message pb_hero_qlt message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_hero_qlt.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.qlc != null && Object.hasOwnProperty.call(message, "qlc"))
                $root.pb_hero_qlc.encode(message.qlc, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.qlcs != null && message.qlcs.length)
                for (var i = 0; i < message.qlcs.length; ++i)
                    $root.pb_hero_qlc.encode(message.qlcs[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.attrIdx != null && Object.hasOwnProperty.call(message, "attrIdx"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.attrIdx);
            return writer;
        };
    
        /**
         * Encodes the specified pb_hero_qlt message, length delimited. Does not implicitly {@link pb_hero_qlt.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_hero_qlt
         * @static
         * @param {Ipb_hero_qlt} message pb_hero_qlt message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_hero_qlt.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_hero_qlt message from the specified reader or buffer.
         * @function decode
         * @memberof pb_hero_qlt
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_hero_qlt} pb_hero_qlt
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_hero_qlt.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_hero_qlt();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.qlc = $root.pb_hero_qlc.decode(reader, reader.uint32());
                        break;
                    }
                case 2: {
                        if (!(message.qlcs && message.qlcs.length))
                            message.qlcs = [];
                        message.qlcs.push($root.pb_hero_qlc.decode(reader, reader.uint32()));
                        break;
                    }
                case 3: {
                        message.attrIdx = reader.int64();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a pb_hero_qlt message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_hero_qlt
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_hero_qlt} pb_hero_qlt
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_hero_qlt.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_hero_qlt message.
         * @function verify
         * @memberof pb_hero_qlt
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_hero_qlt.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.qlc != null && message.hasOwnProperty("qlc")) {
                var error = $root.pb_hero_qlc.verify(message.qlc);
                if (error)
                    return "qlc." + error;
            }
            if (message.qlcs != null && message.hasOwnProperty("qlcs")) {
                if (!Array.isArray(message.qlcs))
                    return "qlcs: array expected";
                for (var i = 0; i < message.qlcs.length; ++i) {
                    var error = $root.pb_hero_qlc.verify(message.qlcs[i]);
                    if (error)
                        return "qlcs." + error;
                }
            }
            if (message.attrIdx != null && message.hasOwnProperty("attrIdx"))
                if (!$util.isInteger(message.attrIdx) && !(message.attrIdx && $util.isInteger(message.attrIdx.low) && $util.isInteger(message.attrIdx.high)))
                    return "attrIdx: integer|Long expected";
            return null;
        };
    
        /**
         * Creates a pb_hero_qlt message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_hero_qlt
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_hero_qlt} pb_hero_qlt
         */
        pb_hero_qlt.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_hero_qlt)
                return object;
            var message = new $root.pb_hero_qlt();
            if (object.qlc != null) {
                if (typeof object.qlc !== "object")
                    throw TypeError(".pb_hero_qlt.qlc: object expected");
                message.qlc = $root.pb_hero_qlc.fromObject(object.qlc);
            }
            if (object.qlcs) {
                if (!Array.isArray(object.qlcs))
                    throw TypeError(".pb_hero_qlt.qlcs: array expected");
                message.qlcs = [];
                for (var i = 0; i < object.qlcs.length; ++i) {
                    if (typeof object.qlcs[i] !== "object")
                        throw TypeError(".pb_hero_qlt.qlcs: object expected");
                    message.qlcs[i] = $root.pb_hero_qlc.fromObject(object.qlcs[i]);
                }
            }
            if (object.attrIdx != null)
                if ($util.Long)
                    (message.attrIdx = $util.Long.fromValue(object.attrIdx)).unsigned = false;
                else if (typeof object.attrIdx === "string")
                    message.attrIdx = parseInt(object.attrIdx, 10);
                else if (typeof object.attrIdx === "number")
                    message.attrIdx = object.attrIdx;
                else if (typeof object.attrIdx === "object")
                    message.attrIdx = new $util.LongBits(object.attrIdx.low >>> 0, object.attrIdx.high >>> 0).toNumber();
            return message;
        };
    
        /**
         * Creates a plain object from a pb_hero_qlt message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_hero_qlt
         * @static
         * @param {pb_hero_qlt} message pb_hero_qlt
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_hero_qlt.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.qlcs = [];
            if (options.defaults) {
                object.qlc = null;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.attrIdx = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.attrIdx = options.longs === String ? "0" : 0;
            }
            if (message.qlc != null && message.hasOwnProperty("qlc"))
                object.qlc = $root.pb_hero_qlc.toObject(message.qlc, options);
            if (message.qlcs && message.qlcs.length) {
                object.qlcs = [];
                for (var j = 0; j < message.qlcs.length; ++j)
                    object.qlcs[j] = $root.pb_hero_qlc.toObject(message.qlcs[j], options);
            }
            if (message.attrIdx != null && message.hasOwnProperty("attrIdx"))
                if (typeof message.attrIdx === "number")
                    object.attrIdx = options.longs === String ? String(message.attrIdx) : message.attrIdx;
                else
                    object.attrIdx = options.longs === String ? $util.Long.prototype.toString.call(message.attrIdx) : options.longs === Number ? new $util.LongBits(message.attrIdx.low >>> 0, message.attrIdx.high >>> 0).toNumber() : message.attrIdx;
            return object;
        };
    
        /**
         * Converts this pb_hero_qlt to JSON.
         * @function toJSON
         * @memberof pb_hero_qlt
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_hero_qlt.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_hero_qlt
         * @function getTypeUrl
         * @memberof pb_hero_qlt
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_hero_qlt.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_hero_qlt";
        };
    
        return pb_hero_qlt;
    })();
    
    $root.pb_tree = (function() {
    
        /**
         * Properties of a pb_tree.
         * @exports Ipb_tree
         * @interface Ipb_tree
         * @property {number|null} [lv] pb_tree lv
         * @property {number|null} [blv] pb_tree blv
         * @property {Array.<number>|null} [bra] pb_tree bra
         */
    
        /**
         * Constructs a new pb_tree.
         * @exports pb_tree
         * @classdesc Represents a pb_tree.
         * @implements Ipb_tree
         * @constructor
         * @param {Ipb_tree=} [properties] Properties to set
         */
        function pb_tree(properties) {
            this.bra = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_tree lv.
         * @member {number} lv
         * @memberof pb_tree
         * @instance
         */
        pb_tree.prototype.lv = 0;
    
        /**
         * pb_tree blv.
         * @member {number} blv
         * @memberof pb_tree
         * @instance
         */
        pb_tree.prototype.blv = 0;
    
        /**
         * pb_tree bra.
         * @member {Array.<number>} bra
         * @memberof pb_tree
         * @instance
         */
        pb_tree.prototype.bra = $util.emptyArray;
    
        /**
         * Creates a new pb_tree instance using the specified properties.
         * @function create
         * @memberof pb_tree
         * @static
         * @param {Ipb_tree=} [properties] Properties to set
         * @returns {pb_tree} pb_tree instance
         */
        pb_tree.create = function create(properties) {
            return new pb_tree(properties);
        };
    
        /**
         * Encodes the specified pb_tree message. Does not implicitly {@link pb_tree.verify|verify} messages.
         * @function encode
         * @memberof pb_tree
         * @static
         * @param {Ipb_tree} message pb_tree message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_tree.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.lv != null && Object.hasOwnProperty.call(message, "lv"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.lv);
            if (message.blv != null && Object.hasOwnProperty.call(message, "blv"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.blv);
            if (message.bra != null && message.bra.length)
                for (var i = 0; i < message.bra.length; ++i)
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.bra[i]);
            return writer;
        };
    
        /**
         * Encodes the specified pb_tree message, length delimited. Does not implicitly {@link pb_tree.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_tree
         * @static
         * @param {Ipb_tree} message pb_tree message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_tree.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_tree message from the specified reader or buffer.
         * @function decode
         * @memberof pb_tree
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_tree} pb_tree
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_tree.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_tree();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.lv = reader.int32();
                        break;
                    }
                case 2: {
                        message.blv = reader.int32();
                        break;
                    }
                case 3: {
                        if (!(message.bra && message.bra.length))
                            message.bra = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.bra.push(reader.int32());
                        } else
                            message.bra.push(reader.int32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a pb_tree message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_tree
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_tree} pb_tree
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_tree.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_tree message.
         * @function verify
         * @memberof pb_tree
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_tree.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.lv != null && message.hasOwnProperty("lv"))
                if (!$util.isInteger(message.lv))
                    return "lv: integer expected";
            if (message.blv != null && message.hasOwnProperty("blv"))
                if (!$util.isInteger(message.blv))
                    return "blv: integer expected";
            if (message.bra != null && message.hasOwnProperty("bra")) {
                if (!Array.isArray(message.bra))
                    return "bra: array expected";
                for (var i = 0; i < message.bra.length; ++i)
                    if (!$util.isInteger(message.bra[i]))
                        return "bra: integer[] expected";
            }
            return null;
        };
    
        /**
         * Creates a pb_tree message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_tree
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_tree} pb_tree
         */
        pb_tree.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_tree)
                return object;
            var message = new $root.pb_tree();
            if (object.lv != null)
                message.lv = object.lv | 0;
            if (object.blv != null)
                message.blv = object.blv | 0;
            if (object.bra) {
                if (!Array.isArray(object.bra))
                    throw TypeError(".pb_tree.bra: array expected");
                message.bra = [];
                for (var i = 0; i < object.bra.length; ++i)
                    message.bra[i] = object.bra[i] | 0;
            }
            return message;
        };
    
        /**
         * Creates a plain object from a pb_tree message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_tree
         * @static
         * @param {pb_tree} message pb_tree
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_tree.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.bra = [];
            if (options.defaults) {
                object.lv = 0;
                object.blv = 0;
            }
            if (message.lv != null && message.hasOwnProperty("lv"))
                object.lv = message.lv;
            if (message.blv != null && message.hasOwnProperty("blv"))
                object.blv = message.blv;
            if (message.bra && message.bra.length) {
                object.bra = [];
                for (var j = 0; j < message.bra.length; ++j)
                    object.bra[j] = message.bra[j];
            }
            return object;
        };
    
        /**
         * Converts this pb_tree to JSON.
         * @function toJSON
         * @memberof pb_tree
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_tree.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_tree
         * @function getTypeUrl
         * @memberof pb_tree
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_tree.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_tree";
        };
    
        return pb_tree;
    })();
    
    $root.pb_hero = (function() {
    
        /**
         * Properties of a pb_hero.
         * @exports Ipb_hero
         * @interface Ipb_hero
         * @property {number} hid pb_hero hid
         * @property {number} id pb_hero id
         * @property {number} lv pb_hero lv
         * @property {number} star pb_hero star
         * @property {number|null} [flag] pb_hero flag
         * @property {Array.<Ipb_equip>|null} [equips] pb_hero equips
         * @property {number|null} [wake] pb_hero wake
         * @property {Array.<number>|null} [jade] pb_hero jade
         * @property {boolean|null} [visit] pb_hero visit
         * @property {Array.<number>|null} [skillId] pb_hero skillId
         * @property {Array.<Ipb_sattr>|null} [sattrs] pb_hero sattrs
         * @property {Ipb_hero_qlt|null} [qlt] pb_hero qlt
         * @property {Ipb_tree|null} [tree] pb_hero tree
         */
    
        /**
         * Constructs a new pb_hero.
         * @exports pb_hero
         * @classdesc Represents a pb_hero.
         * @implements Ipb_hero
         * @constructor
         * @param {Ipb_hero=} [properties] Properties to set
         */
        function pb_hero(properties) {
            this.equips = [];
            this.jade = [];
            this.skillId = [];
            this.sattrs = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_hero hid.
         * @member {number} hid
         * @memberof pb_hero
         * @instance
         */
        pb_hero.prototype.hid = 0;
    
        /**
         * pb_hero id.
         * @member {number} id
         * @memberof pb_hero
         * @instance
         */
        pb_hero.prototype.id = 0;
    
        /**
         * pb_hero lv.
         * @member {number} lv
         * @memberof pb_hero
         * @instance
         */
        pb_hero.prototype.lv = 0;
    
        /**
         * pb_hero star.
         * @member {number} star
         * @memberof pb_hero
         * @instance
         */
        pb_hero.prototype.star = 0;
    
        /**
         * pb_hero flag.
         * @member {number} flag
         * @memberof pb_hero
         * @instance
         */
        pb_hero.prototype.flag = 0;
    
        /**
         * pb_hero equips.
         * @member {Array.<Ipb_equip>} equips
         * @memberof pb_hero
         * @instance
         */
        pb_hero.prototype.equips = $util.emptyArray;
    
        /**
         * pb_hero wake.
         * @member {number} wake
         * @memberof pb_hero
         * @instance
         */
        pb_hero.prototype.wake = 0;
    
        /**
         * pb_hero jade.
         * @member {Array.<number>} jade
         * @memberof pb_hero
         * @instance
         */
        pb_hero.prototype.jade = $util.emptyArray;
    
        /**
         * pb_hero visit.
         * @member {boolean} visit
         * @memberof pb_hero
         * @instance
         */
        pb_hero.prototype.visit = false;
    
        /**
         * pb_hero skillId.
         * @member {Array.<number>} skillId
         * @memberof pb_hero
         * @instance
         */
        pb_hero.prototype.skillId = $util.emptyArray;
    
        /**
         * pb_hero sattrs.
         * @member {Array.<Ipb_sattr>} sattrs
         * @memberof pb_hero
         * @instance
         */
        pb_hero.prototype.sattrs = $util.emptyArray;
    
        /**
         * pb_hero qlt.
         * @member {Ipb_hero_qlt|null|undefined} qlt
         * @memberof pb_hero
         * @instance
         */
        pb_hero.prototype.qlt = null;
    
        /**
         * pb_hero tree.
         * @member {Ipb_tree|null|undefined} tree
         * @memberof pb_hero
         * @instance
         */
        pb_hero.prototype.tree = null;
    
        /**
         * Creates a new pb_hero instance using the specified properties.
         * @function create
         * @memberof pb_hero
         * @static
         * @param {Ipb_hero=} [properties] Properties to set
         * @returns {pb_hero} pb_hero instance
         */
        pb_hero.create = function create(properties) {
            return new pb_hero(properties);
        };
    
        /**
         * Encodes the specified pb_hero message. Does not implicitly {@link pb_hero.verify|verify} messages.
         * @function encode
         * @memberof pb_hero
         * @static
         * @param {Ipb_hero} message pb_hero message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_hero.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.hid);
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.id);
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.lv);
            writer.uint32(/* id 4, wireType 0 =*/32).int32(message.star);
            if (message.flag != null && Object.hasOwnProperty.call(message, "flag"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.flag);
            if (message.equips != null && message.equips.length)
                for (var i = 0; i < message.equips.length; ++i)
                    $root.pb_equip.encode(message.equips[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.wake != null && Object.hasOwnProperty.call(message, "wake"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.wake);
            if (message.jade != null && message.jade.length)
                for (var i = 0; i < message.jade.length; ++i)
                    writer.uint32(/* id 8, wireType 0 =*/64).int32(message.jade[i]);
            if (message.visit != null && Object.hasOwnProperty.call(message, "visit"))
                writer.uint32(/* id 9, wireType 0 =*/72).bool(message.visit);
            if (message.skillId != null && message.skillId.length)
                for (var i = 0; i < message.skillId.length; ++i)
                    writer.uint32(/* id 10, wireType 0 =*/80).int32(message.skillId[i]);
            if (message.sattrs != null && message.sattrs.length)
                for (var i = 0; i < message.sattrs.length; ++i)
                    $root.pb_sattr.encode(message.sattrs[i], writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
            if (message.qlt != null && Object.hasOwnProperty.call(message, "qlt"))
                $root.pb_hero_qlt.encode(message.qlt, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
            if (message.tree != null && Object.hasOwnProperty.call(message, "tree"))
                $root.pb_tree.encode(message.tree, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified pb_hero message, length delimited. Does not implicitly {@link pb_hero.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_hero
         * @static
         * @param {Ipb_hero} message pb_hero message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_hero.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_hero message from the specified reader or buffer.
         * @function decode
         * @memberof pb_hero
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_hero} pb_hero
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_hero.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_hero();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.hid = reader.int32();
                        break;
                    }
                case 2: {
                        message.id = reader.int32();
                        break;
                    }
                case 3: {
                        message.lv = reader.int32();
                        break;
                    }
                case 4: {
                        message.star = reader.int32();
                        break;
                    }
                case 5: {
                        message.flag = reader.int32();
                        break;
                    }
                case 6: {
                        if (!(message.equips && message.equips.length))
                            message.equips = [];
                        message.equips.push($root.pb_equip.decode(reader, reader.uint32()));
                        break;
                    }
                case 7: {
                        message.wake = reader.int32();
                        break;
                    }
                case 8: {
                        if (!(message.jade && message.jade.length))
                            message.jade = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.jade.push(reader.int32());
                        } else
                            message.jade.push(reader.int32());
                        break;
                    }
                case 9: {
                        message.visit = reader.bool();
                        break;
                    }
                case 10: {
                        if (!(message.skillId && message.skillId.length))
                            message.skillId = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.skillId.push(reader.int32());
                        } else
                            message.skillId.push(reader.int32());
                        break;
                    }
                case 11: {
                        if (!(message.sattrs && message.sattrs.length))
                            message.sattrs = [];
                        message.sattrs.push($root.pb_sattr.decode(reader, reader.uint32()));
                        break;
                    }
                case 12: {
                        message.qlt = $root.pb_hero_qlt.decode(reader, reader.uint32());
                        break;
                    }
                case 13: {
                        message.tree = $root.pb_tree.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("hid"))
                throw $util.ProtocolError("missing required 'hid'", { instance: message });
            if (!message.hasOwnProperty("id"))
                throw $util.ProtocolError("missing required 'id'", { instance: message });
            if (!message.hasOwnProperty("lv"))
                throw $util.ProtocolError("missing required 'lv'", { instance: message });
            if (!message.hasOwnProperty("star"))
                throw $util.ProtocolError("missing required 'star'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a pb_hero message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_hero
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_hero} pb_hero
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_hero.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_hero message.
         * @function verify
         * @memberof pb_hero
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_hero.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.hid))
                return "hid: integer expected";
            if (!$util.isInteger(message.id))
                return "id: integer expected";
            if (!$util.isInteger(message.lv))
                return "lv: integer expected";
            if (!$util.isInteger(message.star))
                return "star: integer expected";
            if (message.flag != null && message.hasOwnProperty("flag"))
                if (!$util.isInteger(message.flag))
                    return "flag: integer expected";
            if (message.equips != null && message.hasOwnProperty("equips")) {
                if (!Array.isArray(message.equips))
                    return "equips: array expected";
                for (var i = 0; i < message.equips.length; ++i) {
                    var error = $root.pb_equip.verify(message.equips[i]);
                    if (error)
                        return "equips." + error;
                }
            }
            if (message.wake != null && message.hasOwnProperty("wake"))
                if (!$util.isInteger(message.wake))
                    return "wake: integer expected";
            if (message.jade != null && message.hasOwnProperty("jade")) {
                if (!Array.isArray(message.jade))
                    return "jade: array expected";
                for (var i = 0; i < message.jade.length; ++i)
                    if (!$util.isInteger(message.jade[i]))
                        return "jade: integer[] expected";
            }
            if (message.visit != null && message.hasOwnProperty("visit"))
                if (typeof message.visit !== "boolean")
                    return "visit: boolean expected";
            if (message.skillId != null && message.hasOwnProperty("skillId")) {
                if (!Array.isArray(message.skillId))
                    return "skillId: array expected";
                for (var i = 0; i < message.skillId.length; ++i)
                    if (!$util.isInteger(message.skillId[i]))
                        return "skillId: integer[] expected";
            }
            if (message.sattrs != null && message.hasOwnProperty("sattrs")) {
                if (!Array.isArray(message.sattrs))
                    return "sattrs: array expected";
                for (var i = 0; i < message.sattrs.length; ++i) {
                    var error = $root.pb_sattr.verify(message.sattrs[i]);
                    if (error)
                        return "sattrs." + error;
                }
            }
            if (message.qlt != null && message.hasOwnProperty("qlt")) {
                var error = $root.pb_hero_qlt.verify(message.qlt);
                if (error)
                    return "qlt." + error;
            }
            if (message.tree != null && message.hasOwnProperty("tree")) {
                var error = $root.pb_tree.verify(message.tree);
                if (error)
                    return "tree." + error;
            }
            return null;
        };
    
        /**
         * Creates a pb_hero message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_hero
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_hero} pb_hero
         */
        pb_hero.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_hero)
                return object;
            var message = new $root.pb_hero();
            if (object.hid != null)
                message.hid = object.hid | 0;
            if (object.id != null)
                message.id = object.id | 0;
            if (object.lv != null)
                message.lv = object.lv | 0;
            if (object.star != null)
                message.star = object.star | 0;
            if (object.flag != null)
                message.flag = object.flag | 0;
            if (object.equips) {
                if (!Array.isArray(object.equips))
                    throw TypeError(".pb_hero.equips: array expected");
                message.equips = [];
                for (var i = 0; i < object.equips.length; ++i) {
                    if (typeof object.equips[i] !== "object")
                        throw TypeError(".pb_hero.equips: object expected");
                    message.equips[i] = $root.pb_equip.fromObject(object.equips[i]);
                }
            }
            if (object.wake != null)
                message.wake = object.wake | 0;
            if (object.jade) {
                if (!Array.isArray(object.jade))
                    throw TypeError(".pb_hero.jade: array expected");
                message.jade = [];
                for (var i = 0; i < object.jade.length; ++i)
                    message.jade[i] = object.jade[i] | 0;
            }
            if (object.visit != null)
                message.visit = Boolean(object.visit);
            if (object.skillId) {
                if (!Array.isArray(object.skillId))
                    throw TypeError(".pb_hero.skillId: array expected");
                message.skillId = [];
                for (var i = 0; i < object.skillId.length; ++i)
                    message.skillId[i] = object.skillId[i] | 0;
            }
            if (object.sattrs) {
                if (!Array.isArray(object.sattrs))
                    throw TypeError(".pb_hero.sattrs: array expected");
                message.sattrs = [];
                for (var i = 0; i < object.sattrs.length; ++i) {
                    if (typeof object.sattrs[i] !== "object")
                        throw TypeError(".pb_hero.sattrs: object expected");
                    message.sattrs[i] = $root.pb_sattr.fromObject(object.sattrs[i]);
                }
            }
            if (object.qlt != null) {
                if (typeof object.qlt !== "object")
                    throw TypeError(".pb_hero.qlt: object expected");
                message.qlt = $root.pb_hero_qlt.fromObject(object.qlt);
            }
            if (object.tree != null) {
                if (typeof object.tree !== "object")
                    throw TypeError(".pb_hero.tree: object expected");
                message.tree = $root.pb_tree.fromObject(object.tree);
            }
            return message;
        };
    
        /**
         * Creates a plain object from a pb_hero message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_hero
         * @static
         * @param {pb_hero} message pb_hero
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_hero.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.equips = [];
                object.jade = [];
                object.skillId = [];
                object.sattrs = [];
            }
            if (options.defaults) {
                object.hid = 0;
                object.id = 0;
                object.lv = 0;
                object.star = 0;
                object.flag = 0;
                object.wake = 0;
                object.visit = false;
                object.qlt = null;
                object.tree = null;
            }
            if (message.hid != null && message.hasOwnProperty("hid"))
                object.hid = message.hid;
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.lv != null && message.hasOwnProperty("lv"))
                object.lv = message.lv;
            if (message.star != null && message.hasOwnProperty("star"))
                object.star = message.star;
            if (message.flag != null && message.hasOwnProperty("flag"))
                object.flag = message.flag;
            if (message.equips && message.equips.length) {
                object.equips = [];
                for (var j = 0; j < message.equips.length; ++j)
                    object.equips[j] = $root.pb_equip.toObject(message.equips[j], options);
            }
            if (message.wake != null && message.hasOwnProperty("wake"))
                object.wake = message.wake;
            if (message.jade && message.jade.length) {
                object.jade = [];
                for (var j = 0; j < message.jade.length; ++j)
                    object.jade[j] = message.jade[j];
            }
            if (message.visit != null && message.hasOwnProperty("visit"))
                object.visit = message.visit;
            if (message.skillId && message.skillId.length) {
                object.skillId = [];
                for (var j = 0; j < message.skillId.length; ++j)
                    object.skillId[j] = message.skillId[j];
            }
            if (message.sattrs && message.sattrs.length) {
                object.sattrs = [];
                for (var j = 0; j < message.sattrs.length; ++j)
                    object.sattrs[j] = $root.pb_sattr.toObject(message.sattrs[j], options);
            }
            if (message.qlt != null && message.hasOwnProperty("qlt"))
                object.qlt = $root.pb_hero_qlt.toObject(message.qlt, options);
            if (message.tree != null && message.hasOwnProperty("tree"))
                object.tree = $root.pb_tree.toObject(message.tree, options);
            return object;
        };
    
        /**
         * Converts this pb_hero to JSON.
         * @function toJSON
         * @memberof pb_hero
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_hero.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_hero
         * @function getTypeUrl
         * @memberof pb_hero
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_hero.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_hero";
        };
    
        return pb_hero;
    })();
    
    $root.pb_sattr = (function() {
    
        /**
         * Properties of a pb_sattr.
         * @exports Ipb_sattr
         * @interface Ipb_sattr
         * @property {number|null} [id] pb_sattr id
         * @property {number|null} [attr] pb_sattr attr
         * @property {number|null} [value] pb_sattr value
         */
    
        /**
         * Constructs a new pb_sattr.
         * @exports pb_sattr
         * @classdesc Represents a pb_sattr.
         * @implements Ipb_sattr
         * @constructor
         * @param {Ipb_sattr=} [properties] Properties to set
         */
        function pb_sattr(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_sattr id.
         * @member {number} id
         * @memberof pb_sattr
         * @instance
         */
        pb_sattr.prototype.id = 0;
    
        /**
         * pb_sattr attr.
         * @member {number} attr
         * @memberof pb_sattr
         * @instance
         */
        pb_sattr.prototype.attr = 0;
    
        /**
         * pb_sattr value.
         * @member {number} value
         * @memberof pb_sattr
         * @instance
         */
        pb_sattr.prototype.value = 0;
    
        /**
         * Creates a new pb_sattr instance using the specified properties.
         * @function create
         * @memberof pb_sattr
         * @static
         * @param {Ipb_sattr=} [properties] Properties to set
         * @returns {pb_sattr} pb_sattr instance
         */
        pb_sattr.create = function create(properties) {
            return new pb_sattr(properties);
        };
    
        /**
         * Encodes the specified pb_sattr message. Does not implicitly {@link pb_sattr.verify|verify} messages.
         * @function encode
         * @memberof pb_sattr
         * @static
         * @param {Ipb_sattr} message pb_sattr message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_sattr.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.id);
            if (message.attr != null && Object.hasOwnProperty.call(message, "attr"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.attr);
            if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.value);
            return writer;
        };
    
        /**
         * Encodes the specified pb_sattr message, length delimited. Does not implicitly {@link pb_sattr.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_sattr
         * @static
         * @param {Ipb_sattr} message pb_sattr message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_sattr.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_sattr message from the specified reader or buffer.
         * @function decode
         * @memberof pb_sattr
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_sattr} pb_sattr
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_sattr.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_sattr();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.id = reader.int32();
                        break;
                    }
                case 2: {
                        message.attr = reader.int32();
                        break;
                    }
                case 3: {
                        message.value = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a pb_sattr message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_sattr
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_sattr} pb_sattr
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_sattr.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_sattr message.
         * @function verify
         * @memberof pb_sattr
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_sattr.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id))
                    return "id: integer expected";
            if (message.attr != null && message.hasOwnProperty("attr"))
                if (!$util.isInteger(message.attr))
                    return "attr: integer expected";
            if (message.value != null && message.hasOwnProperty("value"))
                if (!$util.isInteger(message.value))
                    return "value: integer expected";
            return null;
        };
    
        /**
         * Creates a pb_sattr message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_sattr
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_sattr} pb_sattr
         */
        pb_sattr.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_sattr)
                return object;
            var message = new $root.pb_sattr();
            if (object.id != null)
                message.id = object.id | 0;
            if (object.attr != null)
                message.attr = object.attr | 0;
            if (object.value != null)
                message.value = object.value | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a pb_sattr message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_sattr
         * @static
         * @param {pb_sattr} message pb_sattr
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_sattr.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = 0;
                object.attr = 0;
                object.value = 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.attr != null && message.hasOwnProperty("attr"))
                object.attr = message.attr;
            if (message.value != null && message.hasOwnProperty("value"))
                object.value = message.value;
            return object;
        };
    
        /**
         * Converts this pb_sattr to JSON.
         * @function toJSON
         * @memberof pb_sattr
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_sattr.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_sattr
         * @function getTypeUrl
         * @memberof pb_sattr
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_sattr.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_sattr";
        };
    
        return pb_sattr;
    })();
    
    $root.pb_dup = (function() {
    
        /**
         * Properties of a pb_dup.
         * @exports Ipb_dup
         * @interface Ipb_dup
         * @property {number|null} [id] pb_dup id
         * @property {Array.<number>|null} [bids] pb_dup bids
         * @property {number|null} [sts] pb_dup sts
         * @property {number|null} [mid] pb_dup mid
         * @property {number|null} [rid] pb_dup rid
         * @property {number|null} [skip] pb_dup skip
         */
    
        /**
         * Constructs a new pb_dup.
         * @exports pb_dup
         * @classdesc Represents a pb_dup.
         * @implements Ipb_dup
         * @constructor
         * @param {Ipb_dup=} [properties] Properties to set
         */
        function pb_dup(properties) {
            this.bids = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_dup id.
         * @member {number} id
         * @memberof pb_dup
         * @instance
         */
        pb_dup.prototype.id = 0;
    
        /**
         * pb_dup bids.
         * @member {Array.<number>} bids
         * @memberof pb_dup
         * @instance
         */
        pb_dup.prototype.bids = $util.emptyArray;
    
        /**
         * pb_dup sts.
         * @member {number} sts
         * @memberof pb_dup
         * @instance
         */
        pb_dup.prototype.sts = 0;
    
        /**
         * pb_dup mid.
         * @member {number} mid
         * @memberof pb_dup
         * @instance
         */
        pb_dup.prototype.mid = 0;
    
        /**
         * pb_dup rid.
         * @member {number} rid
         * @memberof pb_dup
         * @instance
         */
        pb_dup.prototype.rid = 0;
    
        /**
         * pb_dup skip.
         * @member {number} skip
         * @memberof pb_dup
         * @instance
         */
        pb_dup.prototype.skip = 0;
    
        /**
         * Creates a new pb_dup instance using the specified properties.
         * @function create
         * @memberof pb_dup
         * @static
         * @param {Ipb_dup=} [properties] Properties to set
         * @returns {pb_dup} pb_dup instance
         */
        pb_dup.create = function create(properties) {
            return new pb_dup(properties);
        };
    
        /**
         * Encodes the specified pb_dup message. Does not implicitly {@link pb_dup.verify|verify} messages.
         * @function encode
         * @memberof pb_dup
         * @static
         * @param {Ipb_dup} message pb_dup message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_dup.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.id);
            if (message.bids != null && message.bids.length)
                for (var i = 0; i < message.bids.length; ++i)
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.bids[i]);
            if (message.sts != null && Object.hasOwnProperty.call(message, "sts"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.sts);
            if (message.mid != null && Object.hasOwnProperty.call(message, "mid"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.mid);
            if (message.rid != null && Object.hasOwnProperty.call(message, "rid"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.rid);
            if (message.skip != null && Object.hasOwnProperty.call(message, "skip"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.skip);
            return writer;
        };
    
        /**
         * Encodes the specified pb_dup message, length delimited. Does not implicitly {@link pb_dup.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_dup
         * @static
         * @param {Ipb_dup} message pb_dup message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_dup.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_dup message from the specified reader or buffer.
         * @function decode
         * @memberof pb_dup
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_dup} pb_dup
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_dup.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_dup();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.id = reader.int32();
                        break;
                    }
                case 2: {
                        if (!(message.bids && message.bids.length))
                            message.bids = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.bids.push(reader.int32());
                        } else
                            message.bids.push(reader.int32());
                        break;
                    }
                case 3: {
                        message.sts = reader.int32();
                        break;
                    }
                case 4: {
                        message.mid = reader.int32();
                        break;
                    }
                case 5: {
                        message.rid = reader.int32();
                        break;
                    }
                case 6: {
                        message.skip = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a pb_dup message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_dup
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_dup} pb_dup
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_dup.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_dup message.
         * @function verify
         * @memberof pb_dup
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_dup.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id))
                    return "id: integer expected";
            if (message.bids != null && message.hasOwnProperty("bids")) {
                if (!Array.isArray(message.bids))
                    return "bids: array expected";
                for (var i = 0; i < message.bids.length; ++i)
                    if (!$util.isInteger(message.bids[i]))
                        return "bids: integer[] expected";
            }
            if (message.sts != null && message.hasOwnProperty("sts"))
                if (!$util.isInteger(message.sts))
                    return "sts: integer expected";
            if (message.mid != null && message.hasOwnProperty("mid"))
                if (!$util.isInteger(message.mid))
                    return "mid: integer expected";
            if (message.rid != null && message.hasOwnProperty("rid"))
                if (!$util.isInteger(message.rid))
                    return "rid: integer expected";
            if (message.skip != null && message.hasOwnProperty("skip"))
                if (!$util.isInteger(message.skip))
                    return "skip: integer expected";
            return null;
        };
    
        /**
         * Creates a pb_dup message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_dup
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_dup} pb_dup
         */
        pb_dup.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_dup)
                return object;
            var message = new $root.pb_dup();
            if (object.id != null)
                message.id = object.id | 0;
            if (object.bids) {
                if (!Array.isArray(object.bids))
                    throw TypeError(".pb_dup.bids: array expected");
                message.bids = [];
                for (var i = 0; i < object.bids.length; ++i)
                    message.bids[i] = object.bids[i] | 0;
            }
            if (object.sts != null)
                message.sts = object.sts | 0;
            if (object.mid != null)
                message.mid = object.mid | 0;
            if (object.rid != null)
                message.rid = object.rid | 0;
            if (object.skip != null)
                message.skip = object.skip | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a pb_dup message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_dup
         * @static
         * @param {pb_dup} message pb_dup
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_dup.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.bids = [];
            if (options.defaults) {
                object.id = 0;
                object.sts = 0;
                object.mid = 0;
                object.rid = 0;
                object.skip = 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.bids && message.bids.length) {
                object.bids = [];
                for (var j = 0; j < message.bids.length; ++j)
                    object.bids[j] = message.bids[j];
            }
            if (message.sts != null && message.hasOwnProperty("sts"))
                object.sts = message.sts;
            if (message.mid != null && message.hasOwnProperty("mid"))
                object.mid = message.mid;
            if (message.rid != null && message.hasOwnProperty("rid"))
                object.rid = message.rid;
            if (message.skip != null && message.hasOwnProperty("skip"))
                object.skip = message.skip;
            return object;
        };
    
        /**
         * Converts this pb_dup to JSON.
         * @function toJSON
         * @memberof pb_dup
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_dup.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_dup
         * @function getTypeUrl
         * @memberof pb_dup
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_dup.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_dup";
        };
    
        return pb_dup;
    })();
    
    $root.pb_embr = (function() {
    
        /**
         * Properties of a pb_embr.
         * @exports Ipb_embr
         * @interface Ipb_embr
         * @property {number|null} [uid] pb_embr uid
         * @property {number|null} [lv] pb_embr lv
         * @property {number|null} [status] pb_embr status
         * @property {string|null} [stime] pb_embr stime
         * @property {number|null} [logo] pb_embr logo
         * @property {string|null} [name] pb_embr name
         * @property {number|null} [border] pb_embr border
         * @property {number|null} [id] pb_embr id
         */
    
        /**
         * Constructs a new pb_embr.
         * @exports pb_embr
         * @classdesc Represents a pb_embr.
         * @implements Ipb_embr
         * @constructor
         * @param {Ipb_embr=} [properties] Properties to set
         */
        function pb_embr(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_embr uid.
         * @member {number} uid
         * @memberof pb_embr
         * @instance
         */
        pb_embr.prototype.uid = 0;
    
        /**
         * pb_embr lv.
         * @member {number} lv
         * @memberof pb_embr
         * @instance
         */
        pb_embr.prototype.lv = 0;
    
        /**
         * pb_embr status.
         * @member {number} status
         * @memberof pb_embr
         * @instance
         */
        pb_embr.prototype.status = 0;
    
        /**
         * pb_embr stime.
         * @member {string} stime
         * @memberof pb_embr
         * @instance
         */
        pb_embr.prototype.stime = "";
    
        /**
         * pb_embr logo.
         * @member {number} logo
         * @memberof pb_embr
         * @instance
         */
        pb_embr.prototype.logo = 0;
    
        /**
         * pb_embr name.
         * @member {string} name
         * @memberof pb_embr
         * @instance
         */
        pb_embr.prototype.name = "";
    
        /**
         * pb_embr border.
         * @member {number} border
         * @memberof pb_embr
         * @instance
         */
        pb_embr.prototype.border = 0;
    
        /**
         * pb_embr id.
         * @member {number} id
         * @memberof pb_embr
         * @instance
         */
        pb_embr.prototype.id = 0;
    
        /**
         * Creates a new pb_embr instance using the specified properties.
         * @function create
         * @memberof pb_embr
         * @static
         * @param {Ipb_embr=} [properties] Properties to set
         * @returns {pb_embr} pb_embr instance
         */
        pb_embr.create = function create(properties) {
            return new pb_embr(properties);
        };
    
        /**
         * Encodes the specified pb_embr message. Does not implicitly {@link pb_embr.verify|verify} messages.
         * @function encode
         * @memberof pb_embr
         * @static
         * @param {Ipb_embr} message pb_embr message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_embr.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.uid != null && Object.hasOwnProperty.call(message, "uid"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.uid);
            if (message.lv != null && Object.hasOwnProperty.call(message, "lv"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.lv);
            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.status);
            if (message.stime != null && Object.hasOwnProperty.call(message, "stime"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.stime);
            if (message.logo != null && Object.hasOwnProperty.call(message, "logo"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.logo);
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.name);
            if (message.border != null && Object.hasOwnProperty.call(message, "border"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.border);
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.id);
            return writer;
        };
    
        /**
         * Encodes the specified pb_embr message, length delimited. Does not implicitly {@link pb_embr.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_embr
         * @static
         * @param {Ipb_embr} message pb_embr message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_embr.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_embr message from the specified reader or buffer.
         * @function decode
         * @memberof pb_embr
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_embr} pb_embr
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_embr.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_embr();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.uid = reader.int32();
                        break;
                    }
                case 2: {
                        message.lv = reader.int32();
                        break;
                    }
                case 3: {
                        message.status = reader.int32();
                        break;
                    }
                case 4: {
                        message.stime = reader.string();
                        break;
                    }
                case 5: {
                        message.logo = reader.int32();
                        break;
                    }
                case 6: {
                        message.name = reader.string();
                        break;
                    }
                case 7: {
                        message.border = reader.int32();
                        break;
                    }
                case 8: {
                        message.id = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a pb_embr message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_embr
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_embr} pb_embr
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_embr.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_embr message.
         * @function verify
         * @memberof pb_embr
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_embr.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (!$util.isInteger(message.uid))
                    return "uid: integer expected";
            if (message.lv != null && message.hasOwnProperty("lv"))
                if (!$util.isInteger(message.lv))
                    return "lv: integer expected";
            if (message.status != null && message.hasOwnProperty("status"))
                if (!$util.isInteger(message.status))
                    return "status: integer expected";
            if (message.stime != null && message.hasOwnProperty("stime"))
                if (!$util.isString(message.stime))
                    return "stime: string expected";
            if (message.logo != null && message.hasOwnProperty("logo"))
                if (!$util.isInteger(message.logo))
                    return "logo: integer expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.border != null && message.hasOwnProperty("border"))
                if (!$util.isInteger(message.border))
                    return "border: integer expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id))
                    return "id: integer expected";
            return null;
        };
    
        /**
         * Creates a pb_embr message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_embr
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_embr} pb_embr
         */
        pb_embr.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_embr)
                return object;
            var message = new $root.pb_embr();
            if (object.uid != null)
                message.uid = object.uid | 0;
            if (object.lv != null)
                message.lv = object.lv | 0;
            if (object.status != null)
                message.status = object.status | 0;
            if (object.stime != null)
                message.stime = String(object.stime);
            if (object.logo != null)
                message.logo = object.logo | 0;
            if (object.name != null)
                message.name = String(object.name);
            if (object.border != null)
                message.border = object.border | 0;
            if (object.id != null)
                message.id = object.id | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a pb_embr message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_embr
         * @static
         * @param {pb_embr} message pb_embr
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_embr.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.uid = 0;
                object.lv = 0;
                object.status = 0;
                object.stime = "";
                object.logo = 0;
                object.name = "";
                object.border = 0;
                object.id = 0;
            }
            if (message.uid != null && message.hasOwnProperty("uid"))
                object.uid = message.uid;
            if (message.lv != null && message.hasOwnProperty("lv"))
                object.lv = message.lv;
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = message.status;
            if (message.stime != null && message.hasOwnProperty("stime"))
                object.stime = message.stime;
            if (message.logo != null && message.hasOwnProperty("logo"))
                object.logo = message.logo;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.border != null && message.hasOwnProperty("border"))
                object.border = message.border;
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            return object;
        };
    
        /**
         * Converts this pb_embr to JSON.
         * @function toJSON
         * @memberof pb_embr
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_embr.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_embr
         * @function getTypeUrl
         * @memberof pb_embr
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_embr.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_embr";
        };
    
        return pb_embr;
    })();
    
    $root.pb_scell = (function() {
    
        /**
         * Properties of a pb_scell.
         * @exports Ipb_scell
         * @interface Ipb_scell
         * @property {number|null} [pos] pb_scell pos
         * @property {number|null} [status] pb_scell status
         * @property {number|null} [id] pb_scell id
         * @property {Array.<number>|null} [ids1] pb_scell ids1
         * @property {Array.<number>|null} [ids2] pb_scell ids2
         */
    
        /**
         * Constructs a new pb_scell.
         * @exports pb_scell
         * @classdesc Represents a pb_scell.
         * @implements Ipb_scell
         * @constructor
         * @param {Ipb_scell=} [properties] Properties to set
         */
        function pb_scell(properties) {
            this.ids1 = [];
            this.ids2 = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_scell pos.
         * @member {number} pos
         * @memberof pb_scell
         * @instance
         */
        pb_scell.prototype.pos = 0;
    
        /**
         * pb_scell status.
         * @member {number} status
         * @memberof pb_scell
         * @instance
         */
        pb_scell.prototype.status = 0;
    
        /**
         * pb_scell id.
         * @member {number} id
         * @memberof pb_scell
         * @instance
         */
        pb_scell.prototype.id = 0;
    
        /**
         * pb_scell ids1.
         * @member {Array.<number>} ids1
         * @memberof pb_scell
         * @instance
         */
        pb_scell.prototype.ids1 = $util.emptyArray;
    
        /**
         * pb_scell ids2.
         * @member {Array.<number>} ids2
         * @memberof pb_scell
         * @instance
         */
        pb_scell.prototype.ids2 = $util.emptyArray;
    
        /**
         * Creates a new pb_scell instance using the specified properties.
         * @function create
         * @memberof pb_scell
         * @static
         * @param {Ipb_scell=} [properties] Properties to set
         * @returns {pb_scell} pb_scell instance
         */
        pb_scell.create = function create(properties) {
            return new pb_scell(properties);
        };
    
        /**
         * Encodes the specified pb_scell message. Does not implicitly {@link pb_scell.verify|verify} messages.
         * @function encode
         * @memberof pb_scell
         * @static
         * @param {Ipb_scell} message pb_scell message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_scell.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.pos != null && Object.hasOwnProperty.call(message, "pos"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.pos);
            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.status);
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.id);
            if (message.ids1 != null && message.ids1.length)
                for (var i = 0; i < message.ids1.length; ++i)
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.ids1[i]);
            if (message.ids2 != null && message.ids2.length)
                for (var i = 0; i < message.ids2.length; ++i)
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.ids2[i]);
            return writer;
        };
    
        /**
         * Encodes the specified pb_scell message, length delimited. Does not implicitly {@link pb_scell.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_scell
         * @static
         * @param {Ipb_scell} message pb_scell message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_scell.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_scell message from the specified reader or buffer.
         * @function decode
         * @memberof pb_scell
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_scell} pb_scell
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_scell.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_scell();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.pos = reader.int32();
                        break;
                    }
                case 2: {
                        message.status = reader.int32();
                        break;
                    }
                case 3: {
                        message.id = reader.int32();
                        break;
                    }
                case 4: {
                        if (!(message.ids1 && message.ids1.length))
                            message.ids1 = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.ids1.push(reader.int32());
                        } else
                            message.ids1.push(reader.int32());
                        break;
                    }
                case 5: {
                        if (!(message.ids2 && message.ids2.length))
                            message.ids2 = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.ids2.push(reader.int32());
                        } else
                            message.ids2.push(reader.int32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a pb_scell message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_scell
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_scell} pb_scell
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_scell.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_scell message.
         * @function verify
         * @memberof pb_scell
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_scell.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.pos != null && message.hasOwnProperty("pos"))
                if (!$util.isInteger(message.pos))
                    return "pos: integer expected";
            if (message.status != null && message.hasOwnProperty("status"))
                if (!$util.isInteger(message.status))
                    return "status: integer expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id))
                    return "id: integer expected";
            if (message.ids1 != null && message.hasOwnProperty("ids1")) {
                if (!Array.isArray(message.ids1))
                    return "ids1: array expected";
                for (var i = 0; i < message.ids1.length; ++i)
                    if (!$util.isInteger(message.ids1[i]))
                        return "ids1: integer[] expected";
            }
            if (message.ids2 != null && message.hasOwnProperty("ids2")) {
                if (!Array.isArray(message.ids2))
                    return "ids2: array expected";
                for (var i = 0; i < message.ids2.length; ++i)
                    if (!$util.isInteger(message.ids2[i]))
                        return "ids2: integer[] expected";
            }
            return null;
        };
    
        /**
         * Creates a pb_scell message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_scell
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_scell} pb_scell
         */
        pb_scell.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_scell)
                return object;
            var message = new $root.pb_scell();
            if (object.pos != null)
                message.pos = object.pos | 0;
            if (object.status != null)
                message.status = object.status | 0;
            if (object.id != null)
                message.id = object.id | 0;
            if (object.ids1) {
                if (!Array.isArray(object.ids1))
                    throw TypeError(".pb_scell.ids1: array expected");
                message.ids1 = [];
                for (var i = 0; i < object.ids1.length; ++i)
                    message.ids1[i] = object.ids1[i] | 0;
            }
            if (object.ids2) {
                if (!Array.isArray(object.ids2))
                    throw TypeError(".pb_scell.ids2: array expected");
                message.ids2 = [];
                for (var i = 0; i < object.ids2.length; ++i)
                    message.ids2[i] = object.ids2[i] | 0;
            }
            return message;
        };
    
        /**
         * Creates a plain object from a pb_scell message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_scell
         * @static
         * @param {pb_scell} message pb_scell
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_scell.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.ids1 = [];
                object.ids2 = [];
            }
            if (options.defaults) {
                object.pos = 0;
                object.status = 0;
                object.id = 0;
            }
            if (message.pos != null && message.hasOwnProperty("pos"))
                object.pos = message.pos;
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = message.status;
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.ids1 && message.ids1.length) {
                object.ids1 = [];
                for (var j = 0; j < message.ids1.length; ++j)
                    object.ids1[j] = message.ids1[j];
            }
            if (message.ids2 && message.ids2.length) {
                object.ids2 = [];
                for (var j = 0; j < message.ids2.length; ++j)
                    object.ids2[j] = message.ids2[j];
            }
            return object;
        };
    
        /**
         * Converts this pb_scell to JSON.
         * @function toJSON
         * @memberof pb_scell
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_scell.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_scell
         * @function getTypeUrl
         * @memberof pb_scell
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_scell.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_scell";
        };
    
        return pb_scell;
    })();
    
    $root.pb_sbuilding = (function() {
    
        /**
         * Properties of a pb_sbuilding.
         * @exports Ipb_sbuilding
         * @interface Ipb_sbuilding
         * @property {number|null} [lv] pb_sbuilding lv
         * @property {number|null} [cd] pb_sbuilding cd
         * @property {number|null} [num] pb_sbuilding num
         */
    
        /**
         * Constructs a new pb_sbuilding.
         * @exports pb_sbuilding
         * @classdesc Represents a pb_sbuilding.
         * @implements Ipb_sbuilding
         * @constructor
         * @param {Ipb_sbuilding=} [properties] Properties to set
         */
        function pb_sbuilding(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_sbuilding lv.
         * @member {number} lv
         * @memberof pb_sbuilding
         * @instance
         */
        pb_sbuilding.prototype.lv = 0;
    
        /**
         * pb_sbuilding cd.
         * @member {number} cd
         * @memberof pb_sbuilding
         * @instance
         */
        pb_sbuilding.prototype.cd = 0;
    
        /**
         * pb_sbuilding num.
         * @member {number} num
         * @memberof pb_sbuilding
         * @instance
         */
        pb_sbuilding.prototype.num = 0;
    
        /**
         * Creates a new pb_sbuilding instance using the specified properties.
         * @function create
         * @memberof pb_sbuilding
         * @static
         * @param {Ipb_sbuilding=} [properties] Properties to set
         * @returns {pb_sbuilding} pb_sbuilding instance
         */
        pb_sbuilding.create = function create(properties) {
            return new pb_sbuilding(properties);
        };
    
        /**
         * Encodes the specified pb_sbuilding message. Does not implicitly {@link pb_sbuilding.verify|verify} messages.
         * @function encode
         * @memberof pb_sbuilding
         * @static
         * @param {Ipb_sbuilding} message pb_sbuilding message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_sbuilding.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.lv != null && Object.hasOwnProperty.call(message, "lv"))
                writer.uint32(/* id 1, wireType 0 =*/8).sint32(message.lv);
            if (message.cd != null && Object.hasOwnProperty.call(message, "cd"))
                writer.uint32(/* id 2, wireType 0 =*/16).sint32(message.cd);
            if (message.num != null && Object.hasOwnProperty.call(message, "num"))
                writer.uint32(/* id 3, wireType 0 =*/24).sint32(message.num);
            return writer;
        };
    
        /**
         * Encodes the specified pb_sbuilding message, length delimited. Does not implicitly {@link pb_sbuilding.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_sbuilding
         * @static
         * @param {Ipb_sbuilding} message pb_sbuilding message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_sbuilding.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_sbuilding message from the specified reader or buffer.
         * @function decode
         * @memberof pb_sbuilding
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_sbuilding} pb_sbuilding
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_sbuilding.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_sbuilding();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.lv = reader.sint32();
                        break;
                    }
                case 2: {
                        message.cd = reader.sint32();
                        break;
                    }
                case 3: {
                        message.num = reader.sint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a pb_sbuilding message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_sbuilding
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_sbuilding} pb_sbuilding
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_sbuilding.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_sbuilding message.
         * @function verify
         * @memberof pb_sbuilding
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_sbuilding.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.lv != null && message.hasOwnProperty("lv"))
                if (!$util.isInteger(message.lv))
                    return "lv: integer expected";
            if (message.cd != null && message.hasOwnProperty("cd"))
                if (!$util.isInteger(message.cd))
                    return "cd: integer expected";
            if (message.num != null && message.hasOwnProperty("num"))
                if (!$util.isInteger(message.num))
                    return "num: integer expected";
            return null;
        };
    
        /**
         * Creates a pb_sbuilding message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_sbuilding
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_sbuilding} pb_sbuilding
         */
        pb_sbuilding.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_sbuilding)
                return object;
            var message = new $root.pb_sbuilding();
            if (object.lv != null)
                message.lv = object.lv | 0;
            if (object.cd != null)
                message.cd = object.cd | 0;
            if (object.num != null)
                message.num = object.num | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a pb_sbuilding message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_sbuilding
         * @static
         * @param {pb_sbuilding} message pb_sbuilding
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_sbuilding.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.lv = 0;
                object.cd = 0;
                object.num = 0;
            }
            if (message.lv != null && message.hasOwnProperty("lv"))
                object.lv = message.lv;
            if (message.cd != null && message.hasOwnProperty("cd"))
                object.cd = message.cd;
            if (message.num != null && message.hasOwnProperty("num"))
                object.num = message.num;
            return object;
        };
    
        /**
         * Converts this pb_sbuilding to JSON.
         * @function toJSON
         * @memberof pb_sbuilding
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_sbuilding.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_sbuilding
         * @function getTypeUrl
         * @memberof pb_sbuilding
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_sbuilding.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_sbuilding";
        };
    
        return pb_sbuilding;
    })();
    
    $root.pb_sscell = (function() {
    
        /**
         * Properties of a pb_sscell.
         * @exports Ipb_sscell
         * @interface Ipb_sscell
         * @property {number|null} [pos] pb_sscell pos
         * @property {number|null} [status] pb_sscell status
         * @property {number|null} [id] pb_sscell id
         * @property {number|null} [bossId] pb_sscell bossId
         * @property {Array.<number>|null} [bossHp] pb_sscell bossHp
         * @property {Ipb_pmbr|null} [mbr] pb_sscell mbr
         * @property {number|null} [hid] pb_sscell hid
         * @property {number|null} [cd] pb_sscell cd
         * @property {number|null} [lv] pb_sscell lv
         * @property {number|null} [add] pb_sscell add
         * @property {number|null} [times] pb_sscell times
         * @property {number|null} [rid] pb_sscell rid
         * @property {number|null} [wake] pb_sscell wake
         * @property {number|null} [rlv] pb_sscell rlv
         * @property {number|null} [rqlv] pb_sscell rqlv
         */
    
        /**
         * Constructs a new pb_sscell.
         * @exports pb_sscell
         * @classdesc Represents a pb_sscell.
         * @implements Ipb_sscell
         * @constructor
         * @param {Ipb_sscell=} [properties] Properties to set
         */
        function pb_sscell(properties) {
            this.bossHp = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_sscell pos.
         * @member {number} pos
         * @memberof pb_sscell
         * @instance
         */
        pb_sscell.prototype.pos = 0;
    
        /**
         * pb_sscell status.
         * @member {number} status
         * @memberof pb_sscell
         * @instance
         */
        pb_sscell.prototype.status = 0;
    
        /**
         * pb_sscell id.
         * @member {number} id
         * @memberof pb_sscell
         * @instance
         */
        pb_sscell.prototype.id = 0;
    
        /**
         * pb_sscell bossId.
         * @member {number} bossId
         * @memberof pb_sscell
         * @instance
         */
        pb_sscell.prototype.bossId = 0;
    
        /**
         * pb_sscell bossHp.
         * @member {Array.<number>} bossHp
         * @memberof pb_sscell
         * @instance
         */
        pb_sscell.prototype.bossHp = $util.emptyArray;
    
        /**
         * pb_sscell mbr.
         * @member {Ipb_pmbr|null|undefined} mbr
         * @memberof pb_sscell
         * @instance
         */
        pb_sscell.prototype.mbr = null;
    
        /**
         * pb_sscell hid.
         * @member {number} hid
         * @memberof pb_sscell
         * @instance
         */
        pb_sscell.prototype.hid = 0;
    
        /**
         * pb_sscell cd.
         * @member {number} cd
         * @memberof pb_sscell
         * @instance
         */
        pb_sscell.prototype.cd = 0;
    
        /**
         * pb_sscell lv.
         * @member {number} lv
         * @memberof pb_sscell
         * @instance
         */
        pb_sscell.prototype.lv = 0;
    
        /**
         * pb_sscell add.
         * @member {number} add
         * @memberof pb_sscell
         * @instance
         */
        pb_sscell.prototype.add = 0;
    
        /**
         * pb_sscell times.
         * @member {number} times
         * @memberof pb_sscell
         * @instance
         */
        pb_sscell.prototype.times = 0;
    
        /**
         * pb_sscell rid.
         * @member {number} rid
         * @memberof pb_sscell
         * @instance
         */
        pb_sscell.prototype.rid = 0;
    
        /**
         * pb_sscell wake.
         * @member {number} wake
         * @memberof pb_sscell
         * @instance
         */
        pb_sscell.prototype.wake = 0;
    
        /**
         * pb_sscell rlv.
         * @member {number} rlv
         * @memberof pb_sscell
         * @instance
         */
        pb_sscell.prototype.rlv = 0;
    
        /**
         * pb_sscell rqlv.
         * @member {number} rqlv
         * @memberof pb_sscell
         * @instance
         */
        pb_sscell.prototype.rqlv = 0;
    
        /**
         * Creates a new pb_sscell instance using the specified properties.
         * @function create
         * @memberof pb_sscell
         * @static
         * @param {Ipb_sscell=} [properties] Properties to set
         * @returns {pb_sscell} pb_sscell instance
         */
        pb_sscell.create = function create(properties) {
            return new pb_sscell(properties);
        };
    
        /**
         * Encodes the specified pb_sscell message. Does not implicitly {@link pb_sscell.verify|verify} messages.
         * @function encode
         * @memberof pb_sscell
         * @static
         * @param {Ipb_sscell} message pb_sscell message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_sscell.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.pos != null && Object.hasOwnProperty.call(message, "pos"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.pos);
            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.status);
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.id);
            if (message.bossId != null && Object.hasOwnProperty.call(message, "bossId"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.bossId);
            if (message.bossHp != null && message.bossHp.length)
                for (var i = 0; i < message.bossHp.length; ++i)
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.bossHp[i]);
            if (message.mbr != null && Object.hasOwnProperty.call(message, "mbr"))
                $root.pb_pmbr.encode(message.mbr, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.hid != null && Object.hasOwnProperty.call(message, "hid"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.hid);
            if (message.cd != null && Object.hasOwnProperty.call(message, "cd"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.cd);
            if (message.lv != null && Object.hasOwnProperty.call(message, "lv"))
                writer.uint32(/* id 9, wireType 0 =*/72).int32(message.lv);
            if (message.add != null && Object.hasOwnProperty.call(message, "add"))
                writer.uint32(/* id 10, wireType 0 =*/80).int32(message.add);
            if (message.times != null && Object.hasOwnProperty.call(message, "times"))
                writer.uint32(/* id 11, wireType 0 =*/88).int32(message.times);
            if (message.rid != null && Object.hasOwnProperty.call(message, "rid"))
                writer.uint32(/* id 12, wireType 0 =*/96).int32(message.rid);
            if (message.wake != null && Object.hasOwnProperty.call(message, "wake"))
                writer.uint32(/* id 13, wireType 0 =*/104).int32(message.wake);
            if (message.rlv != null && Object.hasOwnProperty.call(message, "rlv"))
                writer.uint32(/* id 14, wireType 0 =*/112).int32(message.rlv);
            if (message.rqlv != null && Object.hasOwnProperty.call(message, "rqlv"))
                writer.uint32(/* id 15, wireType 0 =*/120).int32(message.rqlv);
            return writer;
        };
    
        /**
         * Encodes the specified pb_sscell message, length delimited. Does not implicitly {@link pb_sscell.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_sscell
         * @static
         * @param {Ipb_sscell} message pb_sscell message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_sscell.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_sscell message from the specified reader or buffer.
         * @function decode
         * @memberof pb_sscell
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_sscell} pb_sscell
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_sscell.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_sscell();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.pos = reader.int32();
                        break;
                    }
                case 2: {
                        message.status = reader.int32();
                        break;
                    }
                case 3: {
                        message.id = reader.int32();
                        break;
                    }
                case 4: {
                        message.bossId = reader.int32();
                        break;
                    }
                case 5: {
                        if (!(message.bossHp && message.bossHp.length))
                            message.bossHp = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.bossHp.push(reader.int32());
                        } else
                            message.bossHp.push(reader.int32());
                        break;
                    }
                case 6: {
                        message.mbr = $root.pb_pmbr.decode(reader, reader.uint32());
                        break;
                    }
                case 7: {
                        message.hid = reader.int32();
                        break;
                    }
                case 8: {
                        message.cd = reader.int32();
                        break;
                    }
                case 9: {
                        message.lv = reader.int32();
                        break;
                    }
                case 10: {
                        message.add = reader.int32();
                        break;
                    }
                case 11: {
                        message.times = reader.int32();
                        break;
                    }
                case 12: {
                        message.rid = reader.int32();
                        break;
                    }
                case 13: {
                        message.wake = reader.int32();
                        break;
                    }
                case 14: {
                        message.rlv = reader.int32();
                        break;
                    }
                case 15: {
                        message.rqlv = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a pb_sscell message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_sscell
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_sscell} pb_sscell
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_sscell.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_sscell message.
         * @function verify
         * @memberof pb_sscell
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_sscell.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.pos != null && message.hasOwnProperty("pos"))
                if (!$util.isInteger(message.pos))
                    return "pos: integer expected";
            if (message.status != null && message.hasOwnProperty("status"))
                if (!$util.isInteger(message.status))
                    return "status: integer expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id))
                    return "id: integer expected";
            if (message.bossId != null && message.hasOwnProperty("bossId"))
                if (!$util.isInteger(message.bossId))
                    return "bossId: integer expected";
            if (message.bossHp != null && message.hasOwnProperty("bossHp")) {
                if (!Array.isArray(message.bossHp))
                    return "bossHp: array expected";
                for (var i = 0; i < message.bossHp.length; ++i)
                    if (!$util.isInteger(message.bossHp[i]))
                        return "bossHp: integer[] expected";
            }
            if (message.mbr != null && message.hasOwnProperty("mbr")) {
                var error = $root.pb_pmbr.verify(message.mbr);
                if (error)
                    return "mbr." + error;
            }
            if (message.hid != null && message.hasOwnProperty("hid"))
                if (!$util.isInteger(message.hid))
                    return "hid: integer expected";
            if (message.cd != null && message.hasOwnProperty("cd"))
                if (!$util.isInteger(message.cd))
                    return "cd: integer expected";
            if (message.lv != null && message.hasOwnProperty("lv"))
                if (!$util.isInteger(message.lv))
                    return "lv: integer expected";
            if (message.add != null && message.hasOwnProperty("add"))
                if (!$util.isInteger(message.add))
                    return "add: integer expected";
            if (message.times != null && message.hasOwnProperty("times"))
                if (!$util.isInteger(message.times))
                    return "times: integer expected";
            if (message.rid != null && message.hasOwnProperty("rid"))
                if (!$util.isInteger(message.rid))
                    return "rid: integer expected";
            if (message.wake != null && message.hasOwnProperty("wake"))
                if (!$util.isInteger(message.wake))
                    return "wake: integer expected";
            if (message.rlv != null && message.hasOwnProperty("rlv"))
                if (!$util.isInteger(message.rlv))
                    return "rlv: integer expected";
            if (message.rqlv != null && message.hasOwnProperty("rqlv"))
                if (!$util.isInteger(message.rqlv))
                    return "rqlv: integer expected";
            return null;
        };
    
        /**
         * Creates a pb_sscell message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_sscell
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_sscell} pb_sscell
         */
        pb_sscell.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_sscell)
                return object;
            var message = new $root.pb_sscell();
            if (object.pos != null)
                message.pos = object.pos | 0;
            if (object.status != null)
                message.status = object.status | 0;
            if (object.id != null)
                message.id = object.id | 0;
            if (object.bossId != null)
                message.bossId = object.bossId | 0;
            if (object.bossHp) {
                if (!Array.isArray(object.bossHp))
                    throw TypeError(".pb_sscell.bossHp: array expected");
                message.bossHp = [];
                for (var i = 0; i < object.bossHp.length; ++i)
                    message.bossHp[i] = object.bossHp[i] | 0;
            }
            if (object.mbr != null) {
                if (typeof object.mbr !== "object")
                    throw TypeError(".pb_sscell.mbr: object expected");
                message.mbr = $root.pb_pmbr.fromObject(object.mbr);
            }
            if (object.hid != null)
                message.hid = object.hid | 0;
            if (object.cd != null)
                message.cd = object.cd | 0;
            if (object.lv != null)
                message.lv = object.lv | 0;
            if (object.add != null)
                message.add = object.add | 0;
            if (object.times != null)
                message.times = object.times | 0;
            if (object.rid != null)
                message.rid = object.rid | 0;
            if (object.wake != null)
                message.wake = object.wake | 0;
            if (object.rlv != null)
                message.rlv = object.rlv | 0;
            if (object.rqlv != null)
                message.rqlv = object.rqlv | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a pb_sscell message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_sscell
         * @static
         * @param {pb_sscell} message pb_sscell
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_sscell.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.bossHp = [];
            if (options.defaults) {
                object.pos = 0;
                object.status = 0;
                object.id = 0;
                object.bossId = 0;
                object.mbr = null;
                object.hid = 0;
                object.cd = 0;
                object.lv = 0;
                object.add = 0;
                object.times = 0;
                object.rid = 0;
                object.wake = 0;
                object.rlv = 0;
                object.rqlv = 0;
            }
            if (message.pos != null && message.hasOwnProperty("pos"))
                object.pos = message.pos;
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = message.status;
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.bossId != null && message.hasOwnProperty("bossId"))
                object.bossId = message.bossId;
            if (message.bossHp && message.bossHp.length) {
                object.bossHp = [];
                for (var j = 0; j < message.bossHp.length; ++j)
                    object.bossHp[j] = message.bossHp[j];
            }
            if (message.mbr != null && message.hasOwnProperty("mbr"))
                object.mbr = $root.pb_pmbr.toObject(message.mbr, options);
            if (message.hid != null && message.hasOwnProperty("hid"))
                object.hid = message.hid;
            if (message.cd != null && message.hasOwnProperty("cd"))
                object.cd = message.cd;
            if (message.lv != null && message.hasOwnProperty("lv"))
                object.lv = message.lv;
            if (message.add != null && message.hasOwnProperty("add"))
                object.add = message.add;
            if (message.times != null && message.hasOwnProperty("times"))
                object.times = message.times;
            if (message.rid != null && message.hasOwnProperty("rid"))
                object.rid = message.rid;
            if (message.wake != null && message.hasOwnProperty("wake"))
                object.wake = message.wake;
            if (message.rlv != null && message.hasOwnProperty("rlv"))
                object.rlv = message.rlv;
            if (message.rqlv != null && message.hasOwnProperty("rqlv"))
                object.rqlv = message.rqlv;
            return object;
        };
    
        /**
         * Converts this pb_sscell to JSON.
         * @function toJSON
         * @memberof pb_sscell
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_sscell.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_sscell
         * @function getTypeUrl
         * @memberof pb_sscell
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_sscell.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_sscell";
        };
    
        return pb_sscell;
    })();
    
    $root.pb_ssevent = (function() {
    
        /**
         * Properties of a pb_ssevent.
         * @exports Ipb_ssevent
         * @interface Ipb_ssevent
         * @property {number|null} [id] pb_ssevent id
         * @property {number|null} [num] pb_ssevent num
         * @property {number|null} [lvItem] pb_ssevent lvItem
         * @property {number|null} [score] pb_ssevent score
         * @property {number|null} [num2] pb_ssevent num2
         * @property {Array.<Ipb_bag>|null} [reward] pb_ssevent reward
         */
    
        /**
         * Constructs a new pb_ssevent.
         * @exports pb_ssevent
         * @classdesc Represents a pb_ssevent.
         * @implements Ipb_ssevent
         * @constructor
         * @param {Ipb_ssevent=} [properties] Properties to set
         */
        function pb_ssevent(properties) {
            this.reward = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_ssevent id.
         * @member {number} id
         * @memberof pb_ssevent
         * @instance
         */
        pb_ssevent.prototype.id = 0;
    
        /**
         * pb_ssevent num.
         * @member {number} num
         * @memberof pb_ssevent
         * @instance
         */
        pb_ssevent.prototype.num = 0;
    
        /**
         * pb_ssevent lvItem.
         * @member {number} lvItem
         * @memberof pb_ssevent
         * @instance
         */
        pb_ssevent.prototype.lvItem = 0;
    
        /**
         * pb_ssevent score.
         * @member {number} score
         * @memberof pb_ssevent
         * @instance
         */
        pb_ssevent.prototype.score = 0;
    
        /**
         * pb_ssevent num2.
         * @member {number} num2
         * @memberof pb_ssevent
         * @instance
         */
        pb_ssevent.prototype.num2 = 0;
    
        /**
         * pb_ssevent reward.
         * @member {Array.<Ipb_bag>} reward
         * @memberof pb_ssevent
         * @instance
         */
        pb_ssevent.prototype.reward = $util.emptyArray;
    
        /**
         * Creates a new pb_ssevent instance using the specified properties.
         * @function create
         * @memberof pb_ssevent
         * @static
         * @param {Ipb_ssevent=} [properties] Properties to set
         * @returns {pb_ssevent} pb_ssevent instance
         */
        pb_ssevent.create = function create(properties) {
            return new pb_ssevent(properties);
        };
    
        /**
         * Encodes the specified pb_ssevent message. Does not implicitly {@link pb_ssevent.verify|verify} messages.
         * @function encode
         * @memberof pb_ssevent
         * @static
         * @param {Ipb_ssevent} message pb_ssevent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_ssevent.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.id);
            if (message.num != null && Object.hasOwnProperty.call(message, "num"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.num);
            if (message.lvItem != null && Object.hasOwnProperty.call(message, "lvItem"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.lvItem);
            if (message.score != null && Object.hasOwnProperty.call(message, "score"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.score);
            if (message.num2 != null && Object.hasOwnProperty.call(message, "num2"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.num2);
            if (message.reward != null && message.reward.length)
                for (var i = 0; i < message.reward.length; ++i)
                    $root.pb_bag.encode(message.reward[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified pb_ssevent message, length delimited. Does not implicitly {@link pb_ssevent.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_ssevent
         * @static
         * @param {Ipb_ssevent} message pb_ssevent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_ssevent.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_ssevent message from the specified reader or buffer.
         * @function decode
         * @memberof pb_ssevent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_ssevent} pb_ssevent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_ssevent.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_ssevent();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.id = reader.int32();
                        break;
                    }
                case 2: {
                        message.num = reader.int32();
                        break;
                    }
                case 3: {
                        message.lvItem = reader.int32();
                        break;
                    }
                case 4: {
                        message.score = reader.int32();
                        break;
                    }
                case 5: {
                        message.num2 = reader.int32();
                        break;
                    }
                case 6: {
                        if (!(message.reward && message.reward.length))
                            message.reward = [];
                        message.reward.push($root.pb_bag.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a pb_ssevent message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_ssevent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_ssevent} pb_ssevent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_ssevent.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_ssevent message.
         * @function verify
         * @memberof pb_ssevent
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_ssevent.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id))
                    return "id: integer expected";
            if (message.num != null && message.hasOwnProperty("num"))
                if (!$util.isInteger(message.num))
                    return "num: integer expected";
            if (message.lvItem != null && message.hasOwnProperty("lvItem"))
                if (!$util.isInteger(message.lvItem))
                    return "lvItem: integer expected";
            if (message.score != null && message.hasOwnProperty("score"))
                if (!$util.isInteger(message.score))
                    return "score: integer expected";
            if (message.num2 != null && message.hasOwnProperty("num2"))
                if (!$util.isInteger(message.num2))
                    return "num2: integer expected";
            if (message.reward != null && message.hasOwnProperty("reward")) {
                if (!Array.isArray(message.reward))
                    return "reward: array expected";
                for (var i = 0; i < message.reward.length; ++i) {
                    var error = $root.pb_bag.verify(message.reward[i]);
                    if (error)
                        return "reward." + error;
                }
            }
            return null;
        };
    
        /**
         * Creates a pb_ssevent message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_ssevent
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_ssevent} pb_ssevent
         */
        pb_ssevent.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_ssevent)
                return object;
            var message = new $root.pb_ssevent();
            if (object.id != null)
                message.id = object.id | 0;
            if (object.num != null)
                message.num = object.num | 0;
            if (object.lvItem != null)
                message.lvItem = object.lvItem | 0;
            if (object.score != null)
                message.score = object.score | 0;
            if (object.num2 != null)
                message.num2 = object.num2 | 0;
            if (object.reward) {
                if (!Array.isArray(object.reward))
                    throw TypeError(".pb_ssevent.reward: array expected");
                message.reward = [];
                for (var i = 0; i < object.reward.length; ++i) {
                    if (typeof object.reward[i] !== "object")
                        throw TypeError(".pb_ssevent.reward: object expected");
                    message.reward[i] = $root.pb_bag.fromObject(object.reward[i]);
                }
            }
            return message;
        };
    
        /**
         * Creates a plain object from a pb_ssevent message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_ssevent
         * @static
         * @param {pb_ssevent} message pb_ssevent
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_ssevent.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.reward = [];
            if (options.defaults) {
                object.id = 0;
                object.num = 0;
                object.lvItem = 0;
                object.score = 0;
                object.num2 = 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.num != null && message.hasOwnProperty("num"))
                object.num = message.num;
            if (message.lvItem != null && message.hasOwnProperty("lvItem"))
                object.lvItem = message.lvItem;
            if (message.score != null && message.hasOwnProperty("score"))
                object.score = message.score;
            if (message.num2 != null && message.hasOwnProperty("num2"))
                object.num2 = message.num2;
            if (message.reward && message.reward.length) {
                object.reward = [];
                for (var j = 0; j < message.reward.length; ++j)
                    object.reward[j] = $root.pb_bag.toObject(message.reward[j], options);
            }
            return object;
        };
    
        /**
         * Converts this pb_ssevent to JSON.
         * @function toJSON
         * @memberof pb_ssevent
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_ssevent.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_ssevent
         * @function getTypeUrl
         * @memberof pb_ssevent
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_ssevent.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_ssevent";
        };
    
        return pb_ssevent;
    })();
    
    $root.pb_sssweep = (function() {
    
        /**
         * Properties of a pb_sssweep.
         * @exports Ipb_sssweep
         * @interface Ipb_sssweep
         * @property {number|null} [pos] pb_sssweep pos
         * @property {number|null} [hid] pb_sssweep hid
         */
    
        /**
         * Constructs a new pb_sssweep.
         * @exports pb_sssweep
         * @classdesc Represents a pb_sssweep.
         * @implements Ipb_sssweep
         * @constructor
         * @param {Ipb_sssweep=} [properties] Properties to set
         */
        function pb_sssweep(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_sssweep pos.
         * @member {number} pos
         * @memberof pb_sssweep
         * @instance
         */
        pb_sssweep.prototype.pos = 0;
    
        /**
         * pb_sssweep hid.
         * @member {number} hid
         * @memberof pb_sssweep
         * @instance
         */
        pb_sssweep.prototype.hid = 0;
    
        /**
         * Creates a new pb_sssweep instance using the specified properties.
         * @function create
         * @memberof pb_sssweep
         * @static
         * @param {Ipb_sssweep=} [properties] Properties to set
         * @returns {pb_sssweep} pb_sssweep instance
         */
        pb_sssweep.create = function create(properties) {
            return new pb_sssweep(properties);
        };
    
        /**
         * Encodes the specified pb_sssweep message. Does not implicitly {@link pb_sssweep.verify|verify} messages.
         * @function encode
         * @memberof pb_sssweep
         * @static
         * @param {Ipb_sssweep} message pb_sssweep message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_sssweep.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.pos != null && Object.hasOwnProperty.call(message, "pos"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.pos);
            if (message.hid != null && Object.hasOwnProperty.call(message, "hid"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.hid);
            return writer;
        };
    
        /**
         * Encodes the specified pb_sssweep message, length delimited. Does not implicitly {@link pb_sssweep.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_sssweep
         * @static
         * @param {Ipb_sssweep} message pb_sssweep message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_sssweep.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_sssweep message from the specified reader or buffer.
         * @function decode
         * @memberof pb_sssweep
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_sssweep} pb_sssweep
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_sssweep.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_sssweep();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.pos = reader.int32();
                        break;
                    }
                case 2: {
                        message.hid = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a pb_sssweep message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_sssweep
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_sssweep} pb_sssweep
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_sssweep.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_sssweep message.
         * @function verify
         * @memberof pb_sssweep
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_sssweep.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.pos != null && message.hasOwnProperty("pos"))
                if (!$util.isInteger(message.pos))
                    return "pos: integer expected";
            if (message.hid != null && message.hasOwnProperty("hid"))
                if (!$util.isInteger(message.hid))
                    return "hid: integer expected";
            return null;
        };
    
        /**
         * Creates a pb_sssweep message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_sssweep
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_sssweep} pb_sssweep
         */
        pb_sssweep.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_sssweep)
                return object;
            var message = new $root.pb_sssweep();
            if (object.pos != null)
                message.pos = object.pos | 0;
            if (object.hid != null)
                message.hid = object.hid | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a pb_sssweep message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_sssweep
         * @static
         * @param {pb_sssweep} message pb_sssweep
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_sssweep.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.pos = 0;
                object.hid = 0;
            }
            if (message.pos != null && message.hasOwnProperty("pos"))
                object.pos = message.pos;
            if (message.hid != null && message.hasOwnProperty("hid"))
                object.hid = message.hid;
            return object;
        };
    
        /**
         * Converts this pb_sssweep to JSON.
         * @function toJSON
         * @memberof pb_sssweep
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_sssweep.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_sssweep
         * @function getTypeUrl
         * @memberof pb_sssweep
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_sssweep.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_sssweep";
        };
    
        return pb_sssweep;
    })();
    
    $root.pb_gacha = (function() {
    
        /**
         * Properties of a pb_gacha.
         * @exports Ipb_gacha
         * @interface Ipb_gacha
         * @property {number} item pb_gacha item
         * @property {number} gem pb_gacha gem
         * @property {number|null} [id] pb_gacha id
         * @property {number|null} [act] pb_gacha act
         * @property {number|null} [cd] pb_gacha cd
         */
    
        /**
         * Constructs a new pb_gacha.
         * @exports pb_gacha
         * @classdesc Represents a pb_gacha.
         * @implements Ipb_gacha
         * @constructor
         * @param {Ipb_gacha=} [properties] Properties to set
         */
        function pb_gacha(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_gacha item.
         * @member {number} item
         * @memberof pb_gacha
         * @instance
         */
        pb_gacha.prototype.item = 0;
    
        /**
         * pb_gacha gem.
         * @member {number} gem
         * @memberof pb_gacha
         * @instance
         */
        pb_gacha.prototype.gem = 0;
    
        /**
         * pb_gacha id.
         * @member {number} id
         * @memberof pb_gacha
         * @instance
         */
        pb_gacha.prototype.id = 0;
    
        /**
         * pb_gacha act.
         * @member {number} act
         * @memberof pb_gacha
         * @instance
         */
        pb_gacha.prototype.act = 0;
    
        /**
         * pb_gacha cd.
         * @member {number} cd
         * @memberof pb_gacha
         * @instance
         */
        pb_gacha.prototype.cd = 0;
    
        /**
         * Creates a new pb_gacha instance using the specified properties.
         * @function create
         * @memberof pb_gacha
         * @static
         * @param {Ipb_gacha=} [properties] Properties to set
         * @returns {pb_gacha} pb_gacha instance
         */
        pb_gacha.create = function create(properties) {
            return new pb_gacha(properties);
        };
    
        /**
         * Encodes the specified pb_gacha message. Does not implicitly {@link pb_gacha.verify|verify} messages.
         * @function encode
         * @memberof pb_gacha
         * @static
         * @param {Ipb_gacha} message pb_gacha message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_gacha.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.item);
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.gem);
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.id);
            if (message.act != null && Object.hasOwnProperty.call(message, "act"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.act);
            if (message.cd != null && Object.hasOwnProperty.call(message, "cd"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.cd);
            return writer;
        };
    
        /**
         * Encodes the specified pb_gacha message, length delimited. Does not implicitly {@link pb_gacha.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_gacha
         * @static
         * @param {Ipb_gacha} message pb_gacha message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_gacha.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_gacha message from the specified reader or buffer.
         * @function decode
         * @memberof pb_gacha
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_gacha} pb_gacha
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_gacha.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_gacha();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.item = reader.int32();
                        break;
                    }
                case 2: {
                        message.gem = reader.int32();
                        break;
                    }
                case 3: {
                        message.id = reader.int32();
                        break;
                    }
                case 4: {
                        message.act = reader.int32();
                        break;
                    }
                case 5: {
                        message.cd = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("item"))
                throw $util.ProtocolError("missing required 'item'", { instance: message });
            if (!message.hasOwnProperty("gem"))
                throw $util.ProtocolError("missing required 'gem'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a pb_gacha message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_gacha
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_gacha} pb_gacha
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_gacha.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_gacha message.
         * @function verify
         * @memberof pb_gacha
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_gacha.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.item))
                return "item: integer expected";
            if (!$util.isInteger(message.gem))
                return "gem: integer expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id))
                    return "id: integer expected";
            if (message.act != null && message.hasOwnProperty("act"))
                if (!$util.isInteger(message.act))
                    return "act: integer expected";
            if (message.cd != null && message.hasOwnProperty("cd"))
                if (!$util.isInteger(message.cd))
                    return "cd: integer expected";
            return null;
        };
    
        /**
         * Creates a pb_gacha message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_gacha
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_gacha} pb_gacha
         */
        pb_gacha.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_gacha)
                return object;
            var message = new $root.pb_gacha();
            if (object.item != null)
                message.item = object.item | 0;
            if (object.gem != null)
                message.gem = object.gem | 0;
            if (object.id != null)
                message.id = object.id | 0;
            if (object.act != null)
                message.act = object.act | 0;
            if (object.cd != null)
                message.cd = object.cd | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a pb_gacha message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_gacha
         * @static
         * @param {pb_gacha} message pb_gacha
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_gacha.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.item = 0;
                object.gem = 0;
                object.id = 0;
                object.act = 0;
                object.cd = 0;
            }
            if (message.item != null && message.hasOwnProperty("item"))
                object.item = message.item;
            if (message.gem != null && message.hasOwnProperty("gem"))
                object.gem = message.gem;
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.act != null && message.hasOwnProperty("act"))
                object.act = message.act;
            if (message.cd != null && message.hasOwnProperty("cd"))
                object.cd = message.cd;
            return object;
        };
    
        /**
         * Converts this pb_gacha to JSON.
         * @function toJSON
         * @memberof pb_gacha
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_gacha.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_gacha
         * @function getTypeUrl
         * @memberof pb_gacha
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_gacha.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_gacha";
        };
    
        return pb_gacha;
    })();
    
    $root.pb_mail = (function() {
    
        /**
         * Properties of a pb_mail.
         * @exports Ipb_mail
         * @interface Ipb_mail
         * @property {number} mid pb_mail mid
         * @property {number} id pb_mail id
         * @property {number|Long|null} [uid] pb_mail uid
         * @property {number} flag pb_mail flag
         * @property {number} sendTime pb_mail sendTime
         * @property {string|null} [title] pb_mail title
         * @property {string|null} [from] pb_mail from
         * @property {string|null} [content] pb_mail content
         * @property {string|null} [contentO] pb_mail contentO
         * @property {Ipb_bag|null} [affix] pb_mail affix
         */
    
        /**
         * Constructs a new pb_mail.
         * @exports pb_mail
         * @classdesc Represents a pb_mail.
         * @implements Ipb_mail
         * @constructor
         * @param {Ipb_mail=} [properties] Properties to set
         */
        function pb_mail(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_mail mid.
         * @member {number} mid
         * @memberof pb_mail
         * @instance
         */
        pb_mail.prototype.mid = 0;
    
        /**
         * pb_mail id.
         * @member {number} id
         * @memberof pb_mail
         * @instance
         */
        pb_mail.prototype.id = 0;
    
        /**
         * pb_mail uid.
         * @member {number|Long} uid
         * @memberof pb_mail
         * @instance
         */
        pb_mail.prototype.uid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * pb_mail flag.
         * @member {number} flag
         * @memberof pb_mail
         * @instance
         */
        pb_mail.prototype.flag = 0;
    
        /**
         * pb_mail sendTime.
         * @member {number} sendTime
         * @memberof pb_mail
         * @instance
         */
        pb_mail.prototype.sendTime = 0;
    
        /**
         * pb_mail title.
         * @member {string} title
         * @memberof pb_mail
         * @instance
         */
        pb_mail.prototype.title = "";
    
        /**
         * pb_mail from.
         * @member {string} from
         * @memberof pb_mail
         * @instance
         */
        pb_mail.prototype.from = "";
    
        /**
         * pb_mail content.
         * @member {string} content
         * @memberof pb_mail
         * @instance
         */
        pb_mail.prototype.content = "";
    
        /**
         * pb_mail contentO.
         * @member {string} contentO
         * @memberof pb_mail
         * @instance
         */
        pb_mail.prototype.contentO = "";
    
        /**
         * pb_mail affix.
         * @member {Ipb_bag|null|undefined} affix
         * @memberof pb_mail
         * @instance
         */
        pb_mail.prototype.affix = null;
    
        /**
         * Creates a new pb_mail instance using the specified properties.
         * @function create
         * @memberof pb_mail
         * @static
         * @param {Ipb_mail=} [properties] Properties to set
         * @returns {pb_mail} pb_mail instance
         */
        pb_mail.create = function create(properties) {
            return new pb_mail(properties);
        };
    
        /**
         * Encodes the specified pb_mail message. Does not implicitly {@link pb_mail.verify|verify} messages.
         * @function encode
         * @memberof pb_mail
         * @static
         * @param {Ipb_mail} message pb_mail message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_mail.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.mid);
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.id);
            if (message.uid != null && Object.hasOwnProperty.call(message, "uid"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.uid);
            writer.uint32(/* id 4, wireType 0 =*/32).int32(message.flag);
            writer.uint32(/* id 5, wireType 0 =*/40).int32(message.sendTime);
            if (message.title != null && Object.hasOwnProperty.call(message, "title"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.title);
            if (message.from != null && Object.hasOwnProperty.call(message, "from"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.from);
            if (message.content != null && Object.hasOwnProperty.call(message, "content"))
                writer.uint32(/* id 8, wireType 2 =*/66).string(message.content);
            if (message.contentO != null && Object.hasOwnProperty.call(message, "contentO"))
                writer.uint32(/* id 9, wireType 2 =*/74).string(message.contentO);
            if (message.affix != null && Object.hasOwnProperty.call(message, "affix"))
                $root.pb_bag.encode(message.affix, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified pb_mail message, length delimited. Does not implicitly {@link pb_mail.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_mail
         * @static
         * @param {Ipb_mail} message pb_mail message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_mail.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_mail message from the specified reader or buffer.
         * @function decode
         * @memberof pb_mail
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_mail} pb_mail
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_mail.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_mail();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.mid = reader.int32();
                        break;
                    }
                case 2: {
                        message.id = reader.int32();
                        break;
                    }
                case 3: {
                        message.uid = reader.int64();
                        break;
                    }
                case 4: {
                        message.flag = reader.int32();
                        break;
                    }
                case 5: {
                        message.sendTime = reader.int32();
                        break;
                    }
                case 6: {
                        message.title = reader.string();
                        break;
                    }
                case 7: {
                        message.from = reader.string();
                        break;
                    }
                case 8: {
                        message.content = reader.string();
                        break;
                    }
                case 9: {
                        message.contentO = reader.string();
                        break;
                    }
                case 10: {
                        message.affix = $root.pb_bag.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("mid"))
                throw $util.ProtocolError("missing required 'mid'", { instance: message });
            if (!message.hasOwnProperty("id"))
                throw $util.ProtocolError("missing required 'id'", { instance: message });
            if (!message.hasOwnProperty("flag"))
                throw $util.ProtocolError("missing required 'flag'", { instance: message });
            if (!message.hasOwnProperty("sendTime"))
                throw $util.ProtocolError("missing required 'sendTime'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a pb_mail message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_mail
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_mail} pb_mail
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_mail.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_mail message.
         * @function verify
         * @memberof pb_mail
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_mail.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.mid))
                return "mid: integer expected";
            if (!$util.isInteger(message.id))
                return "id: integer expected";
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (!$util.isInteger(message.uid) && !(message.uid && $util.isInteger(message.uid.low) && $util.isInteger(message.uid.high)))
                    return "uid: integer|Long expected";
            if (!$util.isInteger(message.flag))
                return "flag: integer expected";
            if (!$util.isInteger(message.sendTime))
                return "sendTime: integer expected";
            if (message.title != null && message.hasOwnProperty("title"))
                if (!$util.isString(message.title))
                    return "title: string expected";
            if (message.from != null && message.hasOwnProperty("from"))
                if (!$util.isString(message.from))
                    return "from: string expected";
            if (message.content != null && message.hasOwnProperty("content"))
                if (!$util.isString(message.content))
                    return "content: string expected";
            if (message.contentO != null && message.hasOwnProperty("contentO"))
                if (!$util.isString(message.contentO))
                    return "contentO: string expected";
            if (message.affix != null && message.hasOwnProperty("affix")) {
                var error = $root.pb_bag.verify(message.affix);
                if (error)
                    return "affix." + error;
            }
            return null;
        };
    
        /**
         * Creates a pb_mail message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_mail
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_mail} pb_mail
         */
        pb_mail.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_mail)
                return object;
            var message = new $root.pb_mail();
            if (object.mid != null)
                message.mid = object.mid | 0;
            if (object.id != null)
                message.id = object.id | 0;
            if (object.uid != null)
                if ($util.Long)
                    (message.uid = $util.Long.fromValue(object.uid)).unsigned = false;
                else if (typeof object.uid === "string")
                    message.uid = parseInt(object.uid, 10);
                else if (typeof object.uid === "number")
                    message.uid = object.uid;
                else if (typeof object.uid === "object")
                    message.uid = new $util.LongBits(object.uid.low >>> 0, object.uid.high >>> 0).toNumber();
            if (object.flag != null)
                message.flag = object.flag | 0;
            if (object.sendTime != null)
                message.sendTime = object.sendTime | 0;
            if (object.title != null)
                message.title = String(object.title);
            if (object.from != null)
                message.from = String(object.from);
            if (object.content != null)
                message.content = String(object.content);
            if (object.contentO != null)
                message.contentO = String(object.contentO);
            if (object.affix != null) {
                if (typeof object.affix !== "object")
                    throw TypeError(".pb_mail.affix: object expected");
                message.affix = $root.pb_bag.fromObject(object.affix);
            }
            return message;
        };
    
        /**
         * Creates a plain object from a pb_mail message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_mail
         * @static
         * @param {pb_mail} message pb_mail
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_mail.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.mid = 0;
                object.id = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.uid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.uid = options.longs === String ? "0" : 0;
                object.flag = 0;
                object.sendTime = 0;
                object.title = "";
                object.from = "";
                object.content = "";
                object.contentO = "";
                object.affix = null;
            }
            if (message.mid != null && message.hasOwnProperty("mid"))
                object.mid = message.mid;
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (typeof message.uid === "number")
                    object.uid = options.longs === String ? String(message.uid) : message.uid;
                else
                    object.uid = options.longs === String ? $util.Long.prototype.toString.call(message.uid) : options.longs === Number ? new $util.LongBits(message.uid.low >>> 0, message.uid.high >>> 0).toNumber() : message.uid;
            if (message.flag != null && message.hasOwnProperty("flag"))
                object.flag = message.flag;
            if (message.sendTime != null && message.hasOwnProperty("sendTime"))
                object.sendTime = message.sendTime;
            if (message.title != null && message.hasOwnProperty("title"))
                object.title = message.title;
            if (message.from != null && message.hasOwnProperty("from"))
                object.from = message.from;
            if (message.content != null && message.hasOwnProperty("content"))
                object.content = message.content;
            if (message.contentO != null && message.hasOwnProperty("contentO"))
                object.contentO = message.contentO;
            if (message.affix != null && message.hasOwnProperty("affix"))
                object.affix = $root.pb_bag.toObject(message.affix, options);
            return object;
        };
    
        /**
         * Converts this pb_mail to JSON.
         * @function toJSON
         * @memberof pb_mail
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_mail.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_mail
         * @function getTypeUrl
         * @memberof pb_mail
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_mail.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_mail";
        };
    
        return pb_mail;
    })();
    
    $root.pb_cunit = (function() {
    
        /**
         * Properties of a pb_cunit.
         * @exports Ipb_cunit
         * @interface Ipb_cunit
         * @property {number} id pb_cunit id
         * @property {number|null} [lv] pb_cunit lv
         * @property {number|null} [star] pb_cunit star
         * @property {number|Long|null} [power] pb_cunit power
         * @property {number|null} [hp] pb_cunit hp
         * @property {number|null} [atk] pb_cunit atk
         * @property {number|null} [armor] pb_cunit armor
         * @property {number|null} [spd] pb_cunit spd
         * @property {number|null} [wake] pb_cunit wake
         * @property {number|null} [skin] pb_cunit skin
         * @property {number|null} [stl] pb_cunit stl
         * @property {number|null} [qlv] pb_cunit qlv
         * @property {Ipb_tree|null} [tree] pb_cunit tree
         * @property {number|null} [core] pb_cunit core
         */
    
        /**
         * Constructs a new pb_cunit.
         * @exports pb_cunit
         * @classdesc Represents a pb_cunit.
         * @implements Ipb_cunit
         * @constructor
         * @param {Ipb_cunit=} [properties] Properties to set
         */
        function pb_cunit(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_cunit id.
         * @member {number} id
         * @memberof pb_cunit
         * @instance
         */
        pb_cunit.prototype.id = 0;
    
        /**
         * pb_cunit lv.
         * @member {number} lv
         * @memberof pb_cunit
         * @instance
         */
        pb_cunit.prototype.lv = 0;
    
        /**
         * pb_cunit star.
         * @member {number} star
         * @memberof pb_cunit
         * @instance
         */
        pb_cunit.prototype.star = 0;
    
        /**
         * pb_cunit power.
         * @member {number|Long} power
         * @memberof pb_cunit
         * @instance
         */
        pb_cunit.prototype.power = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * pb_cunit hp.
         * @member {number} hp
         * @memberof pb_cunit
         * @instance
         */
        pb_cunit.prototype.hp = 0;
    
        /**
         * pb_cunit atk.
         * @member {number} atk
         * @memberof pb_cunit
         * @instance
         */
        pb_cunit.prototype.atk = 0;
    
        /**
         * pb_cunit armor.
         * @member {number} armor
         * @memberof pb_cunit
         * @instance
         */
        pb_cunit.prototype.armor = 0;
    
        /**
         * pb_cunit spd.
         * @member {number} spd
         * @memberof pb_cunit
         * @instance
         */
        pb_cunit.prototype.spd = 0;
    
        /**
         * pb_cunit wake.
         * @member {number} wake
         * @memberof pb_cunit
         * @instance
         */
        pb_cunit.prototype.wake = 0;
    
        /**
         * pb_cunit skin.
         * @member {number} skin
         * @memberof pb_cunit
         * @instance
         */
        pb_cunit.prototype.skin = 0;
    
        /**
         * pb_cunit stl.
         * @member {number} stl
         * @memberof pb_cunit
         * @instance
         */
        pb_cunit.prototype.stl = 0;
    
        /**
         * pb_cunit qlv.
         * @member {number} qlv
         * @memberof pb_cunit
         * @instance
         */
        pb_cunit.prototype.qlv = 0;
    
        /**
         * pb_cunit tree.
         * @member {Ipb_tree|null|undefined} tree
         * @memberof pb_cunit
         * @instance
         */
        pb_cunit.prototype.tree = null;
    
        /**
         * pb_cunit core.
         * @member {number} core
         * @memberof pb_cunit
         * @instance
         */
        pb_cunit.prototype.core = 0;
    
        /**
         * Creates a new pb_cunit instance using the specified properties.
         * @function create
         * @memberof pb_cunit
         * @static
         * @param {Ipb_cunit=} [properties] Properties to set
         * @returns {pb_cunit} pb_cunit instance
         */
        pb_cunit.create = function create(properties) {
            return new pb_cunit(properties);
        };
    
        /**
         * Encodes the specified pb_cunit message. Does not implicitly {@link pb_cunit.verify|verify} messages.
         * @function encode
         * @memberof pb_cunit
         * @static
         * @param {Ipb_cunit} message pb_cunit message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_cunit.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.id);
            if (message.lv != null && Object.hasOwnProperty.call(message, "lv"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.lv);
            if (message.star != null && Object.hasOwnProperty.call(message, "star"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.star);
            if (message.power != null && Object.hasOwnProperty.call(message, "power"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.power);
            if (message.hp != null && Object.hasOwnProperty.call(message, "hp"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.hp);
            if (message.atk != null && Object.hasOwnProperty.call(message, "atk"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.atk);
            if (message.armor != null && Object.hasOwnProperty.call(message, "armor"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.armor);
            if (message.spd != null && Object.hasOwnProperty.call(message, "spd"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.spd);
            if (message.wake != null && Object.hasOwnProperty.call(message, "wake"))
                writer.uint32(/* id 9, wireType 0 =*/72).int32(message.wake);
            if (message.skin != null && Object.hasOwnProperty.call(message, "skin"))
                writer.uint32(/* id 10, wireType 0 =*/80).int32(message.skin);
            if (message.stl != null && Object.hasOwnProperty.call(message, "stl"))
                writer.uint32(/* id 11, wireType 0 =*/88).int32(message.stl);
            if (message.qlv != null && Object.hasOwnProperty.call(message, "qlv"))
                writer.uint32(/* id 12, wireType 0 =*/96).int32(message.qlv);
            if (message.tree != null && Object.hasOwnProperty.call(message, "tree"))
                $root.pb_tree.encode(message.tree, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
            if (message.core != null && Object.hasOwnProperty.call(message, "core"))
                writer.uint32(/* id 14, wireType 0 =*/112).int32(message.core);
            return writer;
        };
    
        /**
         * Encodes the specified pb_cunit message, length delimited. Does not implicitly {@link pb_cunit.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_cunit
         * @static
         * @param {Ipb_cunit} message pb_cunit message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_cunit.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_cunit message from the specified reader or buffer.
         * @function decode
         * @memberof pb_cunit
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_cunit} pb_cunit
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_cunit.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_cunit();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.id = reader.int32();
                        break;
                    }
                case 2: {
                        message.lv = reader.int32();
                        break;
                    }
                case 3: {
                        message.star = reader.int32();
                        break;
                    }
                case 4: {
                        message.power = reader.int64();
                        break;
                    }
                case 5: {
                        message.hp = reader.int32();
                        break;
                    }
                case 6: {
                        message.atk = reader.int32();
                        break;
                    }
                case 7: {
                        message.armor = reader.int32();
                        break;
                    }
                case 8: {
                        message.spd = reader.int32();
                        break;
                    }
                case 9: {
                        message.wake = reader.int32();
                        break;
                    }
                case 10: {
                        message.skin = reader.int32();
                        break;
                    }
                case 11: {
                        message.stl = reader.int32();
                        break;
                    }
                case 12: {
                        message.qlv = reader.int32();
                        break;
                    }
                case 13: {
                        message.tree = $root.pb_tree.decode(reader, reader.uint32());
                        break;
                    }
                case 14: {
                        message.core = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("id"))
                throw $util.ProtocolError("missing required 'id'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a pb_cunit message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_cunit
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_cunit} pb_cunit
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_cunit.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_cunit message.
         * @function verify
         * @memberof pb_cunit
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_cunit.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.id))
                return "id: integer expected";
            if (message.lv != null && message.hasOwnProperty("lv"))
                if (!$util.isInteger(message.lv))
                    return "lv: integer expected";
            if (message.star != null && message.hasOwnProperty("star"))
                if (!$util.isInteger(message.star))
                    return "star: integer expected";
            if (message.power != null && message.hasOwnProperty("power"))
                if (!$util.isInteger(message.power) && !(message.power && $util.isInteger(message.power.low) && $util.isInteger(message.power.high)))
                    return "power: integer|Long expected";
            if (message.hp != null && message.hasOwnProperty("hp"))
                if (!$util.isInteger(message.hp))
                    return "hp: integer expected";
            if (message.atk != null && message.hasOwnProperty("atk"))
                if (!$util.isInteger(message.atk))
                    return "atk: integer expected";
            if (message.armor != null && message.hasOwnProperty("armor"))
                if (!$util.isInteger(message.armor))
                    return "armor: integer expected";
            if (message.spd != null && message.hasOwnProperty("spd"))
                if (!$util.isInteger(message.spd))
                    return "spd: integer expected";
            if (message.wake != null && message.hasOwnProperty("wake"))
                if (!$util.isInteger(message.wake))
                    return "wake: integer expected";
            if (message.skin != null && message.hasOwnProperty("skin"))
                if (!$util.isInteger(message.skin))
                    return "skin: integer expected";
            if (message.stl != null && message.hasOwnProperty("stl"))
                if (!$util.isInteger(message.stl))
                    return "stl: integer expected";
            if (message.qlv != null && message.hasOwnProperty("qlv"))
                if (!$util.isInteger(message.qlv))
                    return "qlv: integer expected";
            if (message.tree != null && message.hasOwnProperty("tree")) {
                var error = $root.pb_tree.verify(message.tree);
                if (error)
                    return "tree." + error;
            }
            if (message.core != null && message.hasOwnProperty("core"))
                if (!$util.isInteger(message.core))
                    return "core: integer expected";
            return null;
        };
    
        /**
         * Creates a pb_cunit message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_cunit
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_cunit} pb_cunit
         */
        pb_cunit.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_cunit)
                return object;
            var message = new $root.pb_cunit();
            if (object.id != null)
                message.id = object.id | 0;
            if (object.lv != null)
                message.lv = object.lv | 0;
            if (object.star != null)
                message.star = object.star | 0;
            if (object.power != null)
                if ($util.Long)
                    (message.power = $util.Long.fromValue(object.power)).unsigned = false;
                else if (typeof object.power === "string")
                    message.power = parseInt(object.power, 10);
                else if (typeof object.power === "number")
                    message.power = object.power;
                else if (typeof object.power === "object")
                    message.power = new $util.LongBits(object.power.low >>> 0, object.power.high >>> 0).toNumber();
            if (object.hp != null)
                message.hp = object.hp | 0;
            if (object.atk != null)
                message.atk = object.atk | 0;
            if (object.armor != null)
                message.armor = object.armor | 0;
            if (object.spd != null)
                message.spd = object.spd | 0;
            if (object.wake != null)
                message.wake = object.wake | 0;
            if (object.skin != null)
                message.skin = object.skin | 0;
            if (object.stl != null)
                message.stl = object.stl | 0;
            if (object.qlv != null)
                message.qlv = object.qlv | 0;
            if (object.tree != null) {
                if (typeof object.tree !== "object")
                    throw TypeError(".pb_cunit.tree: object expected");
                message.tree = $root.pb_tree.fromObject(object.tree);
            }
            if (object.core != null)
                message.core = object.core | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a pb_cunit message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_cunit
         * @static
         * @param {pb_cunit} message pb_cunit
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_cunit.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = 0;
                object.lv = 0;
                object.star = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.power = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.power = options.longs === String ? "0" : 0;
                object.hp = 0;
                object.atk = 0;
                object.armor = 0;
                object.spd = 0;
                object.wake = 0;
                object.skin = 0;
                object.stl = 0;
                object.qlv = 0;
                object.tree = null;
                object.core = 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.lv != null && message.hasOwnProperty("lv"))
                object.lv = message.lv;
            if (message.star != null && message.hasOwnProperty("star"))
                object.star = message.star;
            if (message.power != null && message.hasOwnProperty("power"))
                if (typeof message.power === "number")
                    object.power = options.longs === String ? String(message.power) : message.power;
                else
                    object.power = options.longs === String ? $util.Long.prototype.toString.call(message.power) : options.longs === Number ? new $util.LongBits(message.power.low >>> 0, message.power.high >>> 0).toNumber() : message.power;
            if (message.hp != null && message.hasOwnProperty("hp"))
                object.hp = message.hp;
            if (message.atk != null && message.hasOwnProperty("atk"))
                object.atk = message.atk;
            if (message.armor != null && message.hasOwnProperty("armor"))
                object.armor = message.armor;
            if (message.spd != null && message.hasOwnProperty("spd"))
                object.spd = message.spd;
            if (message.wake != null && message.hasOwnProperty("wake"))
                object.wake = message.wake;
            if (message.skin != null && message.hasOwnProperty("skin"))
                object.skin = message.skin;
            if (message.stl != null && message.hasOwnProperty("stl"))
                object.stl = message.stl;
            if (message.qlv != null && message.hasOwnProperty("qlv"))
                object.qlv = message.qlv;
            if (message.tree != null && message.hasOwnProperty("tree"))
                object.tree = $root.pb_tree.toObject(message.tree, options);
            if (message.core != null && message.hasOwnProperty("core"))
                object.core = message.core;
            return object;
        };
    
        /**
         * Converts this pb_cunit to JSON.
         * @function toJSON
         * @memberof pb_cunit
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_cunit.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_cunit
         * @function getTypeUrl
         * @memberof pb_cunit
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_cunit.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_cunit";
        };
    
        return pb_cunit;
    })();
    
    $root.pb_chat = (function() {
    
        /**
         * Properties of a pb_chat.
         * @exports Ipb_chat
         * @interface Ipb_chat
         * @property {number|Long|null} [uid] pb_chat uid
         * @property {number|null} [logo] pb_chat logo
         * @property {number|null} [lv] pb_chat lv
         * @property {number|null} [vip] pb_chat vip
         * @property {string|null} [name] pb_chat name
         * @property {number|null} [type] pb_chat type
         * @property {string|null} [text] pb_chat text
         * @property {number|null} [time] pb_chat time
         * @property {number|null} [shareId] pb_chat shareId
         * @property {number|null} [heroId] pb_chat heroId
         * @property {number|null} [finalRank] pb_chat finalRank
         * @property {number|null} [gid] pb_chat gid
         * @property {string|null} [gname] pb_chat gname
         * @property {number|null} [glv] pb_chat glv
         * @property {string|null} [gmsg] pb_chat gmsg
         * @property {number|null} [gFight] pb_chat gFight
         * @property {number|null} [border] pb_chat border
         * @property {Ipb_hteam|null} [hteam] pb_chat hteam
         * @property {string|null} [country] pb_chat country
         * @property {string|null} [sds] pb_chat sds
         * @property {string|null} [city] pb_chat city
         * @property {number|Long|null} [emblem] pb_chat emblem
         */
    
        /**
         * Constructs a new pb_chat.
         * @exports pb_chat
         * @classdesc Represents a pb_chat.
         * @implements Ipb_chat
         * @constructor
         * @param {Ipb_chat=} [properties] Properties to set
         */
        function pb_chat(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_chat uid.
         * @member {number|Long} uid
         * @memberof pb_chat
         * @instance
         */
        pb_chat.prototype.uid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * pb_chat logo.
         * @member {number} logo
         * @memberof pb_chat
         * @instance
         */
        pb_chat.prototype.logo = 0;
    
        /**
         * pb_chat lv.
         * @member {number} lv
         * @memberof pb_chat
         * @instance
         */
        pb_chat.prototype.lv = 0;
    
        /**
         * pb_chat vip.
         * @member {number} vip
         * @memberof pb_chat
         * @instance
         */
        pb_chat.prototype.vip = 0;
    
        /**
         * pb_chat name.
         * @member {string} name
         * @memberof pb_chat
         * @instance
         */
        pb_chat.prototype.name = "";
    
        /**
         * pb_chat type.
         * @member {number} type
         * @memberof pb_chat
         * @instance
         */
        pb_chat.prototype.type = 0;
    
        /**
         * pb_chat text.
         * @member {string} text
         * @memberof pb_chat
         * @instance
         */
        pb_chat.prototype.text = "";
    
        /**
         * pb_chat time.
         * @member {number} time
         * @memberof pb_chat
         * @instance
         */
        pb_chat.prototype.time = 0;
    
        /**
         * pb_chat shareId.
         * @member {number} shareId
         * @memberof pb_chat
         * @instance
         */
        pb_chat.prototype.shareId = 0;
    
        /**
         * pb_chat heroId.
         * @member {number} heroId
         * @memberof pb_chat
         * @instance
         */
        pb_chat.prototype.heroId = 0;
    
        /**
         * pb_chat finalRank.
         * @member {number} finalRank
         * @memberof pb_chat
         * @instance
         */
        pb_chat.prototype.finalRank = 0;
    
        /**
         * pb_chat gid.
         * @member {number} gid
         * @memberof pb_chat
         * @instance
         */
        pb_chat.prototype.gid = 0;
    
        /**
         * pb_chat gname.
         * @member {string} gname
         * @memberof pb_chat
         * @instance
         */
        pb_chat.prototype.gname = "";
    
        /**
         * pb_chat glv.
         * @member {number} glv
         * @memberof pb_chat
         * @instance
         */
        pb_chat.prototype.glv = 0;
    
        /**
         * pb_chat gmsg.
         * @member {string} gmsg
         * @memberof pb_chat
         * @instance
         */
        pb_chat.prototype.gmsg = "";
    
        /**
         * pb_chat gFight.
         * @member {number} gFight
         * @memberof pb_chat
         * @instance
         */
        pb_chat.prototype.gFight = 0;
    
        /**
         * pb_chat border.
         * @member {number} border
         * @memberof pb_chat
         * @instance
         */
        pb_chat.prototype.border = 0;
    
        /**
         * pb_chat hteam.
         * @member {Ipb_hteam|null|undefined} hteam
         * @memberof pb_chat
         * @instance
         */
        pb_chat.prototype.hteam = null;
    
        /**
         * pb_chat country.
         * @member {string} country
         * @memberof pb_chat
         * @instance
         */
        pb_chat.prototype.country = "";
    
        /**
         * pb_chat sds.
         * @member {string} sds
         * @memberof pb_chat
         * @instance
         */
        pb_chat.prototype.sds = "";
    
        /**
         * pb_chat city.
         * @member {string} city
         * @memberof pb_chat
         * @instance
         */
        pb_chat.prototype.city = "";
    
        /**
         * pb_chat emblem.
         * @member {number|Long} emblem
         * @memberof pb_chat
         * @instance
         */
        pb_chat.prototype.emblem = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * Creates a new pb_chat instance using the specified properties.
         * @function create
         * @memberof pb_chat
         * @static
         * @param {Ipb_chat=} [properties] Properties to set
         * @returns {pb_chat} pb_chat instance
         */
        pb_chat.create = function create(properties) {
            return new pb_chat(properties);
        };
    
        /**
         * Encodes the specified pb_chat message. Does not implicitly {@link pb_chat.verify|verify} messages.
         * @function encode
         * @memberof pb_chat
         * @static
         * @param {Ipb_chat} message pb_chat message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_chat.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.uid != null && Object.hasOwnProperty.call(message, "uid"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.uid);
            if (message.logo != null && Object.hasOwnProperty.call(message, "logo"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.logo);
            if (message.lv != null && Object.hasOwnProperty.call(message, "lv"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.lv);
            if (message.vip != null && Object.hasOwnProperty.call(message, "vip"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.vip);
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.name);
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.type);
            if (message.text != null && Object.hasOwnProperty.call(message, "text"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.text);
            if (message.time != null && Object.hasOwnProperty.call(message, "time"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.time);
            if (message.shareId != null && Object.hasOwnProperty.call(message, "shareId"))
                writer.uint32(/* id 9, wireType 0 =*/72).int32(message.shareId);
            if (message.heroId != null && Object.hasOwnProperty.call(message, "heroId"))
                writer.uint32(/* id 10, wireType 0 =*/80).int32(message.heroId);
            if (message.finalRank != null && Object.hasOwnProperty.call(message, "finalRank"))
                writer.uint32(/* id 11, wireType 0 =*/88).int32(message.finalRank);
            if (message.gid != null && Object.hasOwnProperty.call(message, "gid"))
                writer.uint32(/* id 12, wireType 0 =*/96).int32(message.gid);
            if (message.gname != null && Object.hasOwnProperty.call(message, "gname"))
                writer.uint32(/* id 13, wireType 2 =*/106).string(message.gname);
            if (message.glv != null && Object.hasOwnProperty.call(message, "glv"))
                writer.uint32(/* id 14, wireType 0 =*/112).int32(message.glv);
            if (message.gmsg != null && Object.hasOwnProperty.call(message, "gmsg"))
                writer.uint32(/* id 15, wireType 2 =*/122).string(message.gmsg);
            if (message.gFight != null && Object.hasOwnProperty.call(message, "gFight"))
                writer.uint32(/* id 16, wireType 0 =*/128).int32(message.gFight);
            if (message.border != null && Object.hasOwnProperty.call(message, "border"))
                writer.uint32(/* id 17, wireType 0 =*/136).int32(message.border);
            if (message.hteam != null && Object.hasOwnProperty.call(message, "hteam"))
                $root.pb_hteam.encode(message.hteam, writer.uint32(/* id 18, wireType 2 =*/146).fork()).ldelim();
            if (message.country != null && Object.hasOwnProperty.call(message, "country"))
                writer.uint32(/* id 19, wireType 2 =*/154).string(message.country);
            if (message.sds != null && Object.hasOwnProperty.call(message, "sds"))
                writer.uint32(/* id 20, wireType 2 =*/162).string(message.sds);
            if (message.city != null && Object.hasOwnProperty.call(message, "city"))
                writer.uint32(/* id 21, wireType 2 =*/170).string(message.city);
            if (message.emblem != null && Object.hasOwnProperty.call(message, "emblem"))
                writer.uint32(/* id 22, wireType 0 =*/176).int64(message.emblem);
            return writer;
        };
    
        /**
         * Encodes the specified pb_chat message, length delimited. Does not implicitly {@link pb_chat.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_chat
         * @static
         * @param {Ipb_chat} message pb_chat message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_chat.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_chat message from the specified reader or buffer.
         * @function decode
         * @memberof pb_chat
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_chat} pb_chat
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_chat.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_chat();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.uid = reader.int64();
                        break;
                    }
                case 2: {
                        message.logo = reader.int32();
                        break;
                    }
                case 3: {
                        message.lv = reader.int32();
                        break;
                    }
                case 4: {
                        message.vip = reader.int32();
                        break;
                    }
                case 5: {
                        message.name = reader.string();
                        break;
                    }
                case 6: {
                        message.type = reader.int32();
                        break;
                    }
                case 7: {
                        message.text = reader.string();
                        break;
                    }
                case 8: {
                        message.time = reader.int32();
                        break;
                    }
                case 9: {
                        message.shareId = reader.int32();
                        break;
                    }
                case 10: {
                        message.heroId = reader.int32();
                        break;
                    }
                case 11: {
                        message.finalRank = reader.int32();
                        break;
                    }
                case 12: {
                        message.gid = reader.int32();
                        break;
                    }
                case 13: {
                        message.gname = reader.string();
                        break;
                    }
                case 14: {
                        message.glv = reader.int32();
                        break;
                    }
                case 15: {
                        message.gmsg = reader.string();
                        break;
                    }
                case 16: {
                        message.gFight = reader.int32();
                        break;
                    }
                case 17: {
                        message.border = reader.int32();
                        break;
                    }
                case 18: {
                        message.hteam = $root.pb_hteam.decode(reader, reader.uint32());
                        break;
                    }
                case 19: {
                        message.country = reader.string();
                        break;
                    }
                case 20: {
                        message.sds = reader.string();
                        break;
                    }
                case 21: {
                        message.city = reader.string();
                        break;
                    }
                case 22: {
                        message.emblem = reader.int64();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a pb_chat message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_chat
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_chat} pb_chat
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_chat.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_chat message.
         * @function verify
         * @memberof pb_chat
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_chat.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (!$util.isInteger(message.uid) && !(message.uid && $util.isInteger(message.uid.low) && $util.isInteger(message.uid.high)))
                    return "uid: integer|Long expected";
            if (message.logo != null && message.hasOwnProperty("logo"))
                if (!$util.isInteger(message.logo))
                    return "logo: integer expected";
            if (message.lv != null && message.hasOwnProperty("lv"))
                if (!$util.isInteger(message.lv))
                    return "lv: integer expected";
            if (message.vip != null && message.hasOwnProperty("vip"))
                if (!$util.isInteger(message.vip))
                    return "vip: integer expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isInteger(message.type))
                    return "type: integer expected";
            if (message.text != null && message.hasOwnProperty("text"))
                if (!$util.isString(message.text))
                    return "text: string expected";
            if (message.time != null && message.hasOwnProperty("time"))
                if (!$util.isInteger(message.time))
                    return "time: integer expected";
            if (message.shareId != null && message.hasOwnProperty("shareId"))
                if (!$util.isInteger(message.shareId))
                    return "shareId: integer expected";
            if (message.heroId != null && message.hasOwnProperty("heroId"))
                if (!$util.isInteger(message.heroId))
                    return "heroId: integer expected";
            if (message.finalRank != null && message.hasOwnProperty("finalRank"))
                if (!$util.isInteger(message.finalRank))
                    return "finalRank: integer expected";
            if (message.gid != null && message.hasOwnProperty("gid"))
                if (!$util.isInteger(message.gid))
                    return "gid: integer expected";
            if (message.gname != null && message.hasOwnProperty("gname"))
                if (!$util.isString(message.gname))
                    return "gname: string expected";
            if (message.glv != null && message.hasOwnProperty("glv"))
                if (!$util.isInteger(message.glv))
                    return "glv: integer expected";
            if (message.gmsg != null && message.hasOwnProperty("gmsg"))
                if (!$util.isString(message.gmsg))
                    return "gmsg: string expected";
            if (message.gFight != null && message.hasOwnProperty("gFight"))
                if (!$util.isInteger(message.gFight))
                    return "gFight: integer expected";
            if (message.border != null && message.hasOwnProperty("border"))
                if (!$util.isInteger(message.border))
                    return "border: integer expected";
            if (message.hteam != null && message.hasOwnProperty("hteam")) {
                var error = $root.pb_hteam.verify(message.hteam);
                if (error)
                    return "hteam." + error;
            }
            if (message.country != null && message.hasOwnProperty("country"))
                if (!$util.isString(message.country))
                    return "country: string expected";
            if (message.sds != null && message.hasOwnProperty("sds"))
                if (!$util.isString(message.sds))
                    return "sds: string expected";
            if (message.city != null && message.hasOwnProperty("city"))
                if (!$util.isString(message.city))
                    return "city: string expected";
            if (message.emblem != null && message.hasOwnProperty("emblem"))
                if (!$util.isInteger(message.emblem) && !(message.emblem && $util.isInteger(message.emblem.low) && $util.isInteger(message.emblem.high)))
                    return "emblem: integer|Long expected";
            return null;
        };
    
        /**
         * Creates a pb_chat message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_chat
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_chat} pb_chat
         */
        pb_chat.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_chat)
                return object;
            var message = new $root.pb_chat();
            if (object.uid != null)
                if ($util.Long)
                    (message.uid = $util.Long.fromValue(object.uid)).unsigned = false;
                else if (typeof object.uid === "string")
                    message.uid = parseInt(object.uid, 10);
                else if (typeof object.uid === "number")
                    message.uid = object.uid;
                else if (typeof object.uid === "object")
                    message.uid = new $util.LongBits(object.uid.low >>> 0, object.uid.high >>> 0).toNumber();
            if (object.logo != null)
                message.logo = object.logo | 0;
            if (object.lv != null)
                message.lv = object.lv | 0;
            if (object.vip != null)
                message.vip = object.vip | 0;
            if (object.name != null)
                message.name = String(object.name);
            if (object.type != null)
                message.type = object.type | 0;
            if (object.text != null)
                message.text = String(object.text);
            if (object.time != null)
                message.time = object.time | 0;
            if (object.shareId != null)
                message.shareId = object.shareId | 0;
            if (object.heroId != null)
                message.heroId = object.heroId | 0;
            if (object.finalRank != null)
                message.finalRank = object.finalRank | 0;
            if (object.gid != null)
                message.gid = object.gid | 0;
            if (object.gname != null)
                message.gname = String(object.gname);
            if (object.glv != null)
                message.glv = object.glv | 0;
            if (object.gmsg != null)
                message.gmsg = String(object.gmsg);
            if (object.gFight != null)
                message.gFight = object.gFight | 0;
            if (object.border != null)
                message.border = object.border | 0;
            if (object.hteam != null) {
                if (typeof object.hteam !== "object")
                    throw TypeError(".pb_chat.hteam: object expected");
                message.hteam = $root.pb_hteam.fromObject(object.hteam);
            }
            if (object.country != null)
                message.country = String(object.country);
            if (object.sds != null)
                message.sds = String(object.sds);
            if (object.city != null)
                message.city = String(object.city);
            if (object.emblem != null)
                if ($util.Long)
                    (message.emblem = $util.Long.fromValue(object.emblem)).unsigned = false;
                else if (typeof object.emblem === "string")
                    message.emblem = parseInt(object.emblem, 10);
                else if (typeof object.emblem === "number")
                    message.emblem = object.emblem;
                else if (typeof object.emblem === "object")
                    message.emblem = new $util.LongBits(object.emblem.low >>> 0, object.emblem.high >>> 0).toNumber();
            return message;
        };
    
        /**
         * Creates a plain object from a pb_chat message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_chat
         * @static
         * @param {pb_chat} message pb_chat
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_chat.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.uid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.uid = options.longs === String ? "0" : 0;
                object.logo = 0;
                object.lv = 0;
                object.vip = 0;
                object.name = "";
                object.type = 0;
                object.text = "";
                object.time = 0;
                object.shareId = 0;
                object.heroId = 0;
                object.finalRank = 0;
                object.gid = 0;
                object.gname = "";
                object.glv = 0;
                object.gmsg = "";
                object.gFight = 0;
                object.border = 0;
                object.hteam = null;
                object.country = "";
                object.sds = "";
                object.city = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.emblem = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.emblem = options.longs === String ? "0" : 0;
            }
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (typeof message.uid === "number")
                    object.uid = options.longs === String ? String(message.uid) : message.uid;
                else
                    object.uid = options.longs === String ? $util.Long.prototype.toString.call(message.uid) : options.longs === Number ? new $util.LongBits(message.uid.low >>> 0, message.uid.high >>> 0).toNumber() : message.uid;
            if (message.logo != null && message.hasOwnProperty("logo"))
                object.logo = message.logo;
            if (message.lv != null && message.hasOwnProperty("lv"))
                object.lv = message.lv;
            if (message.vip != null && message.hasOwnProperty("vip"))
                object.vip = message.vip;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            if (message.text != null && message.hasOwnProperty("text"))
                object.text = message.text;
            if (message.time != null && message.hasOwnProperty("time"))
                object.time = message.time;
            if (message.shareId != null && message.hasOwnProperty("shareId"))
                object.shareId = message.shareId;
            if (message.heroId != null && message.hasOwnProperty("heroId"))
                object.heroId = message.heroId;
            if (message.finalRank != null && message.hasOwnProperty("finalRank"))
                object.finalRank = message.finalRank;
            if (message.gid != null && message.hasOwnProperty("gid"))
                object.gid = message.gid;
            if (message.gname != null && message.hasOwnProperty("gname"))
                object.gname = message.gname;
            if (message.glv != null && message.hasOwnProperty("glv"))
                object.glv = message.glv;
            if (message.gmsg != null && message.hasOwnProperty("gmsg"))
                object.gmsg = message.gmsg;
            if (message.gFight != null && message.hasOwnProperty("gFight"))
                object.gFight = message.gFight;
            if (message.border != null && message.hasOwnProperty("border"))
                object.border = message.border;
            if (message.hteam != null && message.hasOwnProperty("hteam"))
                object.hteam = $root.pb_hteam.toObject(message.hteam, options);
            if (message.country != null && message.hasOwnProperty("country"))
                object.country = message.country;
            if (message.sds != null && message.hasOwnProperty("sds"))
                object.sds = message.sds;
            if (message.city != null && message.hasOwnProperty("city"))
                object.city = message.city;
            if (message.emblem != null && message.hasOwnProperty("emblem"))
                if (typeof message.emblem === "number")
                    object.emblem = options.longs === String ? String(message.emblem) : message.emblem;
                else
                    object.emblem = options.longs === String ? $util.Long.prototype.toString.call(message.emblem) : options.longs === Number ? new $util.LongBits(message.emblem.low >>> 0, message.emblem.high >>> 0).toNumber() : message.emblem;
            return object;
        };
    
        /**
         * Converts this pb_chat to JSON.
         * @function toJSON
         * @memberof pb_chat
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_chat.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_chat
         * @function getTypeUrl
         * @memberof pb_chat
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_chat.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_chat";
        };
    
        return pb_chat;
    })();
    
    $root.pb_upfile = (function() {
    
        /**
         * Properties of a pb_upfile.
         * @exports Ipb_upfile
         * @interface Ipb_upfile
         * @property {string} md5 pb_upfile md5
         * @property {string} path pb_upfile path
         */
    
        /**
         * Constructs a new pb_upfile.
         * @exports pb_upfile
         * @classdesc Represents a pb_upfile.
         * @implements Ipb_upfile
         * @constructor
         * @param {Ipb_upfile=} [properties] Properties to set
         */
        function pb_upfile(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_upfile md5.
         * @member {string} md5
         * @memberof pb_upfile
         * @instance
         */
        pb_upfile.prototype.md5 = "";
    
        /**
         * pb_upfile path.
         * @member {string} path
         * @memberof pb_upfile
         * @instance
         */
        pb_upfile.prototype.path = "";
    
        /**
         * Creates a new pb_upfile instance using the specified properties.
         * @function create
         * @memberof pb_upfile
         * @static
         * @param {Ipb_upfile=} [properties] Properties to set
         * @returns {pb_upfile} pb_upfile instance
         */
        pb_upfile.create = function create(properties) {
            return new pb_upfile(properties);
        };
    
        /**
         * Encodes the specified pb_upfile message. Does not implicitly {@link pb_upfile.verify|verify} messages.
         * @function encode
         * @memberof pb_upfile
         * @static
         * @param {Ipb_upfile} message pb_upfile message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_upfile.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.md5);
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.path);
            return writer;
        };
    
        /**
         * Encodes the specified pb_upfile message, length delimited. Does not implicitly {@link pb_upfile.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_upfile
         * @static
         * @param {Ipb_upfile} message pb_upfile message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_upfile.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_upfile message from the specified reader or buffer.
         * @function decode
         * @memberof pb_upfile
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_upfile} pb_upfile
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_upfile.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_upfile();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.md5 = reader.string();
                        break;
                    }
                case 2: {
                        message.path = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("md5"))
                throw $util.ProtocolError("missing required 'md5'", { instance: message });
            if (!message.hasOwnProperty("path"))
                throw $util.ProtocolError("missing required 'path'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a pb_upfile message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_upfile
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_upfile} pb_upfile
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_upfile.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_upfile message.
         * @function verify
         * @memberof pb_upfile
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_upfile.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isString(message.md5))
                return "md5: string expected";
            if (!$util.isString(message.path))
                return "path: string expected";
            return null;
        };
    
        /**
         * Creates a pb_upfile message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_upfile
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_upfile} pb_upfile
         */
        pb_upfile.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_upfile)
                return object;
            var message = new $root.pb_upfile();
            if (object.md5 != null)
                message.md5 = String(object.md5);
            if (object.path != null)
                message.path = String(object.path);
            return message;
        };
    
        /**
         * Creates a plain object from a pb_upfile message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_upfile
         * @static
         * @param {pb_upfile} message pb_upfile
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_upfile.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.md5 = "";
                object.path = "";
            }
            if (message.md5 != null && message.hasOwnProperty("md5"))
                object.md5 = message.md5;
            if (message.path != null && message.hasOwnProperty("path"))
                object.path = message.path;
            return object;
        };
    
        /**
         * Converts this pb_upfile to JSON.
         * @function toJSON
         * @memberof pb_upfile
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_upfile.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_upfile
         * @function getTypeUrl
         * @memberof pb_upfile
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_upfile.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_upfile";
        };
    
        return pb_upfile;
    })();
    
    $root.pb_good = (function() {
    
        /**
         * Properties of a pb_good.
         * @exports Ipb_good
         * @interface Ipb_good
         * @property {number} id pb_good id
         * @property {number} type pb_good type
         * @property {number} count pb_good count
         * @property {number} excelId pb_good excelId
         * @property {number|null} [bought] pb_good bought
         */
    
        /**
         * Constructs a new pb_good.
         * @exports pb_good
         * @classdesc Represents a pb_good.
         * @implements Ipb_good
         * @constructor
         * @param {Ipb_good=} [properties] Properties to set
         */
        function pb_good(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_good id.
         * @member {number} id
         * @memberof pb_good
         * @instance
         */
        pb_good.prototype.id = 0;
    
        /**
         * pb_good type.
         * @member {number} type
         * @memberof pb_good
         * @instance
         */
        pb_good.prototype.type = 0;
    
        /**
         * pb_good count.
         * @member {number} count
         * @memberof pb_good
         * @instance
         */
        pb_good.prototype.count = 0;
    
        /**
         * pb_good excelId.
         * @member {number} excelId
         * @memberof pb_good
         * @instance
         */
        pb_good.prototype.excelId = 0;
    
        /**
         * pb_good bought.
         * @member {number} bought
         * @memberof pb_good
         * @instance
         */
        pb_good.prototype.bought = 0;
    
        /**
         * Creates a new pb_good instance using the specified properties.
         * @function create
         * @memberof pb_good
         * @static
         * @param {Ipb_good=} [properties] Properties to set
         * @returns {pb_good} pb_good instance
         */
        pb_good.create = function create(properties) {
            return new pb_good(properties);
        };
    
        /**
         * Encodes the specified pb_good message. Does not implicitly {@link pb_good.verify|verify} messages.
         * @function encode
         * @memberof pb_good
         * @static
         * @param {Ipb_good} message pb_good message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_good.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.id);
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.type);
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.count);
            writer.uint32(/* id 4, wireType 0 =*/32).int32(message.excelId);
            if (message.bought != null && Object.hasOwnProperty.call(message, "bought"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.bought);
            return writer;
        };
    
        /**
         * Encodes the specified pb_good message, length delimited. Does not implicitly {@link pb_good.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_good
         * @static
         * @param {Ipb_good} message pb_good message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_good.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_good message from the specified reader or buffer.
         * @function decode
         * @memberof pb_good
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_good} pb_good
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_good.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_good();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.id = reader.int32();
                        break;
                    }
                case 2: {
                        message.type = reader.int32();
                        break;
                    }
                case 3: {
                        message.count = reader.int32();
                        break;
                    }
                case 4: {
                        message.excelId = reader.int32();
                        break;
                    }
                case 5: {
                        message.bought = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("id"))
                throw $util.ProtocolError("missing required 'id'", { instance: message });
            if (!message.hasOwnProperty("type"))
                throw $util.ProtocolError("missing required 'type'", { instance: message });
            if (!message.hasOwnProperty("count"))
                throw $util.ProtocolError("missing required 'count'", { instance: message });
            if (!message.hasOwnProperty("excelId"))
                throw $util.ProtocolError("missing required 'excelId'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a pb_good message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_good
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_good} pb_good
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_good.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_good message.
         * @function verify
         * @memberof pb_good
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_good.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.id))
                return "id: integer expected";
            if (!$util.isInteger(message.type))
                return "type: integer expected";
            if (!$util.isInteger(message.count))
                return "count: integer expected";
            if (!$util.isInteger(message.excelId))
                return "excelId: integer expected";
            if (message.bought != null && message.hasOwnProperty("bought"))
                if (!$util.isInteger(message.bought))
                    return "bought: integer expected";
            return null;
        };
    
        /**
         * Creates a pb_good message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_good
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_good} pb_good
         */
        pb_good.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_good)
                return object;
            var message = new $root.pb_good();
            if (object.id != null)
                message.id = object.id | 0;
            if (object.type != null)
                message.type = object.type | 0;
            if (object.count != null)
                message.count = object.count | 0;
            if (object.excelId != null)
                message.excelId = object.excelId | 0;
            if (object.bought != null)
                message.bought = object.bought | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a pb_good message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_good
         * @static
         * @param {pb_good} message pb_good
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_good.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = 0;
                object.type = 0;
                object.count = 0;
                object.excelId = 0;
                object.bought = 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            if (message.count != null && message.hasOwnProperty("count"))
                object.count = message.count;
            if (message.excelId != null && message.hasOwnProperty("excelId"))
                object.excelId = message.excelId;
            if (message.bought != null && message.hasOwnProperty("bought"))
                object.bought = message.bought;
            return object;
        };
    
        /**
         * Converts this pb_good to JSON.
         * @function toJSON
         * @memberof pb_good
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_good.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_good
         * @function getTypeUrl
         * @memberof pb_good
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_good.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_good";
        };
    
        return pb_good;
    })();
    
    $root.pb_onepay = (function() {
    
        /**
         * Properties of a pb_onepay.
         * @exports Ipb_onepay
         * @interface Ipb_onepay
         * @property {string} tid pb_onepay tid
         * @property {string|null} [txid] pb_onepay txid
         * @property {string|null} [tdate] pb_onepay tdate
         */
    
        /**
         * Constructs a new pb_onepay.
         * @exports pb_onepay
         * @classdesc Represents a pb_onepay.
         * @implements Ipb_onepay
         * @constructor
         * @param {Ipb_onepay=} [properties] Properties to set
         */
        function pb_onepay(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_onepay tid.
         * @member {string} tid
         * @memberof pb_onepay
         * @instance
         */
        pb_onepay.prototype.tid = "";
    
        /**
         * pb_onepay txid.
         * @member {string} txid
         * @memberof pb_onepay
         * @instance
         */
        pb_onepay.prototype.txid = "";
    
        /**
         * pb_onepay tdate.
         * @member {string} tdate
         * @memberof pb_onepay
         * @instance
         */
        pb_onepay.prototype.tdate = "";
    
        /**
         * Creates a new pb_onepay instance using the specified properties.
         * @function create
         * @memberof pb_onepay
         * @static
         * @param {Ipb_onepay=} [properties] Properties to set
         * @returns {pb_onepay} pb_onepay instance
         */
        pb_onepay.create = function create(properties) {
            return new pb_onepay(properties);
        };
    
        /**
         * Encodes the specified pb_onepay message. Does not implicitly {@link pb_onepay.verify|verify} messages.
         * @function encode
         * @memberof pb_onepay
         * @static
         * @param {Ipb_onepay} message pb_onepay message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_onepay.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.tid);
            if (message.txid != null && Object.hasOwnProperty.call(message, "txid"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.txid);
            if (message.tdate != null && Object.hasOwnProperty.call(message, "tdate"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.tdate);
            return writer;
        };
    
        /**
         * Encodes the specified pb_onepay message, length delimited. Does not implicitly {@link pb_onepay.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_onepay
         * @static
         * @param {Ipb_onepay} message pb_onepay message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_onepay.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_onepay message from the specified reader or buffer.
         * @function decode
         * @memberof pb_onepay
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_onepay} pb_onepay
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_onepay.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_onepay();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.tid = reader.string();
                        break;
                    }
                case 2: {
                        message.txid = reader.string();
                        break;
                    }
                case 3: {
                        message.tdate = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("tid"))
                throw $util.ProtocolError("missing required 'tid'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a pb_onepay message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_onepay
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_onepay} pb_onepay
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_onepay.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_onepay message.
         * @function verify
         * @memberof pb_onepay
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_onepay.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isString(message.tid))
                return "tid: string expected";
            if (message.txid != null && message.hasOwnProperty("txid"))
                if (!$util.isString(message.txid))
                    return "txid: string expected";
            if (message.tdate != null && message.hasOwnProperty("tdate"))
                if (!$util.isString(message.tdate))
                    return "tdate: string expected";
            return null;
        };
    
        /**
         * Creates a pb_onepay message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_onepay
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_onepay} pb_onepay
         */
        pb_onepay.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_onepay)
                return object;
            var message = new $root.pb_onepay();
            if (object.tid != null)
                message.tid = String(object.tid);
            if (object.txid != null)
                message.txid = String(object.txid);
            if (object.tdate != null)
                message.tdate = String(object.tdate);
            return message;
        };
    
        /**
         * Creates a plain object from a pb_onepay message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_onepay
         * @static
         * @param {pb_onepay} message pb_onepay
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_onepay.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.tid = "";
                object.txid = "";
                object.tdate = "";
            }
            if (message.tid != null && message.hasOwnProperty("tid"))
                object.tid = message.tid;
            if (message.txid != null && message.hasOwnProperty("txid"))
                object.txid = message.txid;
            if (message.tdate != null && message.hasOwnProperty("tdate"))
                object.tdate = message.tdate;
            return object;
        };
    
        /**
         * Converts this pb_onepay to JSON.
         * @function toJSON
         * @memberof pb_onepay
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_onepay.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_onepay
         * @function getTypeUrl
         * @memberof pb_onepay
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_onepay.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_onepay";
        };
    
        return pb_onepay;
    })();
    
    $root.pb_hook = (function() {
    
        /**
         * Properties of a pb_hook.
         * @exports Ipb_hook
         * @interface Ipb_hook
         * @property {number} status pb_hook status
         * @property {number|null} [hookStage] pb_hook hookStage
         * @property {number|null} [bossCd] pb_hook bossCd
         * @property {number|null} [pokerCd] pb_hook pokerCd
         * @property {Ipb_bag|null} [reward] pb_hook reward
         * @property {number|null} [pveStage] pb_hook pveStage
         * @property {Ipb_bag|null} [extra] pb_hook extra
         * @property {Array.<Ipb_item>|null} [ids] pb_hook ids
         * @property {number|null} [hardStage] pb_hook hardStage
         */
    
        /**
         * Constructs a new pb_hook.
         * @exports pb_hook
         * @classdesc Represents a pb_hook.
         * @implements Ipb_hook
         * @constructor
         * @param {Ipb_hook=} [properties] Properties to set
         */
        function pb_hook(properties) {
            this.ids = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_hook status.
         * @member {number} status
         * @memberof pb_hook
         * @instance
         */
        pb_hook.prototype.status = 0;
    
        /**
         * pb_hook hookStage.
         * @member {number} hookStage
         * @memberof pb_hook
         * @instance
         */
        pb_hook.prototype.hookStage = 0;
    
        /**
         * pb_hook bossCd.
         * @member {number} bossCd
         * @memberof pb_hook
         * @instance
         */
        pb_hook.prototype.bossCd = 0;
    
        /**
         * pb_hook pokerCd.
         * @member {number} pokerCd
         * @memberof pb_hook
         * @instance
         */
        pb_hook.prototype.pokerCd = 0;
    
        /**
         * pb_hook reward.
         * @member {Ipb_bag|null|undefined} reward
         * @memberof pb_hook
         * @instance
         */
        pb_hook.prototype.reward = null;
    
        /**
         * pb_hook pveStage.
         * @member {number} pveStage
         * @memberof pb_hook
         * @instance
         */
        pb_hook.prototype.pveStage = 0;
    
        /**
         * pb_hook extra.
         * @member {Ipb_bag|null|undefined} extra
         * @memberof pb_hook
         * @instance
         */
        pb_hook.prototype.extra = null;
    
        /**
         * pb_hook ids.
         * @member {Array.<Ipb_item>} ids
         * @memberof pb_hook
         * @instance
         */
        pb_hook.prototype.ids = $util.emptyArray;
    
        /**
         * pb_hook hardStage.
         * @member {number} hardStage
         * @memberof pb_hook
         * @instance
         */
        pb_hook.prototype.hardStage = 0;
    
        /**
         * Creates a new pb_hook instance using the specified properties.
         * @function create
         * @memberof pb_hook
         * @static
         * @param {Ipb_hook=} [properties] Properties to set
         * @returns {pb_hook} pb_hook instance
         */
        pb_hook.create = function create(properties) {
            return new pb_hook(properties);
        };
    
        /**
         * Encodes the specified pb_hook message. Does not implicitly {@link pb_hook.verify|verify} messages.
         * @function encode
         * @memberof pb_hook
         * @static
         * @param {Ipb_hook} message pb_hook message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_hook.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).sint32(message.status);
            if (message.hookStage != null && Object.hasOwnProperty.call(message, "hookStage"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.hookStage);
            if (message.bossCd != null && Object.hasOwnProperty.call(message, "bossCd"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.bossCd);
            if (message.pokerCd != null && Object.hasOwnProperty.call(message, "pokerCd"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.pokerCd);
            if (message.reward != null && Object.hasOwnProperty.call(message, "reward"))
                $root.pb_bag.encode(message.reward, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.pveStage != null && Object.hasOwnProperty.call(message, "pveStage"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.pveStage);
            if (message.extra != null && Object.hasOwnProperty.call(message, "extra"))
                $root.pb_bag.encode(message.extra, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.ids != null && message.ids.length)
                for (var i = 0; i < message.ids.length; ++i)
                    $root.pb_item.encode(message.ids[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message.hardStage != null && Object.hasOwnProperty.call(message, "hardStage"))
                writer.uint32(/* id 9, wireType 0 =*/72).uint32(message.hardStage);
            return writer;
        };
    
        /**
         * Encodes the specified pb_hook message, length delimited. Does not implicitly {@link pb_hook.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_hook
         * @static
         * @param {Ipb_hook} message pb_hook message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_hook.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_hook message from the specified reader or buffer.
         * @function decode
         * @memberof pb_hook
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_hook} pb_hook
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_hook.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_hook();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.status = reader.sint32();
                        break;
                    }
                case 2: {
                        message.hookStage = reader.int32();
                        break;
                    }
                case 3: {
                        message.bossCd = reader.int32();
                        break;
                    }
                case 4: {
                        message.pokerCd = reader.int32();
                        break;
                    }
                case 5: {
                        message.reward = $root.pb_bag.decode(reader, reader.uint32());
                        break;
                    }
                case 6: {
                        message.pveStage = reader.int32();
                        break;
                    }
                case 7: {
                        message.extra = $root.pb_bag.decode(reader, reader.uint32());
                        break;
                    }
                case 8: {
                        if (!(message.ids && message.ids.length))
                            message.ids = [];
                        message.ids.push($root.pb_item.decode(reader, reader.uint32()));
                        break;
                    }
                case 9: {
                        message.hardStage = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("status"))
                throw $util.ProtocolError("missing required 'status'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a pb_hook message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_hook
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_hook} pb_hook
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_hook.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_hook message.
         * @function verify
         * @memberof pb_hook
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_hook.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.status))
                return "status: integer expected";
            if (message.hookStage != null && message.hasOwnProperty("hookStage"))
                if (!$util.isInteger(message.hookStage))
                    return "hookStage: integer expected";
            if (message.bossCd != null && message.hasOwnProperty("bossCd"))
                if (!$util.isInteger(message.bossCd))
                    return "bossCd: integer expected";
            if (message.pokerCd != null && message.hasOwnProperty("pokerCd"))
                if (!$util.isInteger(message.pokerCd))
                    return "pokerCd: integer expected";
            if (message.reward != null && message.hasOwnProperty("reward")) {
                var error = $root.pb_bag.verify(message.reward);
                if (error)
                    return "reward." + error;
            }
            if (message.pveStage != null && message.hasOwnProperty("pveStage"))
                if (!$util.isInteger(message.pveStage))
                    return "pveStage: integer expected";
            if (message.extra != null && message.hasOwnProperty("extra")) {
                var error = $root.pb_bag.verify(message.extra);
                if (error)
                    return "extra." + error;
            }
            if (message.ids != null && message.hasOwnProperty("ids")) {
                if (!Array.isArray(message.ids))
                    return "ids: array expected";
                for (var i = 0; i < message.ids.length; ++i) {
                    var error = $root.pb_item.verify(message.ids[i]);
                    if (error)
                        return "ids." + error;
                }
            }
            if (message.hardStage != null && message.hasOwnProperty("hardStage"))
                if (!$util.isInteger(message.hardStage))
                    return "hardStage: integer expected";
            return null;
        };
    
        /**
         * Creates a pb_hook message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_hook
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_hook} pb_hook
         */
        pb_hook.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_hook)
                return object;
            var message = new $root.pb_hook();
            if (object.status != null)
                message.status = object.status | 0;
            if (object.hookStage != null)
                message.hookStage = object.hookStage | 0;
            if (object.bossCd != null)
                message.bossCd = object.bossCd | 0;
            if (object.pokerCd != null)
                message.pokerCd = object.pokerCd | 0;
            if (object.reward != null) {
                if (typeof object.reward !== "object")
                    throw TypeError(".pb_hook.reward: object expected");
                message.reward = $root.pb_bag.fromObject(object.reward);
            }
            if (object.pveStage != null)
                message.pveStage = object.pveStage | 0;
            if (object.extra != null) {
                if (typeof object.extra !== "object")
                    throw TypeError(".pb_hook.extra: object expected");
                message.extra = $root.pb_bag.fromObject(object.extra);
            }
            if (object.ids) {
                if (!Array.isArray(object.ids))
                    throw TypeError(".pb_hook.ids: array expected");
                message.ids = [];
                for (var i = 0; i < object.ids.length; ++i) {
                    if (typeof object.ids[i] !== "object")
                        throw TypeError(".pb_hook.ids: object expected");
                    message.ids[i] = $root.pb_item.fromObject(object.ids[i]);
                }
            }
            if (object.hardStage != null)
                message.hardStage = object.hardStage >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a pb_hook message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_hook
         * @static
         * @param {pb_hook} message pb_hook
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_hook.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.ids = [];
            if (options.defaults) {
                object.status = 0;
                object.hookStage = 0;
                object.bossCd = 0;
                object.pokerCd = 0;
                object.reward = null;
                object.pveStage = 0;
                object.extra = null;
                object.hardStage = 0;
            }
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = message.status;
            if (message.hookStage != null && message.hasOwnProperty("hookStage"))
                object.hookStage = message.hookStage;
            if (message.bossCd != null && message.hasOwnProperty("bossCd"))
                object.bossCd = message.bossCd;
            if (message.pokerCd != null && message.hasOwnProperty("pokerCd"))
                object.pokerCd = message.pokerCd;
            if (message.reward != null && message.hasOwnProperty("reward"))
                object.reward = $root.pb_bag.toObject(message.reward, options);
            if (message.pveStage != null && message.hasOwnProperty("pveStage"))
                object.pveStage = message.pveStage;
            if (message.extra != null && message.hasOwnProperty("extra"))
                object.extra = $root.pb_bag.toObject(message.extra, options);
            if (message.ids && message.ids.length) {
                object.ids = [];
                for (var j = 0; j < message.ids.length; ++j)
                    object.ids[j] = $root.pb_item.toObject(message.ids[j], options);
            }
            if (message.hardStage != null && message.hasOwnProperty("hardStage"))
                object.hardStage = message.hardStage;
            return object;
        };
    
        /**
         * Converts this pb_hook to JSON.
         * @function toJSON
         * @memberof pb_hook
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_hook.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_hook
         * @function getTypeUrl
         * @memberof pb_hook
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_hook.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_hook";
        };
    
        return pb_hook;
    })();
    
    $root.pb_frd = (function() {
    
        /**
         * Properties of a pb_frd.
         * @exports Ipb_frd
         * @interface Ipb_frd
         * @property {number} logo pb_frd logo
         * @property {string} name pb_frd name
         * @property {number} lv pb_frd lv
         * @property {number|null} [flag] pb_frd flag
         * @property {number|Long|null} [uid] pb_frd uid
         * @property {number|null} [last] pb_frd last
         * @property {number|Long|null} [power] pb_frd power
         * @property {number|null} [border] pb_frd border
         * @property {string|null} [country] pb_frd country
         * @property {string|null} [sds] pb_frd sds
         * @property {string|null} [city] pb_frd city
         * @property {number|Long|null} [emblem] pb_frd emblem
         */
    
        /**
         * Constructs a new pb_frd.
         * @exports pb_frd
         * @classdesc Represents a pb_frd.
         * @implements Ipb_frd
         * @constructor
         * @param {Ipb_frd=} [properties] Properties to set
         */
        function pb_frd(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_frd logo.
         * @member {number} logo
         * @memberof pb_frd
         * @instance
         */
        pb_frd.prototype.logo = 0;
    
        /**
         * pb_frd name.
         * @member {string} name
         * @memberof pb_frd
         * @instance
         */
        pb_frd.prototype.name = "";
    
        /**
         * pb_frd lv.
         * @member {number} lv
         * @memberof pb_frd
         * @instance
         */
        pb_frd.prototype.lv = 0;
    
        /**
         * pb_frd flag.
         * @member {number} flag
         * @memberof pb_frd
         * @instance
         */
        pb_frd.prototype.flag = 0;
    
        /**
         * pb_frd uid.
         * @member {number|Long} uid
         * @memberof pb_frd
         * @instance
         */
        pb_frd.prototype.uid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * pb_frd last.
         * @member {number} last
         * @memberof pb_frd
         * @instance
         */
        pb_frd.prototype.last = 0;
    
        /**
         * pb_frd power.
         * @member {number|Long} power
         * @memberof pb_frd
         * @instance
         */
        pb_frd.prototype.power = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * pb_frd border.
         * @member {number} border
         * @memberof pb_frd
         * @instance
         */
        pb_frd.prototype.border = 0;
    
        /**
         * pb_frd country.
         * @member {string} country
         * @memberof pb_frd
         * @instance
         */
        pb_frd.prototype.country = "";
    
        /**
         * pb_frd sds.
         * @member {string} sds
         * @memberof pb_frd
         * @instance
         */
        pb_frd.prototype.sds = "";
    
        /**
         * pb_frd city.
         * @member {string} city
         * @memberof pb_frd
         * @instance
         */
        pb_frd.prototype.city = "";
    
        /**
         * pb_frd emblem.
         * @member {number|Long} emblem
         * @memberof pb_frd
         * @instance
         */
        pb_frd.prototype.emblem = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * Creates a new pb_frd instance using the specified properties.
         * @function create
         * @memberof pb_frd
         * @static
         * @param {Ipb_frd=} [properties] Properties to set
         * @returns {pb_frd} pb_frd instance
         */
        pb_frd.create = function create(properties) {
            return new pb_frd(properties);
        };
    
        /**
         * Encodes the specified pb_frd message. Does not implicitly {@link pb_frd.verify|verify} messages.
         * @function encode
         * @memberof pb_frd
         * @static
         * @param {Ipb_frd} message pb_frd message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_frd.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.logo);
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.lv);
            if (message.flag != null && Object.hasOwnProperty.call(message, "flag"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.flag);
            if (message.uid != null && Object.hasOwnProperty.call(message, "uid"))
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.uid);
            if (message.last != null && Object.hasOwnProperty.call(message, "last"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.last);
            if (message.power != null && Object.hasOwnProperty.call(message, "power"))
                writer.uint32(/* id 7, wireType 0 =*/56).int64(message.power);
            if (message.border != null && Object.hasOwnProperty.call(message, "border"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.border);
            if (message.country != null && Object.hasOwnProperty.call(message, "country"))
                writer.uint32(/* id 9, wireType 2 =*/74).string(message.country);
            if (message.sds != null && Object.hasOwnProperty.call(message, "sds"))
                writer.uint32(/* id 10, wireType 2 =*/82).string(message.sds);
            if (message.city != null && Object.hasOwnProperty.call(message, "city"))
                writer.uint32(/* id 11, wireType 2 =*/90).string(message.city);
            if (message.emblem != null && Object.hasOwnProperty.call(message, "emblem"))
                writer.uint32(/* id 12, wireType 0 =*/96).int64(message.emblem);
            return writer;
        };
    
        /**
         * Encodes the specified pb_frd message, length delimited. Does not implicitly {@link pb_frd.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_frd
         * @static
         * @param {Ipb_frd} message pb_frd message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_frd.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_frd message from the specified reader or buffer.
         * @function decode
         * @memberof pb_frd
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_frd} pb_frd
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_frd.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_frd();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.logo = reader.int32();
                        break;
                    }
                case 2: {
                        message.name = reader.string();
                        break;
                    }
                case 3: {
                        message.lv = reader.int32();
                        break;
                    }
                case 4: {
                        message.flag = reader.int32();
                        break;
                    }
                case 5: {
                        message.uid = reader.int64();
                        break;
                    }
                case 6: {
                        message.last = reader.int32();
                        break;
                    }
                case 7: {
                        message.power = reader.int64();
                        break;
                    }
                case 8: {
                        message.border = reader.int32();
                        break;
                    }
                case 9: {
                        message.country = reader.string();
                        break;
                    }
                case 10: {
                        message.sds = reader.string();
                        break;
                    }
                case 11: {
                        message.city = reader.string();
                        break;
                    }
                case 12: {
                        message.emblem = reader.int64();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("logo"))
                throw $util.ProtocolError("missing required 'logo'", { instance: message });
            if (!message.hasOwnProperty("name"))
                throw $util.ProtocolError("missing required 'name'", { instance: message });
            if (!message.hasOwnProperty("lv"))
                throw $util.ProtocolError("missing required 'lv'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a pb_frd message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_frd
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_frd} pb_frd
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_frd.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_frd message.
         * @function verify
         * @memberof pb_frd
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_frd.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.logo))
                return "logo: integer expected";
            if (!$util.isString(message.name))
                return "name: string expected";
            if (!$util.isInteger(message.lv))
                return "lv: integer expected";
            if (message.flag != null && message.hasOwnProperty("flag"))
                if (!$util.isInteger(message.flag))
                    return "flag: integer expected";
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (!$util.isInteger(message.uid) && !(message.uid && $util.isInteger(message.uid.low) && $util.isInteger(message.uid.high)))
                    return "uid: integer|Long expected";
            if (message.last != null && message.hasOwnProperty("last"))
                if (!$util.isInteger(message.last))
                    return "last: integer expected";
            if (message.power != null && message.hasOwnProperty("power"))
                if (!$util.isInteger(message.power) && !(message.power && $util.isInteger(message.power.low) && $util.isInteger(message.power.high)))
                    return "power: integer|Long expected";
            if (message.border != null && message.hasOwnProperty("border"))
                if (!$util.isInteger(message.border))
                    return "border: integer expected";
            if (message.country != null && message.hasOwnProperty("country"))
                if (!$util.isString(message.country))
                    return "country: string expected";
            if (message.sds != null && message.hasOwnProperty("sds"))
                if (!$util.isString(message.sds))
                    return "sds: string expected";
            if (message.city != null && message.hasOwnProperty("city"))
                if (!$util.isString(message.city))
                    return "city: string expected";
            if (message.emblem != null && message.hasOwnProperty("emblem"))
                if (!$util.isInteger(message.emblem) && !(message.emblem && $util.isInteger(message.emblem.low) && $util.isInteger(message.emblem.high)))
                    return "emblem: integer|Long expected";
            return null;
        };
    
        /**
         * Creates a pb_frd message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_frd
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_frd} pb_frd
         */
        pb_frd.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_frd)
                return object;
            var message = new $root.pb_frd();
            if (object.logo != null)
                message.logo = object.logo | 0;
            if (object.name != null)
                message.name = String(object.name);
            if (object.lv != null)
                message.lv = object.lv | 0;
            if (object.flag != null)
                message.flag = object.flag | 0;
            if (object.uid != null)
                if ($util.Long)
                    (message.uid = $util.Long.fromValue(object.uid)).unsigned = false;
                else if (typeof object.uid === "string")
                    message.uid = parseInt(object.uid, 10);
                else if (typeof object.uid === "number")
                    message.uid = object.uid;
                else if (typeof object.uid === "object")
                    message.uid = new $util.LongBits(object.uid.low >>> 0, object.uid.high >>> 0).toNumber();
            if (object.last != null)
                message.last = object.last | 0;
            if (object.power != null)
                if ($util.Long)
                    (message.power = $util.Long.fromValue(object.power)).unsigned = false;
                else if (typeof object.power === "string")
                    message.power = parseInt(object.power, 10);
                else if (typeof object.power === "number")
                    message.power = object.power;
                else if (typeof object.power === "object")
                    message.power = new $util.LongBits(object.power.low >>> 0, object.power.high >>> 0).toNumber();
            if (object.border != null)
                message.border = object.border | 0;
            if (object.country != null)
                message.country = String(object.country);
            if (object.sds != null)
                message.sds = String(object.sds);
            if (object.city != null)
                message.city = String(object.city);
            if (object.emblem != null)
                if ($util.Long)
                    (message.emblem = $util.Long.fromValue(object.emblem)).unsigned = false;
                else if (typeof object.emblem === "string")
                    message.emblem = parseInt(object.emblem, 10);
                else if (typeof object.emblem === "number")
                    message.emblem = object.emblem;
                else if (typeof object.emblem === "object")
                    message.emblem = new $util.LongBits(object.emblem.low >>> 0, object.emblem.high >>> 0).toNumber();
            return message;
        };
    
        /**
         * Creates a plain object from a pb_frd message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_frd
         * @static
         * @param {pb_frd} message pb_frd
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_frd.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.logo = 0;
                object.name = "";
                object.lv = 0;
                object.flag = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.uid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.uid = options.longs === String ? "0" : 0;
                object.last = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.power = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.power = options.longs === String ? "0" : 0;
                object.border = 0;
                object.country = "";
                object.sds = "";
                object.city = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.emblem = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.emblem = options.longs === String ? "0" : 0;
            }
            if (message.logo != null && message.hasOwnProperty("logo"))
                object.logo = message.logo;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.lv != null && message.hasOwnProperty("lv"))
                object.lv = message.lv;
            if (message.flag != null && message.hasOwnProperty("flag"))
                object.flag = message.flag;
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (typeof message.uid === "number")
                    object.uid = options.longs === String ? String(message.uid) : message.uid;
                else
                    object.uid = options.longs === String ? $util.Long.prototype.toString.call(message.uid) : options.longs === Number ? new $util.LongBits(message.uid.low >>> 0, message.uid.high >>> 0).toNumber() : message.uid;
            if (message.last != null && message.hasOwnProperty("last"))
                object.last = message.last;
            if (message.power != null && message.hasOwnProperty("power"))
                if (typeof message.power === "number")
                    object.power = options.longs === String ? String(message.power) : message.power;
                else
                    object.power = options.longs === String ? $util.Long.prototype.toString.call(message.power) : options.longs === Number ? new $util.LongBits(message.power.low >>> 0, message.power.high >>> 0).toNumber() : message.power;
            if (message.border != null && message.hasOwnProperty("border"))
                object.border = message.border;
            if (message.country != null && message.hasOwnProperty("country"))
                object.country = message.country;
            if (message.sds != null && message.hasOwnProperty("sds"))
                object.sds = message.sds;
            if (message.city != null && message.hasOwnProperty("city"))
                object.city = message.city;
            if (message.emblem != null && message.hasOwnProperty("emblem"))
                if (typeof message.emblem === "number")
                    object.emblem = options.longs === String ? String(message.emblem) : message.emblem;
                else
                    object.emblem = options.longs === String ? $util.Long.prototype.toString.call(message.emblem) : options.longs === Number ? new $util.LongBits(message.emblem.low >>> 0, message.emblem.high >>> 0).toNumber() : message.emblem;
            return object;
        };
    
        /**
         * Converts this pb_frd to JSON.
         * @function toJSON
         * @memberof pb_frd
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_frd.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_frd
         * @function getTypeUrl
         * @memberof pb_frd
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_frd.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_frd";
        };
    
        return pb_frd;
    })();
    
    $root.pb_friend = (function() {
    
        /**
         * Properties of a pb_friend.
         * @exports Ipb_friend
         * @interface Ipb_friend
         * @property {Array.<Ipb_frd>|null} [friends] pb_friend friends
         * @property {number} love pb_friend love
         * @property {number} cd pb_friend cd
         * @property {Array.<Ipb_frd>|null} [apply] pb_friend apply
         * @property {Array.<Ipb_frd>|null} [recmd] pb_friend recmd
         */
    
        /**
         * Constructs a new pb_friend.
         * @exports pb_friend
         * @classdesc Represents a pb_friend.
         * @implements Ipb_friend
         * @constructor
         * @param {Ipb_friend=} [properties] Properties to set
         */
        function pb_friend(properties) {
            this.friends = [];
            this.apply = [];
            this.recmd = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_friend friends.
         * @member {Array.<Ipb_frd>} friends
         * @memberof pb_friend
         * @instance
         */
        pb_friend.prototype.friends = $util.emptyArray;
    
        /**
         * pb_friend love.
         * @member {number} love
         * @memberof pb_friend
         * @instance
         */
        pb_friend.prototype.love = 0;
    
        /**
         * pb_friend cd.
         * @member {number} cd
         * @memberof pb_friend
         * @instance
         */
        pb_friend.prototype.cd = 0;
    
        /**
         * pb_friend apply.
         * @member {Array.<Ipb_frd>} apply
         * @memberof pb_friend
         * @instance
         */
        pb_friend.prototype.apply = $util.emptyArray;
    
        /**
         * pb_friend recmd.
         * @member {Array.<Ipb_frd>} recmd
         * @memberof pb_friend
         * @instance
         */
        pb_friend.prototype.recmd = $util.emptyArray;
    
        /**
         * Creates a new pb_friend instance using the specified properties.
         * @function create
         * @memberof pb_friend
         * @static
         * @param {Ipb_friend=} [properties] Properties to set
         * @returns {pb_friend} pb_friend instance
         */
        pb_friend.create = function create(properties) {
            return new pb_friend(properties);
        };
    
        /**
         * Encodes the specified pb_friend message. Does not implicitly {@link pb_friend.verify|verify} messages.
         * @function encode
         * @memberof pb_friend
         * @static
         * @param {Ipb_friend} message pb_friend message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_friend.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.friends != null && message.friends.length)
                for (var i = 0; i < message.friends.length; ++i)
                    $root.pb_frd.encode(message.friends[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.love);
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.cd);
            if (message.apply != null && message.apply.length)
                for (var i = 0; i < message.apply.length; ++i)
                    $root.pb_frd.encode(message.apply[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.recmd != null && message.recmd.length)
                for (var i = 0; i < message.recmd.length; ++i)
                    $root.pb_frd.encode(message.recmd[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified pb_friend message, length delimited. Does not implicitly {@link pb_friend.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_friend
         * @static
         * @param {Ipb_friend} message pb_friend message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_friend.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_friend message from the specified reader or buffer.
         * @function decode
         * @memberof pb_friend
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_friend} pb_friend
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_friend.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_friend();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.friends && message.friends.length))
                            message.friends = [];
                        message.friends.push($root.pb_frd.decode(reader, reader.uint32()));
                        break;
                    }
                case 2: {
                        message.love = reader.int32();
                        break;
                    }
                case 3: {
                        message.cd = reader.int32();
                        break;
                    }
                case 4: {
                        if (!(message.apply && message.apply.length))
                            message.apply = [];
                        message.apply.push($root.pb_frd.decode(reader, reader.uint32()));
                        break;
                    }
                case 5: {
                        if (!(message.recmd && message.recmd.length))
                            message.recmd = [];
                        message.recmd.push($root.pb_frd.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("love"))
                throw $util.ProtocolError("missing required 'love'", { instance: message });
            if (!message.hasOwnProperty("cd"))
                throw $util.ProtocolError("missing required 'cd'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a pb_friend message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_friend
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_friend} pb_friend
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_friend.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_friend message.
         * @function verify
         * @memberof pb_friend
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_friend.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.friends != null && message.hasOwnProperty("friends")) {
                if (!Array.isArray(message.friends))
                    return "friends: array expected";
                for (var i = 0; i < message.friends.length; ++i) {
                    var error = $root.pb_frd.verify(message.friends[i]);
                    if (error)
                        return "friends." + error;
                }
            }
            if (!$util.isInteger(message.love))
                return "love: integer expected";
            if (!$util.isInteger(message.cd))
                return "cd: integer expected";
            if (message.apply != null && message.hasOwnProperty("apply")) {
                if (!Array.isArray(message.apply))
                    return "apply: array expected";
                for (var i = 0; i < message.apply.length; ++i) {
                    var error = $root.pb_frd.verify(message.apply[i]);
                    if (error)
                        return "apply." + error;
                }
            }
            if (message.recmd != null && message.hasOwnProperty("recmd")) {
                if (!Array.isArray(message.recmd))
                    return "recmd: array expected";
                for (var i = 0; i < message.recmd.length; ++i) {
                    var error = $root.pb_frd.verify(message.recmd[i]);
                    if (error)
                        return "recmd." + error;
                }
            }
            return null;
        };
    
        /**
         * Creates a pb_friend message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_friend
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_friend} pb_friend
         */
        pb_friend.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_friend)
                return object;
            var message = new $root.pb_friend();
            if (object.friends) {
                if (!Array.isArray(object.friends))
                    throw TypeError(".pb_friend.friends: array expected");
                message.friends = [];
                for (var i = 0; i < object.friends.length; ++i) {
                    if (typeof object.friends[i] !== "object")
                        throw TypeError(".pb_friend.friends: object expected");
                    message.friends[i] = $root.pb_frd.fromObject(object.friends[i]);
                }
            }
            if (object.love != null)
                message.love = object.love | 0;
            if (object.cd != null)
                message.cd = object.cd | 0;
            if (object.apply) {
                if (!Array.isArray(object.apply))
                    throw TypeError(".pb_friend.apply: array expected");
                message.apply = [];
                for (var i = 0; i < object.apply.length; ++i) {
                    if (typeof object.apply[i] !== "object")
                        throw TypeError(".pb_friend.apply: object expected");
                    message.apply[i] = $root.pb_frd.fromObject(object.apply[i]);
                }
            }
            if (object.recmd) {
                if (!Array.isArray(object.recmd))
                    throw TypeError(".pb_friend.recmd: array expected");
                message.recmd = [];
                for (var i = 0; i < object.recmd.length; ++i) {
                    if (typeof object.recmd[i] !== "object")
                        throw TypeError(".pb_friend.recmd: object expected");
                    message.recmd[i] = $root.pb_frd.fromObject(object.recmd[i]);
                }
            }
            return message;
        };
    
        /**
         * Creates a plain object from a pb_friend message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_friend
         * @static
         * @param {pb_friend} message pb_friend
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_friend.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.friends = [];
                object.apply = [];
                object.recmd = [];
            }
            if (options.defaults) {
                object.love = 0;
                object.cd = 0;
            }
            if (message.friends && message.friends.length) {
                object.friends = [];
                for (var j = 0; j < message.friends.length; ++j)
                    object.friends[j] = $root.pb_frd.toObject(message.friends[j], options);
            }
            if (message.love != null && message.hasOwnProperty("love"))
                object.love = message.love;
            if (message.cd != null && message.hasOwnProperty("cd"))
                object.cd = message.cd;
            if (message.apply && message.apply.length) {
                object.apply = [];
                for (var j = 0; j < message.apply.length; ++j)
                    object.apply[j] = $root.pb_frd.toObject(message.apply[j], options);
            }
            if (message.recmd && message.recmd.length) {
                object.recmd = [];
                for (var j = 0; j < message.recmd.length; ++j)
                    object.recmd[j] = $root.pb_frd.toObject(message.recmd[j], options);
            }
            return object;
        };
    
        /**
         * Converts this pb_friend to JSON.
         * @function toJSON
         * @memberof pb_friend
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_friend.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_friend
         * @function getTypeUrl
         * @memberof pb_friend
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_friend.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_friend";
        };
    
        return pb_friend;
    })();
    
    $root.pb_casino_item = (function() {
    
        /**
         * Properties of a pb_casino_item.
         * @exports Ipb_casino_item
         * @interface Ipb_casino_item
         * @property {number} type pb_casino_item type
         * @property {number} id pb_casino_item id
         * @property {number} count pb_casino_item count
         * @property {number|null} [cool] pb_casino_item cool
         * @property {number|null} [limitBuy] pb_casino_item limitBuy
         * @property {number|null} [weight] pb_casino_item weight
         */
    
        /**
         * Constructs a new pb_casino_item.
         * @exports pb_casino_item
         * @classdesc Represents a pb_casino_item.
         * @implements Ipb_casino_item
         * @constructor
         * @param {Ipb_casino_item=} [properties] Properties to set
         */
        function pb_casino_item(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_casino_item type.
         * @member {number} type
         * @memberof pb_casino_item
         * @instance
         */
        pb_casino_item.prototype.type = 0;
    
        /**
         * pb_casino_item id.
         * @member {number} id
         * @memberof pb_casino_item
         * @instance
         */
        pb_casino_item.prototype.id = 0;
    
        /**
         * pb_casino_item count.
         * @member {number} count
         * @memberof pb_casino_item
         * @instance
         */
        pb_casino_item.prototype.count = 0;
    
        /**
         * pb_casino_item cool.
         * @member {number} cool
         * @memberof pb_casino_item
         * @instance
         */
        pb_casino_item.prototype.cool = 0;
    
        /**
         * pb_casino_item limitBuy.
         * @member {number} limitBuy
         * @memberof pb_casino_item
         * @instance
         */
        pb_casino_item.prototype.limitBuy = 0;
    
        /**
         * pb_casino_item weight.
         * @member {number} weight
         * @memberof pb_casino_item
         * @instance
         */
        pb_casino_item.prototype.weight = 0;
    
        /**
         * Creates a new pb_casino_item instance using the specified properties.
         * @function create
         * @memberof pb_casino_item
         * @static
         * @param {Ipb_casino_item=} [properties] Properties to set
         * @returns {pb_casino_item} pb_casino_item instance
         */
        pb_casino_item.create = function create(properties) {
            return new pb_casino_item(properties);
        };
    
        /**
         * Encodes the specified pb_casino_item message. Does not implicitly {@link pb_casino_item.verify|verify} messages.
         * @function encode
         * @memberof pb_casino_item
         * @static
         * @param {Ipb_casino_item} message pb_casino_item message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_casino_item.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.id);
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.count);
            if (message.cool != null && Object.hasOwnProperty.call(message, "cool"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.cool);
            if (message.limitBuy != null && Object.hasOwnProperty.call(message, "limitBuy"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.limitBuy);
            if (message.weight != null && Object.hasOwnProperty.call(message, "weight"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.weight);
            return writer;
        };
    
        /**
         * Encodes the specified pb_casino_item message, length delimited. Does not implicitly {@link pb_casino_item.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_casino_item
         * @static
         * @param {Ipb_casino_item} message pb_casino_item message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_casino_item.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_casino_item message from the specified reader or buffer.
         * @function decode
         * @memberof pb_casino_item
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_casino_item} pb_casino_item
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_casino_item.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_casino_item();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.type = reader.int32();
                        break;
                    }
                case 2: {
                        message.id = reader.int32();
                        break;
                    }
                case 3: {
                        message.count = reader.int32();
                        break;
                    }
                case 4: {
                        message.cool = reader.int32();
                        break;
                    }
                case 5: {
                        message.limitBuy = reader.int32();
                        break;
                    }
                case 6: {
                        message.weight = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("type"))
                throw $util.ProtocolError("missing required 'type'", { instance: message });
            if (!message.hasOwnProperty("id"))
                throw $util.ProtocolError("missing required 'id'", { instance: message });
            if (!message.hasOwnProperty("count"))
                throw $util.ProtocolError("missing required 'count'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a pb_casino_item message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_casino_item
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_casino_item} pb_casino_item
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_casino_item.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_casino_item message.
         * @function verify
         * @memberof pb_casino_item
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_casino_item.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.type))
                return "type: integer expected";
            if (!$util.isInteger(message.id))
                return "id: integer expected";
            if (!$util.isInteger(message.count))
                return "count: integer expected";
            if (message.cool != null && message.hasOwnProperty("cool"))
                if (!$util.isInteger(message.cool))
                    return "cool: integer expected";
            if (message.limitBuy != null && message.hasOwnProperty("limitBuy"))
                if (!$util.isInteger(message.limitBuy))
                    return "limitBuy: integer expected";
            if (message.weight != null && message.hasOwnProperty("weight"))
                if (!$util.isInteger(message.weight))
                    return "weight: integer expected";
            return null;
        };
    
        /**
         * Creates a pb_casino_item message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_casino_item
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_casino_item} pb_casino_item
         */
        pb_casino_item.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_casino_item)
                return object;
            var message = new $root.pb_casino_item();
            if (object.type != null)
                message.type = object.type | 0;
            if (object.id != null)
                message.id = object.id | 0;
            if (object.count != null)
                message.count = object.count | 0;
            if (object.cool != null)
                message.cool = object.cool | 0;
            if (object.limitBuy != null)
                message.limitBuy = object.limitBuy | 0;
            if (object.weight != null)
                message.weight = object.weight | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a pb_casino_item message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_casino_item
         * @static
         * @param {pb_casino_item} message pb_casino_item
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_casino_item.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.type = 0;
                object.id = 0;
                object.count = 0;
                object.cool = 0;
                object.limitBuy = 0;
                object.weight = 0;
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.count != null && message.hasOwnProperty("count"))
                object.count = message.count;
            if (message.cool != null && message.hasOwnProperty("cool"))
                object.cool = message.cool;
            if (message.limitBuy != null && message.hasOwnProperty("limitBuy"))
                object.limitBuy = message.limitBuy;
            if (message.weight != null && message.hasOwnProperty("weight"))
                object.weight = message.weight;
            return object;
        };
    
        /**
         * Converts this pb_casino_item to JSON.
         * @function toJSON
         * @memberof pb_casino_item
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_casino_item.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_casino_item
         * @function getTypeUrl
         * @memberof pb_casino_item
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_casino_item.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_casino_item";
        };
    
        return pb_casino_item;
    })();
    
    $root.pb_casino_msg = (function() {
    
        /**
         * Properties of a pb_casino_msg.
         * @exports Ipb_casino_msg
         * @interface Ipb_casino_msg
         * @property {string} name pb_casino_msg name
         * @property {number} type pb_casino_msg type
         * @property {number} id pb_casino_msg id
         * @property {number} count pb_casino_msg count
         */
    
        /**
         * Constructs a new pb_casino_msg.
         * @exports pb_casino_msg
         * @classdesc Represents a pb_casino_msg.
         * @implements Ipb_casino_msg
         * @constructor
         * @param {Ipb_casino_msg=} [properties] Properties to set
         */
        function pb_casino_msg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_casino_msg name.
         * @member {string} name
         * @memberof pb_casino_msg
         * @instance
         */
        pb_casino_msg.prototype.name = "";
    
        /**
         * pb_casino_msg type.
         * @member {number} type
         * @memberof pb_casino_msg
         * @instance
         */
        pb_casino_msg.prototype.type = 0;
    
        /**
         * pb_casino_msg id.
         * @member {number} id
         * @memberof pb_casino_msg
         * @instance
         */
        pb_casino_msg.prototype.id = 0;
    
        /**
         * pb_casino_msg count.
         * @member {number} count
         * @memberof pb_casino_msg
         * @instance
         */
        pb_casino_msg.prototype.count = 0;
    
        /**
         * Creates a new pb_casino_msg instance using the specified properties.
         * @function create
         * @memberof pb_casino_msg
         * @static
         * @param {Ipb_casino_msg=} [properties] Properties to set
         * @returns {pb_casino_msg} pb_casino_msg instance
         */
        pb_casino_msg.create = function create(properties) {
            return new pb_casino_msg(properties);
        };
    
        /**
         * Encodes the specified pb_casino_msg message. Does not implicitly {@link pb_casino_msg.verify|verify} messages.
         * @function encode
         * @memberof pb_casino_msg
         * @static
         * @param {Ipb_casino_msg} message pb_casino_msg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_casino_msg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.type);
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.id);
            writer.uint32(/* id 4, wireType 0 =*/32).int32(message.count);
            return writer;
        };
    
        /**
         * Encodes the specified pb_casino_msg message, length delimited. Does not implicitly {@link pb_casino_msg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_casino_msg
         * @static
         * @param {Ipb_casino_msg} message pb_casino_msg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_casino_msg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_casino_msg message from the specified reader or buffer.
         * @function decode
         * @memberof pb_casino_msg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_casino_msg} pb_casino_msg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_casino_msg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_casino_msg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.name = reader.string();
                        break;
                    }
                case 2: {
                        message.type = reader.int32();
                        break;
                    }
                case 3: {
                        message.id = reader.int32();
                        break;
                    }
                case 4: {
                        message.count = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("name"))
                throw $util.ProtocolError("missing required 'name'", { instance: message });
            if (!message.hasOwnProperty("type"))
                throw $util.ProtocolError("missing required 'type'", { instance: message });
            if (!message.hasOwnProperty("id"))
                throw $util.ProtocolError("missing required 'id'", { instance: message });
            if (!message.hasOwnProperty("count"))
                throw $util.ProtocolError("missing required 'count'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a pb_casino_msg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_casino_msg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_casino_msg} pb_casino_msg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_casino_msg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_casino_msg message.
         * @function verify
         * @memberof pb_casino_msg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_casino_msg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isString(message.name))
                return "name: string expected";
            if (!$util.isInteger(message.type))
                return "type: integer expected";
            if (!$util.isInteger(message.id))
                return "id: integer expected";
            if (!$util.isInteger(message.count))
                return "count: integer expected";
            return null;
        };
    
        /**
         * Creates a pb_casino_msg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_casino_msg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_casino_msg} pb_casino_msg
         */
        pb_casino_msg.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_casino_msg)
                return object;
            var message = new $root.pb_casino_msg();
            if (object.name != null)
                message.name = String(object.name);
            if (object.type != null)
                message.type = object.type | 0;
            if (object.id != null)
                message.id = object.id | 0;
            if (object.count != null)
                message.count = object.count | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a pb_casino_msg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_casino_msg
         * @static
         * @param {pb_casino_msg} message pb_casino_msg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_casino_msg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.name = "";
                object.type = 0;
                object.id = 0;
                object.count = 0;
            }
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.count != null && message.hasOwnProperty("count"))
                object.count = message.count;
            return object;
        };
    
        /**
         * Converts this pb_casino_msg to JSON.
         * @function toJSON
         * @memberof pb_casino_msg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_casino_msg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_casino_msg
         * @function getTypeUrl
         * @memberof pb_casino_msg
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_casino_msg.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_casino_msg";
        };
    
        return pb_casino_msg;
    })();
    
    $root.pb_gmember = (function() {
    
        /**
         * Properties of a pb_gmember.
         * @exports Ipb_gmember
         * @interface Ipb_gmember
         * @property {number|Long} uid pb_gmember uid
         * @property {string} name pb_gmember name
         * @property {number|null} [lv] pb_gmember lv
         * @property {number|null} [logo] pb_gmember logo
         * @property {number|null} [last] pb_gmember last
         * @property {number|null} [title] pb_gmember title
         * @property {number|Long|null} [power] pb_gmember power
         * @property {number|null} [gfight] pb_gmember gfight
         * @property {number|null} [border] pb_gmember border
         * @property {number|null} [cwar] pb_gmember cwar
         * @property {string|null} [country] pb_gmember country
         * @property {string|null} [sds] pb_gmember sds
         * @property {string|null} [city] pb_gmember city
         * @property {number|Long|null} [emblem] pb_gmember emblem
         */
    
        /**
         * Constructs a new pb_gmember.
         * @exports pb_gmember
         * @classdesc Represents a pb_gmember.
         * @implements Ipb_gmember
         * @constructor
         * @param {Ipb_gmember=} [properties] Properties to set
         */
        function pb_gmember(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_gmember uid.
         * @member {number|Long} uid
         * @memberof pb_gmember
         * @instance
         */
        pb_gmember.prototype.uid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * pb_gmember name.
         * @member {string} name
         * @memberof pb_gmember
         * @instance
         */
        pb_gmember.prototype.name = "";
    
        /**
         * pb_gmember lv.
         * @member {number} lv
         * @memberof pb_gmember
         * @instance
         */
        pb_gmember.prototype.lv = 0;
    
        /**
         * pb_gmember logo.
         * @member {number} logo
         * @memberof pb_gmember
         * @instance
         */
        pb_gmember.prototype.logo = 0;
    
        /**
         * pb_gmember last.
         * @member {number} last
         * @memberof pb_gmember
         * @instance
         */
        pb_gmember.prototype.last = 0;
    
        /**
         * pb_gmember title.
         * @member {number} title
         * @memberof pb_gmember
         * @instance
         */
        pb_gmember.prototype.title = 0;
    
        /**
         * pb_gmember power.
         * @member {number|Long} power
         * @memberof pb_gmember
         * @instance
         */
        pb_gmember.prototype.power = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * pb_gmember gfight.
         * @member {number} gfight
         * @memberof pb_gmember
         * @instance
         */
        pb_gmember.prototype.gfight = 0;
    
        /**
         * pb_gmember border.
         * @member {number} border
         * @memberof pb_gmember
         * @instance
         */
        pb_gmember.prototype.border = 0;
    
        /**
         * pb_gmember cwar.
         * @member {number} cwar
         * @memberof pb_gmember
         * @instance
         */
        pb_gmember.prototype.cwar = 0;
    
        /**
         * pb_gmember country.
         * @member {string} country
         * @memberof pb_gmember
         * @instance
         */
        pb_gmember.prototype.country = "";
    
        /**
         * pb_gmember sds.
         * @member {string} sds
         * @memberof pb_gmember
         * @instance
         */
        pb_gmember.prototype.sds = "";
    
        /**
         * pb_gmember city.
         * @member {string} city
         * @memberof pb_gmember
         * @instance
         */
        pb_gmember.prototype.city = "";
    
        /**
         * pb_gmember emblem.
         * @member {number|Long} emblem
         * @memberof pb_gmember
         * @instance
         */
        pb_gmember.prototype.emblem = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * Creates a new pb_gmember instance using the specified properties.
         * @function create
         * @memberof pb_gmember
         * @static
         * @param {Ipb_gmember=} [properties] Properties to set
         * @returns {pb_gmember} pb_gmember instance
         */
        pb_gmember.create = function create(properties) {
            return new pb_gmember(properties);
        };
    
        /**
         * Encodes the specified pb_gmember message. Does not implicitly {@link pb_gmember.verify|verify} messages.
         * @function encode
         * @memberof pb_gmember
         * @static
         * @param {Ipb_gmember} message pb_gmember message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_gmember.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int64(message.uid);
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
            if (message.lv != null && Object.hasOwnProperty.call(message, "lv"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.lv);
            if (message.logo != null && Object.hasOwnProperty.call(message, "logo"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.logo);
            if (message.last != null && Object.hasOwnProperty.call(message, "last"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.last);
            if (message.title != null && Object.hasOwnProperty.call(message, "title"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.title);
            if (message.power != null && Object.hasOwnProperty.call(message, "power"))
                writer.uint32(/* id 7, wireType 0 =*/56).int64(message.power);
            if (message.gfight != null && Object.hasOwnProperty.call(message, "gfight"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.gfight);
            if (message.border != null && Object.hasOwnProperty.call(message, "border"))
                writer.uint32(/* id 9, wireType 0 =*/72).int32(message.border);
            if (message.cwar != null && Object.hasOwnProperty.call(message, "cwar"))
                writer.uint32(/* id 10, wireType 0 =*/80).int32(message.cwar);
            if (message.country != null && Object.hasOwnProperty.call(message, "country"))
                writer.uint32(/* id 11, wireType 2 =*/90).string(message.country);
            if (message.sds != null && Object.hasOwnProperty.call(message, "sds"))
                writer.uint32(/* id 12, wireType 2 =*/98).string(message.sds);
            if (message.city != null && Object.hasOwnProperty.call(message, "city"))
                writer.uint32(/* id 13, wireType 2 =*/106).string(message.city);
            if (message.emblem != null && Object.hasOwnProperty.call(message, "emblem"))
                writer.uint32(/* id 14, wireType 0 =*/112).int64(message.emblem);
            return writer;
        };
    
        /**
         * Encodes the specified pb_gmember message, length delimited. Does not implicitly {@link pb_gmember.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_gmember
         * @static
         * @param {Ipb_gmember} message pb_gmember message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_gmember.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_gmember message from the specified reader or buffer.
         * @function decode
         * @memberof pb_gmember
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_gmember} pb_gmember
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_gmember.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_gmember();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.uid = reader.int64();
                        break;
                    }
                case 2: {
                        message.name = reader.string();
                        break;
                    }
                case 3: {
                        message.lv = reader.int32();
                        break;
                    }
                case 4: {
                        message.logo = reader.int32();
                        break;
                    }
                case 5: {
                        message.last = reader.int32();
                        break;
                    }
                case 6: {
                        message.title = reader.int32();
                        break;
                    }
                case 7: {
                        message.power = reader.int64();
                        break;
                    }
                case 8: {
                        message.gfight = reader.int32();
                        break;
                    }
                case 9: {
                        message.border = reader.int32();
                        break;
                    }
                case 10: {
                        message.cwar = reader.int32();
                        break;
                    }
                case 11: {
                        message.country = reader.string();
                        break;
                    }
                case 12: {
                        message.sds = reader.string();
                        break;
                    }
                case 13: {
                        message.city = reader.string();
                        break;
                    }
                case 14: {
                        message.emblem = reader.int64();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("uid"))
                throw $util.ProtocolError("missing required 'uid'", { instance: message });
            if (!message.hasOwnProperty("name"))
                throw $util.ProtocolError("missing required 'name'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a pb_gmember message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_gmember
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_gmember} pb_gmember
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_gmember.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_gmember message.
         * @function verify
         * @memberof pb_gmember
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_gmember.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.uid) && !(message.uid && $util.isInteger(message.uid.low) && $util.isInteger(message.uid.high)))
                return "uid: integer|Long expected";
            if (!$util.isString(message.name))
                return "name: string expected";
            if (message.lv != null && message.hasOwnProperty("lv"))
                if (!$util.isInteger(message.lv))
                    return "lv: integer expected";
            if (message.logo != null && message.hasOwnProperty("logo"))
                if (!$util.isInteger(message.logo))
                    return "logo: integer expected";
            if (message.last != null && message.hasOwnProperty("last"))
                if (!$util.isInteger(message.last))
                    return "last: integer expected";
            if (message.title != null && message.hasOwnProperty("title"))
                if (!$util.isInteger(message.title))
                    return "title: integer expected";
            if (message.power != null && message.hasOwnProperty("power"))
                if (!$util.isInteger(message.power) && !(message.power && $util.isInteger(message.power.low) && $util.isInteger(message.power.high)))
                    return "power: integer|Long expected";
            if (message.gfight != null && message.hasOwnProperty("gfight"))
                if (!$util.isInteger(message.gfight))
                    return "gfight: integer expected";
            if (message.border != null && message.hasOwnProperty("border"))
                if (!$util.isInteger(message.border))
                    return "border: integer expected";
            if (message.cwar != null && message.hasOwnProperty("cwar"))
                if (!$util.isInteger(message.cwar))
                    return "cwar: integer expected";
            if (message.country != null && message.hasOwnProperty("country"))
                if (!$util.isString(message.country))
                    return "country: string expected";
            if (message.sds != null && message.hasOwnProperty("sds"))
                if (!$util.isString(message.sds))
                    return "sds: string expected";
            if (message.city != null && message.hasOwnProperty("city"))
                if (!$util.isString(message.city))
                    return "city: string expected";
            if (message.emblem != null && message.hasOwnProperty("emblem"))
                if (!$util.isInteger(message.emblem) && !(message.emblem && $util.isInteger(message.emblem.low) && $util.isInteger(message.emblem.high)))
                    return "emblem: integer|Long expected";
            return null;
        };
    
        /**
         * Creates a pb_gmember message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_gmember
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_gmember} pb_gmember
         */
        pb_gmember.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_gmember)
                return object;
            var message = new $root.pb_gmember();
            if (object.uid != null)
                if ($util.Long)
                    (message.uid = $util.Long.fromValue(object.uid)).unsigned = false;
                else if (typeof object.uid === "string")
                    message.uid = parseInt(object.uid, 10);
                else if (typeof object.uid === "number")
                    message.uid = object.uid;
                else if (typeof object.uid === "object")
                    message.uid = new $util.LongBits(object.uid.low >>> 0, object.uid.high >>> 0).toNumber();
            if (object.name != null)
                message.name = String(object.name);
            if (object.lv != null)
                message.lv = object.lv | 0;
            if (object.logo != null)
                message.logo = object.logo | 0;
            if (object.last != null)
                message.last = object.last | 0;
            if (object.title != null)
                message.title = object.title | 0;
            if (object.power != null)
                if ($util.Long)
                    (message.power = $util.Long.fromValue(object.power)).unsigned = false;
                else if (typeof object.power === "string")
                    message.power = parseInt(object.power, 10);
                else if (typeof object.power === "number")
                    message.power = object.power;
                else if (typeof object.power === "object")
                    message.power = new $util.LongBits(object.power.low >>> 0, object.power.high >>> 0).toNumber();
            if (object.gfight != null)
                message.gfight = object.gfight | 0;
            if (object.border != null)
                message.border = object.border | 0;
            if (object.cwar != null)
                message.cwar = object.cwar | 0;
            if (object.country != null)
                message.country = String(object.country);
            if (object.sds != null)
                message.sds = String(object.sds);
            if (object.city != null)
                message.city = String(object.city);
            if (object.emblem != null)
                if ($util.Long)
                    (message.emblem = $util.Long.fromValue(object.emblem)).unsigned = false;
                else if (typeof object.emblem === "string")
                    message.emblem = parseInt(object.emblem, 10);
                else if (typeof object.emblem === "number")
                    message.emblem = object.emblem;
                else if (typeof object.emblem === "object")
                    message.emblem = new $util.LongBits(object.emblem.low >>> 0, object.emblem.high >>> 0).toNumber();
            return message;
        };
    
        /**
         * Creates a plain object from a pb_gmember message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_gmember
         * @static
         * @param {pb_gmember} message pb_gmember
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_gmember.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.uid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.uid = options.longs === String ? "0" : 0;
                object.name = "";
                object.lv = 0;
                object.logo = 0;
                object.last = 0;
                object.title = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.power = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.power = options.longs === String ? "0" : 0;
                object.gfight = 0;
                object.border = 0;
                object.cwar = 0;
                object.country = "";
                object.sds = "";
                object.city = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.emblem = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.emblem = options.longs === String ? "0" : 0;
            }
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (typeof message.uid === "number")
                    object.uid = options.longs === String ? String(message.uid) : message.uid;
                else
                    object.uid = options.longs === String ? $util.Long.prototype.toString.call(message.uid) : options.longs === Number ? new $util.LongBits(message.uid.low >>> 0, message.uid.high >>> 0).toNumber() : message.uid;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.lv != null && message.hasOwnProperty("lv"))
                object.lv = message.lv;
            if (message.logo != null && message.hasOwnProperty("logo"))
                object.logo = message.logo;
            if (message.last != null && message.hasOwnProperty("last"))
                object.last = message.last;
            if (message.title != null && message.hasOwnProperty("title"))
                object.title = message.title;
            if (message.power != null && message.hasOwnProperty("power"))
                if (typeof message.power === "number")
                    object.power = options.longs === String ? String(message.power) : message.power;
                else
                    object.power = options.longs === String ? $util.Long.prototype.toString.call(message.power) : options.longs === Number ? new $util.LongBits(message.power.low >>> 0, message.power.high >>> 0).toNumber() : message.power;
            if (message.gfight != null && message.hasOwnProperty("gfight"))
                object.gfight = message.gfight;
            if (message.border != null && message.hasOwnProperty("border"))
                object.border = message.border;
            if (message.cwar != null && message.hasOwnProperty("cwar"))
                object.cwar = message.cwar;
            if (message.country != null && message.hasOwnProperty("country"))
                object.country = message.country;
            if (message.sds != null && message.hasOwnProperty("sds"))
                object.sds = message.sds;
            if (message.city != null && message.hasOwnProperty("city"))
                object.city = message.city;
            if (message.emblem != null && message.hasOwnProperty("emblem"))
                if (typeof message.emblem === "number")
                    object.emblem = options.longs === String ? String(message.emblem) : message.emblem;
                else
                    object.emblem = options.longs === String ? $util.Long.prototype.toString.call(message.emblem) : options.longs === Number ? new $util.LongBits(message.emblem.low >>> 0, message.emblem.high >>> 0).toNumber() : message.emblem;
            return object;
        };
    
        /**
         * Converts this pb_gmember to JSON.
         * @function toJSON
         * @memberof pb_gmember
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_gmember.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_gmember
         * @function getTypeUrl
         * @memberof pb_gmember
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_gmember.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_gmember";
        };
    
        return pb_gmember;
    })();
    
    $root.pb_guild = (function() {
    
        /**
         * Properties of a pb_guild.
         * @exports Ipb_guild
         * @interface Ipb_guild
         * @property {number} id pb_guild id
         * @property {string} name pb_guild name
         * @property {number} logo pb_guild logo
         * @property {number} exp pb_guild exp
         * @property {string|null} [notice] pb_guild notice
         * @property {number|Long|null} [power] pb_guild power
         * @property {number|null} [rank] pb_guild rank
         * @property {number|null} [members] pb_guild members
         * @property {string|null} [pname] pb_guild pname
         * @property {number|null} [dismissCd] pb_guild dismissCd
         * @property {number|null} [flag] pb_guild flag
         */
    
        /**
         * Constructs a new pb_guild.
         * @exports pb_guild
         * @classdesc Represents a pb_guild.
         * @implements Ipb_guild
         * @constructor
         * @param {Ipb_guild=} [properties] Properties to set
         */
        function pb_guild(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_guild id.
         * @member {number} id
         * @memberof pb_guild
         * @instance
         */
        pb_guild.prototype.id = 0;
    
        /**
         * pb_guild name.
         * @member {string} name
         * @memberof pb_guild
         * @instance
         */
        pb_guild.prototype.name = "";
    
        /**
         * pb_guild logo.
         * @member {number} logo
         * @memberof pb_guild
         * @instance
         */
        pb_guild.prototype.logo = 0;
    
        /**
         * pb_guild exp.
         * @member {number} exp
         * @memberof pb_guild
         * @instance
         */
        pb_guild.prototype.exp = 0;
    
        /**
         * pb_guild notice.
         * @member {string} notice
         * @memberof pb_guild
         * @instance
         */
        pb_guild.prototype.notice = "";
    
        /**
         * pb_guild power.
         * @member {number|Long} power
         * @memberof pb_guild
         * @instance
         */
        pb_guild.prototype.power = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * pb_guild rank.
         * @member {number} rank
         * @memberof pb_guild
         * @instance
         */
        pb_guild.prototype.rank = 0;
    
        /**
         * pb_guild members.
         * @member {number} members
         * @memberof pb_guild
         * @instance
         */
        pb_guild.prototype.members = 0;
    
        /**
         * pb_guild pname.
         * @member {string} pname
         * @memberof pb_guild
         * @instance
         */
        pb_guild.prototype.pname = "";
    
        /**
         * pb_guild dismissCd.
         * @member {number} dismissCd
         * @memberof pb_guild
         * @instance
         */
        pb_guild.prototype.dismissCd = 0;
    
        /**
         * pb_guild flag.
         * @member {number} flag
         * @memberof pb_guild
         * @instance
         */
        pb_guild.prototype.flag = 0;
    
        /**
         * Creates a new pb_guild instance using the specified properties.
         * @function create
         * @memberof pb_guild
         * @static
         * @param {Ipb_guild=} [properties] Properties to set
         * @returns {pb_guild} pb_guild instance
         */
        pb_guild.create = function create(properties) {
            return new pb_guild(properties);
        };
    
        /**
         * Encodes the specified pb_guild message. Does not implicitly {@link pb_guild.verify|verify} messages.
         * @function encode
         * @memberof pb_guild
         * @static
         * @param {Ipb_guild} message pb_guild message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_guild.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.id);
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.logo);
            writer.uint32(/* id 4, wireType 0 =*/32).int32(message.exp);
            if (message.notice != null && Object.hasOwnProperty.call(message, "notice"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.notice);
            if (message.power != null && Object.hasOwnProperty.call(message, "power"))
                writer.uint32(/* id 6, wireType 0 =*/48).int64(message.power);
            if (message.rank != null && Object.hasOwnProperty.call(message, "rank"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.rank);
            if (message.members != null && Object.hasOwnProperty.call(message, "members"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.members);
            if (message.pname != null && Object.hasOwnProperty.call(message, "pname"))
                writer.uint32(/* id 9, wireType 2 =*/74).string(message.pname);
            if (message.dismissCd != null && Object.hasOwnProperty.call(message, "dismissCd"))
                writer.uint32(/* id 10, wireType 0 =*/80).int32(message.dismissCd);
            if (message.flag != null && Object.hasOwnProperty.call(message, "flag"))
                writer.uint32(/* id 11, wireType 0 =*/88).int32(message.flag);
            return writer;
        };
    
        /**
         * Encodes the specified pb_guild message, length delimited. Does not implicitly {@link pb_guild.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_guild
         * @static
         * @param {Ipb_guild} message pb_guild message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_guild.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_guild message from the specified reader or buffer.
         * @function decode
         * @memberof pb_guild
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_guild} pb_guild
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_guild.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_guild();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.id = reader.int32();
                        break;
                    }
                case 2: {
                        message.name = reader.string();
                        break;
                    }
                case 3: {
                        message.logo = reader.int32();
                        break;
                    }
                case 4: {
                        message.exp = reader.int32();
                        break;
                    }
                case 5: {
                        message.notice = reader.string();
                        break;
                    }
                case 6: {
                        message.power = reader.int64();
                        break;
                    }
                case 7: {
                        message.rank = reader.int32();
                        break;
                    }
                case 8: {
                        message.members = reader.int32();
                        break;
                    }
                case 9: {
                        message.pname = reader.string();
                        break;
                    }
                case 10: {
                        message.dismissCd = reader.int32();
                        break;
                    }
                case 11: {
                        message.flag = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("id"))
                throw $util.ProtocolError("missing required 'id'", { instance: message });
            if (!message.hasOwnProperty("name"))
                throw $util.ProtocolError("missing required 'name'", { instance: message });
            if (!message.hasOwnProperty("logo"))
                throw $util.ProtocolError("missing required 'logo'", { instance: message });
            if (!message.hasOwnProperty("exp"))
                throw $util.ProtocolError("missing required 'exp'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a pb_guild message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_guild
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_guild} pb_guild
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_guild.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_guild message.
         * @function verify
         * @memberof pb_guild
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_guild.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.id))
                return "id: integer expected";
            if (!$util.isString(message.name))
                return "name: string expected";
            if (!$util.isInteger(message.logo))
                return "logo: integer expected";
            if (!$util.isInteger(message.exp))
                return "exp: integer expected";
            if (message.notice != null && message.hasOwnProperty("notice"))
                if (!$util.isString(message.notice))
                    return "notice: string expected";
            if (message.power != null && message.hasOwnProperty("power"))
                if (!$util.isInteger(message.power) && !(message.power && $util.isInteger(message.power.low) && $util.isInteger(message.power.high)))
                    return "power: integer|Long expected";
            if (message.rank != null && message.hasOwnProperty("rank"))
                if (!$util.isInteger(message.rank))
                    return "rank: integer expected";
            if (message.members != null && message.hasOwnProperty("members"))
                if (!$util.isInteger(message.members))
                    return "members: integer expected";
            if (message.pname != null && message.hasOwnProperty("pname"))
                if (!$util.isString(message.pname))
                    return "pname: string expected";
            if (message.dismissCd != null && message.hasOwnProperty("dismissCd"))
                if (!$util.isInteger(message.dismissCd))
                    return "dismissCd: integer expected";
            if (message.flag != null && message.hasOwnProperty("flag"))
                if (!$util.isInteger(message.flag))
                    return "flag: integer expected";
            return null;
        };
    
        /**
         * Creates a pb_guild message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_guild
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_guild} pb_guild
         */
        pb_guild.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_guild)
                return object;
            var message = new $root.pb_guild();
            if (object.id != null)
                message.id = object.id | 0;
            if (object.name != null)
                message.name = String(object.name);
            if (object.logo != null)
                message.logo = object.logo | 0;
            if (object.exp != null)
                message.exp = object.exp | 0;
            if (object.notice != null)
                message.notice = String(object.notice);
            if (object.power != null)
                if ($util.Long)
                    (message.power = $util.Long.fromValue(object.power)).unsigned = false;
                else if (typeof object.power === "string")
                    message.power = parseInt(object.power, 10);
                else if (typeof object.power === "number")
                    message.power = object.power;
                else if (typeof object.power === "object")
                    message.power = new $util.LongBits(object.power.low >>> 0, object.power.high >>> 0).toNumber();
            if (object.rank != null)
                message.rank = object.rank | 0;
            if (object.members != null)
                message.members = object.members | 0;
            if (object.pname != null)
                message.pname = String(object.pname);
            if (object.dismissCd != null)
                message.dismissCd = object.dismissCd | 0;
            if (object.flag != null)
                message.flag = object.flag | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a pb_guild message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_guild
         * @static
         * @param {pb_guild} message pb_guild
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_guild.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = 0;
                object.name = "";
                object.logo = 0;
                object.exp = 0;
                object.notice = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.power = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.power = options.longs === String ? "0" : 0;
                object.rank = 0;
                object.members = 0;
                object.pname = "";
                object.dismissCd = 0;
                object.flag = 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.logo != null && message.hasOwnProperty("logo"))
                object.logo = message.logo;
            if (message.exp != null && message.hasOwnProperty("exp"))
                object.exp = message.exp;
            if (message.notice != null && message.hasOwnProperty("notice"))
                object.notice = message.notice;
            if (message.power != null && message.hasOwnProperty("power"))
                if (typeof message.power === "number")
                    object.power = options.longs === String ? String(message.power) : message.power;
                else
                    object.power = options.longs === String ? $util.Long.prototype.toString.call(message.power) : options.longs === Number ? new $util.LongBits(message.power.low >>> 0, message.power.high >>> 0).toNumber() : message.power;
            if (message.rank != null && message.hasOwnProperty("rank"))
                object.rank = message.rank;
            if (message.members != null && message.hasOwnProperty("members"))
                object.members = message.members;
            if (message.pname != null && message.hasOwnProperty("pname"))
                object.pname = message.pname;
            if (message.dismissCd != null && message.hasOwnProperty("dismissCd"))
                object.dismissCd = message.dismissCd;
            if (message.flag != null && message.hasOwnProperty("flag"))
                object.flag = message.flag;
            return object;
        };
    
        /**
         * Converts this pb_guild to JSON.
         * @function toJSON
         * @memberof pb_guild
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_guild.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_guild
         * @function getTypeUrl
         * @memberof pb_guild
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_guild.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_guild";
        };
    
        return pb_guild;
    })();
    
    $root.pb_glog = (function() {
    
        /**
         * Properties of a pb_glog.
         * @exports Ipb_glog
         * @interface Ipb_glog
         * @property {number} type pb_glog type
         * @property {number|null} [time] pb_glog time
         * @property {string|null} [objName] pb_glog objName
         * @property {string|null} [doName] pb_glog doName
         */
    
        /**
         * Constructs a new pb_glog.
         * @exports pb_glog
         * @classdesc Represents a pb_glog.
         * @implements Ipb_glog
         * @constructor
         * @param {Ipb_glog=} [properties] Properties to set
         */
        function pb_glog(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_glog type.
         * @member {number} type
         * @memberof pb_glog
         * @instance
         */
        pb_glog.prototype.type = 0;
    
        /**
         * pb_glog time.
         * @member {number} time
         * @memberof pb_glog
         * @instance
         */
        pb_glog.prototype.time = 0;
    
        /**
         * pb_glog objName.
         * @member {string} objName
         * @memberof pb_glog
         * @instance
         */
        pb_glog.prototype.objName = "";
    
        /**
         * pb_glog doName.
         * @member {string} doName
         * @memberof pb_glog
         * @instance
         */
        pb_glog.prototype.doName = "";
    
        /**
         * Creates a new pb_glog instance using the specified properties.
         * @function create
         * @memberof pb_glog
         * @static
         * @param {Ipb_glog=} [properties] Properties to set
         * @returns {pb_glog} pb_glog instance
         */
        pb_glog.create = function create(properties) {
            return new pb_glog(properties);
        };
    
        /**
         * Encodes the specified pb_glog message. Does not implicitly {@link pb_glog.verify|verify} messages.
         * @function encode
         * @memberof pb_glog
         * @static
         * @param {Ipb_glog} message pb_glog message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_glog.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            if (message.time != null && Object.hasOwnProperty.call(message, "time"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.time);
            if (message.objName != null && Object.hasOwnProperty.call(message, "objName"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.objName);
            if (message.doName != null && Object.hasOwnProperty.call(message, "doName"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.doName);
            return writer;
        };
    
        /**
         * Encodes the specified pb_glog message, length delimited. Does not implicitly {@link pb_glog.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_glog
         * @static
         * @param {Ipb_glog} message pb_glog message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_glog.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_glog message from the specified reader or buffer.
         * @function decode
         * @memberof pb_glog
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_glog} pb_glog
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_glog.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_glog();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.type = reader.int32();
                        break;
                    }
                case 2: {
                        message.time = reader.int32();
                        break;
                    }
                case 3: {
                        message.objName = reader.string();
                        break;
                    }
                case 4: {
                        message.doName = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("type"))
                throw $util.ProtocolError("missing required 'type'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a pb_glog message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_glog
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_glog} pb_glog
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_glog.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_glog message.
         * @function verify
         * @memberof pb_glog
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_glog.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.type))
                return "type: integer expected";
            if (message.time != null && message.hasOwnProperty("time"))
                if (!$util.isInteger(message.time))
                    return "time: integer expected";
            if (message.objName != null && message.hasOwnProperty("objName"))
                if (!$util.isString(message.objName))
                    return "objName: string expected";
            if (message.doName != null && message.hasOwnProperty("doName"))
                if (!$util.isString(message.doName))
                    return "doName: string expected";
            return null;
        };
    
        /**
         * Creates a pb_glog message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_glog
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_glog} pb_glog
         */
        pb_glog.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_glog)
                return object;
            var message = new $root.pb_glog();
            if (object.type != null)
                message.type = object.type | 0;
            if (object.time != null)
                message.time = object.time | 0;
            if (object.objName != null)
                message.objName = String(object.objName);
            if (object.doName != null)
                message.doName = String(object.doName);
            return message;
        };
    
        /**
         * Creates a plain object from a pb_glog message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_glog
         * @static
         * @param {pb_glog} message pb_glog
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_glog.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.type = 0;
                object.time = 0;
                object.objName = "";
                object.doName = "";
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            if (message.time != null && message.hasOwnProperty("time"))
                object.time = message.time;
            if (message.objName != null && message.hasOwnProperty("objName"))
                object.objName = message.objName;
            if (message.doName != null && message.hasOwnProperty("doName"))
                object.doName = message.doName;
            return object;
        };
    
        /**
         * Converts this pb_glog to JSON.
         * @function toJSON
         * @memberof pb_glog
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_glog.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_glog
         * @function getTypeUrl
         * @memberof pb_glog
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_glog.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_glog";
        };
    
        return pb_glog;
    })();
    
    $root.pb_unit = (function() {
    
        /**
         * Properties of a pb_unit.
         * @exports Ipb_unit
         * @interface Ipb_unit
         * @property {number|null} [hid] pb_unit hid
         * @property {number|null} [id] pb_unit id
         * @property {number|null} [pos] pb_unit pos
         * @property {number|null} [lv] pb_unit lv
         * @property {number|null} [star] pb_unit star
         * @property {number|null} [energy] pb_unit energy
         * @property {number|null} [hpp] pb_unit hpp
         * @property {number|null} [wake] pb_unit wake
         * @property {number|null} [skin] pb_unit skin
         * @property {number|null} [stl] pb_unit stl
         * @property {number|null} [flag] pb_unit flag
         * @property {number|null} [ex2] pb_unit ex2
         * @property {number|null} [core] pb_unit core
         * @property {number|null} [ex4] pb_unit ex4
         * @property {Array.<number>|null} [bra] pb_unit bra
         */
    
        /**
         * Constructs a new pb_unit.
         * @exports pb_unit
         * @classdesc Represents a pb_unit.
         * @implements Ipb_unit
         * @constructor
         * @param {Ipb_unit=} [properties] Properties to set
         */
        function pb_unit(properties) {
            this.bra = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_unit hid.
         * @member {number} hid
         * @memberof pb_unit
         * @instance
         */
        pb_unit.prototype.hid = 0;
    
        /**
         * pb_unit id.
         * @member {number} id
         * @memberof pb_unit
         * @instance
         */
        pb_unit.prototype.id = 0;
    
        /**
         * pb_unit pos.
         * @member {number} pos
         * @memberof pb_unit
         * @instance
         */
        pb_unit.prototype.pos = 0;
    
        /**
         * pb_unit lv.
         * @member {number} lv
         * @memberof pb_unit
         * @instance
         */
        pb_unit.prototype.lv = 0;
    
        /**
         * pb_unit star.
         * @member {number} star
         * @memberof pb_unit
         * @instance
         */
        pb_unit.prototype.star = 0;
    
        /**
         * pb_unit energy.
         * @member {number} energy
         * @memberof pb_unit
         * @instance
         */
        pb_unit.prototype.energy = 0;
    
        /**
         * pb_unit hpp.
         * @member {number} hpp
         * @memberof pb_unit
         * @instance
         */
        pb_unit.prototype.hpp = 0;
    
        /**
         * pb_unit wake.
         * @member {number} wake
         * @memberof pb_unit
         * @instance
         */
        pb_unit.prototype.wake = 0;
    
        /**
         * pb_unit skin.
         * @member {number} skin
         * @memberof pb_unit
         * @instance
         */
        pb_unit.prototype.skin = 0;
    
        /**
         * pb_unit stl.
         * @member {number} stl
         * @memberof pb_unit
         * @instance
         */
        pb_unit.prototype.stl = 0;
    
        /**
         * pb_unit flag.
         * @member {number} flag
         * @memberof pb_unit
         * @instance
         */
        pb_unit.prototype.flag = 0;
    
        /**
         * pb_unit ex2.
         * @member {number} ex2
         * @memberof pb_unit
         * @instance
         */
        pb_unit.prototype.ex2 = 0;
    
        /**
         * pb_unit core.
         * @member {number} core
         * @memberof pb_unit
         * @instance
         */
        pb_unit.prototype.core = 0;
    
        /**
         * pb_unit ex4.
         * @member {number} ex4
         * @memberof pb_unit
         * @instance
         */
        pb_unit.prototype.ex4 = 0;
    
        /**
         * pb_unit bra.
         * @member {Array.<number>} bra
         * @memberof pb_unit
         * @instance
         */
        pb_unit.prototype.bra = $util.emptyArray;
    
        /**
         * Creates a new pb_unit instance using the specified properties.
         * @function create
         * @memberof pb_unit
         * @static
         * @param {Ipb_unit=} [properties] Properties to set
         * @returns {pb_unit} pb_unit instance
         */
        pb_unit.create = function create(properties) {
            return new pb_unit(properties);
        };
    
        /**
         * Encodes the specified pb_unit message. Does not implicitly {@link pb_unit.verify|verify} messages.
         * @function encode
         * @memberof pb_unit
         * @static
         * @param {Ipb_unit} message pb_unit message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_unit.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.hid != null && Object.hasOwnProperty.call(message, "hid"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.hid);
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.id);
            if (message.pos != null && Object.hasOwnProperty.call(message, "pos"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.pos);
            if (message.lv != null && Object.hasOwnProperty.call(message, "lv"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.lv);
            if (message.star != null && Object.hasOwnProperty.call(message, "star"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.star);
            if (message.energy != null && Object.hasOwnProperty.call(message, "energy"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.energy);
            if (message.hpp != null && Object.hasOwnProperty.call(message, "hpp"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.hpp);
            if (message.wake != null && Object.hasOwnProperty.call(message, "wake"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.wake);
            if (message.skin != null && Object.hasOwnProperty.call(message, "skin"))
                writer.uint32(/* id 9, wireType 0 =*/72).int32(message.skin);
            if (message.stl != null && Object.hasOwnProperty.call(message, "stl"))
                writer.uint32(/* id 10, wireType 0 =*/80).int32(message.stl);
            if (message.flag != null && Object.hasOwnProperty.call(message, "flag"))
                writer.uint32(/* id 11, wireType 0 =*/88).int32(message.flag);
            if (message.ex2 != null && Object.hasOwnProperty.call(message, "ex2"))
                writer.uint32(/* id 12, wireType 0 =*/96).int32(message.ex2);
            if (message.core != null && Object.hasOwnProperty.call(message, "core"))
                writer.uint32(/* id 13, wireType 0 =*/104).int32(message.core);
            if (message.ex4 != null && Object.hasOwnProperty.call(message, "ex4"))
                writer.uint32(/* id 14, wireType 0 =*/112).int32(message.ex4);
            if (message.bra != null && message.bra.length)
                for (var i = 0; i < message.bra.length; ++i)
                    writer.uint32(/* id 15, wireType 0 =*/120).int32(message.bra[i]);
            return writer;
        };
    
        /**
         * Encodes the specified pb_unit message, length delimited. Does not implicitly {@link pb_unit.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_unit
         * @static
         * @param {Ipb_unit} message pb_unit message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_unit.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_unit message from the specified reader or buffer.
         * @function decode
         * @memberof pb_unit
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_unit} pb_unit
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_unit.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_unit();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.hid = reader.int32();
                        break;
                    }
                case 2: {
                        message.id = reader.int32();
                        break;
                    }
                case 3: {
                        message.pos = reader.int32();
                        break;
                    }
                case 4: {
                        message.lv = reader.int32();
                        break;
                    }
                case 5: {
                        message.star = reader.int32();
                        break;
                    }
                case 6: {
                        message.energy = reader.int32();
                        break;
                    }
                case 7: {
                        message.hpp = reader.int32();
                        break;
                    }
                case 8: {
                        message.wake = reader.int32();
                        break;
                    }
                case 9: {
                        message.skin = reader.int32();
                        break;
                    }
                case 10: {
                        message.stl = reader.int32();
                        break;
                    }
                case 11: {
                        message.flag = reader.int32();
                        break;
                    }
                case 12: {
                        message.ex2 = reader.int32();
                        break;
                    }
                case 13: {
                        message.core = reader.int32();
                        break;
                    }
                case 14: {
                        message.ex4 = reader.int32();
                        break;
                    }
                case 15: {
                        if (!(message.bra && message.bra.length))
                            message.bra = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.bra.push(reader.int32());
                        } else
                            message.bra.push(reader.int32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a pb_unit message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_unit
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_unit} pb_unit
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_unit.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_unit message.
         * @function verify
         * @memberof pb_unit
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_unit.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.hid != null && message.hasOwnProperty("hid"))
                if (!$util.isInteger(message.hid))
                    return "hid: integer expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id))
                    return "id: integer expected";
            if (message.pos != null && message.hasOwnProperty("pos"))
                if (!$util.isInteger(message.pos))
                    return "pos: integer expected";
            if (message.lv != null && message.hasOwnProperty("lv"))
                if (!$util.isInteger(message.lv))
                    return "lv: integer expected";
            if (message.star != null && message.hasOwnProperty("star"))
                if (!$util.isInteger(message.star))
                    return "star: integer expected";
            if (message.energy != null && message.hasOwnProperty("energy"))
                if (!$util.isInteger(message.energy))
                    return "energy: integer expected";
            if (message.hpp != null && message.hasOwnProperty("hpp"))
                if (!$util.isInteger(message.hpp))
                    return "hpp: integer expected";
            if (message.wake != null && message.hasOwnProperty("wake"))
                if (!$util.isInteger(message.wake))
                    return "wake: integer expected";
            if (message.skin != null && message.hasOwnProperty("skin"))
                if (!$util.isInteger(message.skin))
                    return "skin: integer expected";
            if (message.stl != null && message.hasOwnProperty("stl"))
                if (!$util.isInteger(message.stl))
                    return "stl: integer expected";
            if (message.flag != null && message.hasOwnProperty("flag"))
                if (!$util.isInteger(message.flag))
                    return "flag: integer expected";
            if (message.ex2 != null && message.hasOwnProperty("ex2"))
                if (!$util.isInteger(message.ex2))
                    return "ex2: integer expected";
            if (message.core != null && message.hasOwnProperty("core"))
                if (!$util.isInteger(message.core))
                    return "core: integer expected";
            if (message.ex4 != null && message.hasOwnProperty("ex4"))
                if (!$util.isInteger(message.ex4))
                    return "ex4: integer expected";
            if (message.bra != null && message.hasOwnProperty("bra")) {
                if (!Array.isArray(message.bra))
                    return "bra: array expected";
                for (var i = 0; i < message.bra.length; ++i)
                    if (!$util.isInteger(message.bra[i]))
                        return "bra: integer[] expected";
            }
            return null;
        };
    
        /**
         * Creates a pb_unit message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_unit
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_unit} pb_unit
         */
        pb_unit.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_unit)
                return object;
            var message = new $root.pb_unit();
            if (object.hid != null)
                message.hid = object.hid | 0;
            if (object.id != null)
                message.id = object.id | 0;
            if (object.pos != null)
                message.pos = object.pos | 0;
            if (object.lv != null)
                message.lv = object.lv | 0;
            if (object.star != null)
                message.star = object.star | 0;
            if (object.energy != null)
                message.energy = object.energy | 0;
            if (object.hpp != null)
                message.hpp = object.hpp | 0;
            if (object.wake != null)
                message.wake = object.wake | 0;
            if (object.skin != null)
                message.skin = object.skin | 0;
            if (object.stl != null)
                message.stl = object.stl | 0;
            if (object.flag != null)
                message.flag = object.flag | 0;
            if (object.ex2 != null)
                message.ex2 = object.ex2 | 0;
            if (object.core != null)
                message.core = object.core | 0;
            if (object.ex4 != null)
                message.ex4 = object.ex4 | 0;
            if (object.bra) {
                if (!Array.isArray(object.bra))
                    throw TypeError(".pb_unit.bra: array expected");
                message.bra = [];
                for (var i = 0; i < object.bra.length; ++i)
                    message.bra[i] = object.bra[i] | 0;
            }
            return message;
        };
    
        /**
         * Creates a plain object from a pb_unit message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_unit
         * @static
         * @param {pb_unit} message pb_unit
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_unit.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.bra = [];
            if (options.defaults) {
                object.hid = 0;
                object.id = 0;
                object.pos = 0;
                object.lv = 0;
                object.star = 0;
                object.energy = 0;
                object.hpp = 0;
                object.wake = 0;
                object.skin = 0;
                object.stl = 0;
                object.flag = 0;
                object.ex2 = 0;
                object.core = 0;
                object.ex4 = 0;
            }
            if (message.hid != null && message.hasOwnProperty("hid"))
                object.hid = message.hid;
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.pos != null && message.hasOwnProperty("pos"))
                object.pos = message.pos;
            if (message.lv != null && message.hasOwnProperty("lv"))
                object.lv = message.lv;
            if (message.star != null && message.hasOwnProperty("star"))
                object.star = message.star;
            if (message.energy != null && message.hasOwnProperty("energy"))
                object.energy = message.energy;
            if (message.hpp != null && message.hasOwnProperty("hpp"))
                object.hpp = message.hpp;
            if (message.wake != null && message.hasOwnProperty("wake"))
                object.wake = message.wake;
            if (message.skin != null && message.hasOwnProperty("skin"))
                object.skin = message.skin;
            if (message.stl != null && message.hasOwnProperty("stl"))
                object.stl = message.stl;
            if (message.flag != null && message.hasOwnProperty("flag"))
                object.flag = message.flag;
            if (message.ex2 != null && message.hasOwnProperty("ex2"))
                object.ex2 = message.ex2;
            if (message.core != null && message.hasOwnProperty("core"))
                object.core = message.core;
            if (message.ex4 != null && message.hasOwnProperty("ex4"))
                object.ex4 = message.ex4;
            if (message.bra && message.bra.length) {
                object.bra = [];
                for (var j = 0; j < message.bra.length; ++j)
                    object.bra[j] = message.bra[j];
            }
            return object;
        };
    
        /**
         * Converts this pb_unit to JSON.
         * @function toJSON
         * @memberof pb_unit
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_unit.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_unit
         * @function getTypeUrl
         * @memberof pb_unit
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_unit.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_unit";
        };
    
        return pb_unit;
    })();
    
    $root.pb_strial = (function() {
    
        /**
         * Properties of a pb_strial.
         * @exports Ipb_strial
         * @interface Ipb_strial
         * @property {number} id pb_strial id
         * @property {number} tl pb_strial tl
         * @property {number} cd pb_strial cd
         */
    
        /**
         * Constructs a new pb_strial.
         * @exports pb_strial
         * @classdesc Represents a pb_strial.
         * @implements Ipb_strial
         * @constructor
         * @param {Ipb_strial=} [properties] Properties to set
         */
        function pb_strial(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_strial id.
         * @member {number} id
         * @memberof pb_strial
         * @instance
         */
        pb_strial.prototype.id = 0;
    
        /**
         * pb_strial tl.
         * @member {number} tl
         * @memberof pb_strial
         * @instance
         */
        pb_strial.prototype.tl = 0;
    
        /**
         * pb_strial cd.
         * @member {number} cd
         * @memberof pb_strial
         * @instance
         */
        pb_strial.prototype.cd = 0;
    
        /**
         * Creates a new pb_strial instance using the specified properties.
         * @function create
         * @memberof pb_strial
         * @static
         * @param {Ipb_strial=} [properties] Properties to set
         * @returns {pb_strial} pb_strial instance
         */
        pb_strial.create = function create(properties) {
            return new pb_strial(properties);
        };
    
        /**
         * Encodes the specified pb_strial message. Does not implicitly {@link pb_strial.verify|verify} messages.
         * @function encode
         * @memberof pb_strial
         * @static
         * @param {Ipb_strial} message pb_strial message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_strial.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.id);
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.tl);
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.cd);
            return writer;
        };
    
        /**
         * Encodes the specified pb_strial message, length delimited. Does not implicitly {@link pb_strial.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_strial
         * @static
         * @param {Ipb_strial} message pb_strial message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_strial.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_strial message from the specified reader or buffer.
         * @function decode
         * @memberof pb_strial
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_strial} pb_strial
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_strial.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_strial();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.id = reader.int32();
                        break;
                    }
                case 2: {
                        message.tl = reader.int32();
                        break;
                    }
                case 3: {
                        message.cd = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("id"))
                throw $util.ProtocolError("missing required 'id'", { instance: message });
            if (!message.hasOwnProperty("tl"))
                throw $util.ProtocolError("missing required 'tl'", { instance: message });
            if (!message.hasOwnProperty("cd"))
                throw $util.ProtocolError("missing required 'cd'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a pb_strial message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_strial
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_strial} pb_strial
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_strial.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_strial message.
         * @function verify
         * @memberof pb_strial
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_strial.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.id))
                return "id: integer expected";
            if (!$util.isInteger(message.tl))
                return "tl: integer expected";
            if (!$util.isInteger(message.cd))
                return "cd: integer expected";
            return null;
        };
    
        /**
         * Creates a pb_strial message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_strial
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_strial} pb_strial
         */
        pb_strial.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_strial)
                return object;
            var message = new $root.pb_strial();
            if (object.id != null)
                message.id = object.id | 0;
            if (object.tl != null)
                message.tl = object.tl | 0;
            if (object.cd != null)
                message.cd = object.cd | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a pb_strial message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_strial
         * @static
         * @param {pb_strial} message pb_strial
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_strial.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = 0;
                object.tl = 0;
                object.cd = 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.tl != null && message.hasOwnProperty("tl"))
                object.tl = message.tl;
            if (message.cd != null && message.hasOwnProperty("cd"))
                object.cd = message.cd;
            return object;
        };
    
        /**
         * Converts this pb_strial to JSON.
         * @function toJSON
         * @memberof pb_strial
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_strial.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_strial
         * @function getTypeUrl
         * @memberof pb_strial
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_strial.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_strial";
        };
    
        return pb_strial;
    })();
    
    $root.pb_trial = (function() {
    
        /**
         * Properties of a pb_trial.
         * @exports Ipb_trial
         * @interface Ipb_trial
         * @property {number} logo pb_trial logo
         * @property {number} lv pb_trial lv
         * @property {string} name pb_trial name
         * @property {number|Long|null} [power] pb_trial power
         * @property {number|null} [stage] pb_trial stage
         * @property {Ipb_evideo|null} [video] pb_trial video
         * @property {number|null} [border] pb_trial border
         * @property {number|Long|null} [uid] pb_trial uid
         */
    
        /**
         * Constructs a new pb_trial.
         * @exports pb_trial
         * @classdesc Represents a pb_trial.
         * @implements Ipb_trial
         * @constructor
         * @param {Ipb_trial=} [properties] Properties to set
         */
        function pb_trial(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_trial logo.
         * @member {number} logo
         * @memberof pb_trial
         * @instance
         */
        pb_trial.prototype.logo = 0;
    
        /**
         * pb_trial lv.
         * @member {number} lv
         * @memberof pb_trial
         * @instance
         */
        pb_trial.prototype.lv = 0;
    
        /**
         * pb_trial name.
         * @member {string} name
         * @memberof pb_trial
         * @instance
         */
        pb_trial.prototype.name = "";
    
        /**
         * pb_trial power.
         * @member {number|Long} power
         * @memberof pb_trial
         * @instance
         */
        pb_trial.prototype.power = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * pb_trial stage.
         * @member {number} stage
         * @memberof pb_trial
         * @instance
         */
        pb_trial.prototype.stage = 0;
    
        /**
         * pb_trial video.
         * @member {Ipb_evideo|null|undefined} video
         * @memberof pb_trial
         * @instance
         */
        pb_trial.prototype.video = null;
    
        /**
         * pb_trial border.
         * @member {number} border
         * @memberof pb_trial
         * @instance
         */
        pb_trial.prototype.border = 0;
    
        /**
         * pb_trial uid.
         * @member {number|Long} uid
         * @memberof pb_trial
         * @instance
         */
        pb_trial.prototype.uid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * Creates a new pb_trial instance using the specified properties.
         * @function create
         * @memberof pb_trial
         * @static
         * @param {Ipb_trial=} [properties] Properties to set
         * @returns {pb_trial} pb_trial instance
         */
        pb_trial.create = function create(properties) {
            return new pb_trial(properties);
        };
    
        /**
         * Encodes the specified pb_trial message. Does not implicitly {@link pb_trial.verify|verify} messages.
         * @function encode
         * @memberof pb_trial
         * @static
         * @param {Ipb_trial} message pb_trial message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_trial.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.logo);
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.lv);
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.name);
            if (message.power != null && Object.hasOwnProperty.call(message, "power"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.power);
            if (message.stage != null && Object.hasOwnProperty.call(message, "stage"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.stage);
            if (message.video != null && Object.hasOwnProperty.call(message, "video"))
                $root.pb_evideo.encode(message.video, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.border != null && Object.hasOwnProperty.call(message, "border"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.border);
            if (message.uid != null && Object.hasOwnProperty.call(message, "uid"))
                writer.uint32(/* id 8, wireType 0 =*/64).int64(message.uid);
            return writer;
        };
    
        /**
         * Encodes the specified pb_trial message, length delimited. Does not implicitly {@link pb_trial.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_trial
         * @static
         * @param {Ipb_trial} message pb_trial message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_trial.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_trial message from the specified reader or buffer.
         * @function decode
         * @memberof pb_trial
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_trial} pb_trial
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_trial.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_trial();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.logo = reader.int32();
                        break;
                    }
                case 2: {
                        message.lv = reader.int32();
                        break;
                    }
                case 3: {
                        message.name = reader.string();
                        break;
                    }
                case 4: {
                        message.power = reader.int64();
                        break;
                    }
                case 5: {
                        message.stage = reader.int32();
                        break;
                    }
                case 6: {
                        message.video = $root.pb_evideo.decode(reader, reader.uint32());
                        break;
                    }
                case 7: {
                        message.border = reader.int32();
                        break;
                    }
                case 8: {
                        message.uid = reader.int64();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("logo"))
                throw $util.ProtocolError("missing required 'logo'", { instance: message });
            if (!message.hasOwnProperty("lv"))
                throw $util.ProtocolError("missing required 'lv'", { instance: message });
            if (!message.hasOwnProperty("name"))
                throw $util.ProtocolError("missing required 'name'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a pb_trial message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_trial
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_trial} pb_trial
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_trial.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_trial message.
         * @function verify
         * @memberof pb_trial
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_trial.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.logo))
                return "logo: integer expected";
            if (!$util.isInteger(message.lv))
                return "lv: integer expected";
            if (!$util.isString(message.name))
                return "name: string expected";
            if (message.power != null && message.hasOwnProperty("power"))
                if (!$util.isInteger(message.power) && !(message.power && $util.isInteger(message.power.low) && $util.isInteger(message.power.high)))
                    return "power: integer|Long expected";
            if (message.stage != null && message.hasOwnProperty("stage"))
                if (!$util.isInteger(message.stage))
                    return "stage: integer expected";
            if (message.video != null && message.hasOwnProperty("video")) {
                var error = $root.pb_evideo.verify(message.video);
                if (error)
                    return "video." + error;
            }
            if (message.border != null && message.hasOwnProperty("border"))
                if (!$util.isInteger(message.border))
                    return "border: integer expected";
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (!$util.isInteger(message.uid) && !(message.uid && $util.isInteger(message.uid.low) && $util.isInteger(message.uid.high)))
                    return "uid: integer|Long expected";
            return null;
        };
    
        /**
         * Creates a pb_trial message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_trial
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_trial} pb_trial
         */
        pb_trial.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_trial)
                return object;
            var message = new $root.pb_trial();
            if (object.logo != null)
                message.logo = object.logo | 0;
            if (object.lv != null)
                message.lv = object.lv | 0;
            if (object.name != null)
                message.name = String(object.name);
            if (object.power != null)
                if ($util.Long)
                    (message.power = $util.Long.fromValue(object.power)).unsigned = false;
                else if (typeof object.power === "string")
                    message.power = parseInt(object.power, 10);
                else if (typeof object.power === "number")
                    message.power = object.power;
                else if (typeof object.power === "object")
                    message.power = new $util.LongBits(object.power.low >>> 0, object.power.high >>> 0).toNumber();
            if (object.stage != null)
                message.stage = object.stage | 0;
            if (object.video != null) {
                if (typeof object.video !== "object")
                    throw TypeError(".pb_trial.video: object expected");
                message.video = $root.pb_evideo.fromObject(object.video);
            }
            if (object.border != null)
                message.border = object.border | 0;
            if (object.uid != null)
                if ($util.Long)
                    (message.uid = $util.Long.fromValue(object.uid)).unsigned = false;
                else if (typeof object.uid === "string")
                    message.uid = parseInt(object.uid, 10);
                else if (typeof object.uid === "number")
                    message.uid = object.uid;
                else if (typeof object.uid === "object")
                    message.uid = new $util.LongBits(object.uid.low >>> 0, object.uid.high >>> 0).toNumber();
            return message;
        };
    
        /**
         * Creates a plain object from a pb_trial message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_trial
         * @static
         * @param {pb_trial} message pb_trial
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_trial.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.logo = 0;
                object.lv = 0;
                object.name = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.power = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.power = options.longs === String ? "0" : 0;
                object.stage = 0;
                object.video = null;
                object.border = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.uid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.uid = options.longs === String ? "0" : 0;
            }
            if (message.logo != null && message.hasOwnProperty("logo"))
                object.logo = message.logo;
            if (message.lv != null && message.hasOwnProperty("lv"))
                object.lv = message.lv;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.power != null && message.hasOwnProperty("power"))
                if (typeof message.power === "number")
                    object.power = options.longs === String ? String(message.power) : message.power;
                else
                    object.power = options.longs === String ? $util.Long.prototype.toString.call(message.power) : options.longs === Number ? new $util.LongBits(message.power.low >>> 0, message.power.high >>> 0).toNumber() : message.power;
            if (message.stage != null && message.hasOwnProperty("stage"))
                object.stage = message.stage;
            if (message.video != null && message.hasOwnProperty("video"))
                object.video = $root.pb_evideo.toObject(message.video, options);
            if (message.border != null && message.hasOwnProperty("border"))
                object.border = message.border;
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (typeof message.uid === "number")
                    object.uid = options.longs === String ? String(message.uid) : message.uid;
                else
                    object.uid = options.longs === String ? $util.Long.prototype.toString.call(message.uid) : options.longs === Number ? new $util.LongBits(message.uid.low >>> 0, message.uid.high >>> 0).toNumber() : message.uid;
            return object;
        };
    
        /**
         * Converts this pb_trial to JSON.
         * @function toJSON
         * @memberof pb_trial
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_trial.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_trial
         * @function getTypeUrl
         * @memberof pb_trial
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_trial.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_trial";
        };
    
        return pb_trial;
    })();
    
    $root.pb_plog = (function() {
    
        /**
         * Properties of a pb_plog.
         * @exports Ipb_plog
         * @interface Ipb_plog
         * @property {Ipb_pmbr} rival pb_plog rival
         * @property {boolean} atk pb_plog atk
         * @property {boolean} win pb_plog win
         * @property {Array.<number>|null} [vid] pb_plog vid
         * @property {number} time pb_plog time
         * @property {number} score pb_plog score
         * @property {Array.<boolean>|null} [wins] pb_plog wins
         */
    
        /**
         * Constructs a new pb_plog.
         * @exports pb_plog
         * @classdesc Represents a pb_plog.
         * @implements Ipb_plog
         * @constructor
         * @param {Ipb_plog=} [properties] Properties to set
         */
        function pb_plog(properties) {
            this.vid = [];
            this.wins = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_plog rival.
         * @member {Ipb_pmbr} rival
         * @memberof pb_plog
         * @instance
         */
        pb_plog.prototype.rival = null;
    
        /**
         * pb_plog atk.
         * @member {boolean} atk
         * @memberof pb_plog
         * @instance
         */
        pb_plog.prototype.atk = false;
    
        /**
         * pb_plog win.
         * @member {boolean} win
         * @memberof pb_plog
         * @instance
         */
        pb_plog.prototype.win = false;
    
        /**
         * pb_plog vid.
         * @member {Array.<number>} vid
         * @memberof pb_plog
         * @instance
         */
        pb_plog.prototype.vid = $util.emptyArray;
    
        /**
         * pb_plog time.
         * @member {number} time
         * @memberof pb_plog
         * @instance
         */
        pb_plog.prototype.time = 0;
    
        /**
         * pb_plog score.
         * @member {number} score
         * @memberof pb_plog
         * @instance
         */
        pb_plog.prototype.score = 0;
    
        /**
         * pb_plog wins.
         * @member {Array.<boolean>} wins
         * @memberof pb_plog
         * @instance
         */
        pb_plog.prototype.wins = $util.emptyArray;
    
        /**
         * Creates a new pb_plog instance using the specified properties.
         * @function create
         * @memberof pb_plog
         * @static
         * @param {Ipb_plog=} [properties] Properties to set
         * @returns {pb_plog} pb_plog instance
         */
        pb_plog.create = function create(properties) {
            return new pb_plog(properties);
        };
    
        /**
         * Encodes the specified pb_plog message. Does not implicitly {@link pb_plog.verify|verify} messages.
         * @function encode
         * @memberof pb_plog
         * @static
         * @param {Ipb_plog} message pb_plog message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_plog.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.pb_pmbr.encode(message.rival, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            writer.uint32(/* id 2, wireType 0 =*/16).bool(message.atk);
            writer.uint32(/* id 3, wireType 0 =*/24).bool(message.win);
            if (message.vid != null && message.vid.length)
                for (var i = 0; i < message.vid.length; ++i)
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.vid[i]);
            writer.uint32(/* id 5, wireType 0 =*/40).int32(message.time);
            writer.uint32(/* id 6, wireType 0 =*/48).int32(message.score);
            if (message.wins != null && message.wins.length)
                for (var i = 0; i < message.wins.length; ++i)
                    writer.uint32(/* id 7, wireType 0 =*/56).bool(message.wins[i]);
            return writer;
        };
    
        /**
         * Encodes the specified pb_plog message, length delimited. Does not implicitly {@link pb_plog.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_plog
         * @static
         * @param {Ipb_plog} message pb_plog message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_plog.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_plog message from the specified reader or buffer.
         * @function decode
         * @memberof pb_plog
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_plog} pb_plog
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_plog.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_plog();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.rival = $root.pb_pmbr.decode(reader, reader.uint32());
                        break;
                    }
                case 2: {
                        message.atk = reader.bool();
                        break;
                    }
                case 3: {
                        message.win = reader.bool();
                        break;
                    }
                case 4: {
                        if (!(message.vid && message.vid.length))
                            message.vid = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.vid.push(reader.int32());
                        } else
                            message.vid.push(reader.int32());
                        break;
                    }
                case 5: {
                        message.time = reader.int32();
                        break;
                    }
                case 6: {
                        message.score = reader.int32();
                        break;
                    }
                case 7: {
                        if (!(message.wins && message.wins.length))
                            message.wins = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.wins.push(reader.bool());
                        } else
                            message.wins.push(reader.bool());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("rival"))
                throw $util.ProtocolError("missing required 'rival'", { instance: message });
            if (!message.hasOwnProperty("atk"))
                throw $util.ProtocolError("missing required 'atk'", { instance: message });
            if (!message.hasOwnProperty("win"))
                throw $util.ProtocolError("missing required 'win'", { instance: message });
            if (!message.hasOwnProperty("time"))
                throw $util.ProtocolError("missing required 'time'", { instance: message });
            if (!message.hasOwnProperty("score"))
                throw $util.ProtocolError("missing required 'score'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a pb_plog message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_plog
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_plog} pb_plog
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_plog.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_plog message.
         * @function verify
         * @memberof pb_plog
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_plog.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.pb_pmbr.verify(message.rival);
                if (error)
                    return "rival." + error;
            }
            if (typeof message.atk !== "boolean")
                return "atk: boolean expected";
            if (typeof message.win !== "boolean")
                return "win: boolean expected";
            if (message.vid != null && message.hasOwnProperty("vid")) {
                if (!Array.isArray(message.vid))
                    return "vid: array expected";
                for (var i = 0; i < message.vid.length; ++i)
                    if (!$util.isInteger(message.vid[i]))
                        return "vid: integer[] expected";
            }
            if (!$util.isInteger(message.time))
                return "time: integer expected";
            if (!$util.isInteger(message.score))
                return "score: integer expected";
            if (message.wins != null && message.hasOwnProperty("wins")) {
                if (!Array.isArray(message.wins))
                    return "wins: array expected";
                for (var i = 0; i < message.wins.length; ++i)
                    if (typeof message.wins[i] !== "boolean")
                        return "wins: boolean[] expected";
            }
            return null;
        };
    
        /**
         * Creates a pb_plog message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_plog
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_plog} pb_plog
         */
        pb_plog.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_plog)
                return object;
            var message = new $root.pb_plog();
            if (object.rival != null) {
                if (typeof object.rival !== "object")
                    throw TypeError(".pb_plog.rival: object expected");
                message.rival = $root.pb_pmbr.fromObject(object.rival);
            }
            if (object.atk != null)
                message.atk = Boolean(object.atk);
            if (object.win != null)
                message.win = Boolean(object.win);
            if (object.vid) {
                if (!Array.isArray(object.vid))
                    throw TypeError(".pb_plog.vid: array expected");
                message.vid = [];
                for (var i = 0; i < object.vid.length; ++i)
                    message.vid[i] = object.vid[i] | 0;
            }
            if (object.time != null)
                message.time = object.time | 0;
            if (object.score != null)
                message.score = object.score | 0;
            if (object.wins) {
                if (!Array.isArray(object.wins))
                    throw TypeError(".pb_plog.wins: array expected");
                message.wins = [];
                for (var i = 0; i < object.wins.length; ++i)
                    message.wins[i] = Boolean(object.wins[i]);
            }
            return message;
        };
    
        /**
         * Creates a plain object from a pb_plog message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_plog
         * @static
         * @param {pb_plog} message pb_plog
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_plog.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.vid = [];
                object.wins = [];
            }
            if (options.defaults) {
                object.rival = null;
                object.atk = false;
                object.win = false;
                object.time = 0;
                object.score = 0;
            }
            if (message.rival != null && message.hasOwnProperty("rival"))
                object.rival = $root.pb_pmbr.toObject(message.rival, options);
            if (message.atk != null && message.hasOwnProperty("atk"))
                object.atk = message.atk;
            if (message.win != null && message.hasOwnProperty("win"))
                object.win = message.win;
            if (message.vid && message.vid.length) {
                object.vid = [];
                for (var j = 0; j < message.vid.length; ++j)
                    object.vid[j] = message.vid[j];
            }
            if (message.time != null && message.hasOwnProperty("time"))
                object.time = message.time;
            if (message.score != null && message.hasOwnProperty("score"))
                object.score = message.score;
            if (message.wins && message.wins.length) {
                object.wins = [];
                for (var j = 0; j < message.wins.length; ++j)
                    object.wins[j] = message.wins[j];
            }
            return object;
        };
    
        /**
         * Converts this pb_plog to JSON.
         * @function toJSON
         * @memberof pb_plog
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_plog.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_plog
         * @function getTypeUrl
         * @memberof pb_plog
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_plog.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_plog";
        };
    
        return pb_plog;
    })();
    
    $root.pb_p3plog = (function() {
    
        /**
         * Properties of a pb_p3plog.
         * @exports Ipb_p3plog
         * @interface Ipb_p3plog
         * @property {Ipb_p3pmbr|null} [def] pb_p3plog def
         * @property {boolean|null} [atk] pb_p3plog atk
         * @property {boolean|null} [win] pb_p3plog win
         * @property {number|null} [vid] pb_p3plog vid
         * @property {number|null} [time] pb_p3plog time
         * @property {number|null} [score] pb_p3plog score
         */
    
        /**
         * Constructs a new pb_p3plog.
         * @exports pb_p3plog
         * @classdesc Represents a pb_p3plog.
         * @implements Ipb_p3plog
         * @constructor
         * @param {Ipb_p3plog=} [properties] Properties to set
         */
        function pb_p3plog(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_p3plog def.
         * @member {Ipb_p3pmbr|null|undefined} def
         * @memberof pb_p3plog
         * @instance
         */
        pb_p3plog.prototype.def = null;
    
        /**
         * pb_p3plog atk.
         * @member {boolean} atk
         * @memberof pb_p3plog
         * @instance
         */
        pb_p3plog.prototype.atk = false;
    
        /**
         * pb_p3plog win.
         * @member {boolean} win
         * @memberof pb_p3plog
         * @instance
         */
        pb_p3plog.prototype.win = false;
    
        /**
         * pb_p3plog vid.
         * @member {number} vid
         * @memberof pb_p3plog
         * @instance
         */
        pb_p3plog.prototype.vid = 0;
    
        /**
         * pb_p3plog time.
         * @member {number} time
         * @memberof pb_p3plog
         * @instance
         */
        pb_p3plog.prototype.time = 0;
    
        /**
         * pb_p3plog score.
         * @member {number} score
         * @memberof pb_p3plog
         * @instance
         */
        pb_p3plog.prototype.score = 0;
    
        /**
         * Creates a new pb_p3plog instance using the specified properties.
         * @function create
         * @memberof pb_p3plog
         * @static
         * @param {Ipb_p3plog=} [properties] Properties to set
         * @returns {pb_p3plog} pb_p3plog instance
         */
        pb_p3plog.create = function create(properties) {
            return new pb_p3plog(properties);
        };
    
        /**
         * Encodes the specified pb_p3plog message. Does not implicitly {@link pb_p3plog.verify|verify} messages.
         * @function encode
         * @memberof pb_p3plog
         * @static
         * @param {Ipb_p3plog} message pb_p3plog message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_p3plog.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.def != null && Object.hasOwnProperty.call(message, "def"))
                $root.pb_p3pmbr.encode(message.def, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.atk != null && Object.hasOwnProperty.call(message, "atk"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.atk);
            if (message.win != null && Object.hasOwnProperty.call(message, "win"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.win);
            if (message.vid != null && Object.hasOwnProperty.call(message, "vid"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.vid);
            if (message.time != null && Object.hasOwnProperty.call(message, "time"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.time);
            if (message.score != null && Object.hasOwnProperty.call(message, "score"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.score);
            return writer;
        };
    
        /**
         * Encodes the specified pb_p3plog message, length delimited. Does not implicitly {@link pb_p3plog.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_p3plog
         * @static
         * @param {Ipb_p3plog} message pb_p3plog message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_p3plog.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_p3plog message from the specified reader or buffer.
         * @function decode
         * @memberof pb_p3plog
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_p3plog} pb_p3plog
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_p3plog.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_p3plog();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.def = $root.pb_p3pmbr.decode(reader, reader.uint32());
                        break;
                    }
                case 2: {
                        message.atk = reader.bool();
                        break;
                    }
                case 3: {
                        message.win = reader.bool();
                        break;
                    }
                case 4: {
                        message.vid = reader.int32();
                        break;
                    }
                case 5: {
                        message.time = reader.int32();
                        break;
                    }
                case 6: {
                        message.score = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a pb_p3plog message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_p3plog
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_p3plog} pb_p3plog
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_p3plog.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_p3plog message.
         * @function verify
         * @memberof pb_p3plog
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_p3plog.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.def != null && message.hasOwnProperty("def")) {
                var error = $root.pb_p3pmbr.verify(message.def);
                if (error)
                    return "def." + error;
            }
            if (message.atk != null && message.hasOwnProperty("atk"))
                if (typeof message.atk !== "boolean")
                    return "atk: boolean expected";
            if (message.win != null && message.hasOwnProperty("win"))
                if (typeof message.win !== "boolean")
                    return "win: boolean expected";
            if (message.vid != null && message.hasOwnProperty("vid"))
                if (!$util.isInteger(message.vid))
                    return "vid: integer expected";
            if (message.time != null && message.hasOwnProperty("time"))
                if (!$util.isInteger(message.time))
                    return "time: integer expected";
            if (message.score != null && message.hasOwnProperty("score"))
                if (!$util.isInteger(message.score))
                    return "score: integer expected";
            return null;
        };
    
        /**
         * Creates a pb_p3plog message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_p3plog
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_p3plog} pb_p3plog
         */
        pb_p3plog.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_p3plog)
                return object;
            var message = new $root.pb_p3plog();
            if (object.def != null) {
                if (typeof object.def !== "object")
                    throw TypeError(".pb_p3plog.def: object expected");
                message.def = $root.pb_p3pmbr.fromObject(object.def);
            }
            if (object.atk != null)
                message.atk = Boolean(object.atk);
            if (object.win != null)
                message.win = Boolean(object.win);
            if (object.vid != null)
                message.vid = object.vid | 0;
            if (object.time != null)
                message.time = object.time | 0;
            if (object.score != null)
                message.score = object.score | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a pb_p3plog message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_p3plog
         * @static
         * @param {pb_p3plog} message pb_p3plog
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_p3plog.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.def = null;
                object.atk = false;
                object.win = false;
                object.vid = 0;
                object.time = 0;
                object.score = 0;
            }
            if (message.def != null && message.hasOwnProperty("def"))
                object.def = $root.pb_p3pmbr.toObject(message.def, options);
            if (message.atk != null && message.hasOwnProperty("atk"))
                object.atk = message.atk;
            if (message.win != null && message.hasOwnProperty("win"))
                object.win = message.win;
            if (message.vid != null && message.hasOwnProperty("vid"))
                object.vid = message.vid;
            if (message.time != null && message.hasOwnProperty("time"))
                object.time = message.time;
            if (message.score != null && message.hasOwnProperty("score"))
                object.score = message.score;
            return object;
        };
    
        /**
         * Converts this pb_p3plog to JSON.
         * @function toJSON
         * @memberof pb_p3plog
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_p3plog.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_p3plog
         * @function getTypeUrl
         * @memberof pb_p3plog
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_p3plog.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_p3plog";
        };
    
        return pb_p3plog;
    })();
    
    $root.pb_pmbr = (function() {
    
        /**
         * Properties of a pb_pmbr.
         * @exports Ipb_pmbr
         * @interface Ipb_pmbr
         * @property {string|null} [name] pb_pmbr name
         * @property {number|Long|null} [uid] pb_pmbr uid
         * @property {number|null} [lv] pb_pmbr lv
         * @property {number|null} [logo] pb_pmbr logo
         * @property {number|null} [score] pb_pmbr score
         * @property {number|Long|null} [power] pb_pmbr power
         * @property {number|null} [rank] pb_pmbr rank
         * @property {string|null} [gname] pb_pmbr gname
         * @property {number|null} [trank] pb_pmbr trank
         * @property {number|null} [tscore] pb_pmbr tscore
         * @property {Array.<Ipb_unit>|null} [camp] pb_pmbr camp
         * @property {number|null} [win] pb_pmbr win
         * @property {number|null} [fight] pb_pmbr fight
         * @property {number|null} [sid] pb_pmbr sid
         * @property {number|null} [border] pb_pmbr border
         * @property {number|null} [ptype] pb_pmbr ptype
         * @property {number|Long|null} [emblem] pb_pmbr emblem
         */
    
        /**
         * Constructs a new pb_pmbr.
         * @exports pb_pmbr
         * @classdesc Represents a pb_pmbr.
         * @implements Ipb_pmbr
         * @constructor
         * @param {Ipb_pmbr=} [properties] Properties to set
         */
        function pb_pmbr(properties) {
            this.camp = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_pmbr name.
         * @member {string} name
         * @memberof pb_pmbr
         * @instance
         */
        pb_pmbr.prototype.name = "";
    
        /**
         * pb_pmbr uid.
         * @member {number|Long} uid
         * @memberof pb_pmbr
         * @instance
         */
        pb_pmbr.prototype.uid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * pb_pmbr lv.
         * @member {number} lv
         * @memberof pb_pmbr
         * @instance
         */
        pb_pmbr.prototype.lv = 0;
    
        /**
         * pb_pmbr logo.
         * @member {number} logo
         * @memberof pb_pmbr
         * @instance
         */
        pb_pmbr.prototype.logo = 0;
    
        /**
         * pb_pmbr score.
         * @member {number} score
         * @memberof pb_pmbr
         * @instance
         */
        pb_pmbr.prototype.score = 0;
    
        /**
         * pb_pmbr power.
         * @member {number|Long} power
         * @memberof pb_pmbr
         * @instance
         */
        pb_pmbr.prototype.power = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * pb_pmbr rank.
         * @member {number} rank
         * @memberof pb_pmbr
         * @instance
         */
        pb_pmbr.prototype.rank = 0;
    
        /**
         * pb_pmbr gname.
         * @member {string} gname
         * @memberof pb_pmbr
         * @instance
         */
        pb_pmbr.prototype.gname = "";
    
        /**
         * pb_pmbr trank.
         * @member {number} trank
         * @memberof pb_pmbr
         * @instance
         */
        pb_pmbr.prototype.trank = 0;
    
        /**
         * pb_pmbr tscore.
         * @member {number} tscore
         * @memberof pb_pmbr
         * @instance
         */
        pb_pmbr.prototype.tscore = 0;
    
        /**
         * pb_pmbr camp.
         * @member {Array.<Ipb_unit>} camp
         * @memberof pb_pmbr
         * @instance
         */
        pb_pmbr.prototype.camp = $util.emptyArray;
    
        /**
         * pb_pmbr win.
         * @member {number} win
         * @memberof pb_pmbr
         * @instance
         */
        pb_pmbr.prototype.win = 0;
    
        /**
         * pb_pmbr fight.
         * @member {number} fight
         * @memberof pb_pmbr
         * @instance
         */
        pb_pmbr.prototype.fight = 0;
    
        /**
         * pb_pmbr sid.
         * @member {number} sid
         * @memberof pb_pmbr
         * @instance
         */
        pb_pmbr.prototype.sid = 0;
    
        /**
         * pb_pmbr border.
         * @member {number} border
         * @memberof pb_pmbr
         * @instance
         */
        pb_pmbr.prototype.border = 0;
    
        /**
         * pb_pmbr ptype.
         * @member {number} ptype
         * @memberof pb_pmbr
         * @instance
         */
        pb_pmbr.prototype.ptype = 0;
    
        /**
         * pb_pmbr emblem.
         * @member {number|Long} emblem
         * @memberof pb_pmbr
         * @instance
         */
        pb_pmbr.prototype.emblem = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * Creates a new pb_pmbr instance using the specified properties.
         * @function create
         * @memberof pb_pmbr
         * @static
         * @param {Ipb_pmbr=} [properties] Properties to set
         * @returns {pb_pmbr} pb_pmbr instance
         */
        pb_pmbr.create = function create(properties) {
            return new pb_pmbr(properties);
        };
    
        /**
         * Encodes the specified pb_pmbr message. Does not implicitly {@link pb_pmbr.verify|verify} messages.
         * @function encode
         * @memberof pb_pmbr
         * @static
         * @param {Ipb_pmbr} message pb_pmbr message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_pmbr.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
            if (message.uid != null && Object.hasOwnProperty.call(message, "uid"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.uid);
            if (message.lv != null && Object.hasOwnProperty.call(message, "lv"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.lv);
            if (message.logo != null && Object.hasOwnProperty.call(message, "logo"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.logo);
            if (message.score != null && Object.hasOwnProperty.call(message, "score"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.score);
            if (message.power != null && Object.hasOwnProperty.call(message, "power"))
                writer.uint32(/* id 6, wireType 0 =*/48).int64(message.power);
            if (message.rank != null && Object.hasOwnProperty.call(message, "rank"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.rank);
            if (message.gname != null && Object.hasOwnProperty.call(message, "gname"))
                writer.uint32(/* id 8, wireType 2 =*/66).string(message.gname);
            if (message.trank != null && Object.hasOwnProperty.call(message, "trank"))
                writer.uint32(/* id 9, wireType 0 =*/72).int32(message.trank);
            if (message.tscore != null && Object.hasOwnProperty.call(message, "tscore"))
                writer.uint32(/* id 10, wireType 0 =*/80).int32(message.tscore);
            if (message.camp != null && message.camp.length)
                for (var i = 0; i < message.camp.length; ++i)
                    $root.pb_unit.encode(message.camp[i], writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
            if (message.win != null && Object.hasOwnProperty.call(message, "win"))
                writer.uint32(/* id 12, wireType 0 =*/96).int32(message.win);
            if (message.fight != null && Object.hasOwnProperty.call(message, "fight"))
                writer.uint32(/* id 13, wireType 0 =*/104).int32(message.fight);
            if (message.sid != null && Object.hasOwnProperty.call(message, "sid"))
                writer.uint32(/* id 14, wireType 0 =*/112).int32(message.sid);
            if (message.border != null && Object.hasOwnProperty.call(message, "border"))
                writer.uint32(/* id 15, wireType 0 =*/120).int32(message.border);
            if (message.ptype != null && Object.hasOwnProperty.call(message, "ptype"))
                writer.uint32(/* id 16, wireType 0 =*/128).int32(message.ptype);
            if (message.emblem != null && Object.hasOwnProperty.call(message, "emblem"))
                writer.uint32(/* id 17, wireType 0 =*/136).int64(message.emblem);
            return writer;
        };
    
        /**
         * Encodes the specified pb_pmbr message, length delimited. Does not implicitly {@link pb_pmbr.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_pmbr
         * @static
         * @param {Ipb_pmbr} message pb_pmbr message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_pmbr.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_pmbr message from the specified reader or buffer.
         * @function decode
         * @memberof pb_pmbr
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_pmbr} pb_pmbr
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_pmbr.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_pmbr();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.name = reader.string();
                        break;
                    }
                case 2: {
                        message.uid = reader.int64();
                        break;
                    }
                case 3: {
                        message.lv = reader.int32();
                        break;
                    }
                case 4: {
                        message.logo = reader.int32();
                        break;
                    }
                case 5: {
                        message.score = reader.int32();
                        break;
                    }
                case 6: {
                        message.power = reader.int64();
                        break;
                    }
                case 7: {
                        message.rank = reader.int32();
                        break;
                    }
                case 8: {
                        message.gname = reader.string();
                        break;
                    }
                case 9: {
                        message.trank = reader.int32();
                        break;
                    }
                case 10: {
                        message.tscore = reader.int32();
                        break;
                    }
                case 11: {
                        if (!(message.camp && message.camp.length))
                            message.camp = [];
                        message.camp.push($root.pb_unit.decode(reader, reader.uint32()));
                        break;
                    }
                case 12: {
                        message.win = reader.int32();
                        break;
                    }
                case 13: {
                        message.fight = reader.int32();
                        break;
                    }
                case 14: {
                        message.sid = reader.int32();
                        break;
                    }
                case 15: {
                        message.border = reader.int32();
                        break;
                    }
                case 16: {
                        message.ptype = reader.int32();
                        break;
                    }
                case 17: {
                        message.emblem = reader.int64();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a pb_pmbr message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_pmbr
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_pmbr} pb_pmbr
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_pmbr.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_pmbr message.
         * @function verify
         * @memberof pb_pmbr
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_pmbr.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (!$util.isInteger(message.uid) && !(message.uid && $util.isInteger(message.uid.low) && $util.isInteger(message.uid.high)))
                    return "uid: integer|Long expected";
            if (message.lv != null && message.hasOwnProperty("lv"))
                if (!$util.isInteger(message.lv))
                    return "lv: integer expected";
            if (message.logo != null && message.hasOwnProperty("logo"))
                if (!$util.isInteger(message.logo))
                    return "logo: integer expected";
            if (message.score != null && message.hasOwnProperty("score"))
                if (!$util.isInteger(message.score))
                    return "score: integer expected";
            if (message.power != null && message.hasOwnProperty("power"))
                if (!$util.isInteger(message.power) && !(message.power && $util.isInteger(message.power.low) && $util.isInteger(message.power.high)))
                    return "power: integer|Long expected";
            if (message.rank != null && message.hasOwnProperty("rank"))
                if (!$util.isInteger(message.rank))
                    return "rank: integer expected";
            if (message.gname != null && message.hasOwnProperty("gname"))
                if (!$util.isString(message.gname))
                    return "gname: string expected";
            if (message.trank != null && message.hasOwnProperty("trank"))
                if (!$util.isInteger(message.trank))
                    return "trank: integer expected";
            if (message.tscore != null && message.hasOwnProperty("tscore"))
                if (!$util.isInteger(message.tscore))
                    return "tscore: integer expected";
            if (message.camp != null && message.hasOwnProperty("camp")) {
                if (!Array.isArray(message.camp))
                    return "camp: array expected";
                for (var i = 0; i < message.camp.length; ++i) {
                    var error = $root.pb_unit.verify(message.camp[i]);
                    if (error)
                        return "camp." + error;
                }
            }
            if (message.win != null && message.hasOwnProperty("win"))
                if (!$util.isInteger(message.win))
                    return "win: integer expected";
            if (message.fight != null && message.hasOwnProperty("fight"))
                if (!$util.isInteger(message.fight))
                    return "fight: integer expected";
            if (message.sid != null && message.hasOwnProperty("sid"))
                if (!$util.isInteger(message.sid))
                    return "sid: integer expected";
            if (message.border != null && message.hasOwnProperty("border"))
                if (!$util.isInteger(message.border))
                    return "border: integer expected";
            if (message.ptype != null && message.hasOwnProperty("ptype"))
                if (!$util.isInteger(message.ptype))
                    return "ptype: integer expected";
            if (message.emblem != null && message.hasOwnProperty("emblem"))
                if (!$util.isInteger(message.emblem) && !(message.emblem && $util.isInteger(message.emblem.low) && $util.isInteger(message.emblem.high)))
                    return "emblem: integer|Long expected";
            return null;
        };
    
        /**
         * Creates a pb_pmbr message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_pmbr
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_pmbr} pb_pmbr
         */
        pb_pmbr.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_pmbr)
                return object;
            var message = new $root.pb_pmbr();
            if (object.name != null)
                message.name = String(object.name);
            if (object.uid != null)
                if ($util.Long)
                    (message.uid = $util.Long.fromValue(object.uid)).unsigned = false;
                else if (typeof object.uid === "string")
                    message.uid = parseInt(object.uid, 10);
                else if (typeof object.uid === "number")
                    message.uid = object.uid;
                else if (typeof object.uid === "object")
                    message.uid = new $util.LongBits(object.uid.low >>> 0, object.uid.high >>> 0).toNumber();
            if (object.lv != null)
                message.lv = object.lv | 0;
            if (object.logo != null)
                message.logo = object.logo | 0;
            if (object.score != null)
                message.score = object.score | 0;
            if (object.power != null)
                if ($util.Long)
                    (message.power = $util.Long.fromValue(object.power)).unsigned = false;
                else if (typeof object.power === "string")
                    message.power = parseInt(object.power, 10);
                else if (typeof object.power === "number")
                    message.power = object.power;
                else if (typeof object.power === "object")
                    message.power = new $util.LongBits(object.power.low >>> 0, object.power.high >>> 0).toNumber();
            if (object.rank != null)
                message.rank = object.rank | 0;
            if (object.gname != null)
                message.gname = String(object.gname);
            if (object.trank != null)
                message.trank = object.trank | 0;
            if (object.tscore != null)
                message.tscore = object.tscore | 0;
            if (object.camp) {
                if (!Array.isArray(object.camp))
                    throw TypeError(".pb_pmbr.camp: array expected");
                message.camp = [];
                for (var i = 0; i < object.camp.length; ++i) {
                    if (typeof object.camp[i] !== "object")
                        throw TypeError(".pb_pmbr.camp: object expected");
                    message.camp[i] = $root.pb_unit.fromObject(object.camp[i]);
                }
            }
            if (object.win != null)
                message.win = object.win | 0;
            if (object.fight != null)
                message.fight = object.fight | 0;
            if (object.sid != null)
                message.sid = object.sid | 0;
            if (object.border != null)
                message.border = object.border | 0;
            if (object.ptype != null)
                message.ptype = object.ptype | 0;
            if (object.emblem != null)
                if ($util.Long)
                    (message.emblem = $util.Long.fromValue(object.emblem)).unsigned = false;
                else if (typeof object.emblem === "string")
                    message.emblem = parseInt(object.emblem, 10);
                else if (typeof object.emblem === "number")
                    message.emblem = object.emblem;
                else if (typeof object.emblem === "object")
                    message.emblem = new $util.LongBits(object.emblem.low >>> 0, object.emblem.high >>> 0).toNumber();
            return message;
        };
    
        /**
         * Creates a plain object from a pb_pmbr message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_pmbr
         * @static
         * @param {pb_pmbr} message pb_pmbr
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_pmbr.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.camp = [];
            if (options.defaults) {
                object.name = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.uid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.uid = options.longs === String ? "0" : 0;
                object.lv = 0;
                object.logo = 0;
                object.score = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.power = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.power = options.longs === String ? "0" : 0;
                object.rank = 0;
                object.gname = "";
                object.trank = 0;
                object.tscore = 0;
                object.win = 0;
                object.fight = 0;
                object.sid = 0;
                object.border = 0;
                object.ptype = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.emblem = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.emblem = options.longs === String ? "0" : 0;
            }
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (typeof message.uid === "number")
                    object.uid = options.longs === String ? String(message.uid) : message.uid;
                else
                    object.uid = options.longs === String ? $util.Long.prototype.toString.call(message.uid) : options.longs === Number ? new $util.LongBits(message.uid.low >>> 0, message.uid.high >>> 0).toNumber() : message.uid;
            if (message.lv != null && message.hasOwnProperty("lv"))
                object.lv = message.lv;
            if (message.logo != null && message.hasOwnProperty("logo"))
                object.logo = message.logo;
            if (message.score != null && message.hasOwnProperty("score"))
                object.score = message.score;
            if (message.power != null && message.hasOwnProperty("power"))
                if (typeof message.power === "number")
                    object.power = options.longs === String ? String(message.power) : message.power;
                else
                    object.power = options.longs === String ? $util.Long.prototype.toString.call(message.power) : options.longs === Number ? new $util.LongBits(message.power.low >>> 0, message.power.high >>> 0).toNumber() : message.power;
            if (message.rank != null && message.hasOwnProperty("rank"))
                object.rank = message.rank;
            if (message.gname != null && message.hasOwnProperty("gname"))
                object.gname = message.gname;
            if (message.trank != null && message.hasOwnProperty("trank"))
                object.trank = message.trank;
            if (message.tscore != null && message.hasOwnProperty("tscore"))
                object.tscore = message.tscore;
            if (message.camp && message.camp.length) {
                object.camp = [];
                for (var j = 0; j < message.camp.length; ++j)
                    object.camp[j] = $root.pb_unit.toObject(message.camp[j], options);
            }
            if (message.win != null && message.hasOwnProperty("win"))
                object.win = message.win;
            if (message.fight != null && message.hasOwnProperty("fight"))
                object.fight = message.fight;
            if (message.sid != null && message.hasOwnProperty("sid"))
                object.sid = message.sid;
            if (message.border != null && message.hasOwnProperty("border"))
                object.border = message.border;
            if (message.ptype != null && message.hasOwnProperty("ptype"))
                object.ptype = message.ptype;
            if (message.emblem != null && message.hasOwnProperty("emblem"))
                if (typeof message.emblem === "number")
                    object.emblem = options.longs === String ? String(message.emblem) : message.emblem;
                else
                    object.emblem = options.longs === String ? $util.Long.prototype.toString.call(message.emblem) : options.longs === Number ? new $util.LongBits(message.emblem.low >>> 0, message.emblem.high >>> 0).toNumber() : message.emblem;
            return object;
        };
    
        /**
         * Converts this pb_pmbr to JSON.
         * @function toJSON
         * @memberof pb_pmbr
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_pmbr.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_pmbr
         * @function getTypeUrl
         * @memberof pb_pmbr
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_pmbr.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_pmbr";
        };
    
        return pb_pmbr;
    })();
    
    $root.pb_p3pmbr = (function() {
    
        /**
         * Properties of a pb_p3pmbr.
         * @exports Ipb_p3pmbr
         * @interface Ipb_p3pmbr
         * @property {string|null} [name] pb_p3pmbr name
         * @property {number|Long|null} [uid] pb_p3pmbr uid
         * @property {number|null} [lv] pb_p3pmbr lv
         * @property {number|null} [logo] pb_p3pmbr logo
         * @property {number|null} [lbox] pb_p3pmbr lbox
         * @property {number|Long|null} [power] pb_p3pmbr power
         * @property {number|null} [rank] pb_p3pmbr rank
         * @property {number|null} [score] pb_p3pmbr score
         * @property {Array.<Ipb_unit>|null} [camp] pb_p3pmbr camp
         * @property {number|Long|null} [emblem] pb_p3pmbr emblem
         */
    
        /**
         * Constructs a new pb_p3pmbr.
         * @exports pb_p3pmbr
         * @classdesc Represents a pb_p3pmbr.
         * @implements Ipb_p3pmbr
         * @constructor
         * @param {Ipb_p3pmbr=} [properties] Properties to set
         */
        function pb_p3pmbr(properties) {
            this.camp = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_p3pmbr name.
         * @member {string} name
         * @memberof pb_p3pmbr
         * @instance
         */
        pb_p3pmbr.prototype.name = "";
    
        /**
         * pb_p3pmbr uid.
         * @member {number|Long} uid
         * @memberof pb_p3pmbr
         * @instance
         */
        pb_p3pmbr.prototype.uid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * pb_p3pmbr lv.
         * @member {number} lv
         * @memberof pb_p3pmbr
         * @instance
         */
        pb_p3pmbr.prototype.lv = 0;
    
        /**
         * pb_p3pmbr logo.
         * @member {number} logo
         * @memberof pb_p3pmbr
         * @instance
         */
        pb_p3pmbr.prototype.logo = 0;
    
        /**
         * pb_p3pmbr lbox.
         * @member {number} lbox
         * @memberof pb_p3pmbr
         * @instance
         */
        pb_p3pmbr.prototype.lbox = 0;
    
        /**
         * pb_p3pmbr power.
         * @member {number|Long} power
         * @memberof pb_p3pmbr
         * @instance
         */
        pb_p3pmbr.prototype.power = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * pb_p3pmbr rank.
         * @member {number} rank
         * @memberof pb_p3pmbr
         * @instance
         */
        pb_p3pmbr.prototype.rank = 0;
    
        /**
         * pb_p3pmbr score.
         * @member {number} score
         * @memberof pb_p3pmbr
         * @instance
         */
        pb_p3pmbr.prototype.score = 0;
    
        /**
         * pb_p3pmbr camp.
         * @member {Array.<Ipb_unit>} camp
         * @memberof pb_p3pmbr
         * @instance
         */
        pb_p3pmbr.prototype.camp = $util.emptyArray;
    
        /**
         * pb_p3pmbr emblem.
         * @member {number|Long} emblem
         * @memberof pb_p3pmbr
         * @instance
         */
        pb_p3pmbr.prototype.emblem = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * Creates a new pb_p3pmbr instance using the specified properties.
         * @function create
         * @memberof pb_p3pmbr
         * @static
         * @param {Ipb_p3pmbr=} [properties] Properties to set
         * @returns {pb_p3pmbr} pb_p3pmbr instance
         */
        pb_p3pmbr.create = function create(properties) {
            return new pb_p3pmbr(properties);
        };
    
        /**
         * Encodes the specified pb_p3pmbr message. Does not implicitly {@link pb_p3pmbr.verify|verify} messages.
         * @function encode
         * @memberof pb_p3pmbr
         * @static
         * @param {Ipb_p3pmbr} message pb_p3pmbr message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_p3pmbr.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
            if (message.uid != null && Object.hasOwnProperty.call(message, "uid"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.uid);
            if (message.lv != null && Object.hasOwnProperty.call(message, "lv"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.lv);
            if (message.logo != null && Object.hasOwnProperty.call(message, "logo"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.logo);
            if (message.lbox != null && Object.hasOwnProperty.call(message, "lbox"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.lbox);
            if (message.power != null && Object.hasOwnProperty.call(message, "power"))
                writer.uint32(/* id 6, wireType 0 =*/48).int64(message.power);
            if (message.rank != null && Object.hasOwnProperty.call(message, "rank"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.rank);
            if (message.score != null && Object.hasOwnProperty.call(message, "score"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.score);
            if (message.camp != null && message.camp.length)
                for (var i = 0; i < message.camp.length; ++i)
                    $root.pb_unit.encode(message.camp[i], writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
            if (message.emblem != null && Object.hasOwnProperty.call(message, "emblem"))
                writer.uint32(/* id 10, wireType 0 =*/80).int64(message.emblem);
            return writer;
        };
    
        /**
         * Encodes the specified pb_p3pmbr message, length delimited. Does not implicitly {@link pb_p3pmbr.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_p3pmbr
         * @static
         * @param {Ipb_p3pmbr} message pb_p3pmbr message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_p3pmbr.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_p3pmbr message from the specified reader or buffer.
         * @function decode
         * @memberof pb_p3pmbr
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_p3pmbr} pb_p3pmbr
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_p3pmbr.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_p3pmbr();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.name = reader.string();
                        break;
                    }
                case 2: {
                        message.uid = reader.int64();
                        break;
                    }
                case 3: {
                        message.lv = reader.int32();
                        break;
                    }
                case 4: {
                        message.logo = reader.int32();
                        break;
                    }
                case 5: {
                        message.lbox = reader.int32();
                        break;
                    }
                case 6: {
                        message.power = reader.int64();
                        break;
                    }
                case 7: {
                        message.rank = reader.int32();
                        break;
                    }
                case 8: {
                        message.score = reader.int32();
                        break;
                    }
                case 9: {
                        if (!(message.camp && message.camp.length))
                            message.camp = [];
                        message.camp.push($root.pb_unit.decode(reader, reader.uint32()));
                        break;
                    }
                case 10: {
                        message.emblem = reader.int64();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a pb_p3pmbr message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_p3pmbr
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_p3pmbr} pb_p3pmbr
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_p3pmbr.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_p3pmbr message.
         * @function verify
         * @memberof pb_p3pmbr
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_p3pmbr.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (!$util.isInteger(message.uid) && !(message.uid && $util.isInteger(message.uid.low) && $util.isInteger(message.uid.high)))
                    return "uid: integer|Long expected";
            if (message.lv != null && message.hasOwnProperty("lv"))
                if (!$util.isInteger(message.lv))
                    return "lv: integer expected";
            if (message.logo != null && message.hasOwnProperty("logo"))
                if (!$util.isInteger(message.logo))
                    return "logo: integer expected";
            if (message.lbox != null && message.hasOwnProperty("lbox"))
                if (!$util.isInteger(message.lbox))
                    return "lbox: integer expected";
            if (message.power != null && message.hasOwnProperty("power"))
                if (!$util.isInteger(message.power) && !(message.power && $util.isInteger(message.power.low) && $util.isInteger(message.power.high)))
                    return "power: integer|Long expected";
            if (message.rank != null && message.hasOwnProperty("rank"))
                if (!$util.isInteger(message.rank))
                    return "rank: integer expected";
            if (message.score != null && message.hasOwnProperty("score"))
                if (!$util.isInteger(message.score))
                    return "score: integer expected";
            if (message.camp != null && message.hasOwnProperty("camp")) {
                if (!Array.isArray(message.camp))
                    return "camp: array expected";
                for (var i = 0; i < message.camp.length; ++i) {
                    var error = $root.pb_unit.verify(message.camp[i]);
                    if (error)
                        return "camp." + error;
                }
            }
            if (message.emblem != null && message.hasOwnProperty("emblem"))
                if (!$util.isInteger(message.emblem) && !(message.emblem && $util.isInteger(message.emblem.low) && $util.isInteger(message.emblem.high)))
                    return "emblem: integer|Long expected";
            return null;
        };
    
        /**
         * Creates a pb_p3pmbr message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_p3pmbr
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_p3pmbr} pb_p3pmbr
         */
        pb_p3pmbr.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_p3pmbr)
                return object;
            var message = new $root.pb_p3pmbr();
            if (object.name != null)
                message.name = String(object.name);
            if (object.uid != null)
                if ($util.Long)
                    (message.uid = $util.Long.fromValue(object.uid)).unsigned = false;
                else if (typeof object.uid === "string")
                    message.uid = parseInt(object.uid, 10);
                else if (typeof object.uid === "number")
                    message.uid = object.uid;
                else if (typeof object.uid === "object")
                    message.uid = new $util.LongBits(object.uid.low >>> 0, object.uid.high >>> 0).toNumber();
            if (object.lv != null)
                message.lv = object.lv | 0;
            if (object.logo != null)
                message.logo = object.logo | 0;
            if (object.lbox != null)
                message.lbox = object.lbox | 0;
            if (object.power != null)
                if ($util.Long)
                    (message.power = $util.Long.fromValue(object.power)).unsigned = false;
                else if (typeof object.power === "string")
                    message.power = parseInt(object.power, 10);
                else if (typeof object.power === "number")
                    message.power = object.power;
                else if (typeof object.power === "object")
                    message.power = new $util.LongBits(object.power.low >>> 0, object.power.high >>> 0).toNumber();
            if (object.rank != null)
                message.rank = object.rank | 0;
            if (object.score != null)
                message.score = object.score | 0;
            if (object.camp) {
                if (!Array.isArray(object.camp))
                    throw TypeError(".pb_p3pmbr.camp: array expected");
                message.camp = [];
                for (var i = 0; i < object.camp.length; ++i) {
                    if (typeof object.camp[i] !== "object")
                        throw TypeError(".pb_p3pmbr.camp: object expected");
                    message.camp[i] = $root.pb_unit.fromObject(object.camp[i]);
                }
            }
            if (object.emblem != null)
                if ($util.Long)
                    (message.emblem = $util.Long.fromValue(object.emblem)).unsigned = false;
                else if (typeof object.emblem === "string")
                    message.emblem = parseInt(object.emblem, 10);
                else if (typeof object.emblem === "number")
                    message.emblem = object.emblem;
                else if (typeof object.emblem === "object")
                    message.emblem = new $util.LongBits(object.emblem.low >>> 0, object.emblem.high >>> 0).toNumber();
            return message;
        };
    
        /**
         * Creates a plain object from a pb_p3pmbr message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_p3pmbr
         * @static
         * @param {pb_p3pmbr} message pb_p3pmbr
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_p3pmbr.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.camp = [];
            if (options.defaults) {
                object.name = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.uid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.uid = options.longs === String ? "0" : 0;
                object.lv = 0;
                object.logo = 0;
                object.lbox = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.power = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.power = options.longs === String ? "0" : 0;
                object.rank = 0;
                object.score = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.emblem = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.emblem = options.longs === String ? "0" : 0;
            }
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (typeof message.uid === "number")
                    object.uid = options.longs === String ? String(message.uid) : message.uid;
                else
                    object.uid = options.longs === String ? $util.Long.prototype.toString.call(message.uid) : options.longs === Number ? new $util.LongBits(message.uid.low >>> 0, message.uid.high >>> 0).toNumber() : message.uid;
            if (message.lv != null && message.hasOwnProperty("lv"))
                object.lv = message.lv;
            if (message.logo != null && message.hasOwnProperty("logo"))
                object.logo = message.logo;
            if (message.lbox != null && message.hasOwnProperty("lbox"))
                object.lbox = message.lbox;
            if (message.power != null && message.hasOwnProperty("power"))
                if (typeof message.power === "number")
                    object.power = options.longs === String ? String(message.power) : message.power;
                else
                    object.power = options.longs === String ? $util.Long.prototype.toString.call(message.power) : options.longs === Number ? new $util.LongBits(message.power.low >>> 0, message.power.high >>> 0).toNumber() : message.power;
            if (message.rank != null && message.hasOwnProperty("rank"))
                object.rank = message.rank;
            if (message.score != null && message.hasOwnProperty("score"))
                object.score = message.score;
            if (message.camp && message.camp.length) {
                object.camp = [];
                for (var j = 0; j < message.camp.length; ++j)
                    object.camp[j] = $root.pb_unit.toObject(message.camp[j], options);
            }
            if (message.emblem != null && message.hasOwnProperty("emblem"))
                if (typeof message.emblem === "number")
                    object.emblem = options.longs === String ? String(message.emblem) : message.emblem;
                else
                    object.emblem = options.longs === String ? $util.Long.prototype.toString.call(message.emblem) : options.longs === Number ? new $util.LongBits(message.emblem.low >>> 0, message.emblem.high >>> 0).toNumber() : message.emblem;
            return object;
        };
    
        /**
         * Converts this pb_p3pmbr to JSON.
         * @function toJSON
         * @memberof pb_p3pmbr
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_p3pmbr.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_p3pmbr
         * @function getTypeUrl
         * @memberof pb_p3pmbr
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_p3pmbr.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_p3pmbr";
        };
    
        return pb_p3pmbr;
    })();
    
    $root.pb_smbr = (function() {
    
        /**
         * Properties of a pb_smbr.
         * @exports Ipb_smbr
         * @interface Ipb_smbr
         * @property {string|null} [name] pb_smbr name
         * @property {number|Long|null} [uid] pb_smbr uid
         * @property {number|null} [lv] pb_smbr lv
         * @property {number|null} [logo] pb_smbr logo
         * @property {number|null} [lbox] pb_smbr lbox
         * @property {number|null} [score] pb_smbr score
         * @property {number|null} [like] pb_smbr like
         * @property {string|null} [cluster] pb_smbr cluster
         * @property {string|null} [udk] pb_smbr udk
         * @property {string|null} [gname] pb_smbr gname
         * @property {Array.<Ipb_unit>|null} [camp] pb_smbr camp
         * @property {Array.<number>|null} [skls] pb_smbr skls
         * @property {number|Long|null} [power] pb_smbr power
         * @property {Array.<number>|null} [hide] pb_smbr hide
         * @property {number|Long|null} [emblem] pb_smbr emblem
         */
    
        /**
         * Constructs a new pb_smbr.
         * @exports pb_smbr
         * @classdesc Represents a pb_smbr.
         * @implements Ipb_smbr
         * @constructor
         * @param {Ipb_smbr=} [properties] Properties to set
         */
        function pb_smbr(properties) {
            this.camp = [];
            this.skls = [];
            this.hide = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_smbr name.
         * @member {string} name
         * @memberof pb_smbr
         * @instance
         */
        pb_smbr.prototype.name = "";
    
        /**
         * pb_smbr uid.
         * @member {number|Long} uid
         * @memberof pb_smbr
         * @instance
         */
        pb_smbr.prototype.uid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * pb_smbr lv.
         * @member {number} lv
         * @memberof pb_smbr
         * @instance
         */
        pb_smbr.prototype.lv = 0;
    
        /**
         * pb_smbr logo.
         * @member {number} logo
         * @memberof pb_smbr
         * @instance
         */
        pb_smbr.prototype.logo = 0;
    
        /**
         * pb_smbr lbox.
         * @member {number} lbox
         * @memberof pb_smbr
         * @instance
         */
        pb_smbr.prototype.lbox = 0;
    
        /**
         * pb_smbr score.
         * @member {number} score
         * @memberof pb_smbr
         * @instance
         */
        pb_smbr.prototype.score = 0;
    
        /**
         * pb_smbr like.
         * @member {number} like
         * @memberof pb_smbr
         * @instance
         */
        pb_smbr.prototype.like = 0;
    
        /**
         * pb_smbr cluster.
         * @member {string} cluster
         * @memberof pb_smbr
         * @instance
         */
        pb_smbr.prototype.cluster = "";
    
        /**
         * pb_smbr udk.
         * @member {string} udk
         * @memberof pb_smbr
         * @instance
         */
        pb_smbr.prototype.udk = "";
    
        /**
         * pb_smbr gname.
         * @member {string} gname
         * @memberof pb_smbr
         * @instance
         */
        pb_smbr.prototype.gname = "";
    
        /**
         * pb_smbr camp.
         * @member {Array.<Ipb_unit>} camp
         * @memberof pb_smbr
         * @instance
         */
        pb_smbr.prototype.camp = $util.emptyArray;
    
        /**
         * pb_smbr skls.
         * @member {Array.<number>} skls
         * @memberof pb_smbr
         * @instance
         */
        pb_smbr.prototype.skls = $util.emptyArray;
    
        /**
         * pb_smbr power.
         * @member {number|Long} power
         * @memberof pb_smbr
         * @instance
         */
        pb_smbr.prototype.power = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * pb_smbr hide.
         * @member {Array.<number>} hide
         * @memberof pb_smbr
         * @instance
         */
        pb_smbr.prototype.hide = $util.emptyArray;
    
        /**
         * pb_smbr emblem.
         * @member {number|Long} emblem
         * @memberof pb_smbr
         * @instance
         */
        pb_smbr.prototype.emblem = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * Creates a new pb_smbr instance using the specified properties.
         * @function create
         * @memberof pb_smbr
         * @static
         * @param {Ipb_smbr=} [properties] Properties to set
         * @returns {pb_smbr} pb_smbr instance
         */
        pb_smbr.create = function create(properties) {
            return new pb_smbr(properties);
        };
    
        /**
         * Encodes the specified pb_smbr message. Does not implicitly {@link pb_smbr.verify|verify} messages.
         * @function encode
         * @memberof pb_smbr
         * @static
         * @param {Ipb_smbr} message pb_smbr message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_smbr.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
            if (message.uid != null && Object.hasOwnProperty.call(message, "uid"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.uid);
            if (message.lv != null && Object.hasOwnProperty.call(message, "lv"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.lv);
            if (message.logo != null && Object.hasOwnProperty.call(message, "logo"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.logo);
            if (message.lbox != null && Object.hasOwnProperty.call(message, "lbox"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.lbox);
            if (message.score != null && Object.hasOwnProperty.call(message, "score"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.score);
            if (message.like != null && Object.hasOwnProperty.call(message, "like"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.like);
            if (message.cluster != null && Object.hasOwnProperty.call(message, "cluster"))
                writer.uint32(/* id 8, wireType 2 =*/66).string(message.cluster);
            if (message.udk != null && Object.hasOwnProperty.call(message, "udk"))
                writer.uint32(/* id 9, wireType 2 =*/74).string(message.udk);
            if (message.gname != null && Object.hasOwnProperty.call(message, "gname"))
                writer.uint32(/* id 10, wireType 2 =*/82).string(message.gname);
            if (message.camp != null && message.camp.length)
                for (var i = 0; i < message.camp.length; ++i)
                    $root.pb_unit.encode(message.camp[i], writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
            if (message.skls != null && message.skls.length)
                for (var i = 0; i < message.skls.length; ++i)
                    writer.uint32(/* id 12, wireType 0 =*/96).int32(message.skls[i]);
            if (message.power != null && Object.hasOwnProperty.call(message, "power"))
                writer.uint32(/* id 13, wireType 0 =*/104).sint64(message.power);
            if (message.hide != null && message.hide.length)
                for (var i = 0; i < message.hide.length; ++i)
                    writer.uint32(/* id 14, wireType 0 =*/112).sint32(message.hide[i]);
            if (message.emblem != null && Object.hasOwnProperty.call(message, "emblem"))
                writer.uint32(/* id 15, wireType 0 =*/120).int64(message.emblem);
            return writer;
        };
    
        /**
         * Encodes the specified pb_smbr message, length delimited. Does not implicitly {@link pb_smbr.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_smbr
         * @static
         * @param {Ipb_smbr} message pb_smbr message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_smbr.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_smbr message from the specified reader or buffer.
         * @function decode
         * @memberof pb_smbr
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_smbr} pb_smbr
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_smbr.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_smbr();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.name = reader.string();
                        break;
                    }
                case 2: {
                        message.uid = reader.int64();
                        break;
                    }
                case 3: {
                        message.lv = reader.int32();
                        break;
                    }
                case 4: {
                        message.logo = reader.int32();
                        break;
                    }
                case 5: {
                        message.lbox = reader.int32();
                        break;
                    }
                case 6: {
                        message.score = reader.int32();
                        break;
                    }
                case 7: {
                        message.like = reader.int32();
                        break;
                    }
                case 8: {
                        message.cluster = reader.string();
                        break;
                    }
                case 9: {
                        message.udk = reader.string();
                        break;
                    }
                case 10: {
                        message.gname = reader.string();
                        break;
                    }
                case 11: {
                        if (!(message.camp && message.camp.length))
                            message.camp = [];
                        message.camp.push($root.pb_unit.decode(reader, reader.uint32()));
                        break;
                    }
                case 12: {
                        if (!(message.skls && message.skls.length))
                            message.skls = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.skls.push(reader.int32());
                        } else
                            message.skls.push(reader.int32());
                        break;
                    }
                case 13: {
                        message.power = reader.sint64();
                        break;
                    }
                case 14: {
                        if (!(message.hide && message.hide.length))
                            message.hide = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.hide.push(reader.sint32());
                        } else
                            message.hide.push(reader.sint32());
                        break;
                    }
                case 15: {
                        message.emblem = reader.int64();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a pb_smbr message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_smbr
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_smbr} pb_smbr
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_smbr.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_smbr message.
         * @function verify
         * @memberof pb_smbr
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_smbr.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (!$util.isInteger(message.uid) && !(message.uid && $util.isInteger(message.uid.low) && $util.isInteger(message.uid.high)))
                    return "uid: integer|Long expected";
            if (message.lv != null && message.hasOwnProperty("lv"))
                if (!$util.isInteger(message.lv))
                    return "lv: integer expected";
            if (message.logo != null && message.hasOwnProperty("logo"))
                if (!$util.isInteger(message.logo))
                    return "logo: integer expected";
            if (message.lbox != null && message.hasOwnProperty("lbox"))
                if (!$util.isInteger(message.lbox))
                    return "lbox: integer expected";
            if (message.score != null && message.hasOwnProperty("score"))
                if (!$util.isInteger(message.score))
                    return "score: integer expected";
            if (message.like != null && message.hasOwnProperty("like"))
                if (!$util.isInteger(message.like))
                    return "like: integer expected";
            if (message.cluster != null && message.hasOwnProperty("cluster"))
                if (!$util.isString(message.cluster))
                    return "cluster: string expected";
            if (message.udk != null && message.hasOwnProperty("udk"))
                if (!$util.isString(message.udk))
                    return "udk: string expected";
            if (message.gname != null && message.hasOwnProperty("gname"))
                if (!$util.isString(message.gname))
                    return "gname: string expected";
            if (message.camp != null && message.hasOwnProperty("camp")) {
                if (!Array.isArray(message.camp))
                    return "camp: array expected";
                for (var i = 0; i < message.camp.length; ++i) {
                    var error = $root.pb_unit.verify(message.camp[i]);
                    if (error)
                        return "camp." + error;
                }
            }
            if (message.skls != null && message.hasOwnProperty("skls")) {
                if (!Array.isArray(message.skls))
                    return "skls: array expected";
                for (var i = 0; i < message.skls.length; ++i)
                    if (!$util.isInteger(message.skls[i]))
                        return "skls: integer[] expected";
            }
            if (message.power != null && message.hasOwnProperty("power"))
                if (!$util.isInteger(message.power) && !(message.power && $util.isInteger(message.power.low) && $util.isInteger(message.power.high)))
                    return "power: integer|Long expected";
            if (message.hide != null && message.hasOwnProperty("hide")) {
                if (!Array.isArray(message.hide))
                    return "hide: array expected";
                for (var i = 0; i < message.hide.length; ++i)
                    if (!$util.isInteger(message.hide[i]))
                        return "hide: integer[] expected";
            }
            if (message.emblem != null && message.hasOwnProperty("emblem"))
                if (!$util.isInteger(message.emblem) && !(message.emblem && $util.isInteger(message.emblem.low) && $util.isInteger(message.emblem.high)))
                    return "emblem: integer|Long expected";
            return null;
        };
    
        /**
         * Creates a pb_smbr message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_smbr
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_smbr} pb_smbr
         */
        pb_smbr.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_smbr)
                return object;
            var message = new $root.pb_smbr();
            if (object.name != null)
                message.name = String(object.name);
            if (object.uid != null)
                if ($util.Long)
                    (message.uid = $util.Long.fromValue(object.uid)).unsigned = false;
                else if (typeof object.uid === "string")
                    message.uid = parseInt(object.uid, 10);
                else if (typeof object.uid === "number")
                    message.uid = object.uid;
                else if (typeof object.uid === "object")
                    message.uid = new $util.LongBits(object.uid.low >>> 0, object.uid.high >>> 0).toNumber();
            if (object.lv != null)
                message.lv = object.lv | 0;
            if (object.logo != null)
                message.logo = object.logo | 0;
            if (object.lbox != null)
                message.lbox = object.lbox | 0;
            if (object.score != null)
                message.score = object.score | 0;
            if (object.like != null)
                message.like = object.like | 0;
            if (object.cluster != null)
                message.cluster = String(object.cluster);
            if (object.udk != null)
                message.udk = String(object.udk);
            if (object.gname != null)
                message.gname = String(object.gname);
            if (object.camp) {
                if (!Array.isArray(object.camp))
                    throw TypeError(".pb_smbr.camp: array expected");
                message.camp = [];
                for (var i = 0; i < object.camp.length; ++i) {
                    if (typeof object.camp[i] !== "object")
                        throw TypeError(".pb_smbr.camp: object expected");
                    message.camp[i] = $root.pb_unit.fromObject(object.camp[i]);
                }
            }
            if (object.skls) {
                if (!Array.isArray(object.skls))
                    throw TypeError(".pb_smbr.skls: array expected");
                message.skls = [];
                for (var i = 0; i < object.skls.length; ++i)
                    message.skls[i] = object.skls[i] | 0;
            }
            if (object.power != null)
                if ($util.Long)
                    (message.power = $util.Long.fromValue(object.power)).unsigned = false;
                else if (typeof object.power === "string")
                    message.power = parseInt(object.power, 10);
                else if (typeof object.power === "number")
                    message.power = object.power;
                else if (typeof object.power === "object")
                    message.power = new $util.LongBits(object.power.low >>> 0, object.power.high >>> 0).toNumber();
            if (object.hide) {
                if (!Array.isArray(object.hide))
                    throw TypeError(".pb_smbr.hide: array expected");
                message.hide = [];
                for (var i = 0; i < object.hide.length; ++i)
                    message.hide[i] = object.hide[i] | 0;
            }
            if (object.emblem != null)
                if ($util.Long)
                    (message.emblem = $util.Long.fromValue(object.emblem)).unsigned = false;
                else if (typeof object.emblem === "string")
                    message.emblem = parseInt(object.emblem, 10);
                else if (typeof object.emblem === "number")
                    message.emblem = object.emblem;
                else if (typeof object.emblem === "object")
                    message.emblem = new $util.LongBits(object.emblem.low >>> 0, object.emblem.high >>> 0).toNumber();
            return message;
        };
    
        /**
         * Creates a plain object from a pb_smbr message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_smbr
         * @static
         * @param {pb_smbr} message pb_smbr
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_smbr.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.camp = [];
                object.skls = [];
                object.hide = [];
            }
            if (options.defaults) {
                object.name = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.uid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.uid = options.longs === String ? "0" : 0;
                object.lv = 0;
                object.logo = 0;
                object.lbox = 0;
                object.score = 0;
                object.like = 0;
                object.cluster = "";
                object.udk = "";
                object.gname = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.power = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.power = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.emblem = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.emblem = options.longs === String ? "0" : 0;
            }
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (typeof message.uid === "number")
                    object.uid = options.longs === String ? String(message.uid) : message.uid;
                else
                    object.uid = options.longs === String ? $util.Long.prototype.toString.call(message.uid) : options.longs === Number ? new $util.LongBits(message.uid.low >>> 0, message.uid.high >>> 0).toNumber() : message.uid;
            if (message.lv != null && message.hasOwnProperty("lv"))
                object.lv = message.lv;
            if (message.logo != null && message.hasOwnProperty("logo"))
                object.logo = message.logo;
            if (message.lbox != null && message.hasOwnProperty("lbox"))
                object.lbox = message.lbox;
            if (message.score != null && message.hasOwnProperty("score"))
                object.score = message.score;
            if (message.like != null && message.hasOwnProperty("like"))
                object.like = message.like;
            if (message.cluster != null && message.hasOwnProperty("cluster"))
                object.cluster = message.cluster;
            if (message.udk != null && message.hasOwnProperty("udk"))
                object.udk = message.udk;
            if (message.gname != null && message.hasOwnProperty("gname"))
                object.gname = message.gname;
            if (message.camp && message.camp.length) {
                object.camp = [];
                for (var j = 0; j < message.camp.length; ++j)
                    object.camp[j] = $root.pb_unit.toObject(message.camp[j], options);
            }
            if (message.skls && message.skls.length) {
                object.skls = [];
                for (var j = 0; j < message.skls.length; ++j)
                    object.skls[j] = message.skls[j];
            }
            if (message.power != null && message.hasOwnProperty("power"))
                if (typeof message.power === "number")
                    object.power = options.longs === String ? String(message.power) : message.power;
                else
                    object.power = options.longs === String ? $util.Long.prototype.toString.call(message.power) : options.longs === Number ? new $util.LongBits(message.power.low >>> 0, message.power.high >>> 0).toNumber() : message.power;
            if (message.hide && message.hide.length) {
                object.hide = [];
                for (var j = 0; j < message.hide.length; ++j)
                    object.hide[j] = message.hide[j];
            }
            if (message.emblem != null && message.hasOwnProperty("emblem"))
                if (typeof message.emblem === "number")
                    object.emblem = options.longs === String ? String(message.emblem) : message.emblem;
                else
                    object.emblem = options.longs === String ? $util.Long.prototype.toString.call(message.emblem) : options.longs === Number ? new $util.LongBits(message.emblem.low >>> 0, message.emblem.high >>> 0).toNumber() : message.emblem;
            return object;
        };
    
        /**
         * Converts this pb_smbr to JSON.
         * @function toJSON
         * @memberof pb_smbr
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_smbr.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_smbr
         * @function getTypeUrl
         * @memberof pb_smbr
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_smbr.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_smbr";
        };
    
        return pb_smbr;
    })();
    
    $root.pb_smbrs = (function() {
    
        /**
         * Properties of a pb_smbrs.
         * @exports Ipb_smbrs
         * @interface Ipb_smbrs
         * @property {Array.<Ipb_smbr>|null} [mbrs] pb_smbrs mbrs
         * @property {number|null} [score] pb_smbrs score
         * @property {number|null} [rank] pb_smbrs rank
         * @property {number|null} [like] pb_smbrs like
         */
    
        /**
         * Constructs a new pb_smbrs.
         * @exports pb_smbrs
         * @classdesc Represents a pb_smbrs.
         * @implements Ipb_smbrs
         * @constructor
         * @param {Ipb_smbrs=} [properties] Properties to set
         */
        function pb_smbrs(properties) {
            this.mbrs = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_smbrs mbrs.
         * @member {Array.<Ipb_smbr>} mbrs
         * @memberof pb_smbrs
         * @instance
         */
        pb_smbrs.prototype.mbrs = $util.emptyArray;
    
        /**
         * pb_smbrs score.
         * @member {number} score
         * @memberof pb_smbrs
         * @instance
         */
        pb_smbrs.prototype.score = 0;
    
        /**
         * pb_smbrs rank.
         * @member {number} rank
         * @memberof pb_smbrs
         * @instance
         */
        pb_smbrs.prototype.rank = 0;
    
        /**
         * pb_smbrs like.
         * @member {number} like
         * @memberof pb_smbrs
         * @instance
         */
        pb_smbrs.prototype.like = 0;
    
        /**
         * Creates a new pb_smbrs instance using the specified properties.
         * @function create
         * @memberof pb_smbrs
         * @static
         * @param {Ipb_smbrs=} [properties] Properties to set
         * @returns {pb_smbrs} pb_smbrs instance
         */
        pb_smbrs.create = function create(properties) {
            return new pb_smbrs(properties);
        };
    
        /**
         * Encodes the specified pb_smbrs message. Does not implicitly {@link pb_smbrs.verify|verify} messages.
         * @function encode
         * @memberof pb_smbrs
         * @static
         * @param {Ipb_smbrs} message pb_smbrs message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_smbrs.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.mbrs != null && message.mbrs.length)
                for (var i = 0; i < message.mbrs.length; ++i)
                    $root.pb_smbr.encode(message.mbrs[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.score != null && Object.hasOwnProperty.call(message, "score"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.score);
            if (message.rank != null && Object.hasOwnProperty.call(message, "rank"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.rank);
            if (message.like != null && Object.hasOwnProperty.call(message, "like"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.like);
            return writer;
        };
    
        /**
         * Encodes the specified pb_smbrs message, length delimited. Does not implicitly {@link pb_smbrs.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_smbrs
         * @static
         * @param {Ipb_smbrs} message pb_smbrs message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_smbrs.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_smbrs message from the specified reader or buffer.
         * @function decode
         * @memberof pb_smbrs
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_smbrs} pb_smbrs
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_smbrs.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_smbrs();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.mbrs && message.mbrs.length))
                            message.mbrs = [];
                        message.mbrs.push($root.pb_smbr.decode(reader, reader.uint32()));
                        break;
                    }
                case 2: {
                        message.score = reader.int32();
                        break;
                    }
                case 3: {
                        message.rank = reader.int32();
                        break;
                    }
                case 4: {
                        message.like = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a pb_smbrs message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_smbrs
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_smbrs} pb_smbrs
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_smbrs.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_smbrs message.
         * @function verify
         * @memberof pb_smbrs
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_smbrs.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.mbrs != null && message.hasOwnProperty("mbrs")) {
                if (!Array.isArray(message.mbrs))
                    return "mbrs: array expected";
                for (var i = 0; i < message.mbrs.length; ++i) {
                    var error = $root.pb_smbr.verify(message.mbrs[i]);
                    if (error)
                        return "mbrs." + error;
                }
            }
            if (message.score != null && message.hasOwnProperty("score"))
                if (!$util.isInteger(message.score))
                    return "score: integer expected";
            if (message.rank != null && message.hasOwnProperty("rank"))
                if (!$util.isInteger(message.rank))
                    return "rank: integer expected";
            if (message.like != null && message.hasOwnProperty("like"))
                if (!$util.isInteger(message.like))
                    return "like: integer expected";
            return null;
        };
    
        /**
         * Creates a pb_smbrs message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_smbrs
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_smbrs} pb_smbrs
         */
        pb_smbrs.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_smbrs)
                return object;
            var message = new $root.pb_smbrs();
            if (object.mbrs) {
                if (!Array.isArray(object.mbrs))
                    throw TypeError(".pb_smbrs.mbrs: array expected");
                message.mbrs = [];
                for (var i = 0; i < object.mbrs.length; ++i) {
                    if (typeof object.mbrs[i] !== "object")
                        throw TypeError(".pb_smbrs.mbrs: object expected");
                    message.mbrs[i] = $root.pb_smbr.fromObject(object.mbrs[i]);
                }
            }
            if (object.score != null)
                message.score = object.score | 0;
            if (object.rank != null)
                message.rank = object.rank | 0;
            if (object.like != null)
                message.like = object.like | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a pb_smbrs message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_smbrs
         * @static
         * @param {pb_smbrs} message pb_smbrs
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_smbrs.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.mbrs = [];
            if (options.defaults) {
                object.score = 0;
                object.rank = 0;
                object.like = 0;
            }
            if (message.mbrs && message.mbrs.length) {
                object.mbrs = [];
                for (var j = 0; j < message.mbrs.length; ++j)
                    object.mbrs[j] = $root.pb_smbr.toObject(message.mbrs[j], options);
            }
            if (message.score != null && message.hasOwnProperty("score"))
                object.score = message.score;
            if (message.rank != null && message.hasOwnProperty("rank"))
                object.rank = message.rank;
            if (message.like != null && message.hasOwnProperty("like"))
                object.like = message.like;
            return object;
        };
    
        /**
         * Converts this pb_smbrs to JSON.
         * @function toJSON
         * @memberof pb_smbrs
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_smbrs.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_smbrs
         * @function getTypeUrl
         * @memberof pb_smbrs
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_smbrs.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_smbrs";
        };
    
        return pb_smbrs;
    })();
    
    $root.pb_template = (function() {
    
        /**
         * Properties of a pb_template.
         * @exports Ipb_template
         * @interface Ipb_template
         * @property {number|null} [id] pb_template id
         * @property {string|null} [name] pb_template name
         * @property {Array.<Ipb_buildings>|null} [buildings] pb_template buildings
         * @property {Array.<Ipb_room>|null} [rooms] pb_template rooms
         */
    
        /**
         * Constructs a new pb_template.
         * @exports pb_template
         * @classdesc Represents a pb_template.
         * @implements Ipb_template
         * @constructor
         * @param {Ipb_template=} [properties] Properties to set
         */
        function pb_template(properties) {
            this.buildings = [];
            this.rooms = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_template id.
         * @member {number} id
         * @memberof pb_template
         * @instance
         */
        pb_template.prototype.id = 0;
    
        /**
         * pb_template name.
         * @member {string} name
         * @memberof pb_template
         * @instance
         */
        pb_template.prototype.name = "";
    
        /**
         * pb_template buildings.
         * @member {Array.<Ipb_buildings>} buildings
         * @memberof pb_template
         * @instance
         */
        pb_template.prototype.buildings = $util.emptyArray;
    
        /**
         * pb_template rooms.
         * @member {Array.<Ipb_room>} rooms
         * @memberof pb_template
         * @instance
         */
        pb_template.prototype.rooms = $util.emptyArray;
    
        /**
         * Creates a new pb_template instance using the specified properties.
         * @function create
         * @memberof pb_template
         * @static
         * @param {Ipb_template=} [properties] Properties to set
         * @returns {pb_template} pb_template instance
         */
        pb_template.create = function create(properties) {
            return new pb_template(properties);
        };
    
        /**
         * Encodes the specified pb_template message. Does not implicitly {@link pb_template.verify|verify} messages.
         * @function encode
         * @memberof pb_template
         * @static
         * @param {Ipb_template} message pb_template message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_template.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.id);
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
            if (message.buildings != null && message.buildings.length)
                for (var i = 0; i < message.buildings.length; ++i)
                    $root.pb_buildings.encode(message.buildings[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.rooms != null && message.rooms.length)
                for (var i = 0; i < message.rooms.length; ++i)
                    $root.pb_room.encode(message.rooms[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified pb_template message, length delimited. Does not implicitly {@link pb_template.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_template
         * @static
         * @param {Ipb_template} message pb_template message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_template.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_template message from the specified reader or buffer.
         * @function decode
         * @memberof pb_template
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_template} pb_template
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_template.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_template();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.id = reader.int32();
                        break;
                    }
                case 2: {
                        message.name = reader.string();
                        break;
                    }
                case 3: {
                        if (!(message.buildings && message.buildings.length))
                            message.buildings = [];
                        message.buildings.push($root.pb_buildings.decode(reader, reader.uint32()));
                        break;
                    }
                case 4: {
                        if (!(message.rooms && message.rooms.length))
                            message.rooms = [];
                        message.rooms.push($root.pb_room.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a pb_template message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_template
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_template} pb_template
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_template.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_template message.
         * @function verify
         * @memberof pb_template
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_template.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id))
                    return "id: integer expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.buildings != null && message.hasOwnProperty("buildings")) {
                if (!Array.isArray(message.buildings))
                    return "buildings: array expected";
                for (var i = 0; i < message.buildings.length; ++i) {
                    var error = $root.pb_buildings.verify(message.buildings[i]);
                    if (error)
                        return "buildings." + error;
                }
            }
            if (message.rooms != null && message.hasOwnProperty("rooms")) {
                if (!Array.isArray(message.rooms))
                    return "rooms: array expected";
                for (var i = 0; i < message.rooms.length; ++i) {
                    var error = $root.pb_room.verify(message.rooms[i]);
                    if (error)
                        return "rooms." + error;
                }
            }
            return null;
        };
    
        /**
         * Creates a pb_template message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_template
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_template} pb_template
         */
        pb_template.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_template)
                return object;
            var message = new $root.pb_template();
            if (object.id != null)
                message.id = object.id | 0;
            if (object.name != null)
                message.name = String(object.name);
            if (object.buildings) {
                if (!Array.isArray(object.buildings))
                    throw TypeError(".pb_template.buildings: array expected");
                message.buildings = [];
                for (var i = 0; i < object.buildings.length; ++i) {
                    if (typeof object.buildings[i] !== "object")
                        throw TypeError(".pb_template.buildings: object expected");
                    message.buildings[i] = $root.pb_buildings.fromObject(object.buildings[i]);
                }
            }
            if (object.rooms) {
                if (!Array.isArray(object.rooms))
                    throw TypeError(".pb_template.rooms: array expected");
                message.rooms = [];
                for (var i = 0; i < object.rooms.length; ++i) {
                    if (typeof object.rooms[i] !== "object")
                        throw TypeError(".pb_template.rooms: object expected");
                    message.rooms[i] = $root.pb_room.fromObject(object.rooms[i]);
                }
            }
            return message;
        };
    
        /**
         * Creates a plain object from a pb_template message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_template
         * @static
         * @param {pb_template} message pb_template
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_template.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.buildings = [];
                object.rooms = [];
            }
            if (options.defaults) {
                object.id = 0;
                object.name = "";
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.buildings && message.buildings.length) {
                object.buildings = [];
                for (var j = 0; j < message.buildings.length; ++j)
                    object.buildings[j] = $root.pb_buildings.toObject(message.buildings[j], options);
            }
            if (message.rooms && message.rooms.length) {
                object.rooms = [];
                for (var j = 0; j < message.rooms.length; ++j)
                    object.rooms[j] = $root.pb_room.toObject(message.rooms[j], options);
            }
            return object;
        };
    
        /**
         * Converts this pb_template to JSON.
         * @function toJSON
         * @memberof pb_template
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_template.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_template
         * @function getTypeUrl
         * @memberof pb_template
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_template.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_template";
        };
    
        return pb_template;
    })();
    
    $root.pb_pvp = (function() {
    
        /**
         * Properties of a pb_pvp.
         * @exports Ipb_pvp
         * @interface Ipb_pvp
         * @property {number} id pb_pvp id
         * @property {number} status pb_pvp status
         * @property {Ipb_pmbr|null} [self] pb_pvp self
         * @property {number|null} [seasonCd] pb_pvp seasonCd
         * @property {number|null} [dailyCd] pb_pvp dailyCd
         */
    
        /**
         * Constructs a new pb_pvp.
         * @exports pb_pvp
         * @classdesc Represents a pb_pvp.
         * @implements Ipb_pvp
         * @constructor
         * @param {Ipb_pvp=} [properties] Properties to set
         */
        function pb_pvp(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_pvp id.
         * @member {number} id
         * @memberof pb_pvp
         * @instance
         */
        pb_pvp.prototype.id = 0;
    
        /**
         * pb_pvp status.
         * @member {number} status
         * @memberof pb_pvp
         * @instance
         */
        pb_pvp.prototype.status = 0;
    
        /**
         * pb_pvp self.
         * @member {Ipb_pmbr|null|undefined} self
         * @memberof pb_pvp
         * @instance
         */
        pb_pvp.prototype.self = null;
    
        /**
         * pb_pvp seasonCd.
         * @member {number} seasonCd
         * @memberof pb_pvp
         * @instance
         */
        pb_pvp.prototype.seasonCd = 0;
    
        /**
         * pb_pvp dailyCd.
         * @member {number} dailyCd
         * @memberof pb_pvp
         * @instance
         */
        pb_pvp.prototype.dailyCd = 0;
    
        /**
         * Creates a new pb_pvp instance using the specified properties.
         * @function create
         * @memberof pb_pvp
         * @static
         * @param {Ipb_pvp=} [properties] Properties to set
         * @returns {pb_pvp} pb_pvp instance
         */
        pb_pvp.create = function create(properties) {
            return new pb_pvp(properties);
        };
    
        /**
         * Encodes the specified pb_pvp message. Does not implicitly {@link pb_pvp.verify|verify} messages.
         * @function encode
         * @memberof pb_pvp
         * @static
         * @param {Ipb_pvp} message pb_pvp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_pvp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.id);
            writer.uint32(/* id 2, wireType 0 =*/16).sint32(message.status);
            if (message.self != null && Object.hasOwnProperty.call(message, "self"))
                $root.pb_pmbr.encode(message.self, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.seasonCd != null && Object.hasOwnProperty.call(message, "seasonCd"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.seasonCd);
            if (message.dailyCd != null && Object.hasOwnProperty.call(message, "dailyCd"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.dailyCd);
            return writer;
        };
    
        /**
         * Encodes the specified pb_pvp message, length delimited. Does not implicitly {@link pb_pvp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_pvp
         * @static
         * @param {Ipb_pvp} message pb_pvp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_pvp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_pvp message from the specified reader or buffer.
         * @function decode
         * @memberof pb_pvp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_pvp} pb_pvp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_pvp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_pvp();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.id = reader.int32();
                        break;
                    }
                case 2: {
                        message.status = reader.sint32();
                        break;
                    }
                case 3: {
                        message.self = $root.pb_pmbr.decode(reader, reader.uint32());
                        break;
                    }
                case 4: {
                        message.seasonCd = reader.int32();
                        break;
                    }
                case 5: {
                        message.dailyCd = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("id"))
                throw $util.ProtocolError("missing required 'id'", { instance: message });
            if (!message.hasOwnProperty("status"))
                throw $util.ProtocolError("missing required 'status'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a pb_pvp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_pvp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_pvp} pb_pvp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_pvp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_pvp message.
         * @function verify
         * @memberof pb_pvp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_pvp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.id))
                return "id: integer expected";
            if (!$util.isInteger(message.status))
                return "status: integer expected";
            if (message.self != null && message.hasOwnProperty("self")) {
                var error = $root.pb_pmbr.verify(message.self);
                if (error)
                    return "self." + error;
            }
            if (message.seasonCd != null && message.hasOwnProperty("seasonCd"))
                if (!$util.isInteger(message.seasonCd))
                    return "seasonCd: integer expected";
            if (message.dailyCd != null && message.hasOwnProperty("dailyCd"))
                if (!$util.isInteger(message.dailyCd))
                    return "dailyCd: integer expected";
            return null;
        };
    
        /**
         * Creates a pb_pvp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_pvp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_pvp} pb_pvp
         */
        pb_pvp.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_pvp)
                return object;
            var message = new $root.pb_pvp();
            if (object.id != null)
                message.id = object.id | 0;
            if (object.status != null)
                message.status = object.status | 0;
            if (object.self != null) {
                if (typeof object.self !== "object")
                    throw TypeError(".pb_pvp.self: object expected");
                message.self = $root.pb_pmbr.fromObject(object.self);
            }
            if (object.seasonCd != null)
                message.seasonCd = object.seasonCd | 0;
            if (object.dailyCd != null)
                message.dailyCd = object.dailyCd | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a pb_pvp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_pvp
         * @static
         * @param {pb_pvp} message pb_pvp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_pvp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = 0;
                object.status = 0;
                object.self = null;
                object.seasonCd = 0;
                object.dailyCd = 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = message.status;
            if (message.self != null && message.hasOwnProperty("self"))
                object.self = $root.pb_pmbr.toObject(message.self, options);
            if (message.seasonCd != null && message.hasOwnProperty("seasonCd"))
                object.seasonCd = message.seasonCd;
            if (message.dailyCd != null && message.hasOwnProperty("dailyCd"))
                object.dailyCd = message.dailyCd;
            return object;
        };
    
        /**
         * Converts this pb_pvp to JSON.
         * @function toJSON
         * @memberof pb_pvp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_pvp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_pvp
         * @function getTypeUrl
         * @memberof pb_pvp
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_pvp.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_pvp";
        };
    
        return pb_pvp;
    })();
    
    $root.pb_wpvp = (function() {
    
        /**
         * Properties of a pb_wpvp.
         * @exports Ipb_wpvp
         * @interface Ipb_wpvp
         * @property {number} wid pb_wpvp wid
         * @property {number|null} [flag] pb_wpvp flag
         * @property {number|null} [cd] pb_wpvp cd
         */
    
        /**
         * Constructs a new pb_wpvp.
         * @exports pb_wpvp
         * @classdesc Represents a pb_wpvp.
         * @implements Ipb_wpvp
         * @constructor
         * @param {Ipb_wpvp=} [properties] Properties to set
         */
        function pb_wpvp(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_wpvp wid.
         * @member {number} wid
         * @memberof pb_wpvp
         * @instance
         */
        pb_wpvp.prototype.wid = 0;
    
        /**
         * pb_wpvp flag.
         * @member {number} flag
         * @memberof pb_wpvp
         * @instance
         */
        pb_wpvp.prototype.flag = 0;
    
        /**
         * pb_wpvp cd.
         * @member {number} cd
         * @memberof pb_wpvp
         * @instance
         */
        pb_wpvp.prototype.cd = 0;
    
        /**
         * Creates a new pb_wpvp instance using the specified properties.
         * @function create
         * @memberof pb_wpvp
         * @static
         * @param {Ipb_wpvp=} [properties] Properties to set
         * @returns {pb_wpvp} pb_wpvp instance
         */
        pb_wpvp.create = function create(properties) {
            return new pb_wpvp(properties);
        };
    
        /**
         * Encodes the specified pb_wpvp message. Does not implicitly {@link pb_wpvp.verify|verify} messages.
         * @function encode
         * @memberof pb_wpvp
         * @static
         * @param {Ipb_wpvp} message pb_wpvp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_wpvp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.wid);
            if (message.flag != null && Object.hasOwnProperty.call(message, "flag"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.flag);
            if (message.cd != null && Object.hasOwnProperty.call(message, "cd"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.cd);
            return writer;
        };
    
        /**
         * Encodes the specified pb_wpvp message, length delimited. Does not implicitly {@link pb_wpvp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_wpvp
         * @static
         * @param {Ipb_wpvp} message pb_wpvp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_wpvp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_wpvp message from the specified reader or buffer.
         * @function decode
         * @memberof pb_wpvp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_wpvp} pb_wpvp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_wpvp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_wpvp();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.wid = reader.int32();
                        break;
                    }
                case 2: {
                        message.flag = reader.int32();
                        break;
                    }
                case 3: {
                        message.cd = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("wid"))
                throw $util.ProtocolError("missing required 'wid'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a pb_wpvp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_wpvp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_wpvp} pb_wpvp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_wpvp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_wpvp message.
         * @function verify
         * @memberof pb_wpvp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_wpvp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.wid))
                return "wid: integer expected";
            if (message.flag != null && message.hasOwnProperty("flag"))
                if (!$util.isInteger(message.flag))
                    return "flag: integer expected";
            if (message.cd != null && message.hasOwnProperty("cd"))
                if (!$util.isInteger(message.cd))
                    return "cd: integer expected";
            return null;
        };
    
        /**
         * Creates a pb_wpvp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_wpvp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_wpvp} pb_wpvp
         */
        pb_wpvp.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_wpvp)
                return object;
            var message = new $root.pb_wpvp();
            if (object.wid != null)
                message.wid = object.wid | 0;
            if (object.flag != null)
                message.flag = object.flag | 0;
            if (object.cd != null)
                message.cd = object.cd | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a pb_wpvp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_wpvp
         * @static
         * @param {pb_wpvp} message pb_wpvp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_wpvp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.wid = 0;
                object.flag = 0;
                object.cd = 0;
            }
            if (message.wid != null && message.hasOwnProperty("wid"))
                object.wid = message.wid;
            if (message.flag != null && message.hasOwnProperty("flag"))
                object.flag = message.flag;
            if (message.cd != null && message.hasOwnProperty("cd"))
                object.cd = message.cd;
            return object;
        };
    
        /**
         * Converts this pb_wpvp to JSON.
         * @function toJSON
         * @memberof pb_wpvp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_wpvp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_wpvp
         * @function getTypeUrl
         * @memberof pb_wpvp
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_wpvp.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_wpvp";
        };
    
        return pb_wpvp;
    })();
    
    $root.pb_wmbr = (function() {
    
        /**
         * Properties of a pb_wmbr.
         * @exports Ipb_wmbr
         * @interface Ipb_wmbr
         * @property {number|Long|null} [uid] pb_wmbr uid
         * @property {string|null} [gname] pb_wmbr gname
         * @property {number|null} [score] pb_wmbr score
         * @property {string|null} [name] pb_wmbr name
         * @property {number|null} [logo] pb_wmbr logo
         * @property {number|null} [lv] pb_wmbr lv
         * @property {number|Long|null} [power] pb_wmbr power
         * @property {number|null} [lbox] pb_wmbr lbox
         * @property {number|null} [like] pb_wmbr like
         * @property {boolean|null} [king] pb_wmbr king
         * @property {number|null} [num] pb_wmbr num
         * @property {number|Long|null} [emblem] pb_wmbr emblem
         */
    
        /**
         * Constructs a new pb_wmbr.
         * @exports pb_wmbr
         * @classdesc Represents a pb_wmbr.
         * @implements Ipb_wmbr
         * @constructor
         * @param {Ipb_wmbr=} [properties] Properties to set
         */
        function pb_wmbr(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_wmbr uid.
         * @member {number|Long} uid
         * @memberof pb_wmbr
         * @instance
         */
        pb_wmbr.prototype.uid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * pb_wmbr gname.
         * @member {string} gname
         * @memberof pb_wmbr
         * @instance
         */
        pb_wmbr.prototype.gname = "";
    
        /**
         * pb_wmbr score.
         * @member {number} score
         * @memberof pb_wmbr
         * @instance
         */
        pb_wmbr.prototype.score = 0;
    
        /**
         * pb_wmbr name.
         * @member {string} name
         * @memberof pb_wmbr
         * @instance
         */
        pb_wmbr.prototype.name = "";
    
        /**
         * pb_wmbr logo.
         * @member {number} logo
         * @memberof pb_wmbr
         * @instance
         */
        pb_wmbr.prototype.logo = 0;
    
        /**
         * pb_wmbr lv.
         * @member {number} lv
         * @memberof pb_wmbr
         * @instance
         */
        pb_wmbr.prototype.lv = 0;
    
        /**
         * pb_wmbr power.
         * @member {number|Long} power
         * @memberof pb_wmbr
         * @instance
         */
        pb_wmbr.prototype.power = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * pb_wmbr lbox.
         * @member {number} lbox
         * @memberof pb_wmbr
         * @instance
         */
        pb_wmbr.prototype.lbox = 0;
    
        /**
         * pb_wmbr like.
         * @member {number} like
         * @memberof pb_wmbr
         * @instance
         */
        pb_wmbr.prototype.like = 0;
    
        /**
         * pb_wmbr king.
         * @member {boolean} king
         * @memberof pb_wmbr
         * @instance
         */
        pb_wmbr.prototype.king = false;
    
        /**
         * pb_wmbr num.
         * @member {number} num
         * @memberof pb_wmbr
         * @instance
         */
        pb_wmbr.prototype.num = 0;
    
        /**
         * pb_wmbr emblem.
         * @member {number|Long} emblem
         * @memberof pb_wmbr
         * @instance
         */
        pb_wmbr.prototype.emblem = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * Creates a new pb_wmbr instance using the specified properties.
         * @function create
         * @memberof pb_wmbr
         * @static
         * @param {Ipb_wmbr=} [properties] Properties to set
         * @returns {pb_wmbr} pb_wmbr instance
         */
        pb_wmbr.create = function create(properties) {
            return new pb_wmbr(properties);
        };
    
        /**
         * Encodes the specified pb_wmbr message. Does not implicitly {@link pb_wmbr.verify|verify} messages.
         * @function encode
         * @memberof pb_wmbr
         * @static
         * @param {Ipb_wmbr} message pb_wmbr message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_wmbr.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.uid != null && Object.hasOwnProperty.call(message, "uid"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.uid);
            if (message.gname != null && Object.hasOwnProperty.call(message, "gname"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.gname);
            if (message.score != null && Object.hasOwnProperty.call(message, "score"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.score);
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.name);
            if (message.logo != null && Object.hasOwnProperty.call(message, "logo"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.logo);
            if (message.lv != null && Object.hasOwnProperty.call(message, "lv"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.lv);
            if (message.power != null && Object.hasOwnProperty.call(message, "power"))
                writer.uint32(/* id 7, wireType 0 =*/56).int64(message.power);
            if (message.lbox != null && Object.hasOwnProperty.call(message, "lbox"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.lbox);
            if (message.like != null && Object.hasOwnProperty.call(message, "like"))
                writer.uint32(/* id 9, wireType 0 =*/72).int32(message.like);
            if (message.king != null && Object.hasOwnProperty.call(message, "king"))
                writer.uint32(/* id 10, wireType 0 =*/80).bool(message.king);
            if (message.num != null && Object.hasOwnProperty.call(message, "num"))
                writer.uint32(/* id 11, wireType 0 =*/88).int32(message.num);
            if (message.emblem != null && Object.hasOwnProperty.call(message, "emblem"))
                writer.uint32(/* id 12, wireType 0 =*/96).int64(message.emblem);
            return writer;
        };
    
        /**
         * Encodes the specified pb_wmbr message, length delimited. Does not implicitly {@link pb_wmbr.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_wmbr
         * @static
         * @param {Ipb_wmbr} message pb_wmbr message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_wmbr.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_wmbr message from the specified reader or buffer.
         * @function decode
         * @memberof pb_wmbr
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_wmbr} pb_wmbr
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_wmbr.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_wmbr();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.uid = reader.int64();
                        break;
                    }
                case 2: {
                        message.gname = reader.string();
                        break;
                    }
                case 3: {
                        message.score = reader.int32();
                        break;
                    }
                case 4: {
                        message.name = reader.string();
                        break;
                    }
                case 5: {
                        message.logo = reader.int32();
                        break;
                    }
                case 6: {
                        message.lv = reader.int32();
                        break;
                    }
                case 7: {
                        message.power = reader.int64();
                        break;
                    }
                case 8: {
                        message.lbox = reader.int32();
                        break;
                    }
                case 9: {
                        message.like = reader.int32();
                        break;
                    }
                case 10: {
                        message.king = reader.bool();
                        break;
                    }
                case 11: {
                        message.num = reader.int32();
                        break;
                    }
                case 12: {
                        message.emblem = reader.int64();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a pb_wmbr message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_wmbr
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_wmbr} pb_wmbr
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_wmbr.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_wmbr message.
         * @function verify
         * @memberof pb_wmbr
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_wmbr.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (!$util.isInteger(message.uid) && !(message.uid && $util.isInteger(message.uid.low) && $util.isInteger(message.uid.high)))
                    return "uid: integer|Long expected";
            if (message.gname != null && message.hasOwnProperty("gname"))
                if (!$util.isString(message.gname))
                    return "gname: string expected";
            if (message.score != null && message.hasOwnProperty("score"))
                if (!$util.isInteger(message.score))
                    return "score: integer expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.logo != null && message.hasOwnProperty("logo"))
                if (!$util.isInteger(message.logo))
                    return "logo: integer expected";
            if (message.lv != null && message.hasOwnProperty("lv"))
                if (!$util.isInteger(message.lv))
                    return "lv: integer expected";
            if (message.power != null && message.hasOwnProperty("power"))
                if (!$util.isInteger(message.power) && !(message.power && $util.isInteger(message.power.low) && $util.isInteger(message.power.high)))
                    return "power: integer|Long expected";
            if (message.lbox != null && message.hasOwnProperty("lbox"))
                if (!$util.isInteger(message.lbox))
                    return "lbox: integer expected";
            if (message.like != null && message.hasOwnProperty("like"))
                if (!$util.isInteger(message.like))
                    return "like: integer expected";
            if (message.king != null && message.hasOwnProperty("king"))
                if (typeof message.king !== "boolean")
                    return "king: boolean expected";
            if (message.num != null && message.hasOwnProperty("num"))
                if (!$util.isInteger(message.num))
                    return "num: integer expected";
            if (message.emblem != null && message.hasOwnProperty("emblem"))
                if (!$util.isInteger(message.emblem) && !(message.emblem && $util.isInteger(message.emblem.low) && $util.isInteger(message.emblem.high)))
                    return "emblem: integer|Long expected";
            return null;
        };
    
        /**
         * Creates a pb_wmbr message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_wmbr
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_wmbr} pb_wmbr
         */
        pb_wmbr.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_wmbr)
                return object;
            var message = new $root.pb_wmbr();
            if (object.uid != null)
                if ($util.Long)
                    (message.uid = $util.Long.fromValue(object.uid)).unsigned = false;
                else if (typeof object.uid === "string")
                    message.uid = parseInt(object.uid, 10);
                else if (typeof object.uid === "number")
                    message.uid = object.uid;
                else if (typeof object.uid === "object")
                    message.uid = new $util.LongBits(object.uid.low >>> 0, object.uid.high >>> 0).toNumber();
            if (object.gname != null)
                message.gname = String(object.gname);
            if (object.score != null)
                message.score = object.score | 0;
            if (object.name != null)
                message.name = String(object.name);
            if (object.logo != null)
                message.logo = object.logo | 0;
            if (object.lv != null)
                message.lv = object.lv | 0;
            if (object.power != null)
                if ($util.Long)
                    (message.power = $util.Long.fromValue(object.power)).unsigned = false;
                else if (typeof object.power === "string")
                    message.power = parseInt(object.power, 10);
                else if (typeof object.power === "number")
                    message.power = object.power;
                else if (typeof object.power === "object")
                    message.power = new $util.LongBits(object.power.low >>> 0, object.power.high >>> 0).toNumber();
            if (object.lbox != null)
                message.lbox = object.lbox | 0;
            if (object.like != null)
                message.like = object.like | 0;
            if (object.king != null)
                message.king = Boolean(object.king);
            if (object.num != null)
                message.num = object.num | 0;
            if (object.emblem != null)
                if ($util.Long)
                    (message.emblem = $util.Long.fromValue(object.emblem)).unsigned = false;
                else if (typeof object.emblem === "string")
                    message.emblem = parseInt(object.emblem, 10);
                else if (typeof object.emblem === "number")
                    message.emblem = object.emblem;
                else if (typeof object.emblem === "object")
                    message.emblem = new $util.LongBits(object.emblem.low >>> 0, object.emblem.high >>> 0).toNumber();
            return message;
        };
    
        /**
         * Creates a plain object from a pb_wmbr message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_wmbr
         * @static
         * @param {pb_wmbr} message pb_wmbr
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_wmbr.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.uid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.uid = options.longs === String ? "0" : 0;
                object.gname = "";
                object.score = 0;
                object.name = "";
                object.logo = 0;
                object.lv = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.power = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.power = options.longs === String ? "0" : 0;
                object.lbox = 0;
                object.like = 0;
                object.king = false;
                object.num = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.emblem = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.emblem = options.longs === String ? "0" : 0;
            }
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (typeof message.uid === "number")
                    object.uid = options.longs === String ? String(message.uid) : message.uid;
                else
                    object.uid = options.longs === String ? $util.Long.prototype.toString.call(message.uid) : options.longs === Number ? new $util.LongBits(message.uid.low >>> 0, message.uid.high >>> 0).toNumber() : message.uid;
            if (message.gname != null && message.hasOwnProperty("gname"))
                object.gname = message.gname;
            if (message.score != null && message.hasOwnProperty("score"))
                object.score = message.score;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.logo != null && message.hasOwnProperty("logo"))
                object.logo = message.logo;
            if (message.lv != null && message.hasOwnProperty("lv"))
                object.lv = message.lv;
            if (message.power != null && message.hasOwnProperty("power"))
                if (typeof message.power === "number")
                    object.power = options.longs === String ? String(message.power) : message.power;
                else
                    object.power = options.longs === String ? $util.Long.prototype.toString.call(message.power) : options.longs === Number ? new $util.LongBits(message.power.low >>> 0, message.power.high >>> 0).toNumber() : message.power;
            if (message.lbox != null && message.hasOwnProperty("lbox"))
                object.lbox = message.lbox;
            if (message.like != null && message.hasOwnProperty("like"))
                object.like = message.like;
            if (message.king != null && message.hasOwnProperty("king"))
                object.king = message.king;
            if (message.num != null && message.hasOwnProperty("num"))
                object.num = message.num;
            if (message.emblem != null && message.hasOwnProperty("emblem"))
                if (typeof message.emblem === "number")
                    object.emblem = options.longs === String ? String(message.emblem) : message.emblem;
                else
                    object.emblem = options.longs === String ? $util.Long.prototype.toString.call(message.emblem) : options.longs === Number ? new $util.LongBits(message.emblem.low >>> 0, message.emblem.high >>> 0).toNumber() : message.emblem;
            return object;
        };
    
        /**
         * Converts this pb_wmbr to JSON.
         * @function toJSON
         * @memberof pb_wmbr
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_wmbr.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_wmbr
         * @function getTypeUrl
         * @memberof pb_wmbr
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_wmbr.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_wmbr";
        };
    
        return pb_wmbr;
    })();
    
    $root.pb_link = (function() {
    
        /**
         * Properties of a pb_link.
         * @exports Ipb_link
         * @interface Ipb_link
         * @property {number|null} [cd] pb_link cd
         * @property {number|null} [win] pb_link win
         * @property {number|Long|null} [vid] pb_link vid
         */
    
        /**
         * Constructs a new pb_link.
         * @exports pb_link
         * @classdesc Represents a pb_link.
         * @implements Ipb_link
         * @constructor
         * @param {Ipb_link=} [properties] Properties to set
         */
        function pb_link(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_link cd.
         * @member {number} cd
         * @memberof pb_link
         * @instance
         */
        pb_link.prototype.cd = 0;
    
        /**
         * pb_link win.
         * @member {number} win
         * @memberof pb_link
         * @instance
         */
        pb_link.prototype.win = 0;
    
        /**
         * pb_link vid.
         * @member {number|Long} vid
         * @memberof pb_link
         * @instance
         */
        pb_link.prototype.vid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * Creates a new pb_link instance using the specified properties.
         * @function create
         * @memberof pb_link
         * @static
         * @param {Ipb_link=} [properties] Properties to set
         * @returns {pb_link} pb_link instance
         */
        pb_link.create = function create(properties) {
            return new pb_link(properties);
        };
    
        /**
         * Encodes the specified pb_link message. Does not implicitly {@link pb_link.verify|verify} messages.
         * @function encode
         * @memberof pb_link
         * @static
         * @param {Ipb_link} message pb_link message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_link.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.cd != null && Object.hasOwnProperty.call(message, "cd"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.cd);
            if (message.win != null && Object.hasOwnProperty.call(message, "win"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.win);
            if (message.vid != null && Object.hasOwnProperty.call(message, "vid"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.vid);
            return writer;
        };
    
        /**
         * Encodes the specified pb_link message, length delimited. Does not implicitly {@link pb_link.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_link
         * @static
         * @param {Ipb_link} message pb_link message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_link.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_link message from the specified reader or buffer.
         * @function decode
         * @memberof pb_link
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_link} pb_link
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_link.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_link();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.cd = reader.int32();
                        break;
                    }
                case 2: {
                        message.win = reader.int32();
                        break;
                    }
                case 3: {
                        message.vid = reader.int64();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a pb_link message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_link
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_link} pb_link
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_link.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_link message.
         * @function verify
         * @memberof pb_link
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_link.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.cd != null && message.hasOwnProperty("cd"))
                if (!$util.isInteger(message.cd))
                    return "cd: integer expected";
            if (message.win != null && message.hasOwnProperty("win"))
                if (!$util.isInteger(message.win))
                    return "win: integer expected";
            if (message.vid != null && message.hasOwnProperty("vid"))
                if (!$util.isInteger(message.vid) && !(message.vid && $util.isInteger(message.vid.low) && $util.isInteger(message.vid.high)))
                    return "vid: integer|Long expected";
            return null;
        };
    
        /**
         * Creates a pb_link message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_link
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_link} pb_link
         */
        pb_link.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_link)
                return object;
            var message = new $root.pb_link();
            if (object.cd != null)
                message.cd = object.cd | 0;
            if (object.win != null)
                message.win = object.win | 0;
            if (object.vid != null)
                if ($util.Long)
                    (message.vid = $util.Long.fromValue(object.vid)).unsigned = false;
                else if (typeof object.vid === "string")
                    message.vid = parseInt(object.vid, 10);
                else if (typeof object.vid === "number")
                    message.vid = object.vid;
                else if (typeof object.vid === "object")
                    message.vid = new $util.LongBits(object.vid.low >>> 0, object.vid.high >>> 0).toNumber();
            return message;
        };
    
        /**
         * Creates a plain object from a pb_link message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_link
         * @static
         * @param {pb_link} message pb_link
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_link.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.cd = 0;
                object.win = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.vid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.vid = options.longs === String ? "0" : 0;
            }
            if (message.cd != null && message.hasOwnProperty("cd"))
                object.cd = message.cd;
            if (message.win != null && message.hasOwnProperty("win"))
                object.win = message.win;
            if (message.vid != null && message.hasOwnProperty("vid"))
                if (typeof message.vid === "number")
                    object.vid = options.longs === String ? String(message.vid) : message.vid;
                else
                    object.vid = options.longs === String ? $util.Long.prototype.toString.call(message.vid) : options.longs === Number ? new $util.LongBits(message.vid.low >>> 0, message.vid.high >>> 0).toNumber() : message.vid;
            return object;
        };
    
        /**
         * Converts this pb_link to JSON.
         * @function toJSON
         * @memberof pb_link
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_link.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_link
         * @function getTypeUrl
         * @memberof pb_link
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_link.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_link";
        };
    
        return pb_link;
    })();
    
    $root.pb_wlog = (function() {
    
        /**
         * Properties of a pb_wlog.
         * @exports Ipb_wlog
         * @interface Ipb_wlog
         * @property {number|Long|null} [vid] pb_wlog vid
         * @property {Array.<Ipb_unit>|null} [atk] pb_wlog atk
         * @property {Array.<Ipb_unit>|null} [def] pb_wlog def
         * @property {boolean} win pb_wlog win
         */
    
        /**
         * Constructs a new pb_wlog.
         * @exports pb_wlog
         * @classdesc Represents a pb_wlog.
         * @implements Ipb_wlog
         * @constructor
         * @param {Ipb_wlog=} [properties] Properties to set
         */
        function pb_wlog(properties) {
            this.atk = [];
            this.def = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_wlog vid.
         * @member {number|Long} vid
         * @memberof pb_wlog
         * @instance
         */
        pb_wlog.prototype.vid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * pb_wlog atk.
         * @member {Array.<Ipb_unit>} atk
         * @memberof pb_wlog
         * @instance
         */
        pb_wlog.prototype.atk = $util.emptyArray;
    
        /**
         * pb_wlog def.
         * @member {Array.<Ipb_unit>} def
         * @memberof pb_wlog
         * @instance
         */
        pb_wlog.prototype.def = $util.emptyArray;
    
        /**
         * pb_wlog win.
         * @member {boolean} win
         * @memberof pb_wlog
         * @instance
         */
        pb_wlog.prototype.win = false;
    
        /**
         * Creates a new pb_wlog instance using the specified properties.
         * @function create
         * @memberof pb_wlog
         * @static
         * @param {Ipb_wlog=} [properties] Properties to set
         * @returns {pb_wlog} pb_wlog instance
         */
        pb_wlog.create = function create(properties) {
            return new pb_wlog(properties);
        };
    
        /**
         * Encodes the specified pb_wlog message. Does not implicitly {@link pb_wlog.verify|verify} messages.
         * @function encode
         * @memberof pb_wlog
         * @static
         * @param {Ipb_wlog} message pb_wlog message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_wlog.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.vid != null && Object.hasOwnProperty.call(message, "vid"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.vid);
            if (message.atk != null && message.atk.length)
                for (var i = 0; i < message.atk.length; ++i)
                    $root.pb_unit.encode(message.atk[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.def != null && message.def.length)
                for (var i = 0; i < message.def.length; ++i)
                    $root.pb_unit.encode(message.def[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            writer.uint32(/* id 4, wireType 0 =*/32).bool(message.win);
            return writer;
        };
    
        /**
         * Encodes the specified pb_wlog message, length delimited. Does not implicitly {@link pb_wlog.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_wlog
         * @static
         * @param {Ipb_wlog} message pb_wlog message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_wlog.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_wlog message from the specified reader or buffer.
         * @function decode
         * @memberof pb_wlog
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_wlog} pb_wlog
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_wlog.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_wlog();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.vid = reader.int64();
                        break;
                    }
                case 2: {
                        if (!(message.atk && message.atk.length))
                            message.atk = [];
                        message.atk.push($root.pb_unit.decode(reader, reader.uint32()));
                        break;
                    }
                case 3: {
                        if (!(message.def && message.def.length))
                            message.def = [];
                        message.def.push($root.pb_unit.decode(reader, reader.uint32()));
                        break;
                    }
                case 4: {
                        message.win = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("win"))
                throw $util.ProtocolError("missing required 'win'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a pb_wlog message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_wlog
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_wlog} pb_wlog
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_wlog.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_wlog message.
         * @function verify
         * @memberof pb_wlog
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_wlog.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.vid != null && message.hasOwnProperty("vid"))
                if (!$util.isInteger(message.vid) && !(message.vid && $util.isInteger(message.vid.low) && $util.isInteger(message.vid.high)))
                    return "vid: integer|Long expected";
            if (message.atk != null && message.hasOwnProperty("atk")) {
                if (!Array.isArray(message.atk))
                    return "atk: array expected";
                for (var i = 0; i < message.atk.length; ++i) {
                    var error = $root.pb_unit.verify(message.atk[i]);
                    if (error)
                        return "atk." + error;
                }
            }
            if (message.def != null && message.hasOwnProperty("def")) {
                if (!Array.isArray(message.def))
                    return "def: array expected";
                for (var i = 0; i < message.def.length; ++i) {
                    var error = $root.pb_unit.verify(message.def[i]);
                    if (error)
                        return "def." + error;
                }
            }
            if (typeof message.win !== "boolean")
                return "win: boolean expected";
            return null;
        };
    
        /**
         * Creates a pb_wlog message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_wlog
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_wlog} pb_wlog
         */
        pb_wlog.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_wlog)
                return object;
            var message = new $root.pb_wlog();
            if (object.vid != null)
                if ($util.Long)
                    (message.vid = $util.Long.fromValue(object.vid)).unsigned = false;
                else if (typeof object.vid === "string")
                    message.vid = parseInt(object.vid, 10);
                else if (typeof object.vid === "number")
                    message.vid = object.vid;
                else if (typeof object.vid === "object")
                    message.vid = new $util.LongBits(object.vid.low >>> 0, object.vid.high >>> 0).toNumber();
            if (object.atk) {
                if (!Array.isArray(object.atk))
                    throw TypeError(".pb_wlog.atk: array expected");
                message.atk = [];
                for (var i = 0; i < object.atk.length; ++i) {
                    if (typeof object.atk[i] !== "object")
                        throw TypeError(".pb_wlog.atk: object expected");
                    message.atk[i] = $root.pb_unit.fromObject(object.atk[i]);
                }
            }
            if (object.def) {
                if (!Array.isArray(object.def))
                    throw TypeError(".pb_wlog.def: array expected");
                message.def = [];
                for (var i = 0; i < object.def.length; ++i) {
                    if (typeof object.def[i] !== "object")
                        throw TypeError(".pb_wlog.def: object expected");
                    message.def[i] = $root.pb_unit.fromObject(object.def[i]);
                }
            }
            if (object.win != null)
                message.win = Boolean(object.win);
            return message;
        };
    
        /**
         * Creates a plain object from a pb_wlog message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_wlog
         * @static
         * @param {pb_wlog} message pb_wlog
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_wlog.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.atk = [];
                object.def = [];
            }
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.vid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.vid = options.longs === String ? "0" : 0;
                object.win = false;
            }
            if (message.vid != null && message.hasOwnProperty("vid"))
                if (typeof message.vid === "number")
                    object.vid = options.longs === String ? String(message.vid) : message.vid;
                else
                    object.vid = options.longs === String ? $util.Long.prototype.toString.call(message.vid) : options.longs === Number ? new $util.LongBits(message.vid.low >>> 0, message.vid.high >>> 0).toNumber() : message.vid;
            if (message.atk && message.atk.length) {
                object.atk = [];
                for (var j = 0; j < message.atk.length; ++j)
                    object.atk[j] = $root.pb_unit.toObject(message.atk[j], options);
            }
            if (message.def && message.def.length) {
                object.def = [];
                for (var j = 0; j < message.def.length; ++j)
                    object.def[j] = $root.pb_unit.toObject(message.def[j], options);
            }
            if (message.win != null && message.hasOwnProperty("win"))
                object.win = message.win;
            return object;
        };
    
        /**
         * Converts this pb_wlog to JSON.
         * @function toJSON
         * @memberof pb_wlog
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_wlog.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_wlog
         * @function getTypeUrl
         * @memberof pb_wlog
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_wlog.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_wlog";
        };
    
        return pb_wlog;
    })();
    
    $root.pb_wvideo = (function() {
    
        /**
         * Properties of a pb_wvideo.
         * @exports Ipb_wvideo
         * @interface Ipb_wvideo
         * @property {Array.<Ipb_unit>|null} [atk] pb_wvideo atk
         * @property {Array.<Ipb_unit>|null} [def] pb_wvideo def
         * @property {Array.<Uint8Array>|null} [frames] pb_wvideo frames
         * @property {Array.<Ipb_hurts>|null} [hurts] pb_wvideo hurts
         * @property {boolean} win pb_wvideo win
         */
    
        /**
         * Constructs a new pb_wvideo.
         * @exports pb_wvideo
         * @classdesc Represents a pb_wvideo.
         * @implements Ipb_wvideo
         * @constructor
         * @param {Ipb_wvideo=} [properties] Properties to set
         */
        function pb_wvideo(properties) {
            this.atk = [];
            this.def = [];
            this.frames = [];
            this.hurts = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_wvideo atk.
         * @member {Array.<Ipb_unit>} atk
         * @memberof pb_wvideo
         * @instance
         */
        pb_wvideo.prototype.atk = $util.emptyArray;
    
        /**
         * pb_wvideo def.
         * @member {Array.<Ipb_unit>} def
         * @memberof pb_wvideo
         * @instance
         */
        pb_wvideo.prototype.def = $util.emptyArray;
    
        /**
         * pb_wvideo frames.
         * @member {Array.<Uint8Array>} frames
         * @memberof pb_wvideo
         * @instance
         */
        pb_wvideo.prototype.frames = $util.emptyArray;
    
        /**
         * pb_wvideo hurts.
         * @member {Array.<Ipb_hurts>} hurts
         * @memberof pb_wvideo
         * @instance
         */
        pb_wvideo.prototype.hurts = $util.emptyArray;
    
        /**
         * pb_wvideo win.
         * @member {boolean} win
         * @memberof pb_wvideo
         * @instance
         */
        pb_wvideo.prototype.win = false;
    
        /**
         * Creates a new pb_wvideo instance using the specified properties.
         * @function create
         * @memberof pb_wvideo
         * @static
         * @param {Ipb_wvideo=} [properties] Properties to set
         * @returns {pb_wvideo} pb_wvideo instance
         */
        pb_wvideo.create = function create(properties) {
            return new pb_wvideo(properties);
        };
    
        /**
         * Encodes the specified pb_wvideo message. Does not implicitly {@link pb_wvideo.verify|verify} messages.
         * @function encode
         * @memberof pb_wvideo
         * @static
         * @param {Ipb_wvideo} message pb_wvideo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_wvideo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.atk != null && message.atk.length)
                for (var i = 0; i < message.atk.length; ++i)
                    $root.pb_unit.encode(message.atk[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.def != null && message.def.length)
                for (var i = 0; i < message.def.length; ++i)
                    $root.pb_unit.encode(message.def[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.frames != null && message.frames.length)
                for (var i = 0; i < message.frames.length; ++i)
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.frames[i]);
            if (message.hurts != null && message.hurts.length)
                for (var i = 0; i < message.hurts.length; ++i)
                    $root.pb_hurts.encode(message.hurts[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            writer.uint32(/* id 5, wireType 0 =*/40).bool(message.win);
            return writer;
        };
    
        /**
         * Encodes the specified pb_wvideo message, length delimited. Does not implicitly {@link pb_wvideo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_wvideo
         * @static
         * @param {Ipb_wvideo} message pb_wvideo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_wvideo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_wvideo message from the specified reader or buffer.
         * @function decode
         * @memberof pb_wvideo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_wvideo} pb_wvideo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_wvideo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_wvideo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.atk && message.atk.length))
                            message.atk = [];
                        message.atk.push($root.pb_unit.decode(reader, reader.uint32()));
                        break;
                    }
                case 2: {
                        if (!(message.def && message.def.length))
                            message.def = [];
                        message.def.push($root.pb_unit.decode(reader, reader.uint32()));
                        break;
                    }
                case 3: {
                        if (!(message.frames && message.frames.length))
                            message.frames = [];
                        message.frames.push(reader.bytes());
                        break;
                    }
                case 4: {
                        if (!(message.hurts && message.hurts.length))
                            message.hurts = [];
                        message.hurts.push($root.pb_hurts.decode(reader, reader.uint32()));
                        break;
                    }
                case 5: {
                        message.win = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("win"))
                throw $util.ProtocolError("missing required 'win'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a pb_wvideo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_wvideo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_wvideo} pb_wvideo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_wvideo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_wvideo message.
         * @function verify
         * @memberof pb_wvideo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_wvideo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.atk != null && message.hasOwnProperty("atk")) {
                if (!Array.isArray(message.atk))
                    return "atk: array expected";
                for (var i = 0; i < message.atk.length; ++i) {
                    var error = $root.pb_unit.verify(message.atk[i]);
                    if (error)
                        return "atk." + error;
                }
            }
            if (message.def != null && message.hasOwnProperty("def")) {
                if (!Array.isArray(message.def))
                    return "def: array expected";
                for (var i = 0; i < message.def.length; ++i) {
                    var error = $root.pb_unit.verify(message.def[i]);
                    if (error)
                        return "def." + error;
                }
            }
            if (message.frames != null && message.hasOwnProperty("frames")) {
                if (!Array.isArray(message.frames))
                    return "frames: array expected";
                for (var i = 0; i < message.frames.length; ++i)
                    if (!(message.frames[i] && typeof message.frames[i].length === "number" || $util.isString(message.frames[i])))
                        return "frames: buffer[] expected";
            }
            if (message.hurts != null && message.hasOwnProperty("hurts")) {
                if (!Array.isArray(message.hurts))
                    return "hurts: array expected";
                for (var i = 0; i < message.hurts.length; ++i) {
                    var error = $root.pb_hurts.verify(message.hurts[i]);
                    if (error)
                        return "hurts." + error;
                }
            }
            if (typeof message.win !== "boolean")
                return "win: boolean expected";
            return null;
        };
    
        /**
         * Creates a pb_wvideo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_wvideo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_wvideo} pb_wvideo
         */
        pb_wvideo.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_wvideo)
                return object;
            var message = new $root.pb_wvideo();
            if (object.atk) {
                if (!Array.isArray(object.atk))
                    throw TypeError(".pb_wvideo.atk: array expected");
                message.atk = [];
                for (var i = 0; i < object.atk.length; ++i) {
                    if (typeof object.atk[i] !== "object")
                        throw TypeError(".pb_wvideo.atk: object expected");
                    message.atk[i] = $root.pb_unit.fromObject(object.atk[i]);
                }
            }
            if (object.def) {
                if (!Array.isArray(object.def))
                    throw TypeError(".pb_wvideo.def: array expected");
                message.def = [];
                for (var i = 0; i < object.def.length; ++i) {
                    if (typeof object.def[i] !== "object")
                        throw TypeError(".pb_wvideo.def: object expected");
                    message.def[i] = $root.pb_unit.fromObject(object.def[i]);
                }
            }
            if (object.frames) {
                if (!Array.isArray(object.frames))
                    throw TypeError(".pb_wvideo.frames: array expected");
                message.frames = [];
                for (var i = 0; i < object.frames.length; ++i)
                    if (typeof object.frames[i] === "string")
                        $util.base64.decode(object.frames[i], message.frames[i] = $util.newBuffer($util.base64.length(object.frames[i])), 0);
                    else if (object.frames[i].length >= 0)
                        message.frames[i] = object.frames[i];
            }
            if (object.hurts) {
                if (!Array.isArray(object.hurts))
                    throw TypeError(".pb_wvideo.hurts: array expected");
                message.hurts = [];
                for (var i = 0; i < object.hurts.length; ++i) {
                    if (typeof object.hurts[i] !== "object")
                        throw TypeError(".pb_wvideo.hurts: object expected");
                    message.hurts[i] = $root.pb_hurts.fromObject(object.hurts[i]);
                }
            }
            if (object.win != null)
                message.win = Boolean(object.win);
            return message;
        };
    
        /**
         * Creates a plain object from a pb_wvideo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_wvideo
         * @static
         * @param {pb_wvideo} message pb_wvideo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_wvideo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.atk = [];
                object.def = [];
                object.frames = [];
                object.hurts = [];
            }
            if (options.defaults)
                object.win = false;
            if (message.atk && message.atk.length) {
                object.atk = [];
                for (var j = 0; j < message.atk.length; ++j)
                    object.atk[j] = $root.pb_unit.toObject(message.atk[j], options);
            }
            if (message.def && message.def.length) {
                object.def = [];
                for (var j = 0; j < message.def.length; ++j)
                    object.def[j] = $root.pb_unit.toObject(message.def[j], options);
            }
            if (message.frames && message.frames.length) {
                object.frames = [];
                for (var j = 0; j < message.frames.length; ++j)
                    object.frames[j] = options.bytes === String ? $util.base64.encode(message.frames[j], 0, message.frames[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.frames[j]) : message.frames[j];
            }
            if (message.hurts && message.hurts.length) {
                object.hurts = [];
                for (var j = 0; j < message.hurts.length; ++j)
                    object.hurts[j] = $root.pb_hurts.toObject(message.hurts[j], options);
            }
            if (message.win != null && message.hasOwnProperty("win"))
                object.win = message.win;
            return object;
        };
    
        /**
         * Converts this pb_wvideo to JSON.
         * @function toJSON
         * @memberof pb_wvideo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_wvideo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_wvideo
         * @function getTypeUrl
         * @memberof pb_wvideo
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_wvideo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_wvideo";
        };
    
        return pb_wvideo;
    })();
    
    $root.pb_wscore = (function() {
    
        /**
         * Properties of a pb_wscore.
         * @exports Ipb_wscore
         * @interface Ipb_wscore
         * @property {number} score pb_wscore score
         * @property {number} delta pb_wscore delta
         * @property {boolean|null} [king] pb_wscore king
         */
    
        /**
         * Constructs a new pb_wscore.
         * @exports pb_wscore
         * @classdesc Represents a pb_wscore.
         * @implements Ipb_wscore
         * @constructor
         * @param {Ipb_wscore=} [properties] Properties to set
         */
        function pb_wscore(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_wscore score.
         * @member {number} score
         * @memberof pb_wscore
         * @instance
         */
        pb_wscore.prototype.score = 0;
    
        /**
         * pb_wscore delta.
         * @member {number} delta
         * @memberof pb_wscore
         * @instance
         */
        pb_wscore.prototype.delta = 0;
    
        /**
         * pb_wscore king.
         * @member {boolean} king
         * @memberof pb_wscore
         * @instance
         */
        pb_wscore.prototype.king = false;
    
        /**
         * Creates a new pb_wscore instance using the specified properties.
         * @function create
         * @memberof pb_wscore
         * @static
         * @param {Ipb_wscore=} [properties] Properties to set
         * @returns {pb_wscore} pb_wscore instance
         */
        pb_wscore.create = function create(properties) {
            return new pb_wscore(properties);
        };
    
        /**
         * Encodes the specified pb_wscore message. Does not implicitly {@link pb_wscore.verify|verify} messages.
         * @function encode
         * @memberof pb_wscore
         * @static
         * @param {Ipb_wscore} message pb_wscore message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_wscore.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).sint32(message.score);
            writer.uint32(/* id 2, wireType 0 =*/16).sint32(message.delta);
            if (message.king != null && Object.hasOwnProperty.call(message, "king"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.king);
            return writer;
        };
    
        /**
         * Encodes the specified pb_wscore message, length delimited. Does not implicitly {@link pb_wscore.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_wscore
         * @static
         * @param {Ipb_wscore} message pb_wscore message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_wscore.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_wscore message from the specified reader or buffer.
         * @function decode
         * @memberof pb_wscore
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_wscore} pb_wscore
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_wscore.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_wscore();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.score = reader.sint32();
                        break;
                    }
                case 2: {
                        message.delta = reader.sint32();
                        break;
                    }
                case 3: {
                        message.king = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("score"))
                throw $util.ProtocolError("missing required 'score'", { instance: message });
            if (!message.hasOwnProperty("delta"))
                throw $util.ProtocolError("missing required 'delta'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a pb_wscore message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_wscore
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_wscore} pb_wscore
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_wscore.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_wscore message.
         * @function verify
         * @memberof pb_wscore
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_wscore.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.score))
                return "score: integer expected";
            if (!$util.isInteger(message.delta))
                return "delta: integer expected";
            if (message.king != null && message.hasOwnProperty("king"))
                if (typeof message.king !== "boolean")
                    return "king: boolean expected";
            return null;
        };
    
        /**
         * Creates a pb_wscore message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_wscore
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_wscore} pb_wscore
         */
        pb_wscore.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_wscore)
                return object;
            var message = new $root.pb_wscore();
            if (object.score != null)
                message.score = object.score | 0;
            if (object.delta != null)
                message.delta = object.delta | 0;
            if (object.king != null)
                message.king = Boolean(object.king);
            return message;
        };
    
        /**
         * Creates a plain object from a pb_wscore message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_wscore
         * @static
         * @param {pb_wscore} message pb_wscore
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_wscore.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.score = 0;
                object.delta = 0;
                object.king = false;
            }
            if (message.score != null && message.hasOwnProperty("score"))
                object.score = message.score;
            if (message.delta != null && message.hasOwnProperty("delta"))
                object.delta = message.delta;
            if (message.king != null && message.hasOwnProperty("king"))
                object.king = message.king;
            return object;
        };
    
        /**
         * Converts this pb_wscore to JSON.
         * @function toJSON
         * @memberof pb_wscore
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_wscore.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_wscore
         * @function getTypeUrl
         * @memberof pb_wscore
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_wscore.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_wscore";
        };
    
        return pb_wscore;
    })();
    
    $root.pb_wcamp = (function() {
    
        /**
         * Properties of a pb_wcamp.
         * @exports Ipb_wcamp
         * @interface Ipb_wcamp
         * @property {Array.<Ipb_unit>|null} [camp] pb_wcamp camp
         */
    
        /**
         * Constructs a new pb_wcamp.
         * @exports pb_wcamp
         * @classdesc Represents a pb_wcamp.
         * @implements Ipb_wcamp
         * @constructor
         * @param {Ipb_wcamp=} [properties] Properties to set
         */
        function pb_wcamp(properties) {
            this.camp = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_wcamp camp.
         * @member {Array.<Ipb_unit>} camp
         * @memberof pb_wcamp
         * @instance
         */
        pb_wcamp.prototype.camp = $util.emptyArray;
    
        /**
         * Creates a new pb_wcamp instance using the specified properties.
         * @function create
         * @memberof pb_wcamp
         * @static
         * @param {Ipb_wcamp=} [properties] Properties to set
         * @returns {pb_wcamp} pb_wcamp instance
         */
        pb_wcamp.create = function create(properties) {
            return new pb_wcamp(properties);
        };
    
        /**
         * Encodes the specified pb_wcamp message. Does not implicitly {@link pb_wcamp.verify|verify} messages.
         * @function encode
         * @memberof pb_wcamp
         * @static
         * @param {Ipb_wcamp} message pb_wcamp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_wcamp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.camp != null && message.camp.length)
                for (var i = 0; i < message.camp.length; ++i)
                    $root.pb_unit.encode(message.camp[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified pb_wcamp message, length delimited. Does not implicitly {@link pb_wcamp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_wcamp
         * @static
         * @param {Ipb_wcamp} message pb_wcamp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_wcamp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_wcamp message from the specified reader or buffer.
         * @function decode
         * @memberof pb_wcamp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_wcamp} pb_wcamp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_wcamp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_wcamp();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.camp && message.camp.length))
                            message.camp = [];
                        message.camp.push($root.pb_unit.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a pb_wcamp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_wcamp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_wcamp} pb_wcamp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_wcamp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_wcamp message.
         * @function verify
         * @memberof pb_wcamp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_wcamp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.camp != null && message.hasOwnProperty("camp")) {
                if (!Array.isArray(message.camp))
                    return "camp: array expected";
                for (var i = 0; i < message.camp.length; ++i) {
                    var error = $root.pb_unit.verify(message.camp[i]);
                    if (error)
                        return "camp." + error;
                }
            }
            return null;
        };
    
        /**
         * Creates a pb_wcamp message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_wcamp
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_wcamp} pb_wcamp
         */
        pb_wcamp.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_wcamp)
                return object;
            var message = new $root.pb_wcamp();
            if (object.camp) {
                if (!Array.isArray(object.camp))
                    throw TypeError(".pb_wcamp.camp: array expected");
                message.camp = [];
                for (var i = 0; i < object.camp.length; ++i) {
                    if (typeof object.camp[i] !== "object")
                        throw TypeError(".pb_wcamp.camp: object expected");
                    message.camp[i] = $root.pb_unit.fromObject(object.camp[i]);
                }
            }
            return message;
        };
    
        /**
         * Creates a plain object from a pb_wcamp message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_wcamp
         * @static
         * @param {pb_wcamp} message pb_wcamp
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_wcamp.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.camp = [];
            if (message.camp && message.camp.length) {
                object.camp = [];
                for (var j = 0; j < message.camp.length; ++j)
                    object.camp[j] = $root.pb_unit.toObject(message.camp[j], options);
            }
            return object;
        };
    
        /**
         * Converts this pb_wcamp to JSON.
         * @function toJSON
         * @memberof pb_wcamp
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_wcamp.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_wcamp
         * @function getTypeUrl
         * @memberof pb_wcamp
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_wcamp.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_wcamp";
        };
    
        return pb_wcamp;
    })();
    
    $root.pb_wloger = (function() {
    
        /**
         * Properties of a pb_wloger.
         * @exports Ipb_wloger
         * @interface Ipb_wloger
         * @property {number|Long} vid pb_wloger vid
         * @property {Ipb_wmbr|null} [mbr] pb_wloger mbr
         * @property {number|null} [time] pb_wloger time
         * @property {boolean|null} [atk] pb_wloger atk
         * @property {boolean|null} [win] pb_wloger win
         * @property {number|null} [delta] pb_wloger delta
         */
    
        /**
         * Constructs a new pb_wloger.
         * @exports pb_wloger
         * @classdesc Represents a pb_wloger.
         * @implements Ipb_wloger
         * @constructor
         * @param {Ipb_wloger=} [properties] Properties to set
         */
        function pb_wloger(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_wloger vid.
         * @member {number|Long} vid
         * @memberof pb_wloger
         * @instance
         */
        pb_wloger.prototype.vid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * pb_wloger mbr.
         * @member {Ipb_wmbr|null|undefined} mbr
         * @memberof pb_wloger
         * @instance
         */
        pb_wloger.prototype.mbr = null;
    
        /**
         * pb_wloger time.
         * @member {number} time
         * @memberof pb_wloger
         * @instance
         */
        pb_wloger.prototype.time = 0;
    
        /**
         * pb_wloger atk.
         * @member {boolean} atk
         * @memberof pb_wloger
         * @instance
         */
        pb_wloger.prototype.atk = false;
    
        /**
         * pb_wloger win.
         * @member {boolean} win
         * @memberof pb_wloger
         * @instance
         */
        pb_wloger.prototype.win = false;
    
        /**
         * pb_wloger delta.
         * @member {number} delta
         * @memberof pb_wloger
         * @instance
         */
        pb_wloger.prototype.delta = 0;
    
        /**
         * Creates a new pb_wloger instance using the specified properties.
         * @function create
         * @memberof pb_wloger
         * @static
         * @param {Ipb_wloger=} [properties] Properties to set
         * @returns {pb_wloger} pb_wloger instance
         */
        pb_wloger.create = function create(properties) {
            return new pb_wloger(properties);
        };
    
        /**
         * Encodes the specified pb_wloger message. Does not implicitly {@link pb_wloger.verify|verify} messages.
         * @function encode
         * @memberof pb_wloger
         * @static
         * @param {Ipb_wloger} message pb_wloger message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_wloger.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int64(message.vid);
            if (message.mbr != null && Object.hasOwnProperty.call(message, "mbr"))
                $root.pb_wmbr.encode(message.mbr, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.time != null && Object.hasOwnProperty.call(message, "time"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.time);
            if (message.atk != null && Object.hasOwnProperty.call(message, "atk"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.atk);
            if (message.win != null && Object.hasOwnProperty.call(message, "win"))
                writer.uint32(/* id 5, wireType 0 =*/40).bool(message.win);
            if (message.delta != null && Object.hasOwnProperty.call(message, "delta"))
                writer.uint32(/* id 6, wireType 0 =*/48).sint32(message.delta);
            return writer;
        };
    
        /**
         * Encodes the specified pb_wloger message, length delimited. Does not implicitly {@link pb_wloger.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_wloger
         * @static
         * @param {Ipb_wloger} message pb_wloger message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_wloger.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_wloger message from the specified reader or buffer.
         * @function decode
         * @memberof pb_wloger
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_wloger} pb_wloger
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_wloger.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_wloger();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.vid = reader.int64();
                        break;
                    }
                case 2: {
                        message.mbr = $root.pb_wmbr.decode(reader, reader.uint32());
                        break;
                    }
                case 3: {
                        message.time = reader.int32();
                        break;
                    }
                case 4: {
                        message.atk = reader.bool();
                        break;
                    }
                case 5: {
                        message.win = reader.bool();
                        break;
                    }
                case 6: {
                        message.delta = reader.sint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("vid"))
                throw $util.ProtocolError("missing required 'vid'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a pb_wloger message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_wloger
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_wloger} pb_wloger
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_wloger.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_wloger message.
         * @function verify
         * @memberof pb_wloger
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_wloger.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.vid) && !(message.vid && $util.isInteger(message.vid.low) && $util.isInteger(message.vid.high)))
                return "vid: integer|Long expected";
            if (message.mbr != null && message.hasOwnProperty("mbr")) {
                var error = $root.pb_wmbr.verify(message.mbr);
                if (error)
                    return "mbr." + error;
            }
            if (message.time != null && message.hasOwnProperty("time"))
                if (!$util.isInteger(message.time))
                    return "time: integer expected";
            if (message.atk != null && message.hasOwnProperty("atk"))
                if (typeof message.atk !== "boolean")
                    return "atk: boolean expected";
            if (message.win != null && message.hasOwnProperty("win"))
                if (typeof message.win !== "boolean")
                    return "win: boolean expected";
            if (message.delta != null && message.hasOwnProperty("delta"))
                if (!$util.isInteger(message.delta))
                    return "delta: integer expected";
            return null;
        };
    
        /**
         * Creates a pb_wloger message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_wloger
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_wloger} pb_wloger
         */
        pb_wloger.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_wloger)
                return object;
            var message = new $root.pb_wloger();
            if (object.vid != null)
                if ($util.Long)
                    (message.vid = $util.Long.fromValue(object.vid)).unsigned = false;
                else if (typeof object.vid === "string")
                    message.vid = parseInt(object.vid, 10);
                else if (typeof object.vid === "number")
                    message.vid = object.vid;
                else if (typeof object.vid === "object")
                    message.vid = new $util.LongBits(object.vid.low >>> 0, object.vid.high >>> 0).toNumber();
            if (object.mbr != null) {
                if (typeof object.mbr !== "object")
                    throw TypeError(".pb_wloger.mbr: object expected");
                message.mbr = $root.pb_wmbr.fromObject(object.mbr);
            }
            if (object.time != null)
                message.time = object.time | 0;
            if (object.atk != null)
                message.atk = Boolean(object.atk);
            if (object.win != null)
                message.win = Boolean(object.win);
            if (object.delta != null)
                message.delta = object.delta | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a pb_wloger message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_wloger
         * @static
         * @param {pb_wloger} message pb_wloger
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_wloger.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.vid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.vid = options.longs === String ? "0" : 0;
                object.mbr = null;
                object.time = 0;
                object.atk = false;
                object.win = false;
                object.delta = 0;
            }
            if (message.vid != null && message.hasOwnProperty("vid"))
                if (typeof message.vid === "number")
                    object.vid = options.longs === String ? String(message.vid) : message.vid;
                else
                    object.vid = options.longs === String ? $util.Long.prototype.toString.call(message.vid) : options.longs === Number ? new $util.LongBits(message.vid.low >>> 0, message.vid.high >>> 0).toNumber() : message.vid;
            if (message.mbr != null && message.hasOwnProperty("mbr"))
                object.mbr = $root.pb_wmbr.toObject(message.mbr, options);
            if (message.time != null && message.hasOwnProperty("time"))
                object.time = message.time;
            if (message.atk != null && message.hasOwnProperty("atk"))
                object.atk = message.atk;
            if (message.win != null && message.hasOwnProperty("win"))
                object.win = message.win;
            if (message.delta != null && message.hasOwnProperty("delta"))
                object.delta = message.delta;
            return object;
        };
    
        /**
         * Converts this pb_wloger to JSON.
         * @function toJSON
         * @memberof pb_wloger
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_wloger.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_wloger
         * @function getTypeUrl
         * @memberof pb_wloger
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_wloger.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_wloger";
        };
    
        return pb_wloger;
    })();
    
    $root.pb_pvideo = (function() {
    
        /**
         * Properties of a pb_pvideo.
         * @exports Ipb_pvideo
         * @interface Ipb_pvideo
         * @property {number|null} [id] pb_pvideo id
         * @property {Ipb_pmbr|null} [atk] pb_pvideo atk
         * @property {Ipb_pmbr|null} [def] pb_pvideo def
         * @property {boolean} win pb_pvideo win
         * @property {Array.<Uint8Array>|null} [frames] pb_pvideo frames
         * @property {number|null} [ascore] pb_pvideo ascore
         * @property {number|null} [dscore] pb_pvideo dscore
         * @property {number|null} [adelta] pb_pvideo adelta
         * @property {number|null} [ddelta] pb_pvideo ddelta
         * @property {Array.<Ipb_hurts>|null} [hurts] pb_pvideo hurts
         * @property {Array.<Ipb_bag>|null} [rewards] pb_pvideo rewards
         * @property {number|null} [select] pb_pvideo select
         */
    
        /**
         * Constructs a new pb_pvideo.
         * @exports pb_pvideo
         * @classdesc Represents a pb_pvideo.
         * @implements Ipb_pvideo
         * @constructor
         * @param {Ipb_pvideo=} [properties] Properties to set
         */
        function pb_pvideo(properties) {
            this.frames = [];
            this.hurts = [];
            this.rewards = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_pvideo id.
         * @member {number} id
         * @memberof pb_pvideo
         * @instance
         */
        pb_pvideo.prototype.id = 0;
    
        /**
         * pb_pvideo atk.
         * @member {Ipb_pmbr|null|undefined} atk
         * @memberof pb_pvideo
         * @instance
         */
        pb_pvideo.prototype.atk = null;
    
        /**
         * pb_pvideo def.
         * @member {Ipb_pmbr|null|undefined} def
         * @memberof pb_pvideo
         * @instance
         */
        pb_pvideo.prototype.def = null;
    
        /**
         * pb_pvideo win.
         * @member {boolean} win
         * @memberof pb_pvideo
         * @instance
         */
        pb_pvideo.prototype.win = false;
    
        /**
         * pb_pvideo frames.
         * @member {Array.<Uint8Array>} frames
         * @memberof pb_pvideo
         * @instance
         */
        pb_pvideo.prototype.frames = $util.emptyArray;
    
        /**
         * pb_pvideo ascore.
         * @member {number} ascore
         * @memberof pb_pvideo
         * @instance
         */
        pb_pvideo.prototype.ascore = 0;
    
        /**
         * pb_pvideo dscore.
         * @member {number} dscore
         * @memberof pb_pvideo
         * @instance
         */
        pb_pvideo.prototype.dscore = 0;
    
        /**
         * pb_pvideo adelta.
         * @member {number} adelta
         * @memberof pb_pvideo
         * @instance
         */
        pb_pvideo.prototype.adelta = 0;
    
        /**
         * pb_pvideo ddelta.
         * @member {number} ddelta
         * @memberof pb_pvideo
         * @instance
         */
        pb_pvideo.prototype.ddelta = 0;
    
        /**
         * pb_pvideo hurts.
         * @member {Array.<Ipb_hurts>} hurts
         * @memberof pb_pvideo
         * @instance
         */
        pb_pvideo.prototype.hurts = $util.emptyArray;
    
        /**
         * pb_pvideo rewards.
         * @member {Array.<Ipb_bag>} rewards
         * @memberof pb_pvideo
         * @instance
         */
        pb_pvideo.prototype.rewards = $util.emptyArray;
    
        /**
         * pb_pvideo select.
         * @member {number} select
         * @memberof pb_pvideo
         * @instance
         */
        pb_pvideo.prototype.select = 0;
    
        /**
         * Creates a new pb_pvideo instance using the specified properties.
         * @function create
         * @memberof pb_pvideo
         * @static
         * @param {Ipb_pvideo=} [properties] Properties to set
         * @returns {pb_pvideo} pb_pvideo instance
         */
        pb_pvideo.create = function create(properties) {
            return new pb_pvideo(properties);
        };
    
        /**
         * Encodes the specified pb_pvideo message. Does not implicitly {@link pb_pvideo.verify|verify} messages.
         * @function encode
         * @memberof pb_pvideo
         * @static
         * @param {Ipb_pvideo} message pb_pvideo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_pvideo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.id);
            if (message.atk != null && Object.hasOwnProperty.call(message, "atk"))
                $root.pb_pmbr.encode(message.atk, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.def != null && Object.hasOwnProperty.call(message, "def"))
                $root.pb_pmbr.encode(message.def, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            writer.uint32(/* id 4, wireType 0 =*/32).bool(message.win);
            if (message.frames != null && message.frames.length)
                for (var i = 0; i < message.frames.length; ++i)
                    writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.frames[i]);
            if (message.ascore != null && Object.hasOwnProperty.call(message, "ascore"))
                writer.uint32(/* id 6, wireType 0 =*/48).sint32(message.ascore);
            if (message.dscore != null && Object.hasOwnProperty.call(message, "dscore"))
                writer.uint32(/* id 7, wireType 0 =*/56).sint32(message.dscore);
            if (message.adelta != null && Object.hasOwnProperty.call(message, "adelta"))
                writer.uint32(/* id 8, wireType 0 =*/64).sint32(message.adelta);
            if (message.ddelta != null && Object.hasOwnProperty.call(message, "ddelta"))
                writer.uint32(/* id 9, wireType 0 =*/72).sint32(message.ddelta);
            if (message.hurts != null && message.hurts.length)
                for (var i = 0; i < message.hurts.length; ++i)
                    $root.pb_hurts.encode(message.hurts[i], writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
            if (message.rewards != null && message.rewards.length)
                for (var i = 0; i < message.rewards.length; ++i)
                    $root.pb_bag.encode(message.rewards[i], writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
            if (message.select != null && Object.hasOwnProperty.call(message, "select"))
                writer.uint32(/* id 12, wireType 0 =*/96).int32(message.select);
            return writer;
        };
    
        /**
         * Encodes the specified pb_pvideo message, length delimited. Does not implicitly {@link pb_pvideo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_pvideo
         * @static
         * @param {Ipb_pvideo} message pb_pvideo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_pvideo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_pvideo message from the specified reader or buffer.
         * @function decode
         * @memberof pb_pvideo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_pvideo} pb_pvideo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_pvideo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_pvideo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.id = reader.int32();
                        break;
                    }
                case 2: {
                        message.atk = $root.pb_pmbr.decode(reader, reader.uint32());
                        break;
                    }
                case 3: {
                        message.def = $root.pb_pmbr.decode(reader, reader.uint32());
                        break;
                    }
                case 4: {
                        message.win = reader.bool();
                        break;
                    }
                case 5: {
                        if (!(message.frames && message.frames.length))
                            message.frames = [];
                        message.frames.push(reader.bytes());
                        break;
                    }
                case 6: {
                        message.ascore = reader.sint32();
                        break;
                    }
                case 7: {
                        message.dscore = reader.sint32();
                        break;
                    }
                case 8: {
                        message.adelta = reader.sint32();
                        break;
                    }
                case 9: {
                        message.ddelta = reader.sint32();
                        break;
                    }
                case 10: {
                        if (!(message.hurts && message.hurts.length))
                            message.hurts = [];
                        message.hurts.push($root.pb_hurts.decode(reader, reader.uint32()));
                        break;
                    }
                case 11: {
                        if (!(message.rewards && message.rewards.length))
                            message.rewards = [];
                        message.rewards.push($root.pb_bag.decode(reader, reader.uint32()));
                        break;
                    }
                case 12: {
                        message.select = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("win"))
                throw $util.ProtocolError("missing required 'win'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a pb_pvideo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_pvideo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_pvideo} pb_pvideo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_pvideo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_pvideo message.
         * @function verify
         * @memberof pb_pvideo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_pvideo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id))
                    return "id: integer expected";
            if (message.atk != null && message.hasOwnProperty("atk")) {
                var error = $root.pb_pmbr.verify(message.atk);
                if (error)
                    return "atk." + error;
            }
            if (message.def != null && message.hasOwnProperty("def")) {
                var error = $root.pb_pmbr.verify(message.def);
                if (error)
                    return "def." + error;
            }
            if (typeof message.win !== "boolean")
                return "win: boolean expected";
            if (message.frames != null && message.hasOwnProperty("frames")) {
                if (!Array.isArray(message.frames))
                    return "frames: array expected";
                for (var i = 0; i < message.frames.length; ++i)
                    if (!(message.frames[i] && typeof message.frames[i].length === "number" || $util.isString(message.frames[i])))
                        return "frames: buffer[] expected";
            }
            if (message.ascore != null && message.hasOwnProperty("ascore"))
                if (!$util.isInteger(message.ascore))
                    return "ascore: integer expected";
            if (message.dscore != null && message.hasOwnProperty("dscore"))
                if (!$util.isInteger(message.dscore))
                    return "dscore: integer expected";
            if (message.adelta != null && message.hasOwnProperty("adelta"))
                if (!$util.isInteger(message.adelta))
                    return "adelta: integer expected";
            if (message.ddelta != null && message.hasOwnProperty("ddelta"))
                if (!$util.isInteger(message.ddelta))
                    return "ddelta: integer expected";
            if (message.hurts != null && message.hasOwnProperty("hurts")) {
                if (!Array.isArray(message.hurts))
                    return "hurts: array expected";
                for (var i = 0; i < message.hurts.length; ++i) {
                    var error = $root.pb_hurts.verify(message.hurts[i]);
                    if (error)
                        return "hurts." + error;
                }
            }
            if (message.rewards != null && message.hasOwnProperty("rewards")) {
                if (!Array.isArray(message.rewards))
                    return "rewards: array expected";
                for (var i = 0; i < message.rewards.length; ++i) {
                    var error = $root.pb_bag.verify(message.rewards[i]);
                    if (error)
                        return "rewards." + error;
                }
            }
            if (message.select != null && message.hasOwnProperty("select"))
                if (!$util.isInteger(message.select))
                    return "select: integer expected";
            return null;
        };
    
        /**
         * Creates a pb_pvideo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_pvideo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_pvideo} pb_pvideo
         */
        pb_pvideo.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_pvideo)
                return object;
            var message = new $root.pb_pvideo();
            if (object.id != null)
                message.id = object.id | 0;
            if (object.atk != null) {
                if (typeof object.atk !== "object")
                    throw TypeError(".pb_pvideo.atk: object expected");
                message.atk = $root.pb_pmbr.fromObject(object.atk);
            }
            if (object.def != null) {
                if (typeof object.def !== "object")
                    throw TypeError(".pb_pvideo.def: object expected");
                message.def = $root.pb_pmbr.fromObject(object.def);
            }
            if (object.win != null)
                message.win = Boolean(object.win);
            if (object.frames) {
                if (!Array.isArray(object.frames))
                    throw TypeError(".pb_pvideo.frames: array expected");
                message.frames = [];
                for (var i = 0; i < object.frames.length; ++i)
                    if (typeof object.frames[i] === "string")
                        $util.base64.decode(object.frames[i], message.frames[i] = $util.newBuffer($util.base64.length(object.frames[i])), 0);
                    else if (object.frames[i].length >= 0)
                        message.frames[i] = object.frames[i];
            }
            if (object.ascore != null)
                message.ascore = object.ascore | 0;
            if (object.dscore != null)
                message.dscore = object.dscore | 0;
            if (object.adelta != null)
                message.adelta = object.adelta | 0;
            if (object.ddelta != null)
                message.ddelta = object.ddelta | 0;
            if (object.hurts) {
                if (!Array.isArray(object.hurts))
                    throw TypeError(".pb_pvideo.hurts: array expected");
                message.hurts = [];
                for (var i = 0; i < object.hurts.length; ++i) {
                    if (typeof object.hurts[i] !== "object")
                        throw TypeError(".pb_pvideo.hurts: object expected");
                    message.hurts[i] = $root.pb_hurts.fromObject(object.hurts[i]);
                }
            }
            if (object.rewards) {
                if (!Array.isArray(object.rewards))
                    throw TypeError(".pb_pvideo.rewards: array expected");
                message.rewards = [];
                for (var i = 0; i < object.rewards.length; ++i) {
                    if (typeof object.rewards[i] !== "object")
                        throw TypeError(".pb_pvideo.rewards: object expected");
                    message.rewards[i] = $root.pb_bag.fromObject(object.rewards[i]);
                }
            }
            if (object.select != null)
                message.select = object.select | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a pb_pvideo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_pvideo
         * @static
         * @param {pb_pvideo} message pb_pvideo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_pvideo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.frames = [];
                object.hurts = [];
                object.rewards = [];
            }
            if (options.defaults) {
                object.id = 0;
                object.atk = null;
                object.def = null;
                object.win = false;
                object.ascore = 0;
                object.dscore = 0;
                object.adelta = 0;
                object.ddelta = 0;
                object.select = 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.atk != null && message.hasOwnProperty("atk"))
                object.atk = $root.pb_pmbr.toObject(message.atk, options);
            if (message.def != null && message.hasOwnProperty("def"))
                object.def = $root.pb_pmbr.toObject(message.def, options);
            if (message.win != null && message.hasOwnProperty("win"))
                object.win = message.win;
            if (message.frames && message.frames.length) {
                object.frames = [];
                for (var j = 0; j < message.frames.length; ++j)
                    object.frames[j] = options.bytes === String ? $util.base64.encode(message.frames[j], 0, message.frames[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.frames[j]) : message.frames[j];
            }
            if (message.ascore != null && message.hasOwnProperty("ascore"))
                object.ascore = message.ascore;
            if (message.dscore != null && message.hasOwnProperty("dscore"))
                object.dscore = message.dscore;
            if (message.adelta != null && message.hasOwnProperty("adelta"))
                object.adelta = message.adelta;
            if (message.ddelta != null && message.hasOwnProperty("ddelta"))
                object.ddelta = message.ddelta;
            if (message.hurts && message.hurts.length) {
                object.hurts = [];
                for (var j = 0; j < message.hurts.length; ++j)
                    object.hurts[j] = $root.pb_hurts.toObject(message.hurts[j], options);
            }
            if (message.rewards && message.rewards.length) {
                object.rewards = [];
                for (var j = 0; j < message.rewards.length; ++j)
                    object.rewards[j] = $root.pb_bag.toObject(message.rewards[j], options);
            }
            if (message.select != null && message.hasOwnProperty("select"))
                object.select = message.select;
            return object;
        };
    
        /**
         * Converts this pb_pvideo to JSON.
         * @function toJSON
         * @memberof pb_pvideo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_pvideo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_pvideo
         * @function getTypeUrl
         * @memberof pb_pvideo
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_pvideo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_pvideo";
        };
    
        return pb_pvideo;
    })();
    
    $root.pb_p3pvideo = (function() {
    
        /**
         * Properties of a pb_p3pvideo.
         * @exports Ipb_p3pvideo
         * @interface Ipb_p3pvideo
         * @property {Ipb_p3pmbr|null} [atk] pb_p3pvideo atk
         * @property {Ipb_p3pmbr|null} [def] pb_p3pvideo def
         * @property {boolean} win pb_p3pvideo win
         * @property {Array.<Uint8Array>|null} [frames] pb_p3pvideo frames
         * @property {Array.<Ipb_hurts>|null} [hurts] pb_p3pvideo hurts
         * @property {number|null} [ascore] pb_p3pvideo ascore
         * @property {number|null} [dscore] pb_p3pvideo dscore
         * @property {number|null} [adelta] pb_p3pvideo adelta
         * @property {number|null} [ddelta] pb_p3pvideo ddelta
         * @property {Array.<Ipb_bag>|null} [rewards] pb_p3pvideo rewards
         * @property {number|null} [select] pb_p3pvideo select
         */
    
        /**
         * Constructs a new pb_p3pvideo.
         * @exports pb_p3pvideo
         * @classdesc Represents a pb_p3pvideo.
         * @implements Ipb_p3pvideo
         * @constructor
         * @param {Ipb_p3pvideo=} [properties] Properties to set
         */
        function pb_p3pvideo(properties) {
            this.frames = [];
            this.hurts = [];
            this.rewards = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_p3pvideo atk.
         * @member {Ipb_p3pmbr|null|undefined} atk
         * @memberof pb_p3pvideo
         * @instance
         */
        pb_p3pvideo.prototype.atk = null;
    
        /**
         * pb_p3pvideo def.
         * @member {Ipb_p3pmbr|null|undefined} def
         * @memberof pb_p3pvideo
         * @instance
         */
        pb_p3pvideo.prototype.def = null;
    
        /**
         * pb_p3pvideo win.
         * @member {boolean} win
         * @memberof pb_p3pvideo
         * @instance
         */
        pb_p3pvideo.prototype.win = false;
    
        /**
         * pb_p3pvideo frames.
         * @member {Array.<Uint8Array>} frames
         * @memberof pb_p3pvideo
         * @instance
         */
        pb_p3pvideo.prototype.frames = $util.emptyArray;
    
        /**
         * pb_p3pvideo hurts.
         * @member {Array.<Ipb_hurts>} hurts
         * @memberof pb_p3pvideo
         * @instance
         */
        pb_p3pvideo.prototype.hurts = $util.emptyArray;
    
        /**
         * pb_p3pvideo ascore.
         * @member {number} ascore
         * @memberof pb_p3pvideo
         * @instance
         */
        pb_p3pvideo.prototype.ascore = 0;
    
        /**
         * pb_p3pvideo dscore.
         * @member {number} dscore
         * @memberof pb_p3pvideo
         * @instance
         */
        pb_p3pvideo.prototype.dscore = 0;
    
        /**
         * pb_p3pvideo adelta.
         * @member {number} adelta
         * @memberof pb_p3pvideo
         * @instance
         */
        pb_p3pvideo.prototype.adelta = 0;
    
        /**
         * pb_p3pvideo ddelta.
         * @member {number} ddelta
         * @memberof pb_p3pvideo
         * @instance
         */
        pb_p3pvideo.prototype.ddelta = 0;
    
        /**
         * pb_p3pvideo rewards.
         * @member {Array.<Ipb_bag>} rewards
         * @memberof pb_p3pvideo
         * @instance
         */
        pb_p3pvideo.prototype.rewards = $util.emptyArray;
    
        /**
         * pb_p3pvideo select.
         * @member {number} select
         * @memberof pb_p3pvideo
         * @instance
         */
        pb_p3pvideo.prototype.select = 0;
    
        /**
         * Creates a new pb_p3pvideo instance using the specified properties.
         * @function create
         * @memberof pb_p3pvideo
         * @static
         * @param {Ipb_p3pvideo=} [properties] Properties to set
         * @returns {pb_p3pvideo} pb_p3pvideo instance
         */
        pb_p3pvideo.create = function create(properties) {
            return new pb_p3pvideo(properties);
        };
    
        /**
         * Encodes the specified pb_p3pvideo message. Does not implicitly {@link pb_p3pvideo.verify|verify} messages.
         * @function encode
         * @memberof pb_p3pvideo
         * @static
         * @param {Ipb_p3pvideo} message pb_p3pvideo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_p3pvideo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.atk != null && Object.hasOwnProperty.call(message, "atk"))
                $root.pb_p3pmbr.encode(message.atk, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.def != null && Object.hasOwnProperty.call(message, "def"))
                $root.pb_p3pmbr.encode(message.def, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            writer.uint32(/* id 3, wireType 0 =*/24).bool(message.win);
            if (message.frames != null && message.frames.length)
                for (var i = 0; i < message.frames.length; ++i)
                    writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.frames[i]);
            if (message.hurts != null && message.hurts.length)
                for (var i = 0; i < message.hurts.length; ++i)
                    $root.pb_hurts.encode(message.hurts[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.ascore != null && Object.hasOwnProperty.call(message, "ascore"))
                writer.uint32(/* id 6, wireType 0 =*/48).sint32(message.ascore);
            if (message.dscore != null && Object.hasOwnProperty.call(message, "dscore"))
                writer.uint32(/* id 7, wireType 0 =*/56).sint32(message.dscore);
            if (message.adelta != null && Object.hasOwnProperty.call(message, "adelta"))
                writer.uint32(/* id 8, wireType 0 =*/64).sint32(message.adelta);
            if (message.ddelta != null && Object.hasOwnProperty.call(message, "ddelta"))
                writer.uint32(/* id 9, wireType 0 =*/72).sint32(message.ddelta);
            if (message.rewards != null && message.rewards.length)
                for (var i = 0; i < message.rewards.length; ++i)
                    $root.pb_bag.encode(message.rewards[i], writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
            if (message.select != null && Object.hasOwnProperty.call(message, "select"))
                writer.uint32(/* id 11, wireType 0 =*/88).int32(message.select);
            return writer;
        };
    
        /**
         * Encodes the specified pb_p3pvideo message, length delimited. Does not implicitly {@link pb_p3pvideo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_p3pvideo
         * @static
         * @param {Ipb_p3pvideo} message pb_p3pvideo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_p3pvideo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_p3pvideo message from the specified reader or buffer.
         * @function decode
         * @memberof pb_p3pvideo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_p3pvideo} pb_p3pvideo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_p3pvideo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_p3pvideo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.atk = $root.pb_p3pmbr.decode(reader, reader.uint32());
                        break;
                    }
                case 2: {
                        message.def = $root.pb_p3pmbr.decode(reader, reader.uint32());
                        break;
                    }
                case 3: {
                        message.win = reader.bool();
                        break;
                    }
                case 4: {
                        if (!(message.frames && message.frames.length))
                            message.frames = [];
                        message.frames.push(reader.bytes());
                        break;
                    }
                case 5: {
                        if (!(message.hurts && message.hurts.length))
                            message.hurts = [];
                        message.hurts.push($root.pb_hurts.decode(reader, reader.uint32()));
                        break;
                    }
                case 6: {
                        message.ascore = reader.sint32();
                        break;
                    }
                case 7: {
                        message.dscore = reader.sint32();
                        break;
                    }
                case 8: {
                        message.adelta = reader.sint32();
                        break;
                    }
                case 9: {
                        message.ddelta = reader.sint32();
                        break;
                    }
                case 10: {
                        if (!(message.rewards && message.rewards.length))
                            message.rewards = [];
                        message.rewards.push($root.pb_bag.decode(reader, reader.uint32()));
                        break;
                    }
                case 11: {
                        message.select = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("win"))
                throw $util.ProtocolError("missing required 'win'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a pb_p3pvideo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_p3pvideo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_p3pvideo} pb_p3pvideo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_p3pvideo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_p3pvideo message.
         * @function verify
         * @memberof pb_p3pvideo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_p3pvideo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.atk != null && message.hasOwnProperty("atk")) {
                var error = $root.pb_p3pmbr.verify(message.atk);
                if (error)
                    return "atk." + error;
            }
            if (message.def != null && message.hasOwnProperty("def")) {
                var error = $root.pb_p3pmbr.verify(message.def);
                if (error)
                    return "def." + error;
            }
            if (typeof message.win !== "boolean")
                return "win: boolean expected";
            if (message.frames != null && message.hasOwnProperty("frames")) {
                if (!Array.isArray(message.frames))
                    return "frames: array expected";
                for (var i = 0; i < message.frames.length; ++i)
                    if (!(message.frames[i] && typeof message.frames[i].length === "number" || $util.isString(message.frames[i])))
                        return "frames: buffer[] expected";
            }
            if (message.hurts != null && message.hasOwnProperty("hurts")) {
                if (!Array.isArray(message.hurts))
                    return "hurts: array expected";
                for (var i = 0; i < message.hurts.length; ++i) {
                    var error = $root.pb_hurts.verify(message.hurts[i]);
                    if (error)
                        return "hurts." + error;
                }
            }
            if (message.ascore != null && message.hasOwnProperty("ascore"))
                if (!$util.isInteger(message.ascore))
                    return "ascore: integer expected";
            if (message.dscore != null && message.hasOwnProperty("dscore"))
                if (!$util.isInteger(message.dscore))
                    return "dscore: integer expected";
            if (message.adelta != null && message.hasOwnProperty("adelta"))
                if (!$util.isInteger(message.adelta))
                    return "adelta: integer expected";
            if (message.ddelta != null && message.hasOwnProperty("ddelta"))
                if (!$util.isInteger(message.ddelta))
                    return "ddelta: integer expected";
            if (message.rewards != null && message.hasOwnProperty("rewards")) {
                if (!Array.isArray(message.rewards))
                    return "rewards: array expected";
                for (var i = 0; i < message.rewards.length; ++i) {
                    var error = $root.pb_bag.verify(message.rewards[i]);
                    if (error)
                        return "rewards." + error;
                }
            }
            if (message.select != null && message.hasOwnProperty("select"))
                if (!$util.isInteger(message.select))
                    return "select: integer expected";
            return null;
        };
    
        /**
         * Creates a pb_p3pvideo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_p3pvideo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_p3pvideo} pb_p3pvideo
         */
        pb_p3pvideo.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_p3pvideo)
                return object;
            var message = new $root.pb_p3pvideo();
            if (object.atk != null) {
                if (typeof object.atk !== "object")
                    throw TypeError(".pb_p3pvideo.atk: object expected");
                message.atk = $root.pb_p3pmbr.fromObject(object.atk);
            }
            if (object.def != null) {
                if (typeof object.def !== "object")
                    throw TypeError(".pb_p3pvideo.def: object expected");
                message.def = $root.pb_p3pmbr.fromObject(object.def);
            }
            if (object.win != null)
                message.win = Boolean(object.win);
            if (object.frames) {
                if (!Array.isArray(object.frames))
                    throw TypeError(".pb_p3pvideo.frames: array expected");
                message.frames = [];
                for (var i = 0; i < object.frames.length; ++i)
                    if (typeof object.frames[i] === "string")
                        $util.base64.decode(object.frames[i], message.frames[i] = $util.newBuffer($util.base64.length(object.frames[i])), 0);
                    else if (object.frames[i].length >= 0)
                        message.frames[i] = object.frames[i];
            }
            if (object.hurts) {
                if (!Array.isArray(object.hurts))
                    throw TypeError(".pb_p3pvideo.hurts: array expected");
                message.hurts = [];
                for (var i = 0; i < object.hurts.length; ++i) {
                    if (typeof object.hurts[i] !== "object")
                        throw TypeError(".pb_p3pvideo.hurts: object expected");
                    message.hurts[i] = $root.pb_hurts.fromObject(object.hurts[i]);
                }
            }
            if (object.ascore != null)
                message.ascore = object.ascore | 0;
            if (object.dscore != null)
                message.dscore = object.dscore | 0;
            if (object.adelta != null)
                message.adelta = object.adelta | 0;
            if (object.ddelta != null)
                message.ddelta = object.ddelta | 0;
            if (object.rewards) {
                if (!Array.isArray(object.rewards))
                    throw TypeError(".pb_p3pvideo.rewards: array expected");
                message.rewards = [];
                for (var i = 0; i < object.rewards.length; ++i) {
                    if (typeof object.rewards[i] !== "object")
                        throw TypeError(".pb_p3pvideo.rewards: object expected");
                    message.rewards[i] = $root.pb_bag.fromObject(object.rewards[i]);
                }
            }
            if (object.select != null)
                message.select = object.select | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a pb_p3pvideo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_p3pvideo
         * @static
         * @param {pb_p3pvideo} message pb_p3pvideo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_p3pvideo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.frames = [];
                object.hurts = [];
                object.rewards = [];
            }
            if (options.defaults) {
                object.atk = null;
                object.def = null;
                object.win = false;
                object.ascore = 0;
                object.dscore = 0;
                object.adelta = 0;
                object.ddelta = 0;
                object.select = 0;
            }
            if (message.atk != null && message.hasOwnProperty("atk"))
                object.atk = $root.pb_p3pmbr.toObject(message.atk, options);
            if (message.def != null && message.hasOwnProperty("def"))
                object.def = $root.pb_p3pmbr.toObject(message.def, options);
            if (message.win != null && message.hasOwnProperty("win"))
                object.win = message.win;
            if (message.frames && message.frames.length) {
                object.frames = [];
                for (var j = 0; j < message.frames.length; ++j)
                    object.frames[j] = options.bytes === String ? $util.base64.encode(message.frames[j], 0, message.frames[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.frames[j]) : message.frames[j];
            }
            if (message.hurts && message.hurts.length) {
                object.hurts = [];
                for (var j = 0; j < message.hurts.length; ++j)
                    object.hurts[j] = $root.pb_hurts.toObject(message.hurts[j], options);
            }
            if (message.ascore != null && message.hasOwnProperty("ascore"))
                object.ascore = message.ascore;
            if (message.dscore != null && message.hasOwnProperty("dscore"))
                object.dscore = message.dscore;
            if (message.adelta != null && message.hasOwnProperty("adelta"))
                object.adelta = message.adelta;
            if (message.ddelta != null && message.hasOwnProperty("ddelta"))
                object.ddelta = message.ddelta;
            if (message.rewards && message.rewards.length) {
                object.rewards = [];
                for (var j = 0; j < message.rewards.length; ++j)
                    object.rewards[j] = $root.pb_bag.toObject(message.rewards[j], options);
            }
            if (message.select != null && message.hasOwnProperty("select"))
                object.select = message.select;
            return object;
        };
    
        /**
         * Converts this pb_p3pvideo to JSON.
         * @function toJSON
         * @memberof pb_p3pvideo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_p3pvideo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_p3pvideo
         * @function getTypeUrl
         * @memberof pb_p3pvideo
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_p3pvideo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_p3pvideo";
        };
    
        return pb_p3pvideo;
    })();
    
    $root.pb_htask_info = (function() {
    
        /**
         * Properties of a pb_htask_info.
         * @exports Ipb_htask_info
         * @interface Ipb_htask_info
         * @property {number|null} [tid] pb_htask_info tid
         * @property {Array.<number>|null} [hids] pb_htask_info hids
         * @property {Array.<number>|null} [heads] pb_htask_info heads
         */
    
        /**
         * Constructs a new pb_htask_info.
         * @exports pb_htask_info
         * @classdesc Represents a pb_htask_info.
         * @implements Ipb_htask_info
         * @constructor
         * @param {Ipb_htask_info=} [properties] Properties to set
         */
        function pb_htask_info(properties) {
            this.hids = [];
            this.heads = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_htask_info tid.
         * @member {number} tid
         * @memberof pb_htask_info
         * @instance
         */
        pb_htask_info.prototype.tid = 0;
    
        /**
         * pb_htask_info hids.
         * @member {Array.<number>} hids
         * @memberof pb_htask_info
         * @instance
         */
        pb_htask_info.prototype.hids = $util.emptyArray;
    
        /**
         * pb_htask_info heads.
         * @member {Array.<number>} heads
         * @memberof pb_htask_info
         * @instance
         */
        pb_htask_info.prototype.heads = $util.emptyArray;
    
        /**
         * Creates a new pb_htask_info instance using the specified properties.
         * @function create
         * @memberof pb_htask_info
         * @static
         * @param {Ipb_htask_info=} [properties] Properties to set
         * @returns {pb_htask_info} pb_htask_info instance
         */
        pb_htask_info.create = function create(properties) {
            return new pb_htask_info(properties);
        };
    
        /**
         * Encodes the specified pb_htask_info message. Does not implicitly {@link pb_htask_info.verify|verify} messages.
         * @function encode
         * @memberof pb_htask_info
         * @static
         * @param {Ipb_htask_info} message pb_htask_info message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_htask_info.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tid != null && Object.hasOwnProperty.call(message, "tid"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.tid);
            if (message.hids != null && message.hids.length)
                for (var i = 0; i < message.hids.length; ++i)
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.hids[i]);
            if (message.heads != null && message.heads.length)
                for (var i = 0; i < message.heads.length; ++i)
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.heads[i]);
            return writer;
        };
    
        /**
         * Encodes the specified pb_htask_info message, length delimited. Does not implicitly {@link pb_htask_info.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_htask_info
         * @static
         * @param {Ipb_htask_info} message pb_htask_info message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_htask_info.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_htask_info message from the specified reader or buffer.
         * @function decode
         * @memberof pb_htask_info
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_htask_info} pb_htask_info
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_htask_info.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_htask_info();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.tid = reader.int32();
                        break;
                    }
                case 2: {
                        if (!(message.hids && message.hids.length))
                            message.hids = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.hids.push(reader.int32());
                        } else
                            message.hids.push(reader.int32());
                        break;
                    }
                case 3: {
                        if (!(message.heads && message.heads.length))
                            message.heads = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.heads.push(reader.int32());
                        } else
                            message.heads.push(reader.int32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a pb_htask_info message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_htask_info
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_htask_info} pb_htask_info
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_htask_info.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_htask_info message.
         * @function verify
         * @memberof pb_htask_info
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_htask_info.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.tid != null && message.hasOwnProperty("tid"))
                if (!$util.isInteger(message.tid))
                    return "tid: integer expected";
            if (message.hids != null && message.hasOwnProperty("hids")) {
                if (!Array.isArray(message.hids))
                    return "hids: array expected";
                for (var i = 0; i < message.hids.length; ++i)
                    if (!$util.isInteger(message.hids[i]))
                        return "hids: integer[] expected";
            }
            if (message.heads != null && message.hasOwnProperty("heads")) {
                if (!Array.isArray(message.heads))
                    return "heads: array expected";
                for (var i = 0; i < message.heads.length; ++i)
                    if (!$util.isInteger(message.heads[i]))
                        return "heads: integer[] expected";
            }
            return null;
        };
    
        /**
         * Creates a pb_htask_info message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_htask_info
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_htask_info} pb_htask_info
         */
        pb_htask_info.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_htask_info)
                return object;
            var message = new $root.pb_htask_info();
            if (object.tid != null)
                message.tid = object.tid | 0;
            if (object.hids) {
                if (!Array.isArray(object.hids))
                    throw TypeError(".pb_htask_info.hids: array expected");
                message.hids = [];
                for (var i = 0; i < object.hids.length; ++i)
                    message.hids[i] = object.hids[i] | 0;
            }
            if (object.heads) {
                if (!Array.isArray(object.heads))
                    throw TypeError(".pb_htask_info.heads: array expected");
                message.heads = [];
                for (var i = 0; i < object.heads.length; ++i)
                    message.heads[i] = object.heads[i] | 0;
            }
            return message;
        };
    
        /**
         * Creates a plain object from a pb_htask_info message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_htask_info
         * @static
         * @param {pb_htask_info} message pb_htask_info
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_htask_info.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.hids = [];
                object.heads = [];
            }
            if (options.defaults)
                object.tid = 0;
            if (message.tid != null && message.hasOwnProperty("tid"))
                object.tid = message.tid;
            if (message.hids && message.hids.length) {
                object.hids = [];
                for (var j = 0; j < message.hids.length; ++j)
                    object.hids[j] = message.hids[j];
            }
            if (message.heads && message.heads.length) {
                object.heads = [];
                for (var j = 0; j < message.heads.length; ++j)
                    object.heads[j] = message.heads[j];
            }
            return object;
        };
    
        /**
         * Converts this pb_htask_info to JSON.
         * @function toJSON
         * @memberof pb_htask_info
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_htask_info.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_htask_info
         * @function getTypeUrl
         * @memberof pb_htask_info
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_htask_info.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_htask_info";
        };
    
        return pb_htask_info;
    })();
    
    $root.pb_htask_cond = (function() {
    
        /**
         * Properties of a pb_htask_cond.
         * @exports Ipb_htask_cond
         * @interface Ipb_htask_cond
         * @property {number} type pb_htask_cond type
         * @property {number|null} [faction] pb_htask_cond faction
         */
    
        /**
         * Constructs a new pb_htask_cond.
         * @exports pb_htask_cond
         * @classdesc Represents a pb_htask_cond.
         * @implements Ipb_htask_cond
         * @constructor
         * @param {Ipb_htask_cond=} [properties] Properties to set
         */
        function pb_htask_cond(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_htask_cond type.
         * @member {number} type
         * @memberof pb_htask_cond
         * @instance
         */
        pb_htask_cond.prototype.type = 0;
    
        /**
         * pb_htask_cond faction.
         * @member {number} faction
         * @memberof pb_htask_cond
         * @instance
         */
        pb_htask_cond.prototype.faction = 0;
    
        /**
         * Creates a new pb_htask_cond instance using the specified properties.
         * @function create
         * @memberof pb_htask_cond
         * @static
         * @param {Ipb_htask_cond=} [properties] Properties to set
         * @returns {pb_htask_cond} pb_htask_cond instance
         */
        pb_htask_cond.create = function create(properties) {
            return new pb_htask_cond(properties);
        };
    
        /**
         * Encodes the specified pb_htask_cond message. Does not implicitly {@link pb_htask_cond.verify|verify} messages.
         * @function encode
         * @memberof pb_htask_cond
         * @static
         * @param {Ipb_htask_cond} message pb_htask_cond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_htask_cond.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            if (message.faction != null && Object.hasOwnProperty.call(message, "faction"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.faction);
            return writer;
        };
    
        /**
         * Encodes the specified pb_htask_cond message, length delimited. Does not implicitly {@link pb_htask_cond.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_htask_cond
         * @static
         * @param {Ipb_htask_cond} message pb_htask_cond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_htask_cond.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_htask_cond message from the specified reader or buffer.
         * @function decode
         * @memberof pb_htask_cond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_htask_cond} pb_htask_cond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_htask_cond.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_htask_cond();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.type = reader.int32();
                        break;
                    }
                case 2: {
                        message.faction = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("type"))
                throw $util.ProtocolError("missing required 'type'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a pb_htask_cond message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_htask_cond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_htask_cond} pb_htask_cond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_htask_cond.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_htask_cond message.
         * @function verify
         * @memberof pb_htask_cond
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_htask_cond.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.type))
                return "type: integer expected";
            if (message.faction != null && message.hasOwnProperty("faction"))
                if (!$util.isInteger(message.faction))
                    return "faction: integer expected";
            return null;
        };
    
        /**
         * Creates a pb_htask_cond message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_htask_cond
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_htask_cond} pb_htask_cond
         */
        pb_htask_cond.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_htask_cond)
                return object;
            var message = new $root.pb_htask_cond();
            if (object.type != null)
                message.type = object.type | 0;
            if (object.faction != null)
                message.faction = object.faction | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a pb_htask_cond message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_htask_cond
         * @static
         * @param {pb_htask_cond} message pb_htask_cond
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_htask_cond.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.type = 0;
                object.faction = 0;
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            if (message.faction != null && message.hasOwnProperty("faction"))
                object.faction = message.faction;
            return object;
        };
    
        /**
         * Converts this pb_htask_cond to JSON.
         * @function toJSON
         * @memberof pb_htask_cond
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_htask_cond.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_htask_cond
         * @function getTypeUrl
         * @memberof pb_htask_cond
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_htask_cond.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_htask_cond";
        };
    
        return pb_htask_cond;
    })();
    
    $root.pb_htask_sync = (function() {
    
        /**
         * Properties of a pb_htask_sync.
         * @exports Ipb_htask_sync
         * @interface Ipb_htask_sync
         * @property {number} cd pb_htask_sync cd
         * @property {Array.<Ipb_htask>|null} [tasks] pb_htask_sync tasks
         */
    
        /**
         * Constructs a new pb_htask_sync.
         * @exports pb_htask_sync
         * @classdesc Represents a pb_htask_sync.
         * @implements Ipb_htask_sync
         * @constructor
         * @param {Ipb_htask_sync=} [properties] Properties to set
         */
        function pb_htask_sync(properties) {
            this.tasks = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_htask_sync cd.
         * @member {number} cd
         * @memberof pb_htask_sync
         * @instance
         */
        pb_htask_sync.prototype.cd = 0;
    
        /**
         * pb_htask_sync tasks.
         * @member {Array.<Ipb_htask>} tasks
         * @memberof pb_htask_sync
         * @instance
         */
        pb_htask_sync.prototype.tasks = $util.emptyArray;
    
        /**
         * Creates a new pb_htask_sync instance using the specified properties.
         * @function create
         * @memberof pb_htask_sync
         * @static
         * @param {Ipb_htask_sync=} [properties] Properties to set
         * @returns {pb_htask_sync} pb_htask_sync instance
         */
        pb_htask_sync.create = function create(properties) {
            return new pb_htask_sync(properties);
        };
    
        /**
         * Encodes the specified pb_htask_sync message. Does not implicitly {@link pb_htask_sync.verify|verify} messages.
         * @function encode
         * @memberof pb_htask_sync
         * @static
         * @param {Ipb_htask_sync} message pb_htask_sync message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_htask_sync.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.cd);
            if (message.tasks != null && message.tasks.length)
                for (var i = 0; i < message.tasks.length; ++i)
                    $root.pb_htask.encode(message.tasks[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified pb_htask_sync message, length delimited. Does not implicitly {@link pb_htask_sync.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_htask_sync
         * @static
         * @param {Ipb_htask_sync} message pb_htask_sync message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_htask_sync.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_htask_sync message from the specified reader or buffer.
         * @function decode
         * @memberof pb_htask_sync
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_htask_sync} pb_htask_sync
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_htask_sync.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_htask_sync();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.cd = reader.int32();
                        break;
                    }
                case 2: {
                        if (!(message.tasks && message.tasks.length))
                            message.tasks = [];
                        message.tasks.push($root.pb_htask.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("cd"))
                throw $util.ProtocolError("missing required 'cd'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a pb_htask_sync message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_htask_sync
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_htask_sync} pb_htask_sync
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_htask_sync.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_htask_sync message.
         * @function verify
         * @memberof pb_htask_sync
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_htask_sync.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.cd))
                return "cd: integer expected";
            if (message.tasks != null && message.hasOwnProperty("tasks")) {
                if (!Array.isArray(message.tasks))
                    return "tasks: array expected";
                for (var i = 0; i < message.tasks.length; ++i) {
                    var error = $root.pb_htask.verify(message.tasks[i]);
                    if (error)
                        return "tasks." + error;
                }
            }
            return null;
        };
    
        /**
         * Creates a pb_htask_sync message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_htask_sync
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_htask_sync} pb_htask_sync
         */
        pb_htask_sync.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_htask_sync)
                return object;
            var message = new $root.pb_htask_sync();
            if (object.cd != null)
                message.cd = object.cd | 0;
            if (object.tasks) {
                if (!Array.isArray(object.tasks))
                    throw TypeError(".pb_htask_sync.tasks: array expected");
                message.tasks = [];
                for (var i = 0; i < object.tasks.length; ++i) {
                    if (typeof object.tasks[i] !== "object")
                        throw TypeError(".pb_htask_sync.tasks: object expected");
                    message.tasks[i] = $root.pb_htask.fromObject(object.tasks[i]);
                }
            }
            return message;
        };
    
        /**
         * Creates a plain object from a pb_htask_sync message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_htask_sync
         * @static
         * @param {pb_htask_sync} message pb_htask_sync
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_htask_sync.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.tasks = [];
            if (options.defaults)
                object.cd = 0;
            if (message.cd != null && message.hasOwnProperty("cd"))
                object.cd = message.cd;
            if (message.tasks && message.tasks.length) {
                object.tasks = [];
                for (var j = 0; j < message.tasks.length; ++j)
                    object.tasks[j] = $root.pb_htask.toObject(message.tasks[j], options);
            }
            return object;
        };
    
        /**
         * Converts this pb_htask_sync to JSON.
         * @function toJSON
         * @memberof pb_htask_sync
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_htask_sync.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_htask_sync
         * @function getTypeUrl
         * @memberof pb_htask_sync
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_htask_sync.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_htask_sync";
        };
    
        return pb_htask_sync;
    })();
    
    $root.pb_htask = (function() {
    
        /**
         * Properties of a pb_htask.
         * @exports Ipb_htask
         * @interface Ipb_htask
         * @property {number} tid pb_htask tid
         * @property {number} id pb_htask id
         * @property {number|null} [cd] pb_htask cd
         * @property {Array.<Ipb_unit>|null} [heroes] pb_htask heroes
         * @property {Ipb_bag|null} [reward] pb_htask reward
         * @property {Array.<Ipb_htask_cond>|null} [conds] pb_htask conds
         * @property {number|Long|null} [power] pb_htask power
         * @property {number|null} [lock] pb_htask lock
         * @property {number} nameid pb_htask nameid
         * @property {Array.<number>|null} [heads] pb_htask heads
         */
    
        /**
         * Constructs a new pb_htask.
         * @exports pb_htask
         * @classdesc Represents a pb_htask.
         * @implements Ipb_htask
         * @constructor
         * @param {Ipb_htask=} [properties] Properties to set
         */
        function pb_htask(properties) {
            this.heroes = [];
            this.conds = [];
            this.heads = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_htask tid.
         * @member {number} tid
         * @memberof pb_htask
         * @instance
         */
        pb_htask.prototype.tid = 0;
    
        /**
         * pb_htask id.
         * @member {number} id
         * @memberof pb_htask
         * @instance
         */
        pb_htask.prototype.id = 0;
    
        /**
         * pb_htask cd.
         * @member {number} cd
         * @memberof pb_htask
         * @instance
         */
        pb_htask.prototype.cd = 0;
    
        /**
         * pb_htask heroes.
         * @member {Array.<Ipb_unit>} heroes
         * @memberof pb_htask
         * @instance
         */
        pb_htask.prototype.heroes = $util.emptyArray;
    
        /**
         * pb_htask reward.
         * @member {Ipb_bag|null|undefined} reward
         * @memberof pb_htask
         * @instance
         */
        pb_htask.prototype.reward = null;
    
        /**
         * pb_htask conds.
         * @member {Array.<Ipb_htask_cond>} conds
         * @memberof pb_htask
         * @instance
         */
        pb_htask.prototype.conds = $util.emptyArray;
    
        /**
         * pb_htask power.
         * @member {number|Long} power
         * @memberof pb_htask
         * @instance
         */
        pb_htask.prototype.power = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * pb_htask lock.
         * @member {number} lock
         * @memberof pb_htask
         * @instance
         */
        pb_htask.prototype.lock = 0;
    
        /**
         * pb_htask nameid.
         * @member {number} nameid
         * @memberof pb_htask
         * @instance
         */
        pb_htask.prototype.nameid = 0;
    
        /**
         * pb_htask heads.
         * @member {Array.<number>} heads
         * @memberof pb_htask
         * @instance
         */
        pb_htask.prototype.heads = $util.emptyArray;
    
        /**
         * Creates a new pb_htask instance using the specified properties.
         * @function create
         * @memberof pb_htask
         * @static
         * @param {Ipb_htask=} [properties] Properties to set
         * @returns {pb_htask} pb_htask instance
         */
        pb_htask.create = function create(properties) {
            return new pb_htask(properties);
        };
    
        /**
         * Encodes the specified pb_htask message. Does not implicitly {@link pb_htask.verify|verify} messages.
         * @function encode
         * @memberof pb_htask
         * @static
         * @param {Ipb_htask} message pb_htask message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_htask.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.tid);
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.id);
            if (message.cd != null && Object.hasOwnProperty.call(message, "cd"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.cd);
            if (message.heroes != null && message.heroes.length)
                for (var i = 0; i < message.heroes.length; ++i)
                    $root.pb_unit.encode(message.heroes[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.reward != null && Object.hasOwnProperty.call(message, "reward"))
                $root.pb_bag.encode(message.reward, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.conds != null && message.conds.length)
                for (var i = 0; i < message.conds.length; ++i)
                    $root.pb_htask_cond.encode(message.conds[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.power != null && Object.hasOwnProperty.call(message, "power"))
                writer.uint32(/* id 7, wireType 0 =*/56).int64(message.power);
            if (message.lock != null && Object.hasOwnProperty.call(message, "lock"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.lock);
            writer.uint32(/* id 9, wireType 0 =*/72).int32(message.nameid);
            if (message.heads != null && message.heads.length)
                for (var i = 0; i < message.heads.length; ++i)
                    writer.uint32(/* id 10, wireType 0 =*/80).int32(message.heads[i]);
            return writer;
        };
    
        /**
         * Encodes the specified pb_htask message, length delimited. Does not implicitly {@link pb_htask.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_htask
         * @static
         * @param {Ipb_htask} message pb_htask message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_htask.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_htask message from the specified reader or buffer.
         * @function decode
         * @memberof pb_htask
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_htask} pb_htask
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_htask.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_htask();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.tid = reader.int32();
                        break;
                    }
                case 2: {
                        message.id = reader.int32();
                        break;
                    }
                case 3: {
                        message.cd = reader.int32();
                        break;
                    }
                case 4: {
                        if (!(message.heroes && message.heroes.length))
                            message.heroes = [];
                        message.heroes.push($root.pb_unit.decode(reader, reader.uint32()));
                        break;
                    }
                case 5: {
                        message.reward = $root.pb_bag.decode(reader, reader.uint32());
                        break;
                    }
                case 6: {
                        if (!(message.conds && message.conds.length))
                            message.conds = [];
                        message.conds.push($root.pb_htask_cond.decode(reader, reader.uint32()));
                        break;
                    }
                case 7: {
                        message.power = reader.int64();
                        break;
                    }
                case 8: {
                        message.lock = reader.int32();
                        break;
                    }
                case 9: {
                        message.nameid = reader.int32();
                        break;
                    }
                case 10: {
                        if (!(message.heads && message.heads.length))
                            message.heads = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.heads.push(reader.int32());
                        } else
                            message.heads.push(reader.int32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("tid"))
                throw $util.ProtocolError("missing required 'tid'", { instance: message });
            if (!message.hasOwnProperty("id"))
                throw $util.ProtocolError("missing required 'id'", { instance: message });
            if (!message.hasOwnProperty("nameid"))
                throw $util.ProtocolError("missing required 'nameid'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a pb_htask message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_htask
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_htask} pb_htask
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_htask.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_htask message.
         * @function verify
         * @memberof pb_htask
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_htask.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.tid))
                return "tid: integer expected";
            if (!$util.isInteger(message.id))
                return "id: integer expected";
            if (message.cd != null && message.hasOwnProperty("cd"))
                if (!$util.isInteger(message.cd))
                    return "cd: integer expected";
            if (message.heroes != null && message.hasOwnProperty("heroes")) {
                if (!Array.isArray(message.heroes))
                    return "heroes: array expected";
                for (var i = 0; i < message.heroes.length; ++i) {
                    var error = $root.pb_unit.verify(message.heroes[i]);
                    if (error)
                        return "heroes." + error;
                }
            }
            if (message.reward != null && message.hasOwnProperty("reward")) {
                var error = $root.pb_bag.verify(message.reward);
                if (error)
                    return "reward." + error;
            }
            if (message.conds != null && message.hasOwnProperty("conds")) {
                if (!Array.isArray(message.conds))
                    return "conds: array expected";
                for (var i = 0; i < message.conds.length; ++i) {
                    var error = $root.pb_htask_cond.verify(message.conds[i]);
                    if (error)
                        return "conds." + error;
                }
            }
            if (message.power != null && message.hasOwnProperty("power"))
                if (!$util.isInteger(message.power) && !(message.power && $util.isInteger(message.power.low) && $util.isInteger(message.power.high)))
                    return "power: integer|Long expected";
            if (message.lock != null && message.hasOwnProperty("lock"))
                if (!$util.isInteger(message.lock))
                    return "lock: integer expected";
            if (!$util.isInteger(message.nameid))
                return "nameid: integer expected";
            if (message.heads != null && message.hasOwnProperty("heads")) {
                if (!Array.isArray(message.heads))
                    return "heads: array expected";
                for (var i = 0; i < message.heads.length; ++i)
                    if (!$util.isInteger(message.heads[i]))
                        return "heads: integer[] expected";
            }
            return null;
        };
    
        /**
         * Creates a pb_htask message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_htask
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_htask} pb_htask
         */
        pb_htask.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_htask)
                return object;
            var message = new $root.pb_htask();
            if (object.tid != null)
                message.tid = object.tid | 0;
            if (object.id != null)
                message.id = object.id | 0;
            if (object.cd != null)
                message.cd = object.cd | 0;
            if (object.heroes) {
                if (!Array.isArray(object.heroes))
                    throw TypeError(".pb_htask.heroes: array expected");
                message.heroes = [];
                for (var i = 0; i < object.heroes.length; ++i) {
                    if (typeof object.heroes[i] !== "object")
                        throw TypeError(".pb_htask.heroes: object expected");
                    message.heroes[i] = $root.pb_unit.fromObject(object.heroes[i]);
                }
            }
            if (object.reward != null) {
                if (typeof object.reward !== "object")
                    throw TypeError(".pb_htask.reward: object expected");
                message.reward = $root.pb_bag.fromObject(object.reward);
            }
            if (object.conds) {
                if (!Array.isArray(object.conds))
                    throw TypeError(".pb_htask.conds: array expected");
                message.conds = [];
                for (var i = 0; i < object.conds.length; ++i) {
                    if (typeof object.conds[i] !== "object")
                        throw TypeError(".pb_htask.conds: object expected");
                    message.conds[i] = $root.pb_htask_cond.fromObject(object.conds[i]);
                }
            }
            if (object.power != null)
                if ($util.Long)
                    (message.power = $util.Long.fromValue(object.power)).unsigned = false;
                else if (typeof object.power === "string")
                    message.power = parseInt(object.power, 10);
                else if (typeof object.power === "number")
                    message.power = object.power;
                else if (typeof object.power === "object")
                    message.power = new $util.LongBits(object.power.low >>> 0, object.power.high >>> 0).toNumber();
            if (object.lock != null)
                message.lock = object.lock | 0;
            if (object.nameid != null)
                message.nameid = object.nameid | 0;
            if (object.heads) {
                if (!Array.isArray(object.heads))
                    throw TypeError(".pb_htask.heads: array expected");
                message.heads = [];
                for (var i = 0; i < object.heads.length; ++i)
                    message.heads[i] = object.heads[i] | 0;
            }
            return message;
        };
    
        /**
         * Creates a plain object from a pb_htask message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_htask
         * @static
         * @param {pb_htask} message pb_htask
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_htask.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.heroes = [];
                object.conds = [];
                object.heads = [];
            }
            if (options.defaults) {
                object.tid = 0;
                object.id = 0;
                object.cd = 0;
                object.reward = null;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.power = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.power = options.longs === String ? "0" : 0;
                object.lock = 0;
                object.nameid = 0;
            }
            if (message.tid != null && message.hasOwnProperty("tid"))
                object.tid = message.tid;
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.cd != null && message.hasOwnProperty("cd"))
                object.cd = message.cd;
            if (message.heroes && message.heroes.length) {
                object.heroes = [];
                for (var j = 0; j < message.heroes.length; ++j)
                    object.heroes[j] = $root.pb_unit.toObject(message.heroes[j], options);
            }
            if (message.reward != null && message.hasOwnProperty("reward"))
                object.reward = $root.pb_bag.toObject(message.reward, options);
            if (message.conds && message.conds.length) {
                object.conds = [];
                for (var j = 0; j < message.conds.length; ++j)
                    object.conds[j] = $root.pb_htask_cond.toObject(message.conds[j], options);
            }
            if (message.power != null && message.hasOwnProperty("power"))
                if (typeof message.power === "number")
                    object.power = options.longs === String ? String(message.power) : message.power;
                else
                    object.power = options.longs === String ? $util.Long.prototype.toString.call(message.power) : options.longs === Number ? new $util.LongBits(message.power.low >>> 0, message.power.high >>> 0).toNumber() : message.power;
            if (message.lock != null && message.hasOwnProperty("lock"))
                object.lock = message.lock;
            if (message.nameid != null && message.hasOwnProperty("nameid"))
                object.nameid = message.nameid;
            if (message.heads && message.heads.length) {
                object.heads = [];
                for (var j = 0; j < message.heads.length; ++j)
                    object.heads[j] = message.heads[j];
            }
            return object;
        };
    
        /**
         * Converts this pb_htask to JSON.
         * @function toJSON
         * @memberof pb_htask
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_htask.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_htask
         * @function getTypeUrl
         * @memberof pb_htask
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_htask.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_htask";
        };
    
        return pb_htask;
    })();
    
    $root.pb_evideo = (function() {
    
        /**
         * Properties of a pb_evideo.
         * @exports Ipb_evideo
         * @interface Ipb_evideo
         * @property {Array.<Uint8Array>|null} [frames] pb_evideo frames
         * @property {boolean|null} [win] pb_evideo win
         * @property {Ipb_bag|null} [reward] pb_evideo reward
         * @property {Array.<Ipb_unit>|null} [camp] pb_evideo camp
         * @property {Array.<Ipb_hurts>|null} [hurts] pb_evideo hurts
         */
    
        /**
         * Constructs a new pb_evideo.
         * @exports pb_evideo
         * @classdesc Represents a pb_evideo.
         * @implements Ipb_evideo
         * @constructor
         * @param {Ipb_evideo=} [properties] Properties to set
         */
        function pb_evideo(properties) {
            this.frames = [];
            this.camp = [];
            this.hurts = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_evideo frames.
         * @member {Array.<Uint8Array>} frames
         * @memberof pb_evideo
         * @instance
         */
        pb_evideo.prototype.frames = $util.emptyArray;
    
        /**
         * pb_evideo win.
         * @member {boolean} win
         * @memberof pb_evideo
         * @instance
         */
        pb_evideo.prototype.win = false;
    
        /**
         * pb_evideo reward.
         * @member {Ipb_bag|null|undefined} reward
         * @memberof pb_evideo
         * @instance
         */
        pb_evideo.prototype.reward = null;
    
        /**
         * pb_evideo camp.
         * @member {Array.<Ipb_unit>} camp
         * @memberof pb_evideo
         * @instance
         */
        pb_evideo.prototype.camp = $util.emptyArray;
    
        /**
         * pb_evideo hurts.
         * @member {Array.<Ipb_hurts>} hurts
         * @memberof pb_evideo
         * @instance
         */
        pb_evideo.prototype.hurts = $util.emptyArray;
    
        /**
         * Creates a new pb_evideo instance using the specified properties.
         * @function create
         * @memberof pb_evideo
         * @static
         * @param {Ipb_evideo=} [properties] Properties to set
         * @returns {pb_evideo} pb_evideo instance
         */
        pb_evideo.create = function create(properties) {
            return new pb_evideo(properties);
        };
    
        /**
         * Encodes the specified pb_evideo message. Does not implicitly {@link pb_evideo.verify|verify} messages.
         * @function encode
         * @memberof pb_evideo
         * @static
         * @param {Ipb_evideo} message pb_evideo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_evideo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.frames != null && message.frames.length)
                for (var i = 0; i < message.frames.length; ++i)
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.frames[i]);
            if (message.win != null && Object.hasOwnProperty.call(message, "win"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.win);
            if (message.reward != null && Object.hasOwnProperty.call(message, "reward"))
                $root.pb_bag.encode(message.reward, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.camp != null && message.camp.length)
                for (var i = 0; i < message.camp.length; ++i)
                    $root.pb_unit.encode(message.camp[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.hurts != null && message.hurts.length)
                for (var i = 0; i < message.hurts.length; ++i)
                    $root.pb_hurts.encode(message.hurts[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified pb_evideo message, length delimited. Does not implicitly {@link pb_evideo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_evideo
         * @static
         * @param {Ipb_evideo} message pb_evideo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_evideo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_evideo message from the specified reader or buffer.
         * @function decode
         * @memberof pb_evideo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_evideo} pb_evideo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_evideo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_evideo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.frames && message.frames.length))
                            message.frames = [];
                        message.frames.push(reader.bytes());
                        break;
                    }
                case 2: {
                        message.win = reader.bool();
                        break;
                    }
                case 3: {
                        message.reward = $root.pb_bag.decode(reader, reader.uint32());
                        break;
                    }
                case 4: {
                        if (!(message.camp && message.camp.length))
                            message.camp = [];
                        message.camp.push($root.pb_unit.decode(reader, reader.uint32()));
                        break;
                    }
                case 5: {
                        if (!(message.hurts && message.hurts.length))
                            message.hurts = [];
                        message.hurts.push($root.pb_hurts.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a pb_evideo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_evideo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_evideo} pb_evideo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_evideo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_evideo message.
         * @function verify
         * @memberof pb_evideo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_evideo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.frames != null && message.hasOwnProperty("frames")) {
                if (!Array.isArray(message.frames))
                    return "frames: array expected";
                for (var i = 0; i < message.frames.length; ++i)
                    if (!(message.frames[i] && typeof message.frames[i].length === "number" || $util.isString(message.frames[i])))
                        return "frames: buffer[] expected";
            }
            if (message.win != null && message.hasOwnProperty("win"))
                if (typeof message.win !== "boolean")
                    return "win: boolean expected";
            if (message.reward != null && message.hasOwnProperty("reward")) {
                var error = $root.pb_bag.verify(message.reward);
                if (error)
                    return "reward." + error;
            }
            if (message.camp != null && message.hasOwnProperty("camp")) {
                if (!Array.isArray(message.camp))
                    return "camp: array expected";
                for (var i = 0; i < message.camp.length; ++i) {
                    var error = $root.pb_unit.verify(message.camp[i]);
                    if (error)
                        return "camp." + error;
                }
            }
            if (message.hurts != null && message.hasOwnProperty("hurts")) {
                if (!Array.isArray(message.hurts))
                    return "hurts: array expected";
                for (var i = 0; i < message.hurts.length; ++i) {
                    var error = $root.pb_hurts.verify(message.hurts[i]);
                    if (error)
                        return "hurts." + error;
                }
            }
            return null;
        };
    
        /**
         * Creates a pb_evideo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_evideo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_evideo} pb_evideo
         */
        pb_evideo.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_evideo)
                return object;
            var message = new $root.pb_evideo();
            if (object.frames) {
                if (!Array.isArray(object.frames))
                    throw TypeError(".pb_evideo.frames: array expected");
                message.frames = [];
                for (var i = 0; i < object.frames.length; ++i)
                    if (typeof object.frames[i] === "string")
                        $util.base64.decode(object.frames[i], message.frames[i] = $util.newBuffer($util.base64.length(object.frames[i])), 0);
                    else if (object.frames[i].length >= 0)
                        message.frames[i] = object.frames[i];
            }
            if (object.win != null)
                message.win = Boolean(object.win);
            if (object.reward != null) {
                if (typeof object.reward !== "object")
                    throw TypeError(".pb_evideo.reward: object expected");
                message.reward = $root.pb_bag.fromObject(object.reward);
            }
            if (object.camp) {
                if (!Array.isArray(object.camp))
                    throw TypeError(".pb_evideo.camp: array expected");
                message.camp = [];
                for (var i = 0; i < object.camp.length; ++i) {
                    if (typeof object.camp[i] !== "object")
                        throw TypeError(".pb_evideo.camp: object expected");
                    message.camp[i] = $root.pb_unit.fromObject(object.camp[i]);
                }
            }
            if (object.hurts) {
                if (!Array.isArray(object.hurts))
                    throw TypeError(".pb_evideo.hurts: array expected");
                message.hurts = [];
                for (var i = 0; i < object.hurts.length; ++i) {
                    if (typeof object.hurts[i] !== "object")
                        throw TypeError(".pb_evideo.hurts: object expected");
                    message.hurts[i] = $root.pb_hurts.fromObject(object.hurts[i]);
                }
            }
            return message;
        };
    
        /**
         * Creates a plain object from a pb_evideo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_evideo
         * @static
         * @param {pb_evideo} message pb_evideo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_evideo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.frames = [];
                object.camp = [];
                object.hurts = [];
            }
            if (options.defaults) {
                object.win = false;
                object.reward = null;
            }
            if (message.frames && message.frames.length) {
                object.frames = [];
                for (var j = 0; j < message.frames.length; ++j)
                    object.frames[j] = options.bytes === String ? $util.base64.encode(message.frames[j], 0, message.frames[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.frames[j]) : message.frames[j];
            }
            if (message.win != null && message.hasOwnProperty("win"))
                object.win = message.win;
            if (message.reward != null && message.hasOwnProperty("reward"))
                object.reward = $root.pb_bag.toObject(message.reward, options);
            if (message.camp && message.camp.length) {
                object.camp = [];
                for (var j = 0; j < message.camp.length; ++j)
                    object.camp[j] = $root.pb_unit.toObject(message.camp[j], options);
            }
            if (message.hurts && message.hurts.length) {
                object.hurts = [];
                for (var j = 0; j < message.hurts.length; ++j)
                    object.hurts[j] = $root.pb_hurts.toObject(message.hurts[j], options);
            }
            return object;
        };
    
        /**
         * Converts this pb_evideo to JSON.
         * @function toJSON
         * @memberof pb_evideo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_evideo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_evideo
         * @function getTypeUrl
         * @memberof pb_evideo
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_evideo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_evideo";
        };
    
        return pb_evideo;
    })();
    
    $root.pb_hurts = (function() {
    
        /**
         * Properties of a pb_hurts.
         * @exports Ipb_hurts
         * @interface Ipb_hurts
         * @property {number} pos pb_hurts pos
         * @property {number|Long} value pb_hurts value
         * @property {number|Long|null} [heal] pb_hurts heal
         * @property {boolean|null} [alive] pb_hurts alive
         */
    
        /**
         * Constructs a new pb_hurts.
         * @exports pb_hurts
         * @classdesc Represents a pb_hurts.
         * @implements Ipb_hurts
         * @constructor
         * @param {Ipb_hurts=} [properties] Properties to set
         */
        function pb_hurts(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_hurts pos.
         * @member {number} pos
         * @memberof pb_hurts
         * @instance
         */
        pb_hurts.prototype.pos = 0;
    
        /**
         * pb_hurts value.
         * @member {number|Long} value
         * @memberof pb_hurts
         * @instance
         */
        pb_hurts.prototype.value = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * pb_hurts heal.
         * @member {number|Long} heal
         * @memberof pb_hurts
         * @instance
         */
        pb_hurts.prototype.heal = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * pb_hurts alive.
         * @member {boolean} alive
         * @memberof pb_hurts
         * @instance
         */
        pb_hurts.prototype.alive = false;
    
        /**
         * Creates a new pb_hurts instance using the specified properties.
         * @function create
         * @memberof pb_hurts
         * @static
         * @param {Ipb_hurts=} [properties] Properties to set
         * @returns {pb_hurts} pb_hurts instance
         */
        pb_hurts.create = function create(properties) {
            return new pb_hurts(properties);
        };
    
        /**
         * Encodes the specified pb_hurts message. Does not implicitly {@link pb_hurts.verify|verify} messages.
         * @function encode
         * @memberof pb_hurts
         * @static
         * @param {Ipb_hurts} message pb_hurts message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_hurts.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.pos);
            writer.uint32(/* id 2, wireType 0 =*/16).int64(message.value);
            if (message.heal != null && Object.hasOwnProperty.call(message, "heal"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.heal);
            if (message.alive != null && Object.hasOwnProperty.call(message, "alive"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.alive);
            return writer;
        };
    
        /**
         * Encodes the specified pb_hurts message, length delimited. Does not implicitly {@link pb_hurts.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_hurts
         * @static
         * @param {Ipb_hurts} message pb_hurts message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_hurts.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_hurts message from the specified reader or buffer.
         * @function decode
         * @memberof pb_hurts
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_hurts} pb_hurts
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_hurts.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_hurts();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.pos = reader.int32();
                        break;
                    }
                case 2: {
                        message.value = reader.int64();
                        break;
                    }
                case 3: {
                        message.heal = reader.int64();
                        break;
                    }
                case 4: {
                        message.alive = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("pos"))
                throw $util.ProtocolError("missing required 'pos'", { instance: message });
            if (!message.hasOwnProperty("value"))
                throw $util.ProtocolError("missing required 'value'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a pb_hurts message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_hurts
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_hurts} pb_hurts
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_hurts.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_hurts message.
         * @function verify
         * @memberof pb_hurts
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_hurts.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.pos))
                return "pos: integer expected";
            if (!$util.isInteger(message.value) && !(message.value && $util.isInteger(message.value.low) && $util.isInteger(message.value.high)))
                return "value: integer|Long expected";
            if (message.heal != null && message.hasOwnProperty("heal"))
                if (!$util.isInteger(message.heal) && !(message.heal && $util.isInteger(message.heal.low) && $util.isInteger(message.heal.high)))
                    return "heal: integer|Long expected";
            if (message.alive != null && message.hasOwnProperty("alive"))
                if (typeof message.alive !== "boolean")
                    return "alive: boolean expected";
            return null;
        };
    
        /**
         * Creates a pb_hurts message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_hurts
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_hurts} pb_hurts
         */
        pb_hurts.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_hurts)
                return object;
            var message = new $root.pb_hurts();
            if (object.pos != null)
                message.pos = object.pos | 0;
            if (object.value != null)
                if ($util.Long)
                    (message.value = $util.Long.fromValue(object.value)).unsigned = false;
                else if (typeof object.value === "string")
                    message.value = parseInt(object.value, 10);
                else if (typeof object.value === "number")
                    message.value = object.value;
                else if (typeof object.value === "object")
                    message.value = new $util.LongBits(object.value.low >>> 0, object.value.high >>> 0).toNumber();
            if (object.heal != null)
                if ($util.Long)
                    (message.heal = $util.Long.fromValue(object.heal)).unsigned = false;
                else if (typeof object.heal === "string")
                    message.heal = parseInt(object.heal, 10);
                else if (typeof object.heal === "number")
                    message.heal = object.heal;
                else if (typeof object.heal === "object")
                    message.heal = new $util.LongBits(object.heal.low >>> 0, object.heal.high >>> 0).toNumber();
            if (object.alive != null)
                message.alive = Boolean(object.alive);
            return message;
        };
    
        /**
         * Creates a plain object from a pb_hurts message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_hurts
         * @static
         * @param {pb_hurts} message pb_hurts
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_hurts.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.pos = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.value = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.value = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.heal = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.heal = options.longs === String ? "0" : 0;
                object.alive = false;
            }
            if (message.pos != null && message.hasOwnProperty("pos"))
                object.pos = message.pos;
            if (message.value != null && message.hasOwnProperty("value"))
                if (typeof message.value === "number")
                    object.value = options.longs === String ? String(message.value) : message.value;
                else
                    object.value = options.longs === String ? $util.Long.prototype.toString.call(message.value) : options.longs === Number ? new $util.LongBits(message.value.low >>> 0, message.value.high >>> 0).toNumber() : message.value;
            if (message.heal != null && message.hasOwnProperty("heal"))
                if (typeof message.heal === "number")
                    object.heal = options.longs === String ? String(message.heal) : message.heal;
                else
                    object.heal = options.longs === String ? $util.Long.prototype.toString.call(message.heal) : options.longs === Number ? new $util.LongBits(message.heal.low >>> 0, message.heal.high >>> 0).toNumber() : message.heal;
            if (message.alive != null && message.hasOwnProperty("alive"))
                object.alive = message.alive;
            return object;
        };
    
        /**
         * Converts this pb_hurts to JSON.
         * @function toJSON
         * @memberof pb_hurts
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_hurts.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_hurts
         * @function getTypeUrl
         * @memberof pb_hurts
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_hurts.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_hurts";
        };
    
        return pb_hurts;
    })();
    
    $root.pb_alogin = (function() {
    
        /**
         * Properties of a pb_alogin.
         * @exports Ipb_alogin
         * @interface Ipb_alogin
         * @property {string} flag pb_alogin flag
         * @property {number|null} [cd] pb_alogin cd
         * @property {number|null} [idx] pb_alogin idx
         * @property {number|null} [num] pb_alogin num
         * @property {number|null} [cd2] pb_alogin cd2
         * @property {number|null} [first] pb_alogin first
         */
    
        /**
         * Constructs a new pb_alogin.
         * @exports pb_alogin
         * @classdesc Represents a pb_alogin.
         * @implements Ipb_alogin
         * @constructor
         * @param {Ipb_alogin=} [properties] Properties to set
         */
        function pb_alogin(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_alogin flag.
         * @member {string} flag
         * @memberof pb_alogin
         * @instance
         */
        pb_alogin.prototype.flag = "";
    
        /**
         * pb_alogin cd.
         * @member {number} cd
         * @memberof pb_alogin
         * @instance
         */
        pb_alogin.prototype.cd = 0;
    
        /**
         * pb_alogin idx.
         * @member {number} idx
         * @memberof pb_alogin
         * @instance
         */
        pb_alogin.prototype.idx = 0;
    
        /**
         * pb_alogin num.
         * @member {number} num
         * @memberof pb_alogin
         * @instance
         */
        pb_alogin.prototype.num = 0;
    
        /**
         * pb_alogin cd2.
         * @member {number} cd2
         * @memberof pb_alogin
         * @instance
         */
        pb_alogin.prototype.cd2 = 0;
    
        /**
         * pb_alogin first.
         * @member {number} first
         * @memberof pb_alogin
         * @instance
         */
        pb_alogin.prototype.first = 0;
    
        /**
         * Creates a new pb_alogin instance using the specified properties.
         * @function create
         * @memberof pb_alogin
         * @static
         * @param {Ipb_alogin=} [properties] Properties to set
         * @returns {pb_alogin} pb_alogin instance
         */
        pb_alogin.create = function create(properties) {
            return new pb_alogin(properties);
        };
    
        /**
         * Encodes the specified pb_alogin message. Does not implicitly {@link pb_alogin.verify|verify} messages.
         * @function encode
         * @memberof pb_alogin
         * @static
         * @param {Ipb_alogin} message pb_alogin message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_alogin.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.flag);
            if (message.cd != null && Object.hasOwnProperty.call(message, "cd"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.cd);
            if (message.idx != null && Object.hasOwnProperty.call(message, "idx"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.idx);
            if (message.num != null && Object.hasOwnProperty.call(message, "num"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.num);
            if (message.cd2 != null && Object.hasOwnProperty.call(message, "cd2"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.cd2);
            if (message.first != null && Object.hasOwnProperty.call(message, "first"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.first);
            return writer;
        };
    
        /**
         * Encodes the specified pb_alogin message, length delimited. Does not implicitly {@link pb_alogin.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_alogin
         * @static
         * @param {Ipb_alogin} message pb_alogin message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_alogin.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_alogin message from the specified reader or buffer.
         * @function decode
         * @memberof pb_alogin
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_alogin} pb_alogin
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_alogin.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_alogin();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.flag = reader.string();
                        break;
                    }
                case 2: {
                        message.cd = reader.int32();
                        break;
                    }
                case 3: {
                        message.idx = reader.int32();
                        break;
                    }
                case 4: {
                        message.num = reader.int32();
                        break;
                    }
                case 5: {
                        message.cd2 = reader.int32();
                        break;
                    }
                case 6: {
                        message.first = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("flag"))
                throw $util.ProtocolError("missing required 'flag'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a pb_alogin message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_alogin
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_alogin} pb_alogin
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_alogin.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_alogin message.
         * @function verify
         * @memberof pb_alogin
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_alogin.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isString(message.flag))
                return "flag: string expected";
            if (message.cd != null && message.hasOwnProperty("cd"))
                if (!$util.isInteger(message.cd))
                    return "cd: integer expected";
            if (message.idx != null && message.hasOwnProperty("idx"))
                if (!$util.isInteger(message.idx))
                    return "idx: integer expected";
            if (message.num != null && message.hasOwnProperty("num"))
                if (!$util.isInteger(message.num))
                    return "num: integer expected";
            if (message.cd2 != null && message.hasOwnProperty("cd2"))
                if (!$util.isInteger(message.cd2))
                    return "cd2: integer expected";
            if (message.first != null && message.hasOwnProperty("first"))
                if (!$util.isInteger(message.first))
                    return "first: integer expected";
            return null;
        };
    
        /**
         * Creates a pb_alogin message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_alogin
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_alogin} pb_alogin
         */
        pb_alogin.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_alogin)
                return object;
            var message = new $root.pb_alogin();
            if (object.flag != null)
                message.flag = String(object.flag);
            if (object.cd != null)
                message.cd = object.cd | 0;
            if (object.idx != null)
                message.idx = object.idx | 0;
            if (object.num != null)
                message.num = object.num | 0;
            if (object.cd2 != null)
                message.cd2 = object.cd2 | 0;
            if (object.first != null)
                message.first = object.first | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a pb_alogin message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_alogin
         * @static
         * @param {pb_alogin} message pb_alogin
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_alogin.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.flag = "";
                object.cd = 0;
                object.idx = 0;
                object.num = 0;
                object.cd2 = 0;
                object.first = 0;
            }
            if (message.flag != null && message.hasOwnProperty("flag"))
                object.flag = message.flag;
            if (message.cd != null && message.hasOwnProperty("cd"))
                object.cd = message.cd;
            if (message.idx != null && message.hasOwnProperty("idx"))
                object.idx = message.idx;
            if (message.num != null && message.hasOwnProperty("num"))
                object.num = message.num;
            if (message.cd2 != null && message.hasOwnProperty("cd2"))
                object.cd2 = message.cd2;
            if (message.first != null && message.hasOwnProperty("first"))
                object.first = message.first;
            return object;
        };
    
        /**
         * Converts this pb_alogin to JSON.
         * @function toJSON
         * @memberof pb_alogin
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_alogin.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_alogin
         * @function getTypeUrl
         * @memberof pb_alogin
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_alogin.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_alogin";
        };
    
        return pb_alogin;
    })();
    
    $root.pb_act = (function() {
    
        /**
         * Properties of a pb_act.
         * @exports Ipb_act
         * @interface Ipb_act
         * @property {number} id pb_act id
         * @property {number|null} [status] pb_act status
         * @property {number|null} [cd] pb_act cd
         * @property {number|null} [limits] pb_act limits
         * @property {number|null} [read] pb_act read
         * @property {number|null} [next] pb_act next
         * @property {number|null} [loop] pb_act loop
         * @property {number|null} [bomb] pb_act bomb
         * @property {Ipb_monopoly|null} [monopoly] pb_act monopoly
         * @property {string|null} [code] pb_act code
         * @property {number|null} [limits2] pb_act limits2
         * @property {number|null} [bir] pb_act bir
         * @property {Ipb_kvs|null} [kv] pb_act kv
         * @property {Array.<Ipb_growup>|null} [grow] pb_act grow
         */
    
        /**
         * Constructs a new pb_act.
         * @exports pb_act
         * @classdesc Represents a pb_act.
         * @implements Ipb_act
         * @constructor
         * @param {Ipb_act=} [properties] Properties to set
         */
        function pb_act(properties) {
            this.grow = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_act id.
         * @member {number} id
         * @memberof pb_act
         * @instance
         */
        pb_act.prototype.id = 0;
    
        /**
         * pb_act status.
         * @member {number} status
         * @memberof pb_act
         * @instance
         */
        pb_act.prototype.status = 0;
    
        /**
         * pb_act cd.
         * @member {number} cd
         * @memberof pb_act
         * @instance
         */
        pb_act.prototype.cd = 0;
    
        /**
         * pb_act limits.
         * @member {number} limits
         * @memberof pb_act
         * @instance
         */
        pb_act.prototype.limits = 0;
    
        /**
         * pb_act read.
         * @member {number} read
         * @memberof pb_act
         * @instance
         */
        pb_act.prototype.read = 0;
    
        /**
         * pb_act next.
         * @member {number} next
         * @memberof pb_act
         * @instance
         */
        pb_act.prototype.next = 0;
    
        /**
         * pb_act loop.
         * @member {number} loop
         * @memberof pb_act
         * @instance
         */
        pb_act.prototype.loop = 0;
    
        /**
         * pb_act bomb.
         * @member {number} bomb
         * @memberof pb_act
         * @instance
         */
        pb_act.prototype.bomb = 0;
    
        /**
         * pb_act monopoly.
         * @member {Ipb_monopoly|null|undefined} monopoly
         * @memberof pb_act
         * @instance
         */
        pb_act.prototype.monopoly = null;
    
        /**
         * pb_act code.
         * @member {string} code
         * @memberof pb_act
         * @instance
         */
        pb_act.prototype.code = "";
    
        /**
         * pb_act limits2.
         * @member {number} limits2
         * @memberof pb_act
         * @instance
         */
        pb_act.prototype.limits2 = 0;
    
        /**
         * pb_act bir.
         * @member {number} bir
         * @memberof pb_act
         * @instance
         */
        pb_act.prototype.bir = 0;
    
        /**
         * pb_act kv.
         * @member {Ipb_kvs|null|undefined} kv
         * @memberof pb_act
         * @instance
         */
        pb_act.prototype.kv = null;
    
        /**
         * pb_act grow.
         * @member {Array.<Ipb_growup>} grow
         * @memberof pb_act
         * @instance
         */
        pb_act.prototype.grow = $util.emptyArray;
    
        /**
         * Creates a new pb_act instance using the specified properties.
         * @function create
         * @memberof pb_act
         * @static
         * @param {Ipb_act=} [properties] Properties to set
         * @returns {pb_act} pb_act instance
         */
        pb_act.create = function create(properties) {
            return new pb_act(properties);
        };
    
        /**
         * Encodes the specified pb_act message. Does not implicitly {@link pb_act.verify|verify} messages.
         * @function encode
         * @memberof pb_act
         * @static
         * @param {Ipb_act} message pb_act message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_act.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.id);
            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.status);
            if (message.cd != null && Object.hasOwnProperty.call(message, "cd"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.cd);
            if (message.limits != null && Object.hasOwnProperty.call(message, "limits"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.limits);
            if (message.read != null && Object.hasOwnProperty.call(message, "read"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.read);
            if (message.next != null && Object.hasOwnProperty.call(message, "next"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.next);
            if (message.loop != null && Object.hasOwnProperty.call(message, "loop"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.loop);
            if (message.bomb != null && Object.hasOwnProperty.call(message, "bomb"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.bomb);
            if (message.monopoly != null && Object.hasOwnProperty.call(message, "monopoly"))
                $root.pb_monopoly.encode(message.monopoly, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
            if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                writer.uint32(/* id 10, wireType 2 =*/82).string(message.code);
            if (message.limits2 != null && Object.hasOwnProperty.call(message, "limits2"))
                writer.uint32(/* id 11, wireType 0 =*/88).int32(message.limits2);
            if (message.bir != null && Object.hasOwnProperty.call(message, "bir"))
                writer.uint32(/* id 12, wireType 0 =*/96).int32(message.bir);
            if (message.kv != null && Object.hasOwnProperty.call(message, "kv"))
                $root.pb_kvs.encode(message.kv, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
            if (message.grow != null && message.grow.length)
                for (var i = 0; i < message.grow.length; ++i)
                    $root.pb_growup.encode(message.grow[i], writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified pb_act message, length delimited. Does not implicitly {@link pb_act.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_act
         * @static
         * @param {Ipb_act} message pb_act message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_act.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_act message from the specified reader or buffer.
         * @function decode
         * @memberof pb_act
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_act} pb_act
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_act.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_act();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.id = reader.uint32();
                        break;
                    }
                case 2: {
                        message.status = reader.int32();
                        break;
                    }
                case 3: {
                        message.cd = reader.uint32();
                        break;
                    }
                case 4: {
                        message.limits = reader.int32();
                        break;
                    }
                case 5: {
                        message.read = reader.int32();
                        break;
                    }
                case 6: {
                        message.next = reader.uint32();
                        break;
                    }
                case 7: {
                        message.loop = reader.int32();
                        break;
                    }
                case 8: {
                        message.bomb = reader.int32();
                        break;
                    }
                case 9: {
                        message.monopoly = $root.pb_monopoly.decode(reader, reader.uint32());
                        break;
                    }
                case 10: {
                        message.code = reader.string();
                        break;
                    }
                case 11: {
                        message.limits2 = reader.int32();
                        break;
                    }
                case 12: {
                        message.bir = reader.int32();
                        break;
                    }
                case 13: {
                        message.kv = $root.pb_kvs.decode(reader, reader.uint32());
                        break;
                    }
                case 14: {
                        if (!(message.grow && message.grow.length))
                            message.grow = [];
                        message.grow.push($root.pb_growup.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("id"))
                throw $util.ProtocolError("missing required 'id'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a pb_act message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_act
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_act} pb_act
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_act.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_act message.
         * @function verify
         * @memberof pb_act
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_act.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.id))
                return "id: integer expected";
            if (message.status != null && message.hasOwnProperty("status"))
                if (!$util.isInteger(message.status))
                    return "status: integer expected";
            if (message.cd != null && message.hasOwnProperty("cd"))
                if (!$util.isInteger(message.cd))
                    return "cd: integer expected";
            if (message.limits != null && message.hasOwnProperty("limits"))
                if (!$util.isInteger(message.limits))
                    return "limits: integer expected";
            if (message.read != null && message.hasOwnProperty("read"))
                if (!$util.isInteger(message.read))
                    return "read: integer expected";
            if (message.next != null && message.hasOwnProperty("next"))
                if (!$util.isInteger(message.next))
                    return "next: integer expected";
            if (message.loop != null && message.hasOwnProperty("loop"))
                if (!$util.isInteger(message.loop))
                    return "loop: integer expected";
            if (message.bomb != null && message.hasOwnProperty("bomb"))
                if (!$util.isInteger(message.bomb))
                    return "bomb: integer expected";
            if (message.monopoly != null && message.hasOwnProperty("monopoly")) {
                var error = $root.pb_monopoly.verify(message.monopoly);
                if (error)
                    return "monopoly." + error;
            }
            if (message.code != null && message.hasOwnProperty("code"))
                if (!$util.isString(message.code))
                    return "code: string expected";
            if (message.limits2 != null && message.hasOwnProperty("limits2"))
                if (!$util.isInteger(message.limits2))
                    return "limits2: integer expected";
            if (message.bir != null && message.hasOwnProperty("bir"))
                if (!$util.isInteger(message.bir))
                    return "bir: integer expected";
            if (message.kv != null && message.hasOwnProperty("kv")) {
                var error = $root.pb_kvs.verify(message.kv);
                if (error)
                    return "kv." + error;
            }
            if (message.grow != null && message.hasOwnProperty("grow")) {
                if (!Array.isArray(message.grow))
                    return "grow: array expected";
                for (var i = 0; i < message.grow.length; ++i) {
                    var error = $root.pb_growup.verify(message.grow[i]);
                    if (error)
                        return "grow." + error;
                }
            }
            return null;
        };
    
        /**
         * Creates a pb_act message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_act
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_act} pb_act
         */
        pb_act.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_act)
                return object;
            var message = new $root.pb_act();
            if (object.id != null)
                message.id = object.id >>> 0;
            if (object.status != null)
                message.status = object.status | 0;
            if (object.cd != null)
                message.cd = object.cd >>> 0;
            if (object.limits != null)
                message.limits = object.limits | 0;
            if (object.read != null)
                message.read = object.read | 0;
            if (object.next != null)
                message.next = object.next >>> 0;
            if (object.loop != null)
                message.loop = object.loop | 0;
            if (object.bomb != null)
                message.bomb = object.bomb | 0;
            if (object.monopoly != null) {
                if (typeof object.monopoly !== "object")
                    throw TypeError(".pb_act.monopoly: object expected");
                message.monopoly = $root.pb_monopoly.fromObject(object.monopoly);
            }
            if (object.code != null)
                message.code = String(object.code);
            if (object.limits2 != null)
                message.limits2 = object.limits2 | 0;
            if (object.bir != null)
                message.bir = object.bir | 0;
            if (object.kv != null) {
                if (typeof object.kv !== "object")
                    throw TypeError(".pb_act.kv: object expected");
                message.kv = $root.pb_kvs.fromObject(object.kv);
            }
            if (object.grow) {
                if (!Array.isArray(object.grow))
                    throw TypeError(".pb_act.grow: array expected");
                message.grow = [];
                for (var i = 0; i < object.grow.length; ++i) {
                    if (typeof object.grow[i] !== "object")
                        throw TypeError(".pb_act.grow: object expected");
                    message.grow[i] = $root.pb_growup.fromObject(object.grow[i]);
                }
            }
            return message;
        };
    
        /**
         * Creates a plain object from a pb_act message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_act
         * @static
         * @param {pb_act} message pb_act
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_act.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.grow = [];
            if (options.defaults) {
                object.id = 0;
                object.status = 0;
                object.cd = 0;
                object.limits = 0;
                object.read = 0;
                object.next = 0;
                object.loop = 0;
                object.bomb = 0;
                object.monopoly = null;
                object.code = "";
                object.limits2 = 0;
                object.bir = 0;
                object.kv = null;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = message.status;
            if (message.cd != null && message.hasOwnProperty("cd"))
                object.cd = message.cd;
            if (message.limits != null && message.hasOwnProperty("limits"))
                object.limits = message.limits;
            if (message.read != null && message.hasOwnProperty("read"))
                object.read = message.read;
            if (message.next != null && message.hasOwnProperty("next"))
                object.next = message.next;
            if (message.loop != null && message.hasOwnProperty("loop"))
                object.loop = message.loop;
            if (message.bomb != null && message.hasOwnProperty("bomb"))
                object.bomb = message.bomb;
            if (message.monopoly != null && message.hasOwnProperty("monopoly"))
                object.monopoly = $root.pb_monopoly.toObject(message.monopoly, options);
            if (message.code != null && message.hasOwnProperty("code"))
                object.code = message.code;
            if (message.limits2 != null && message.hasOwnProperty("limits2"))
                object.limits2 = message.limits2;
            if (message.bir != null && message.hasOwnProperty("bir"))
                object.bir = message.bir;
            if (message.kv != null && message.hasOwnProperty("kv"))
                object.kv = $root.pb_kvs.toObject(message.kv, options);
            if (message.grow && message.grow.length) {
                object.grow = [];
                for (var j = 0; j < message.grow.length; ++j)
                    object.grow[j] = $root.pb_growup.toObject(message.grow[j], options);
            }
            return object;
        };
    
        /**
         * Converts this pb_act to JSON.
         * @function toJSON
         * @memberof pb_act
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_act.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_act
         * @function getTypeUrl
         * @memberof pb_act
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_act.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_act";
        };
    
        return pb_act;
    })();
    
    $root.pb_qstar = (function() {
    
        /**
         * Properties of a pb_qstar.
         * @exports Ipb_qstar
         * @interface Ipb_qstar
         * @property {number|Long|null} [uid] pb_qstar uid
         * @property {string|null} [name] pb_qstar name
         * @property {number|null} [logo] pb_qstar logo
         * @property {number|null} [score] pb_qstar score
         */
    
        /**
         * Constructs a new pb_qstar.
         * @exports pb_qstar
         * @classdesc Represents a pb_qstar.
         * @implements Ipb_qstar
         * @constructor
         * @param {Ipb_qstar=} [properties] Properties to set
         */
        function pb_qstar(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_qstar uid.
         * @member {number|Long} uid
         * @memberof pb_qstar
         * @instance
         */
        pb_qstar.prototype.uid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * pb_qstar name.
         * @member {string} name
         * @memberof pb_qstar
         * @instance
         */
        pb_qstar.prototype.name = "";
    
        /**
         * pb_qstar logo.
         * @member {number} logo
         * @memberof pb_qstar
         * @instance
         */
        pb_qstar.prototype.logo = 0;
    
        /**
         * pb_qstar score.
         * @member {number} score
         * @memberof pb_qstar
         * @instance
         */
        pb_qstar.prototype.score = 0;
    
        /**
         * Creates a new pb_qstar instance using the specified properties.
         * @function create
         * @memberof pb_qstar
         * @static
         * @param {Ipb_qstar=} [properties] Properties to set
         * @returns {pb_qstar} pb_qstar instance
         */
        pb_qstar.create = function create(properties) {
            return new pb_qstar(properties);
        };
    
        /**
         * Encodes the specified pb_qstar message. Does not implicitly {@link pb_qstar.verify|verify} messages.
         * @function encode
         * @memberof pb_qstar
         * @static
         * @param {Ipb_qstar} message pb_qstar message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_qstar.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.uid != null && Object.hasOwnProperty.call(message, "uid"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.uid);
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
            if (message.logo != null && Object.hasOwnProperty.call(message, "logo"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.logo);
            if (message.score != null && Object.hasOwnProperty.call(message, "score"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.score);
            return writer;
        };
    
        /**
         * Encodes the specified pb_qstar message, length delimited. Does not implicitly {@link pb_qstar.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_qstar
         * @static
         * @param {Ipb_qstar} message pb_qstar message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_qstar.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_qstar message from the specified reader or buffer.
         * @function decode
         * @memberof pb_qstar
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_qstar} pb_qstar
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_qstar.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_qstar();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.uid = reader.int64();
                        break;
                    }
                case 2: {
                        message.name = reader.string();
                        break;
                    }
                case 3: {
                        message.logo = reader.int32();
                        break;
                    }
                case 4: {
                        message.score = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a pb_qstar message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_qstar
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_qstar} pb_qstar
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_qstar.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_qstar message.
         * @function verify
         * @memberof pb_qstar
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_qstar.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (!$util.isInteger(message.uid) && !(message.uid && $util.isInteger(message.uid.low) && $util.isInteger(message.uid.high)))
                    return "uid: integer|Long expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.logo != null && message.hasOwnProperty("logo"))
                if (!$util.isInteger(message.logo))
                    return "logo: integer expected";
            if (message.score != null && message.hasOwnProperty("score"))
                if (!$util.isInteger(message.score))
                    return "score: integer expected";
            return null;
        };
    
        /**
         * Creates a pb_qstar message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_qstar
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_qstar} pb_qstar
         */
        pb_qstar.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_qstar)
                return object;
            var message = new $root.pb_qstar();
            if (object.uid != null)
                if ($util.Long)
                    (message.uid = $util.Long.fromValue(object.uid)).unsigned = false;
                else if (typeof object.uid === "string")
                    message.uid = parseInt(object.uid, 10);
                else if (typeof object.uid === "number")
                    message.uid = object.uid;
                else if (typeof object.uid === "object")
                    message.uid = new $util.LongBits(object.uid.low >>> 0, object.uid.high >>> 0).toNumber();
            if (object.name != null)
                message.name = String(object.name);
            if (object.logo != null)
                message.logo = object.logo | 0;
            if (object.score != null)
                message.score = object.score >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a pb_qstar message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_qstar
         * @static
         * @param {pb_qstar} message pb_qstar
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_qstar.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.uid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.uid = options.longs === String ? "0" : 0;
                object.name = "";
                object.logo = 0;
                object.score = 0;
            }
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (typeof message.uid === "number")
                    object.uid = options.longs === String ? String(message.uid) : message.uid;
                else
                    object.uid = options.longs === String ? $util.Long.prototype.toString.call(message.uid) : options.longs === Number ? new $util.LongBits(message.uid.low >>> 0, message.uid.high >>> 0).toNumber() : message.uid;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.logo != null && message.hasOwnProperty("logo"))
                object.logo = message.logo;
            if (message.score != null && message.hasOwnProperty("score"))
                object.score = message.score;
            return object;
        };
    
        /**
         * Converts this pb_qstar to JSON.
         * @function toJSON
         * @memberof pb_qstar
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_qstar.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_qstar
         * @function getTypeUrl
         * @memberof pb_qstar
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_qstar.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_qstar";
        };
    
        return pb_qstar;
    })();
    
    $root.pb_monopoly = (function() {
    
        /**
         * Properties of a pb_monopoly.
         * @exports Ipb_monopoly
         * @interface Ipb_monopoly
         * @property {number} pos pb_monopoly pos
         * @property {Array.<number>|null} [lv] pb_monopoly lv
         * @property {number|null} [nextEvent] pb_monopoly nextEvent
         * @property {number|null} [star] pb_monopoly star
         */
    
        /**
         * Constructs a new pb_monopoly.
         * @exports pb_monopoly
         * @classdesc Represents a pb_monopoly.
         * @implements Ipb_monopoly
         * @constructor
         * @param {Ipb_monopoly=} [properties] Properties to set
         */
        function pb_monopoly(properties) {
            this.lv = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_monopoly pos.
         * @member {number} pos
         * @memberof pb_monopoly
         * @instance
         */
        pb_monopoly.prototype.pos = 0;
    
        /**
         * pb_monopoly lv.
         * @member {Array.<number>} lv
         * @memberof pb_monopoly
         * @instance
         */
        pb_monopoly.prototype.lv = $util.emptyArray;
    
        /**
         * pb_monopoly nextEvent.
         * @member {number} nextEvent
         * @memberof pb_monopoly
         * @instance
         */
        pb_monopoly.prototype.nextEvent = 0;
    
        /**
         * pb_monopoly star.
         * @member {number} star
         * @memberof pb_monopoly
         * @instance
         */
        pb_monopoly.prototype.star = 0;
    
        /**
         * Creates a new pb_monopoly instance using the specified properties.
         * @function create
         * @memberof pb_monopoly
         * @static
         * @param {Ipb_monopoly=} [properties] Properties to set
         * @returns {pb_monopoly} pb_monopoly instance
         */
        pb_monopoly.create = function create(properties) {
            return new pb_monopoly(properties);
        };
    
        /**
         * Encodes the specified pb_monopoly message. Does not implicitly {@link pb_monopoly.verify|verify} messages.
         * @function encode
         * @memberof pb_monopoly
         * @static
         * @param {Ipb_monopoly} message pb_monopoly message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_monopoly.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.pos);
            if (message.lv != null && message.lv.length)
                for (var i = 0; i < message.lv.length; ++i)
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.lv[i]);
            if (message.nextEvent != null && Object.hasOwnProperty.call(message, "nextEvent"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.nextEvent);
            if (message.star != null && Object.hasOwnProperty.call(message, "star"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.star);
            return writer;
        };
    
        /**
         * Encodes the specified pb_monopoly message, length delimited. Does not implicitly {@link pb_monopoly.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_monopoly
         * @static
         * @param {Ipb_monopoly} message pb_monopoly message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_monopoly.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_monopoly message from the specified reader or buffer.
         * @function decode
         * @memberof pb_monopoly
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_monopoly} pb_monopoly
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_monopoly.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_monopoly();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.pos = reader.int32();
                        break;
                    }
                case 2: {
                        if (!(message.lv && message.lv.length))
                            message.lv = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.lv.push(reader.int32());
                        } else
                            message.lv.push(reader.int32());
                        break;
                    }
                case 3: {
                        message.nextEvent = reader.int32();
                        break;
                    }
                case 4: {
                        message.star = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("pos"))
                throw $util.ProtocolError("missing required 'pos'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a pb_monopoly message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_monopoly
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_monopoly} pb_monopoly
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_monopoly.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_monopoly message.
         * @function verify
         * @memberof pb_monopoly
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_monopoly.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.pos))
                return "pos: integer expected";
            if (message.lv != null && message.hasOwnProperty("lv")) {
                if (!Array.isArray(message.lv))
                    return "lv: array expected";
                for (var i = 0; i < message.lv.length; ++i)
                    if (!$util.isInteger(message.lv[i]))
                        return "lv: integer[] expected";
            }
            if (message.nextEvent != null && message.hasOwnProperty("nextEvent"))
                if (!$util.isInteger(message.nextEvent))
                    return "nextEvent: integer expected";
            if (message.star != null && message.hasOwnProperty("star"))
                if (!$util.isInteger(message.star))
                    return "star: integer expected";
            return null;
        };
    
        /**
         * Creates a pb_monopoly message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_monopoly
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_monopoly} pb_monopoly
         */
        pb_monopoly.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_monopoly)
                return object;
            var message = new $root.pb_monopoly();
            if (object.pos != null)
                message.pos = object.pos | 0;
            if (object.lv) {
                if (!Array.isArray(object.lv))
                    throw TypeError(".pb_monopoly.lv: array expected");
                message.lv = [];
                for (var i = 0; i < object.lv.length; ++i)
                    message.lv[i] = object.lv[i] | 0;
            }
            if (object.nextEvent != null)
                message.nextEvent = object.nextEvent | 0;
            if (object.star != null)
                message.star = object.star | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a pb_monopoly message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_monopoly
         * @static
         * @param {pb_monopoly} message pb_monopoly
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_monopoly.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.lv = [];
            if (options.defaults) {
                object.pos = 0;
                object.nextEvent = 0;
                object.star = 0;
            }
            if (message.pos != null && message.hasOwnProperty("pos"))
                object.pos = message.pos;
            if (message.lv && message.lv.length) {
                object.lv = [];
                for (var j = 0; j < message.lv.length; ++j)
                    object.lv[j] = message.lv[j];
            }
            if (message.nextEvent != null && message.hasOwnProperty("nextEvent"))
                object.nextEvent = message.nextEvent;
            if (message.star != null && message.hasOwnProperty("star"))
                object.star = message.star;
            return object;
        };
    
        /**
         * Converts this pb_monopoly to JSON.
         * @function toJSON
         * @memberof pb_monopoly
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_monopoly.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_monopoly
         * @function getTypeUrl
         * @memberof pb_monopoly
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_monopoly.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_monopoly";
        };
    
        return pb_monopoly;
    })();
    
    $root.pb_monopoly_step = (function() {
    
        /**
         * Properties of a pb_monopoly_step.
         * @exports Ipb_monopoly_step
         * @interface Ipb_monopoly_step
         * @property {number} id pb_monopoly_step id
         * @property {Array.<Ipb_item>|null} [reward] pb_monopoly_step reward
         * @property {number|null} [star] pb_monopoly_step star
         * @property {number|null} [event] pb_monopoly_step event
         * @property {Array.<number>|null} [cards] pb_monopoly_step cards
         * @property {number|null} [opId] pb_monopoly_step opId
         */
    
        /**
         * Constructs a new pb_monopoly_step.
         * @exports pb_monopoly_step
         * @classdesc Represents a pb_monopoly_step.
         * @implements Ipb_monopoly_step
         * @constructor
         * @param {Ipb_monopoly_step=} [properties] Properties to set
         */
        function pb_monopoly_step(properties) {
            this.reward = [];
            this.cards = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_monopoly_step id.
         * @member {number} id
         * @memberof pb_monopoly_step
         * @instance
         */
        pb_monopoly_step.prototype.id = 0;
    
        /**
         * pb_monopoly_step reward.
         * @member {Array.<Ipb_item>} reward
         * @memberof pb_monopoly_step
         * @instance
         */
        pb_monopoly_step.prototype.reward = $util.emptyArray;
    
        /**
         * pb_monopoly_step star.
         * @member {number} star
         * @memberof pb_monopoly_step
         * @instance
         */
        pb_monopoly_step.prototype.star = 0;
    
        /**
         * pb_monopoly_step event.
         * @member {number} event
         * @memberof pb_monopoly_step
         * @instance
         */
        pb_monopoly_step.prototype.event = 0;
    
        /**
         * pb_monopoly_step cards.
         * @member {Array.<number>} cards
         * @memberof pb_monopoly_step
         * @instance
         */
        pb_monopoly_step.prototype.cards = $util.emptyArray;
    
        /**
         * pb_monopoly_step opId.
         * @member {number} opId
         * @memberof pb_monopoly_step
         * @instance
         */
        pb_monopoly_step.prototype.opId = 0;
    
        /**
         * Creates a new pb_monopoly_step instance using the specified properties.
         * @function create
         * @memberof pb_monopoly_step
         * @static
         * @param {Ipb_monopoly_step=} [properties] Properties to set
         * @returns {pb_monopoly_step} pb_monopoly_step instance
         */
        pb_monopoly_step.create = function create(properties) {
            return new pb_monopoly_step(properties);
        };
    
        /**
         * Encodes the specified pb_monopoly_step message. Does not implicitly {@link pb_monopoly_step.verify|verify} messages.
         * @function encode
         * @memberof pb_monopoly_step
         * @static
         * @param {Ipb_monopoly_step} message pb_monopoly_step message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_monopoly_step.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.id);
            if (message.reward != null && message.reward.length)
                for (var i = 0; i < message.reward.length; ++i)
                    $root.pb_item.encode(message.reward[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.star != null && Object.hasOwnProperty.call(message, "star"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.star);
            if (message.event != null && Object.hasOwnProperty.call(message, "event"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.event);
            if (message.cards != null && message.cards.length)
                for (var i = 0; i < message.cards.length; ++i)
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.cards[i]);
            if (message.opId != null && Object.hasOwnProperty.call(message, "opId"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.opId);
            return writer;
        };
    
        /**
         * Encodes the specified pb_monopoly_step message, length delimited. Does not implicitly {@link pb_monopoly_step.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_monopoly_step
         * @static
         * @param {Ipb_monopoly_step} message pb_monopoly_step message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_monopoly_step.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_monopoly_step message from the specified reader or buffer.
         * @function decode
         * @memberof pb_monopoly_step
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_monopoly_step} pb_monopoly_step
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_monopoly_step.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_monopoly_step();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.id = reader.int32();
                        break;
                    }
                case 2: {
                        if (!(message.reward && message.reward.length))
                            message.reward = [];
                        message.reward.push($root.pb_item.decode(reader, reader.uint32()));
                        break;
                    }
                case 3: {
                        message.star = reader.int32();
                        break;
                    }
                case 4: {
                        message.event = reader.int32();
                        break;
                    }
                case 5: {
                        if (!(message.cards && message.cards.length))
                            message.cards = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.cards.push(reader.int32());
                        } else
                            message.cards.push(reader.int32());
                        break;
                    }
                case 6: {
                        message.opId = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("id"))
                throw $util.ProtocolError("missing required 'id'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a pb_monopoly_step message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_monopoly_step
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_monopoly_step} pb_monopoly_step
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_monopoly_step.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_monopoly_step message.
         * @function verify
         * @memberof pb_monopoly_step
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_monopoly_step.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.id))
                return "id: integer expected";
            if (message.reward != null && message.hasOwnProperty("reward")) {
                if (!Array.isArray(message.reward))
                    return "reward: array expected";
                for (var i = 0; i < message.reward.length; ++i) {
                    var error = $root.pb_item.verify(message.reward[i]);
                    if (error)
                        return "reward." + error;
                }
            }
            if (message.star != null && message.hasOwnProperty("star"))
                if (!$util.isInteger(message.star))
                    return "star: integer expected";
            if (message.event != null && message.hasOwnProperty("event"))
                if (!$util.isInteger(message.event))
                    return "event: integer expected";
            if (message.cards != null && message.hasOwnProperty("cards")) {
                if (!Array.isArray(message.cards))
                    return "cards: array expected";
                for (var i = 0; i < message.cards.length; ++i)
                    if (!$util.isInteger(message.cards[i]))
                        return "cards: integer[] expected";
            }
            if (message.opId != null && message.hasOwnProperty("opId"))
                if (!$util.isInteger(message.opId))
                    return "opId: integer expected";
            return null;
        };
    
        /**
         * Creates a pb_monopoly_step message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_monopoly_step
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_monopoly_step} pb_monopoly_step
         */
        pb_monopoly_step.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_monopoly_step)
                return object;
            var message = new $root.pb_monopoly_step();
            if (object.id != null)
                message.id = object.id | 0;
            if (object.reward) {
                if (!Array.isArray(object.reward))
                    throw TypeError(".pb_monopoly_step.reward: array expected");
                message.reward = [];
                for (var i = 0; i < object.reward.length; ++i) {
                    if (typeof object.reward[i] !== "object")
                        throw TypeError(".pb_monopoly_step.reward: object expected");
                    message.reward[i] = $root.pb_item.fromObject(object.reward[i]);
                }
            }
            if (object.star != null)
                message.star = object.star | 0;
            if (object.event != null)
                message.event = object.event | 0;
            if (object.cards) {
                if (!Array.isArray(object.cards))
                    throw TypeError(".pb_monopoly_step.cards: array expected");
                message.cards = [];
                for (var i = 0; i < object.cards.length; ++i)
                    message.cards[i] = object.cards[i] | 0;
            }
            if (object.opId != null)
                message.opId = object.opId | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a pb_monopoly_step message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_monopoly_step
         * @static
         * @param {pb_monopoly_step} message pb_monopoly_step
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_monopoly_step.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.reward = [];
                object.cards = [];
            }
            if (options.defaults) {
                object.id = 0;
                object.star = 0;
                object.event = 0;
                object.opId = 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.reward && message.reward.length) {
                object.reward = [];
                for (var j = 0; j < message.reward.length; ++j)
                    object.reward[j] = $root.pb_item.toObject(message.reward[j], options);
            }
            if (message.star != null && message.hasOwnProperty("star"))
                object.star = message.star;
            if (message.event != null && message.hasOwnProperty("event"))
                object.event = message.event;
            if (message.cards && message.cards.length) {
                object.cards = [];
                for (var j = 0; j < message.cards.length; ++j)
                    object.cards[j] = message.cards[j];
            }
            if (message.opId != null && message.hasOwnProperty("opId"))
                object.opId = message.opId;
            return object;
        };
    
        /**
         * Converts this pb_monopoly_step to JSON.
         * @function toJSON
         * @memberof pb_monopoly_step
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_monopoly_step.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_monopoly_step
         * @function getTypeUrl
         * @memberof pb_monopoly_step
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_monopoly_step.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_monopoly_step";
        };
    
        return pb_monopoly_step;
    })();
    
    $root.pb_dice_sweep = (function() {
    
        /**
         * Properties of a pb_dice_sweep.
         * @exports Ipb_dice_sweep
         * @interface Ipb_dice_sweep
         * @property {number|null} [type] pb_dice_sweep type
         * @property {Array.<Ipb_monopoly_step>|null} [steps] pb_dice_sweep steps
         * @property {number|null} [num1] pb_dice_sweep num1
         * @property {number|null} [num2] pb_dice_sweep num2
         */
    
        /**
         * Constructs a new pb_dice_sweep.
         * @exports pb_dice_sweep
         * @classdesc Represents a pb_dice_sweep.
         * @implements Ipb_dice_sweep
         * @constructor
         * @param {Ipb_dice_sweep=} [properties] Properties to set
         */
        function pb_dice_sweep(properties) {
            this.steps = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_dice_sweep type.
         * @member {number} type
         * @memberof pb_dice_sweep
         * @instance
         */
        pb_dice_sweep.prototype.type = 0;
    
        /**
         * pb_dice_sweep steps.
         * @member {Array.<Ipb_monopoly_step>} steps
         * @memberof pb_dice_sweep
         * @instance
         */
        pb_dice_sweep.prototype.steps = $util.emptyArray;
    
        /**
         * pb_dice_sweep num1.
         * @member {number} num1
         * @memberof pb_dice_sweep
         * @instance
         */
        pb_dice_sweep.prototype.num1 = 0;
    
        /**
         * pb_dice_sweep num2.
         * @member {number} num2
         * @memberof pb_dice_sweep
         * @instance
         */
        pb_dice_sweep.prototype.num2 = 0;
    
        /**
         * Creates a new pb_dice_sweep instance using the specified properties.
         * @function create
         * @memberof pb_dice_sweep
         * @static
         * @param {Ipb_dice_sweep=} [properties] Properties to set
         * @returns {pb_dice_sweep} pb_dice_sweep instance
         */
        pb_dice_sweep.create = function create(properties) {
            return new pb_dice_sweep(properties);
        };
    
        /**
         * Encodes the specified pb_dice_sweep message. Does not implicitly {@link pb_dice_sweep.verify|verify} messages.
         * @function encode
         * @memberof pb_dice_sweep
         * @static
         * @param {Ipb_dice_sweep} message pb_dice_sweep message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_dice_sweep.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            if (message.steps != null && message.steps.length)
                for (var i = 0; i < message.steps.length; ++i)
                    $root.pb_monopoly_step.encode(message.steps[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.num1 != null && Object.hasOwnProperty.call(message, "num1"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.num1);
            if (message.num2 != null && Object.hasOwnProperty.call(message, "num2"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.num2);
            return writer;
        };
    
        /**
         * Encodes the specified pb_dice_sweep message, length delimited. Does not implicitly {@link pb_dice_sweep.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_dice_sweep
         * @static
         * @param {Ipb_dice_sweep} message pb_dice_sweep message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_dice_sweep.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_dice_sweep message from the specified reader or buffer.
         * @function decode
         * @memberof pb_dice_sweep
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_dice_sweep} pb_dice_sweep
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_dice_sweep.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_dice_sweep();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.type = reader.int32();
                        break;
                    }
                case 2: {
                        if (!(message.steps && message.steps.length))
                            message.steps = [];
                        message.steps.push($root.pb_monopoly_step.decode(reader, reader.uint32()));
                        break;
                    }
                case 3: {
                        message.num1 = reader.int32();
                        break;
                    }
                case 4: {
                        message.num2 = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a pb_dice_sweep message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_dice_sweep
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_dice_sweep} pb_dice_sweep
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_dice_sweep.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_dice_sweep message.
         * @function verify
         * @memberof pb_dice_sweep
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_dice_sweep.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isInteger(message.type))
                    return "type: integer expected";
            if (message.steps != null && message.hasOwnProperty("steps")) {
                if (!Array.isArray(message.steps))
                    return "steps: array expected";
                for (var i = 0; i < message.steps.length; ++i) {
                    var error = $root.pb_monopoly_step.verify(message.steps[i]);
                    if (error)
                        return "steps." + error;
                }
            }
            if (message.num1 != null && message.hasOwnProperty("num1"))
                if (!$util.isInteger(message.num1))
                    return "num1: integer expected";
            if (message.num2 != null && message.hasOwnProperty("num2"))
                if (!$util.isInteger(message.num2))
                    return "num2: integer expected";
            return null;
        };
    
        /**
         * Creates a pb_dice_sweep message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_dice_sweep
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_dice_sweep} pb_dice_sweep
         */
        pb_dice_sweep.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_dice_sweep)
                return object;
            var message = new $root.pb_dice_sweep();
            if (object.type != null)
                message.type = object.type | 0;
            if (object.steps) {
                if (!Array.isArray(object.steps))
                    throw TypeError(".pb_dice_sweep.steps: array expected");
                message.steps = [];
                for (var i = 0; i < object.steps.length; ++i) {
                    if (typeof object.steps[i] !== "object")
                        throw TypeError(".pb_dice_sweep.steps: object expected");
                    message.steps[i] = $root.pb_monopoly_step.fromObject(object.steps[i]);
                }
            }
            if (object.num1 != null)
                message.num1 = object.num1 | 0;
            if (object.num2 != null)
                message.num2 = object.num2 | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a pb_dice_sweep message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_dice_sweep
         * @static
         * @param {pb_dice_sweep} message pb_dice_sweep
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_dice_sweep.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.steps = [];
            if (options.defaults) {
                object.type = 0;
                object.num1 = 0;
                object.num2 = 0;
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            if (message.steps && message.steps.length) {
                object.steps = [];
                for (var j = 0; j < message.steps.length; ++j)
                    object.steps[j] = $root.pb_monopoly_step.toObject(message.steps[j], options);
            }
            if (message.num1 != null && message.hasOwnProperty("num1"))
                object.num1 = message.num1;
            if (message.num2 != null && message.hasOwnProperty("num2"))
                object.num2 = message.num2;
            return object;
        };
    
        /**
         * Converts this pb_dice_sweep to JSON.
         * @function toJSON
         * @memberof pb_dice_sweep
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_dice_sweep.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_dice_sweep
         * @function getTypeUrl
         * @memberof pb_dice_sweep
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_dice_sweep.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_dice_sweep";
        };
    
        return pb_dice_sweep;
    })();
    
    $root.pb_sact_item = (function() {
    
        /**
         * Properties of a pb_sact_item.
         * @exports Ipb_sact_item
         * @interface Ipb_sact_item
         * @property {number} id pb_sact_item id
         * @property {number|null} [cd] pb_sact_item cd
         * @property {number|null} [bomb] pb_sact_item bomb
         * @property {number|null} [limits] pb_sact_item limits
         * @property {number|null} [next] pb_sact_item next
         * @property {Array.<Ipb_sact_maze>|null} [maze] pb_sact_item maze
         * @property {number|null} [spec] pb_sact_item spec
         * @property {Array.<Ipb_kv>|null} [log] pb_sact_item log
         */
    
        /**
         * Constructs a new pb_sact_item.
         * @exports pb_sact_item
         * @classdesc Represents a pb_sact_item.
         * @implements Ipb_sact_item
         * @constructor
         * @param {Ipb_sact_item=} [properties] Properties to set
         */
        function pb_sact_item(properties) {
            this.maze = [];
            this.log = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_sact_item id.
         * @member {number} id
         * @memberof pb_sact_item
         * @instance
         */
        pb_sact_item.prototype.id = 0;
    
        /**
         * pb_sact_item cd.
         * @member {number} cd
         * @memberof pb_sact_item
         * @instance
         */
        pb_sact_item.prototype.cd = 0;
    
        /**
         * pb_sact_item bomb.
         * @member {number} bomb
         * @memberof pb_sact_item
         * @instance
         */
        pb_sact_item.prototype.bomb = 0;
    
        /**
         * pb_sact_item limits.
         * @member {number} limits
         * @memberof pb_sact_item
         * @instance
         */
        pb_sact_item.prototype.limits = 0;
    
        /**
         * pb_sact_item next.
         * @member {number} next
         * @memberof pb_sact_item
         * @instance
         */
        pb_sact_item.prototype.next = 0;
    
        /**
         * pb_sact_item maze.
         * @member {Array.<Ipb_sact_maze>} maze
         * @memberof pb_sact_item
         * @instance
         */
        pb_sact_item.prototype.maze = $util.emptyArray;
    
        /**
         * pb_sact_item spec.
         * @member {number} spec
         * @memberof pb_sact_item
         * @instance
         */
        pb_sact_item.prototype.spec = 0;
    
        /**
         * pb_sact_item log.
         * @member {Array.<Ipb_kv>} log
         * @memberof pb_sact_item
         * @instance
         */
        pb_sact_item.prototype.log = $util.emptyArray;
    
        /**
         * Creates a new pb_sact_item instance using the specified properties.
         * @function create
         * @memberof pb_sact_item
         * @static
         * @param {Ipb_sact_item=} [properties] Properties to set
         * @returns {pb_sact_item} pb_sact_item instance
         */
        pb_sact_item.create = function create(properties) {
            return new pb_sact_item(properties);
        };
    
        /**
         * Encodes the specified pb_sact_item message. Does not implicitly {@link pb_sact_item.verify|verify} messages.
         * @function encode
         * @memberof pb_sact_item
         * @static
         * @param {Ipb_sact_item} message pb_sact_item message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_sact_item.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.id);
            if (message.cd != null && Object.hasOwnProperty.call(message, "cd"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.cd);
            if (message.bomb != null && Object.hasOwnProperty.call(message, "bomb"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.bomb);
            if (message.limits != null && Object.hasOwnProperty.call(message, "limits"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.limits);
            if (message.next != null && Object.hasOwnProperty.call(message, "next"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.next);
            if (message.maze != null && message.maze.length)
                for (var i = 0; i < message.maze.length; ++i)
                    $root.pb_sact_maze.encode(message.maze[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.spec != null && Object.hasOwnProperty.call(message, "spec"))
                writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.spec);
            if (message.log != null && message.log.length)
                for (var i = 0; i < message.log.length; ++i)
                    $root.pb_kv.encode(message.log[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified pb_sact_item message, length delimited. Does not implicitly {@link pb_sact_item.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_sact_item
         * @static
         * @param {Ipb_sact_item} message pb_sact_item message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_sact_item.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_sact_item message from the specified reader or buffer.
         * @function decode
         * @memberof pb_sact_item
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_sact_item} pb_sact_item
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_sact_item.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_sact_item();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.id = reader.uint32();
                        break;
                    }
                case 2: {
                        message.cd = reader.uint32();
                        break;
                    }
                case 3: {
                        message.bomb = reader.int32();
                        break;
                    }
                case 4: {
                        message.limits = reader.int32();
                        break;
                    }
                case 5: {
                        message.next = reader.uint32();
                        break;
                    }
                case 6: {
                        if (!(message.maze && message.maze.length))
                            message.maze = [];
                        message.maze.push($root.pb_sact_maze.decode(reader, reader.uint32()));
                        break;
                    }
                case 7: {
                        message.spec = reader.uint32();
                        break;
                    }
                case 8: {
                        if (!(message.log && message.log.length))
                            message.log = [];
                        message.log.push($root.pb_kv.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("id"))
                throw $util.ProtocolError("missing required 'id'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a pb_sact_item message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_sact_item
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_sact_item} pb_sact_item
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_sact_item.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_sact_item message.
         * @function verify
         * @memberof pb_sact_item
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_sact_item.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.id))
                return "id: integer expected";
            if (message.cd != null && message.hasOwnProperty("cd"))
                if (!$util.isInteger(message.cd))
                    return "cd: integer expected";
            if (message.bomb != null && message.hasOwnProperty("bomb"))
                if (!$util.isInteger(message.bomb))
                    return "bomb: integer expected";
            if (message.limits != null && message.hasOwnProperty("limits"))
                if (!$util.isInteger(message.limits))
                    return "limits: integer expected";
            if (message.next != null && message.hasOwnProperty("next"))
                if (!$util.isInteger(message.next))
                    return "next: integer expected";
            if (message.maze != null && message.hasOwnProperty("maze")) {
                if (!Array.isArray(message.maze))
                    return "maze: array expected";
                for (var i = 0; i < message.maze.length; ++i) {
                    var error = $root.pb_sact_maze.verify(message.maze[i]);
                    if (error)
                        return "maze." + error;
                }
            }
            if (message.spec != null && message.hasOwnProperty("spec"))
                if (!$util.isInteger(message.spec))
                    return "spec: integer expected";
            if (message.log != null && message.hasOwnProperty("log")) {
                if (!Array.isArray(message.log))
                    return "log: array expected";
                for (var i = 0; i < message.log.length; ++i) {
                    var error = $root.pb_kv.verify(message.log[i]);
                    if (error)
                        return "log." + error;
                }
            }
            return null;
        };
    
        /**
         * Creates a pb_sact_item message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_sact_item
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_sact_item} pb_sact_item
         */
        pb_sact_item.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_sact_item)
                return object;
            var message = new $root.pb_sact_item();
            if (object.id != null)
                message.id = object.id >>> 0;
            if (object.cd != null)
                message.cd = object.cd >>> 0;
            if (object.bomb != null)
                message.bomb = object.bomb | 0;
            if (object.limits != null)
                message.limits = object.limits | 0;
            if (object.next != null)
                message.next = object.next >>> 0;
            if (object.maze) {
                if (!Array.isArray(object.maze))
                    throw TypeError(".pb_sact_item.maze: array expected");
                message.maze = [];
                for (var i = 0; i < object.maze.length; ++i) {
                    if (typeof object.maze[i] !== "object")
                        throw TypeError(".pb_sact_item.maze: object expected");
                    message.maze[i] = $root.pb_sact_maze.fromObject(object.maze[i]);
                }
            }
            if (object.spec != null)
                message.spec = object.spec >>> 0;
            if (object.log) {
                if (!Array.isArray(object.log))
                    throw TypeError(".pb_sact_item.log: array expected");
                message.log = [];
                for (var i = 0; i < object.log.length; ++i) {
                    if (typeof object.log[i] !== "object")
                        throw TypeError(".pb_sact_item.log: object expected");
                    message.log[i] = $root.pb_kv.fromObject(object.log[i]);
                }
            }
            return message;
        };
    
        /**
         * Creates a plain object from a pb_sact_item message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_sact_item
         * @static
         * @param {pb_sact_item} message pb_sact_item
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_sact_item.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.maze = [];
                object.log = [];
            }
            if (options.defaults) {
                object.id = 0;
                object.cd = 0;
                object.bomb = 0;
                object.limits = 0;
                object.next = 0;
                object.spec = 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.cd != null && message.hasOwnProperty("cd"))
                object.cd = message.cd;
            if (message.bomb != null && message.hasOwnProperty("bomb"))
                object.bomb = message.bomb;
            if (message.limits != null && message.hasOwnProperty("limits"))
                object.limits = message.limits;
            if (message.next != null && message.hasOwnProperty("next"))
                object.next = message.next;
            if (message.maze && message.maze.length) {
                object.maze = [];
                for (var j = 0; j < message.maze.length; ++j)
                    object.maze[j] = $root.pb_sact_maze.toObject(message.maze[j], options);
            }
            if (message.spec != null && message.hasOwnProperty("spec"))
                object.spec = message.spec;
            if (message.log && message.log.length) {
                object.log = [];
                for (var j = 0; j < message.log.length; ++j)
                    object.log[j] = $root.pb_kv.toObject(message.log[j], options);
            }
            return object;
        };
    
        /**
         * Converts this pb_sact_item to JSON.
         * @function toJSON
         * @memberof pb_sact_item
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_sact_item.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_sact_item
         * @function getTypeUrl
         * @memberof pb_sact_item
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_sact_item.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_sact_item";
        };
    
        return pb_sact_item;
    })();
    
    $root.pb_rabbit = (function() {
    
        /**
         * Properties of a pb_rabbit.
         * @exports Ipb_rabbit
         * @interface Ipb_rabbit
         * @property {number|null} [type] pb_rabbit type
         * @property {Array.<Ipb_kv>|null} [poses] pb_rabbit poses
         */
    
        /**
         * Constructs a new pb_rabbit.
         * @exports pb_rabbit
         * @classdesc Represents a pb_rabbit.
         * @implements Ipb_rabbit
         * @constructor
         * @param {Ipb_rabbit=} [properties] Properties to set
         */
        function pb_rabbit(properties) {
            this.poses = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_rabbit type.
         * @member {number} type
         * @memberof pb_rabbit
         * @instance
         */
        pb_rabbit.prototype.type = 0;
    
        /**
         * pb_rabbit poses.
         * @member {Array.<Ipb_kv>} poses
         * @memberof pb_rabbit
         * @instance
         */
        pb_rabbit.prototype.poses = $util.emptyArray;
    
        /**
         * Creates a new pb_rabbit instance using the specified properties.
         * @function create
         * @memberof pb_rabbit
         * @static
         * @param {Ipb_rabbit=} [properties] Properties to set
         * @returns {pb_rabbit} pb_rabbit instance
         */
        pb_rabbit.create = function create(properties) {
            return new pb_rabbit(properties);
        };
    
        /**
         * Encodes the specified pb_rabbit message. Does not implicitly {@link pb_rabbit.verify|verify} messages.
         * @function encode
         * @memberof pb_rabbit
         * @static
         * @param {Ipb_rabbit} message pb_rabbit message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_rabbit.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            if (message.poses != null && message.poses.length)
                for (var i = 0; i < message.poses.length; ++i)
                    $root.pb_kv.encode(message.poses[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified pb_rabbit message, length delimited. Does not implicitly {@link pb_rabbit.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_rabbit
         * @static
         * @param {Ipb_rabbit} message pb_rabbit message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_rabbit.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_rabbit message from the specified reader or buffer.
         * @function decode
         * @memberof pb_rabbit
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_rabbit} pb_rabbit
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_rabbit.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_rabbit();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.type = reader.int32();
                        break;
                    }
                case 3: {
                        if (!(message.poses && message.poses.length))
                            message.poses = [];
                        message.poses.push($root.pb_kv.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a pb_rabbit message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_rabbit
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_rabbit} pb_rabbit
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_rabbit.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_rabbit message.
         * @function verify
         * @memberof pb_rabbit
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_rabbit.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isInteger(message.type))
                    return "type: integer expected";
            if (message.poses != null && message.hasOwnProperty("poses")) {
                if (!Array.isArray(message.poses))
                    return "poses: array expected";
                for (var i = 0; i < message.poses.length; ++i) {
                    var error = $root.pb_kv.verify(message.poses[i]);
                    if (error)
                        return "poses." + error;
                }
            }
            return null;
        };
    
        /**
         * Creates a pb_rabbit message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_rabbit
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_rabbit} pb_rabbit
         */
        pb_rabbit.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_rabbit)
                return object;
            var message = new $root.pb_rabbit();
            if (object.type != null)
                message.type = object.type | 0;
            if (object.poses) {
                if (!Array.isArray(object.poses))
                    throw TypeError(".pb_rabbit.poses: array expected");
                message.poses = [];
                for (var i = 0; i < object.poses.length; ++i) {
                    if (typeof object.poses[i] !== "object")
                        throw TypeError(".pb_rabbit.poses: object expected");
                    message.poses[i] = $root.pb_kv.fromObject(object.poses[i]);
                }
            }
            return message;
        };
    
        /**
         * Creates a plain object from a pb_rabbit message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_rabbit
         * @static
         * @param {pb_rabbit} message pb_rabbit
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_rabbit.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.poses = [];
            if (options.defaults)
                object.type = 0;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            if (message.poses && message.poses.length) {
                object.poses = [];
                for (var j = 0; j < message.poses.length; ++j)
                    object.poses[j] = $root.pb_kv.toObject(message.poses[j], options);
            }
            return object;
        };
    
        /**
         * Converts this pb_rabbit to JSON.
         * @function toJSON
         * @memberof pb_rabbit
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_rabbit.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_rabbit
         * @function getTypeUrl
         * @memberof pb_rabbit
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_rabbit.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_rabbit";
        };
    
        return pb_rabbit;
    })();
    
    $root.pb_ract_item = (function() {
    
        /**
         * Properties of a pb_ract_item.
         * @exports Ipb_ract_item
         * @interface Ipb_ract_item
         * @property {number} id pb_ract_item id
         * @property {Array.<number>|null} [rewards] pb_ract_item rewards
         * @property {Array.<Ipb_item>|null} [item] pb_ract_item item
         * @property {number|null} [day] pb_ract_item day
         * @property {number|null} [cd] pb_ract_item cd
         */
    
        /**
         * Constructs a new pb_ract_item.
         * @exports pb_ract_item
         * @classdesc Represents a pb_ract_item.
         * @implements Ipb_ract_item
         * @constructor
         * @param {Ipb_ract_item=} [properties] Properties to set
         */
        function pb_ract_item(properties) {
            this.rewards = [];
            this.item = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_ract_item id.
         * @member {number} id
         * @memberof pb_ract_item
         * @instance
         */
        pb_ract_item.prototype.id = 0;
    
        /**
         * pb_ract_item rewards.
         * @member {Array.<number>} rewards
         * @memberof pb_ract_item
         * @instance
         */
        pb_ract_item.prototype.rewards = $util.emptyArray;
    
        /**
         * pb_ract_item item.
         * @member {Array.<Ipb_item>} item
         * @memberof pb_ract_item
         * @instance
         */
        pb_ract_item.prototype.item = $util.emptyArray;
    
        /**
         * pb_ract_item day.
         * @member {number} day
         * @memberof pb_ract_item
         * @instance
         */
        pb_ract_item.prototype.day = 0;
    
        /**
         * pb_ract_item cd.
         * @member {number} cd
         * @memberof pb_ract_item
         * @instance
         */
        pb_ract_item.prototype.cd = 0;
    
        /**
         * Creates a new pb_ract_item instance using the specified properties.
         * @function create
         * @memberof pb_ract_item
         * @static
         * @param {Ipb_ract_item=} [properties] Properties to set
         * @returns {pb_ract_item} pb_ract_item instance
         */
        pb_ract_item.create = function create(properties) {
            return new pb_ract_item(properties);
        };
    
        /**
         * Encodes the specified pb_ract_item message. Does not implicitly {@link pb_ract_item.verify|verify} messages.
         * @function encode
         * @memberof pb_ract_item
         * @static
         * @param {Ipb_ract_item} message pb_ract_item message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_ract_item.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.id);
            if (message.rewards != null && message.rewards.length)
                for (var i = 0; i < message.rewards.length; ++i)
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.rewards[i]);
            if (message.item != null && message.item.length)
                for (var i = 0; i < message.item.length; ++i)
                    $root.pb_item.encode(message.item[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.day != null && Object.hasOwnProperty.call(message, "day"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.day);
            if (message.cd != null && Object.hasOwnProperty.call(message, "cd"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.cd);
            return writer;
        };
    
        /**
         * Encodes the specified pb_ract_item message, length delimited. Does not implicitly {@link pb_ract_item.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_ract_item
         * @static
         * @param {Ipb_ract_item} message pb_ract_item message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_ract_item.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_ract_item message from the specified reader or buffer.
         * @function decode
         * @memberof pb_ract_item
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_ract_item} pb_ract_item
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_ract_item.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_ract_item();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.id = reader.uint32();
                        break;
                    }
                case 2: {
                        if (!(message.rewards && message.rewards.length))
                            message.rewards = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.rewards.push(reader.uint32());
                        } else
                            message.rewards.push(reader.uint32());
                        break;
                    }
                case 3: {
                        if (!(message.item && message.item.length))
                            message.item = [];
                        message.item.push($root.pb_item.decode(reader, reader.uint32()));
                        break;
                    }
                case 4: {
                        message.day = reader.int32();
                        break;
                    }
                case 5: {
                        message.cd = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("id"))
                throw $util.ProtocolError("missing required 'id'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a pb_ract_item message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_ract_item
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_ract_item} pb_ract_item
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_ract_item.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_ract_item message.
         * @function verify
         * @memberof pb_ract_item
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_ract_item.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.id))
                return "id: integer expected";
            if (message.rewards != null && message.hasOwnProperty("rewards")) {
                if (!Array.isArray(message.rewards))
                    return "rewards: array expected";
                for (var i = 0; i < message.rewards.length; ++i)
                    if (!$util.isInteger(message.rewards[i]))
                        return "rewards: integer[] expected";
            }
            if (message.item != null && message.hasOwnProperty("item")) {
                if (!Array.isArray(message.item))
                    return "item: array expected";
                for (var i = 0; i < message.item.length; ++i) {
                    var error = $root.pb_item.verify(message.item[i]);
                    if (error)
                        return "item." + error;
                }
            }
            if (message.day != null && message.hasOwnProperty("day"))
                if (!$util.isInteger(message.day))
                    return "day: integer expected";
            if (message.cd != null && message.hasOwnProperty("cd"))
                if (!$util.isInteger(message.cd))
                    return "cd: integer expected";
            return null;
        };
    
        /**
         * Creates a pb_ract_item message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_ract_item
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_ract_item} pb_ract_item
         */
        pb_ract_item.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_ract_item)
                return object;
            var message = new $root.pb_ract_item();
            if (object.id != null)
                message.id = object.id >>> 0;
            if (object.rewards) {
                if (!Array.isArray(object.rewards))
                    throw TypeError(".pb_ract_item.rewards: array expected");
                message.rewards = [];
                for (var i = 0; i < object.rewards.length; ++i)
                    message.rewards[i] = object.rewards[i] >>> 0;
            }
            if (object.item) {
                if (!Array.isArray(object.item))
                    throw TypeError(".pb_ract_item.item: array expected");
                message.item = [];
                for (var i = 0; i < object.item.length; ++i) {
                    if (typeof object.item[i] !== "object")
                        throw TypeError(".pb_ract_item.item: object expected");
                    message.item[i] = $root.pb_item.fromObject(object.item[i]);
                }
            }
            if (object.day != null)
                message.day = object.day | 0;
            if (object.cd != null)
                message.cd = object.cd | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a pb_ract_item message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_ract_item
         * @static
         * @param {pb_ract_item} message pb_ract_item
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_ract_item.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.rewards = [];
                object.item = [];
            }
            if (options.defaults) {
                object.id = 0;
                object.day = 0;
                object.cd = 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.rewards && message.rewards.length) {
                object.rewards = [];
                for (var j = 0; j < message.rewards.length; ++j)
                    object.rewards[j] = message.rewards[j];
            }
            if (message.item && message.item.length) {
                object.item = [];
                for (var j = 0; j < message.item.length; ++j)
                    object.item[j] = $root.pb_item.toObject(message.item[j], options);
            }
            if (message.day != null && message.hasOwnProperty("day"))
                object.day = message.day;
            if (message.cd != null && message.hasOwnProperty("cd"))
                object.cd = message.cd;
            return object;
        };
    
        /**
         * Converts this pb_ract_item to JSON.
         * @function toJSON
         * @memberof pb_ract_item
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_ract_item.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_ract_item
         * @function getTypeUrl
         * @memberof pb_ract_item
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_ract_item.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_ract_item";
        };
    
        return pb_ract_item;
    })();
    
    $root.pb_sact_maze = (function() {
    
        /**
         * Properties of a pb_sact_maze.
         * @exports Ipb_sact_maze
         * @interface Ipb_sact_maze
         * @property {number|Long} pos pb_sact_maze pos
         * @property {number|null} [id] pb_sact_maze id
         * @property {Ipb_bag|null} [rewards] pb_sact_maze rewards
         * @property {number|null} [num] pb_sact_maze num
         */
    
        /**
         * Constructs a new pb_sact_maze.
         * @exports pb_sact_maze
         * @classdesc Represents a pb_sact_maze.
         * @implements Ipb_sact_maze
         * @constructor
         * @param {Ipb_sact_maze=} [properties] Properties to set
         */
        function pb_sact_maze(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_sact_maze pos.
         * @member {number|Long} pos
         * @memberof pb_sact_maze
         * @instance
         */
        pb_sact_maze.prototype.pos = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * pb_sact_maze id.
         * @member {number} id
         * @memberof pb_sact_maze
         * @instance
         */
        pb_sact_maze.prototype.id = 0;
    
        /**
         * pb_sact_maze rewards.
         * @member {Ipb_bag|null|undefined} rewards
         * @memberof pb_sact_maze
         * @instance
         */
        pb_sact_maze.prototype.rewards = null;
    
        /**
         * pb_sact_maze num.
         * @member {number} num
         * @memberof pb_sact_maze
         * @instance
         */
        pb_sact_maze.prototype.num = 0;
    
        /**
         * Creates a new pb_sact_maze instance using the specified properties.
         * @function create
         * @memberof pb_sact_maze
         * @static
         * @param {Ipb_sact_maze=} [properties] Properties to set
         * @returns {pb_sact_maze} pb_sact_maze instance
         */
        pb_sact_maze.create = function create(properties) {
            return new pb_sact_maze(properties);
        };
    
        /**
         * Encodes the specified pb_sact_maze message. Does not implicitly {@link pb_sact_maze.verify|verify} messages.
         * @function encode
         * @memberof pb_sact_maze
         * @static
         * @param {Ipb_sact_maze} message pb_sact_maze message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_sact_maze.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int64(message.pos);
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.id);
            if (message.rewards != null && Object.hasOwnProperty.call(message, "rewards"))
                $root.pb_bag.encode(message.rewards, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.num != null && Object.hasOwnProperty.call(message, "num"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.num);
            return writer;
        };
    
        /**
         * Encodes the specified pb_sact_maze message, length delimited. Does not implicitly {@link pb_sact_maze.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_sact_maze
         * @static
         * @param {Ipb_sact_maze} message pb_sact_maze message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_sact_maze.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_sact_maze message from the specified reader or buffer.
         * @function decode
         * @memberof pb_sact_maze
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_sact_maze} pb_sact_maze
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_sact_maze.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_sact_maze();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.pos = reader.int64();
                        break;
                    }
                case 2: {
                        message.id = reader.int32();
                        break;
                    }
                case 3: {
                        message.rewards = $root.pb_bag.decode(reader, reader.uint32());
                        break;
                    }
                case 4: {
                        message.num = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("pos"))
                throw $util.ProtocolError("missing required 'pos'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a pb_sact_maze message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_sact_maze
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_sact_maze} pb_sact_maze
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_sact_maze.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_sact_maze message.
         * @function verify
         * @memberof pb_sact_maze
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_sact_maze.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.pos) && !(message.pos && $util.isInteger(message.pos.low) && $util.isInteger(message.pos.high)))
                return "pos: integer|Long expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id))
                    return "id: integer expected";
            if (message.rewards != null && message.hasOwnProperty("rewards")) {
                var error = $root.pb_bag.verify(message.rewards);
                if (error)
                    return "rewards." + error;
            }
            if (message.num != null && message.hasOwnProperty("num"))
                if (!$util.isInteger(message.num))
                    return "num: integer expected";
            return null;
        };
    
        /**
         * Creates a pb_sact_maze message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_sact_maze
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_sact_maze} pb_sact_maze
         */
        pb_sact_maze.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_sact_maze)
                return object;
            var message = new $root.pb_sact_maze();
            if (object.pos != null)
                if ($util.Long)
                    (message.pos = $util.Long.fromValue(object.pos)).unsigned = false;
                else if (typeof object.pos === "string")
                    message.pos = parseInt(object.pos, 10);
                else if (typeof object.pos === "number")
                    message.pos = object.pos;
                else if (typeof object.pos === "object")
                    message.pos = new $util.LongBits(object.pos.low >>> 0, object.pos.high >>> 0).toNumber();
            if (object.id != null)
                message.id = object.id | 0;
            if (object.rewards != null) {
                if (typeof object.rewards !== "object")
                    throw TypeError(".pb_sact_maze.rewards: object expected");
                message.rewards = $root.pb_bag.fromObject(object.rewards);
            }
            if (object.num != null)
                message.num = object.num | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a pb_sact_maze message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_sact_maze
         * @static
         * @param {pb_sact_maze} message pb_sact_maze
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_sact_maze.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.pos = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.pos = options.longs === String ? "0" : 0;
                object.id = 0;
                object.rewards = null;
                object.num = 0;
            }
            if (message.pos != null && message.hasOwnProperty("pos"))
                if (typeof message.pos === "number")
                    object.pos = options.longs === String ? String(message.pos) : message.pos;
                else
                    object.pos = options.longs === String ? $util.Long.prototype.toString.call(message.pos) : options.longs === Number ? new $util.LongBits(message.pos.low >>> 0, message.pos.high >>> 0).toNumber() : message.pos;
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.rewards != null && message.hasOwnProperty("rewards"))
                object.rewards = $root.pb_bag.toObject(message.rewards, options);
            if (message.num != null && message.hasOwnProperty("num"))
                object.num = message.num;
            return object;
        };
    
        /**
         * Converts this pb_sact_maze to JSON.
         * @function toJSON
         * @memberof pb_sact_maze
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_sact_maze.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_sact_maze
         * @function getTypeUrl
         * @memberof pb_sact_maze
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_sact_maze.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_sact_maze";
        };
    
        return pb_sact_maze;
    })();
    
    $root.pb_sact_log = (function() {
    
        /**
         * Properties of a pb_sact_log.
         * @exports Ipb_sact_log
         * @interface Ipb_sact_log
         * @property {number|null} [time] pb_sact_log time
         * @property {number|null} [result] pb_sact_log result
         */
    
        /**
         * Constructs a new pb_sact_log.
         * @exports pb_sact_log
         * @classdesc Represents a pb_sact_log.
         * @implements Ipb_sact_log
         * @constructor
         * @param {Ipb_sact_log=} [properties] Properties to set
         */
        function pb_sact_log(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_sact_log time.
         * @member {number} time
         * @memberof pb_sact_log
         * @instance
         */
        pb_sact_log.prototype.time = 0;
    
        /**
         * pb_sact_log result.
         * @member {number} result
         * @memberof pb_sact_log
         * @instance
         */
        pb_sact_log.prototype.result = 0;
    
        /**
         * Creates a new pb_sact_log instance using the specified properties.
         * @function create
         * @memberof pb_sact_log
         * @static
         * @param {Ipb_sact_log=} [properties] Properties to set
         * @returns {pb_sact_log} pb_sact_log instance
         */
        pb_sact_log.create = function create(properties) {
            return new pb_sact_log(properties);
        };
    
        /**
         * Encodes the specified pb_sact_log message. Does not implicitly {@link pb_sact_log.verify|verify} messages.
         * @function encode
         * @memberof pb_sact_log
         * @static
         * @param {Ipb_sact_log} message pb_sact_log message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_sact_log.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.time != null && Object.hasOwnProperty.call(message, "time"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.time);
            if (message.result != null && Object.hasOwnProperty.call(message, "result"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.result);
            return writer;
        };
    
        /**
         * Encodes the specified pb_sact_log message, length delimited. Does not implicitly {@link pb_sact_log.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_sact_log
         * @static
         * @param {Ipb_sact_log} message pb_sact_log message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_sact_log.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_sact_log message from the specified reader or buffer.
         * @function decode
         * @memberof pb_sact_log
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_sact_log} pb_sact_log
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_sact_log.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_sact_log();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.time = reader.int32();
                        break;
                    }
                case 2: {
                        message.result = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a pb_sact_log message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_sact_log
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_sact_log} pb_sact_log
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_sact_log.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_sact_log message.
         * @function verify
         * @memberof pb_sact_log
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_sact_log.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.time != null && message.hasOwnProperty("time"))
                if (!$util.isInteger(message.time))
                    return "time: integer expected";
            if (message.result != null && message.hasOwnProperty("result"))
                if (!$util.isInteger(message.result))
                    return "result: integer expected";
            return null;
        };
    
        /**
         * Creates a pb_sact_log message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_sact_log
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_sact_log} pb_sact_log
         */
        pb_sact_log.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_sact_log)
                return object;
            var message = new $root.pb_sact_log();
            if (object.time != null)
                message.time = object.time | 0;
            if (object.result != null)
                message.result = object.result | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a pb_sact_log message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_sact_log
         * @static
         * @param {pb_sact_log} message pb_sact_log
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_sact_log.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.time = 0;
                object.result = 0;
            }
            if (message.time != null && message.hasOwnProperty("time"))
                object.time = message.time;
            if (message.result != null && message.hasOwnProperty("result"))
                object.result = message.result;
            return object;
        };
    
        /**
         * Converts this pb_sact_log to JSON.
         * @function toJSON
         * @memberof pb_sact_log
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_sact_log.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_sact_log
         * @function getTypeUrl
         * @memberof pb_sact_log
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_sact_log.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_sact_log";
        };
    
        return pb_sact_log;
    })();
    
    $root.pb_mact = (function() {
    
        /**
         * Properties of a pb_mact.
         * @exports Ipb_mact
         * @interface Ipb_mact
         * @property {number} cd pb_mact cd
         * @property {Array.<Ipb_item>|null} [war] pb_mact war
         * @property {Array.<Ipb_item>|null} [htask] pb_mact htask
         * @property {Array.<Ipb_item>|null} [hmerge] pb_mact hmerge
         * @property {number|null} [spaceSt] pb_mact spaceSt
         * @property {Array.<Ipb_item>|null} [brave] pb_mact brave
         * @property {number|null} [status] pb_mact status
         * @property {Array.<Ipb_item>|null} [hmerge2] pb_mact hmerge2
         * @property {Array.<Ipb_item>|null} [highCasino] pb_mact highCasino
         */
    
        /**
         * Constructs a new pb_mact.
         * @exports pb_mact
         * @classdesc Represents a pb_mact.
         * @implements Ipb_mact
         * @constructor
         * @param {Ipb_mact=} [properties] Properties to set
         */
        function pb_mact(properties) {
            this.war = [];
            this.htask = [];
            this.hmerge = [];
            this.brave = [];
            this.hmerge2 = [];
            this.highCasino = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_mact cd.
         * @member {number} cd
         * @memberof pb_mact
         * @instance
         */
        pb_mact.prototype.cd = 0;
    
        /**
         * pb_mact war.
         * @member {Array.<Ipb_item>} war
         * @memberof pb_mact
         * @instance
         */
        pb_mact.prototype.war = $util.emptyArray;
    
        /**
         * pb_mact htask.
         * @member {Array.<Ipb_item>} htask
         * @memberof pb_mact
         * @instance
         */
        pb_mact.prototype.htask = $util.emptyArray;
    
        /**
         * pb_mact hmerge.
         * @member {Array.<Ipb_item>} hmerge
         * @memberof pb_mact
         * @instance
         */
        pb_mact.prototype.hmerge = $util.emptyArray;
    
        /**
         * pb_mact spaceSt.
         * @member {number} spaceSt
         * @memberof pb_mact
         * @instance
         */
        pb_mact.prototype.spaceSt = 0;
    
        /**
         * pb_mact brave.
         * @member {Array.<Ipb_item>} brave
         * @memberof pb_mact
         * @instance
         */
        pb_mact.prototype.brave = $util.emptyArray;
    
        /**
         * pb_mact status.
         * @member {number} status
         * @memberof pb_mact
         * @instance
         */
        pb_mact.prototype.status = 0;
    
        /**
         * pb_mact hmerge2.
         * @member {Array.<Ipb_item>} hmerge2
         * @memberof pb_mact
         * @instance
         */
        pb_mact.prototype.hmerge2 = $util.emptyArray;
    
        /**
         * pb_mact highCasino.
         * @member {Array.<Ipb_item>} highCasino
         * @memberof pb_mact
         * @instance
         */
        pb_mact.prototype.highCasino = $util.emptyArray;
    
        /**
         * Creates a new pb_mact instance using the specified properties.
         * @function create
         * @memberof pb_mact
         * @static
         * @param {Ipb_mact=} [properties] Properties to set
         * @returns {pb_mact} pb_mact instance
         */
        pb_mact.create = function create(properties) {
            return new pb_mact(properties);
        };
    
        /**
         * Encodes the specified pb_mact message. Does not implicitly {@link pb_mact.verify|verify} messages.
         * @function encode
         * @memberof pb_mact
         * @static
         * @param {Ipb_mact} message pb_mact message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_mact.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.cd);
            if (message.war != null && message.war.length)
                for (var i = 0; i < message.war.length; ++i)
                    $root.pb_item.encode(message.war[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.htask != null && message.htask.length)
                for (var i = 0; i < message.htask.length; ++i)
                    $root.pb_item.encode(message.htask[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.hmerge != null && message.hmerge.length)
                for (var i = 0; i < message.hmerge.length; ++i)
                    $root.pb_item.encode(message.hmerge[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.spaceSt != null && Object.hasOwnProperty.call(message, "spaceSt"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.spaceSt);
            if (message.brave != null && message.brave.length)
                for (var i = 0; i < message.brave.length; ++i)
                    $root.pb_item.encode(message.brave[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.status);
            if (message.hmerge2 != null && message.hmerge2.length)
                for (var i = 0; i < message.hmerge2.length; ++i)
                    $root.pb_item.encode(message.hmerge2[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message.highCasino != null && message.highCasino.length)
                for (var i = 0; i < message.highCasino.length; ++i)
                    $root.pb_item.encode(message.highCasino[i], writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified pb_mact message, length delimited. Does not implicitly {@link pb_mact.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_mact
         * @static
         * @param {Ipb_mact} message pb_mact message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_mact.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_mact message from the specified reader or buffer.
         * @function decode
         * @memberof pb_mact
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_mact} pb_mact
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_mact.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_mact();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.cd = reader.uint32();
                        break;
                    }
                case 2: {
                        if (!(message.war && message.war.length))
                            message.war = [];
                        message.war.push($root.pb_item.decode(reader, reader.uint32()));
                        break;
                    }
                case 3: {
                        if (!(message.htask && message.htask.length))
                            message.htask = [];
                        message.htask.push($root.pb_item.decode(reader, reader.uint32()));
                        break;
                    }
                case 4: {
                        if (!(message.hmerge && message.hmerge.length))
                            message.hmerge = [];
                        message.hmerge.push($root.pb_item.decode(reader, reader.uint32()));
                        break;
                    }
                case 5: {
                        message.spaceSt = reader.int32();
                        break;
                    }
                case 6: {
                        if (!(message.brave && message.brave.length))
                            message.brave = [];
                        message.brave.push($root.pb_item.decode(reader, reader.uint32()));
                        break;
                    }
                case 7: {
                        message.status = reader.int32();
                        break;
                    }
                case 8: {
                        if (!(message.hmerge2 && message.hmerge2.length))
                            message.hmerge2 = [];
                        message.hmerge2.push($root.pb_item.decode(reader, reader.uint32()));
                        break;
                    }
                case 9: {
                        if (!(message.highCasino && message.highCasino.length))
                            message.highCasino = [];
                        message.highCasino.push($root.pb_item.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("cd"))
                throw $util.ProtocolError("missing required 'cd'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a pb_mact message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_mact
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_mact} pb_mact
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_mact.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_mact message.
         * @function verify
         * @memberof pb_mact
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_mact.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.cd))
                return "cd: integer expected";
            if (message.war != null && message.hasOwnProperty("war")) {
                if (!Array.isArray(message.war))
                    return "war: array expected";
                for (var i = 0; i < message.war.length; ++i) {
                    var error = $root.pb_item.verify(message.war[i]);
                    if (error)
                        return "war." + error;
                }
            }
            if (message.htask != null && message.hasOwnProperty("htask")) {
                if (!Array.isArray(message.htask))
                    return "htask: array expected";
                for (var i = 0; i < message.htask.length; ++i) {
                    var error = $root.pb_item.verify(message.htask[i]);
                    if (error)
                        return "htask." + error;
                }
            }
            if (message.hmerge != null && message.hasOwnProperty("hmerge")) {
                if (!Array.isArray(message.hmerge))
                    return "hmerge: array expected";
                for (var i = 0; i < message.hmerge.length; ++i) {
                    var error = $root.pb_item.verify(message.hmerge[i]);
                    if (error)
                        return "hmerge." + error;
                }
            }
            if (message.spaceSt != null && message.hasOwnProperty("spaceSt"))
                if (!$util.isInteger(message.spaceSt))
                    return "spaceSt: integer expected";
            if (message.brave != null && message.hasOwnProperty("brave")) {
                if (!Array.isArray(message.brave))
                    return "brave: array expected";
                for (var i = 0; i < message.brave.length; ++i) {
                    var error = $root.pb_item.verify(message.brave[i]);
                    if (error)
                        return "brave." + error;
                }
            }
            if (message.status != null && message.hasOwnProperty("status"))
                if (!$util.isInteger(message.status))
                    return "status: integer expected";
            if (message.hmerge2 != null && message.hasOwnProperty("hmerge2")) {
                if (!Array.isArray(message.hmerge2))
                    return "hmerge2: array expected";
                for (var i = 0; i < message.hmerge2.length; ++i) {
                    var error = $root.pb_item.verify(message.hmerge2[i]);
                    if (error)
                        return "hmerge2." + error;
                }
            }
            if (message.highCasino != null && message.hasOwnProperty("highCasino")) {
                if (!Array.isArray(message.highCasino))
                    return "highCasino: array expected";
                for (var i = 0; i < message.highCasino.length; ++i) {
                    var error = $root.pb_item.verify(message.highCasino[i]);
                    if (error)
                        return "highCasino." + error;
                }
            }
            return null;
        };
    
        /**
         * Creates a pb_mact message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_mact
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_mact} pb_mact
         */
        pb_mact.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_mact)
                return object;
            var message = new $root.pb_mact();
            if (object.cd != null)
                message.cd = object.cd >>> 0;
            if (object.war) {
                if (!Array.isArray(object.war))
                    throw TypeError(".pb_mact.war: array expected");
                message.war = [];
                for (var i = 0; i < object.war.length; ++i) {
                    if (typeof object.war[i] !== "object")
                        throw TypeError(".pb_mact.war: object expected");
                    message.war[i] = $root.pb_item.fromObject(object.war[i]);
                }
            }
            if (object.htask) {
                if (!Array.isArray(object.htask))
                    throw TypeError(".pb_mact.htask: array expected");
                message.htask = [];
                for (var i = 0; i < object.htask.length; ++i) {
                    if (typeof object.htask[i] !== "object")
                        throw TypeError(".pb_mact.htask: object expected");
                    message.htask[i] = $root.pb_item.fromObject(object.htask[i]);
                }
            }
            if (object.hmerge) {
                if (!Array.isArray(object.hmerge))
                    throw TypeError(".pb_mact.hmerge: array expected");
                message.hmerge = [];
                for (var i = 0; i < object.hmerge.length; ++i) {
                    if (typeof object.hmerge[i] !== "object")
                        throw TypeError(".pb_mact.hmerge: object expected");
                    message.hmerge[i] = $root.pb_item.fromObject(object.hmerge[i]);
                }
            }
            if (object.spaceSt != null)
                message.spaceSt = object.spaceSt | 0;
            if (object.brave) {
                if (!Array.isArray(object.brave))
                    throw TypeError(".pb_mact.brave: array expected");
                message.brave = [];
                for (var i = 0; i < object.brave.length; ++i) {
                    if (typeof object.brave[i] !== "object")
                        throw TypeError(".pb_mact.brave: object expected");
                    message.brave[i] = $root.pb_item.fromObject(object.brave[i]);
                }
            }
            if (object.status != null)
                message.status = object.status | 0;
            if (object.hmerge2) {
                if (!Array.isArray(object.hmerge2))
                    throw TypeError(".pb_mact.hmerge2: array expected");
                message.hmerge2 = [];
                for (var i = 0; i < object.hmerge2.length; ++i) {
                    if (typeof object.hmerge2[i] !== "object")
                        throw TypeError(".pb_mact.hmerge2: object expected");
                    message.hmerge2[i] = $root.pb_item.fromObject(object.hmerge2[i]);
                }
            }
            if (object.highCasino) {
                if (!Array.isArray(object.highCasino))
                    throw TypeError(".pb_mact.highCasino: array expected");
                message.highCasino = [];
                for (var i = 0; i < object.highCasino.length; ++i) {
                    if (typeof object.highCasino[i] !== "object")
                        throw TypeError(".pb_mact.highCasino: object expected");
                    message.highCasino[i] = $root.pb_item.fromObject(object.highCasino[i]);
                }
            }
            return message;
        };
    
        /**
         * Creates a plain object from a pb_mact message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_mact
         * @static
         * @param {pb_mact} message pb_mact
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_mact.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.war = [];
                object.htask = [];
                object.hmerge = [];
                object.brave = [];
                object.hmerge2 = [];
                object.highCasino = [];
            }
            if (options.defaults) {
                object.cd = 0;
                object.spaceSt = 0;
                object.status = 0;
            }
            if (message.cd != null && message.hasOwnProperty("cd"))
                object.cd = message.cd;
            if (message.war && message.war.length) {
                object.war = [];
                for (var j = 0; j < message.war.length; ++j)
                    object.war[j] = $root.pb_item.toObject(message.war[j], options);
            }
            if (message.htask && message.htask.length) {
                object.htask = [];
                for (var j = 0; j < message.htask.length; ++j)
                    object.htask[j] = $root.pb_item.toObject(message.htask[j], options);
            }
            if (message.hmerge && message.hmerge.length) {
                object.hmerge = [];
                for (var j = 0; j < message.hmerge.length; ++j)
                    object.hmerge[j] = $root.pb_item.toObject(message.hmerge[j], options);
            }
            if (message.spaceSt != null && message.hasOwnProperty("spaceSt"))
                object.spaceSt = message.spaceSt;
            if (message.brave && message.brave.length) {
                object.brave = [];
                for (var j = 0; j < message.brave.length; ++j)
                    object.brave[j] = $root.pb_item.toObject(message.brave[j], options);
            }
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = message.status;
            if (message.hmerge2 && message.hmerge2.length) {
                object.hmerge2 = [];
                for (var j = 0; j < message.hmerge2.length; ++j)
                    object.hmerge2[j] = $root.pb_item.toObject(message.hmerge2[j], options);
            }
            if (message.highCasino && message.highCasino.length) {
                object.highCasino = [];
                for (var j = 0; j < message.highCasino.length; ++j)
                    object.highCasino[j] = $root.pb_item.toObject(message.highCasino[j], options);
            }
            return object;
        };
    
        /**
         * Converts this pb_mact to JSON.
         * @function toJSON
         * @memberof pb_mact
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_mact.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_mact
         * @function getTypeUrl
         * @memberof pb_mact
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_mact.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_mact";
        };
    
        return pb_mact;
    })();
    
    $root.pb_task = (function() {
    
        /**
         * Properties of a pb_task.
         * @exports Ipb_task
         * @interface Ipb_task
         * @property {number} id pb_task id
         * @property {number} count pb_task count
         * @property {number} isClaim pb_task isClaim
         */
    
        /**
         * Constructs a new pb_task.
         * @exports pb_task
         * @classdesc Represents a pb_task.
         * @implements Ipb_task
         * @constructor
         * @param {Ipb_task=} [properties] Properties to set
         */
        function pb_task(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_task id.
         * @member {number} id
         * @memberof pb_task
         * @instance
         */
        pb_task.prototype.id = 0;
    
        /**
         * pb_task count.
         * @member {number} count
         * @memberof pb_task
         * @instance
         */
        pb_task.prototype.count = 0;
    
        /**
         * pb_task isClaim.
         * @member {number} isClaim
         * @memberof pb_task
         * @instance
         */
        pb_task.prototype.isClaim = 0;
    
        /**
         * Creates a new pb_task instance using the specified properties.
         * @function create
         * @memberof pb_task
         * @static
         * @param {Ipb_task=} [properties] Properties to set
         * @returns {pb_task} pb_task instance
         */
        pb_task.create = function create(properties) {
            return new pb_task(properties);
        };
    
        /**
         * Encodes the specified pb_task message. Does not implicitly {@link pb_task.verify|verify} messages.
         * @function encode
         * @memberof pb_task
         * @static
         * @param {Ipb_task} message pb_task message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_task.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.id);
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.count);
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.isClaim);
            return writer;
        };
    
        /**
         * Encodes the specified pb_task message, length delimited. Does not implicitly {@link pb_task.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_task
         * @static
         * @param {Ipb_task} message pb_task message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_task.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_task message from the specified reader or buffer.
         * @function decode
         * @memberof pb_task
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_task} pb_task
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_task.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_task();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.id = reader.int32();
                        break;
                    }
                case 2: {
                        message.count = reader.int32();
                        break;
                    }
                case 3: {
                        message.isClaim = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("id"))
                throw $util.ProtocolError("missing required 'id'", { instance: message });
            if (!message.hasOwnProperty("count"))
                throw $util.ProtocolError("missing required 'count'", { instance: message });
            if (!message.hasOwnProperty("isClaim"))
                throw $util.ProtocolError("missing required 'isClaim'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a pb_task message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_task
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_task} pb_task
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_task.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_task message.
         * @function verify
         * @memberof pb_task
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_task.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.id))
                return "id: integer expected";
            if (!$util.isInteger(message.count))
                return "count: integer expected";
            if (!$util.isInteger(message.isClaim))
                return "isClaim: integer expected";
            return null;
        };
    
        /**
         * Creates a pb_task message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_task
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_task} pb_task
         */
        pb_task.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_task)
                return object;
            var message = new $root.pb_task();
            if (object.id != null)
                message.id = object.id | 0;
            if (object.count != null)
                message.count = object.count | 0;
            if (object.isClaim != null)
                message.isClaim = object.isClaim | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a pb_task message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_task
         * @static
         * @param {pb_task} message pb_task
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_task.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = 0;
                object.count = 0;
                object.isClaim = 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.count != null && message.hasOwnProperty("count"))
                object.count = message.count;
            if (message.isClaim != null && message.hasOwnProperty("isClaim"))
                object.isClaim = message.isClaim;
            return object;
        };
    
        /**
         * Converts this pb_task to JSON.
         * @function toJSON
         * @memberof pb_task
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_task.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_task
         * @function getTypeUrl
         * @memberof pb_task
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_task.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_task";
        };
    
        return pb_task;
    })();
    
    $root.pb_online = (function() {
    
        /**
         * Properties of a pb_online.
         * @exports Ipb_online
         * @interface Ipb_online
         * @property {number} id pb_online id
         * @property {number|null} [cd] pb_online cd
         */
    
        /**
         * Constructs a new pb_online.
         * @exports pb_online
         * @classdesc Represents a pb_online.
         * @implements Ipb_online
         * @constructor
         * @param {Ipb_online=} [properties] Properties to set
         */
        function pb_online(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_online id.
         * @member {number} id
         * @memberof pb_online
         * @instance
         */
        pb_online.prototype.id = 0;
    
        /**
         * pb_online cd.
         * @member {number} cd
         * @memberof pb_online
         * @instance
         */
        pb_online.prototype.cd = 0;
    
        /**
         * Creates a new pb_online instance using the specified properties.
         * @function create
         * @memberof pb_online
         * @static
         * @param {Ipb_online=} [properties] Properties to set
         * @returns {pb_online} pb_online instance
         */
        pb_online.create = function create(properties) {
            return new pb_online(properties);
        };
    
        /**
         * Encodes the specified pb_online message. Does not implicitly {@link pb_online.verify|verify} messages.
         * @function encode
         * @memberof pb_online
         * @static
         * @param {Ipb_online} message pb_online message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_online.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.id);
            if (message.cd != null && Object.hasOwnProperty.call(message, "cd"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.cd);
            return writer;
        };
    
        /**
         * Encodes the specified pb_online message, length delimited. Does not implicitly {@link pb_online.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_online
         * @static
         * @param {Ipb_online} message pb_online message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_online.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_online message from the specified reader or buffer.
         * @function decode
         * @memberof pb_online
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_online} pb_online
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_online.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_online();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.id = reader.int32();
                        break;
                    }
                case 2: {
                        message.cd = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("id"))
                throw $util.ProtocolError("missing required 'id'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a pb_online message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_online
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_online} pb_online
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_online.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_online message.
         * @function verify
         * @memberof pb_online
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_online.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.id))
                return "id: integer expected";
            if (message.cd != null && message.hasOwnProperty("cd"))
                if (!$util.isInteger(message.cd))
                    return "cd: integer expected";
            return null;
        };
    
        /**
         * Creates a pb_online message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_online
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_online} pb_online
         */
        pb_online.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_online)
                return object;
            var message = new $root.pb_online();
            if (object.id != null)
                message.id = object.id | 0;
            if (object.cd != null)
                message.cd = object.cd | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a pb_online message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_online
         * @static
         * @param {pb_online} message pb_online
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_online.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = 0;
                object.cd = 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.cd != null && message.hasOwnProperty("cd"))
                object.cd = message.cd;
            return object;
        };
    
        /**
         * Converts this pb_online to JSON.
         * @function toJSON
         * @memberof pb_online
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_online.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_online
         * @function getTypeUrl
         * @memberof pb_online
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_online.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_online";
        };
    
        return pb_online;
    })();
    
    $root.pb_sachieve = (function() {
    
        /**
         * Properties of a pb_sachieve.
         * @exports Ipb_sachieve
         * @interface Ipb_sachieve
         * @property {Array.<number>|null} [num] pb_sachieve num
         * @property {Array.<number>|null} [id] pb_sachieve id
         * @property {Array.<number>|null} [curnum] pb_sachieve curnum
         */
    
        /**
         * Constructs a new pb_sachieve.
         * @exports pb_sachieve
         * @classdesc Represents a pb_sachieve.
         * @implements Ipb_sachieve
         * @constructor
         * @param {Ipb_sachieve=} [properties] Properties to set
         */
        function pb_sachieve(properties) {
            this.num = [];
            this.id = [];
            this.curnum = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_sachieve num.
         * @member {Array.<number>} num
         * @memberof pb_sachieve
         * @instance
         */
        pb_sachieve.prototype.num = $util.emptyArray;
    
        /**
         * pb_sachieve id.
         * @member {Array.<number>} id
         * @memberof pb_sachieve
         * @instance
         */
        pb_sachieve.prototype.id = $util.emptyArray;
    
        /**
         * pb_sachieve curnum.
         * @member {Array.<number>} curnum
         * @memberof pb_sachieve
         * @instance
         */
        pb_sachieve.prototype.curnum = $util.emptyArray;
    
        /**
         * Creates a new pb_sachieve instance using the specified properties.
         * @function create
         * @memberof pb_sachieve
         * @static
         * @param {Ipb_sachieve=} [properties] Properties to set
         * @returns {pb_sachieve} pb_sachieve instance
         */
        pb_sachieve.create = function create(properties) {
            return new pb_sachieve(properties);
        };
    
        /**
         * Encodes the specified pb_sachieve message. Does not implicitly {@link pb_sachieve.verify|verify} messages.
         * @function encode
         * @memberof pb_sachieve
         * @static
         * @param {Ipb_sachieve} message pb_sachieve message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_sachieve.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.num != null && message.num.length)
                for (var i = 0; i < message.num.length; ++i)
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.num[i]);
            if (message.id != null && message.id.length)
                for (var i = 0; i < message.id.length; ++i)
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.id[i]);
            if (message.curnum != null && message.curnum.length)
                for (var i = 0; i < message.curnum.length; ++i)
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.curnum[i]);
            return writer;
        };
    
        /**
         * Encodes the specified pb_sachieve message, length delimited. Does not implicitly {@link pb_sachieve.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_sachieve
         * @static
         * @param {Ipb_sachieve} message pb_sachieve message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_sachieve.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_sachieve message from the specified reader or buffer.
         * @function decode
         * @memberof pb_sachieve
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_sachieve} pb_sachieve
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_sachieve.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_sachieve();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.num && message.num.length))
                            message.num = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.num.push(reader.int32());
                        } else
                            message.num.push(reader.int32());
                        break;
                    }
                case 2: {
                        if (!(message.id && message.id.length))
                            message.id = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.id.push(reader.int32());
                        } else
                            message.id.push(reader.int32());
                        break;
                    }
                case 3: {
                        if (!(message.curnum && message.curnum.length))
                            message.curnum = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.curnum.push(reader.int32());
                        } else
                            message.curnum.push(reader.int32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a pb_sachieve message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_sachieve
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_sachieve} pb_sachieve
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_sachieve.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_sachieve message.
         * @function verify
         * @memberof pb_sachieve
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_sachieve.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.num != null && message.hasOwnProperty("num")) {
                if (!Array.isArray(message.num))
                    return "num: array expected";
                for (var i = 0; i < message.num.length; ++i)
                    if (!$util.isInteger(message.num[i]))
                        return "num: integer[] expected";
            }
            if (message.id != null && message.hasOwnProperty("id")) {
                if (!Array.isArray(message.id))
                    return "id: array expected";
                for (var i = 0; i < message.id.length; ++i)
                    if (!$util.isInteger(message.id[i]))
                        return "id: integer[] expected";
            }
            if (message.curnum != null && message.hasOwnProperty("curnum")) {
                if (!Array.isArray(message.curnum))
                    return "curnum: array expected";
                for (var i = 0; i < message.curnum.length; ++i)
                    if (!$util.isInteger(message.curnum[i]))
                        return "curnum: integer[] expected";
            }
            return null;
        };
    
        /**
         * Creates a pb_sachieve message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_sachieve
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_sachieve} pb_sachieve
         */
        pb_sachieve.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_sachieve)
                return object;
            var message = new $root.pb_sachieve();
            if (object.num) {
                if (!Array.isArray(object.num))
                    throw TypeError(".pb_sachieve.num: array expected");
                message.num = [];
                for (var i = 0; i < object.num.length; ++i)
                    message.num[i] = object.num[i] | 0;
            }
            if (object.id) {
                if (!Array.isArray(object.id))
                    throw TypeError(".pb_sachieve.id: array expected");
                message.id = [];
                for (var i = 0; i < object.id.length; ++i)
                    message.id[i] = object.id[i] | 0;
            }
            if (object.curnum) {
                if (!Array.isArray(object.curnum))
                    throw TypeError(".pb_sachieve.curnum: array expected");
                message.curnum = [];
                for (var i = 0; i < object.curnum.length; ++i)
                    message.curnum[i] = object.curnum[i] | 0;
            }
            return message;
        };
    
        /**
         * Creates a plain object from a pb_sachieve message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_sachieve
         * @static
         * @param {pb_sachieve} message pb_sachieve
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_sachieve.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.num = [];
                object.id = [];
                object.curnum = [];
            }
            if (message.num && message.num.length) {
                object.num = [];
                for (var j = 0; j < message.num.length; ++j)
                    object.num[j] = message.num[j];
            }
            if (message.id && message.id.length) {
                object.id = [];
                for (var j = 0; j < message.id.length; ++j)
                    object.id[j] = message.id[j];
            }
            if (message.curnum && message.curnum.length) {
                object.curnum = [];
                for (var j = 0; j < message.curnum.length; ++j)
                    object.curnum[j] = message.curnum[j];
            }
            return object;
        };
    
        /**
         * Converts this pb_sachieve to JSON.
         * @function toJSON
         * @memberof pb_sachieve
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_sachieve.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_sachieve
         * @function getTypeUrl
         * @memberof pb_sachieve
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_sachieve.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_sachieve";
        };
    
        return pb_sachieve;
    })();
    
    $root.pb_hmarket = (function() {
    
        /**
         * Properties of a pb_hmarket.
         * @exports Ipb_hmarket
         * @interface Ipb_hmarket
         * @property {number} id pb_hmarket id
         * @property {number|null} [num] pb_hmarket num
         * @property {number|null} [cd] pb_hmarket cd
         */
    
        /**
         * Constructs a new pb_hmarket.
         * @exports pb_hmarket
         * @classdesc Represents a pb_hmarket.
         * @implements Ipb_hmarket
         * @constructor
         * @param {Ipb_hmarket=} [properties] Properties to set
         */
        function pb_hmarket(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_hmarket id.
         * @member {number} id
         * @memberof pb_hmarket
         * @instance
         */
        pb_hmarket.prototype.id = 0;
    
        /**
         * pb_hmarket num.
         * @member {number} num
         * @memberof pb_hmarket
         * @instance
         */
        pb_hmarket.prototype.num = 0;
    
        /**
         * pb_hmarket cd.
         * @member {number} cd
         * @memberof pb_hmarket
         * @instance
         */
        pb_hmarket.prototype.cd = 0;
    
        /**
         * Creates a new pb_hmarket instance using the specified properties.
         * @function create
         * @memberof pb_hmarket
         * @static
         * @param {Ipb_hmarket=} [properties] Properties to set
         * @returns {pb_hmarket} pb_hmarket instance
         */
        pb_hmarket.create = function create(properties) {
            return new pb_hmarket(properties);
        };
    
        /**
         * Encodes the specified pb_hmarket message. Does not implicitly {@link pb_hmarket.verify|verify} messages.
         * @function encode
         * @memberof pb_hmarket
         * @static
         * @param {Ipb_hmarket} message pb_hmarket message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_hmarket.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.id);
            if (message.num != null && Object.hasOwnProperty.call(message, "num"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.num);
            if (message.cd != null && Object.hasOwnProperty.call(message, "cd"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.cd);
            return writer;
        };
    
        /**
         * Encodes the specified pb_hmarket message, length delimited. Does not implicitly {@link pb_hmarket.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_hmarket
         * @static
         * @param {Ipb_hmarket} message pb_hmarket message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_hmarket.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_hmarket message from the specified reader or buffer.
         * @function decode
         * @memberof pb_hmarket
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_hmarket} pb_hmarket
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_hmarket.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_hmarket();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.id = reader.int32();
                        break;
                    }
                case 2: {
                        message.num = reader.int32();
                        break;
                    }
                case 3: {
                        message.cd = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("id"))
                throw $util.ProtocolError("missing required 'id'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a pb_hmarket message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_hmarket
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_hmarket} pb_hmarket
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_hmarket.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_hmarket message.
         * @function verify
         * @memberof pb_hmarket
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_hmarket.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.id))
                return "id: integer expected";
            if (message.num != null && message.hasOwnProperty("num"))
                if (!$util.isInteger(message.num))
                    return "num: integer expected";
            if (message.cd != null && message.hasOwnProperty("cd"))
                if (!$util.isInteger(message.cd))
                    return "cd: integer expected";
            return null;
        };
    
        /**
         * Creates a pb_hmarket message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_hmarket
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_hmarket} pb_hmarket
         */
        pb_hmarket.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_hmarket)
                return object;
            var message = new $root.pb_hmarket();
            if (object.id != null)
                message.id = object.id | 0;
            if (object.num != null)
                message.num = object.num | 0;
            if (object.cd != null)
                message.cd = object.cd | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a pb_hmarket message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_hmarket
         * @static
         * @param {pb_hmarket} message pb_hmarket
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_hmarket.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = 0;
                object.num = 0;
                object.cd = 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.num != null && message.hasOwnProperty("num"))
                object.num = message.num;
            if (message.cd != null && message.hasOwnProperty("cd"))
                object.cd = message.cd;
            return object;
        };
    
        /**
         * Converts this pb_hmarket to JSON.
         * @function toJSON
         * @memberof pb_hmarket
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_hmarket.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_hmarket
         * @function getTypeUrl
         * @memberof pb_hmarket
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_hmarket.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_hmarket";
        };
    
        return pb_hmarket;
    })();
    
    $root.pb_gmarket = (function() {
    
        /**
         * Properties of a pb_gmarket.
         * @exports Ipb_gmarket
         * @interface Ipb_gmarket
         * @property {number} id pb_gmarket id
         * @property {number|null} [num] pb_gmarket num
         * @property {number|null} [gid] pb_gmarket gid
         */
    
        /**
         * Constructs a new pb_gmarket.
         * @exports pb_gmarket
         * @classdesc Represents a pb_gmarket.
         * @implements Ipb_gmarket
         * @constructor
         * @param {Ipb_gmarket=} [properties] Properties to set
         */
        function pb_gmarket(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_gmarket id.
         * @member {number} id
         * @memberof pb_gmarket
         * @instance
         */
        pb_gmarket.prototype.id = 0;
    
        /**
         * pb_gmarket num.
         * @member {number} num
         * @memberof pb_gmarket
         * @instance
         */
        pb_gmarket.prototype.num = 0;
    
        /**
         * pb_gmarket gid.
         * @member {number} gid
         * @memberof pb_gmarket
         * @instance
         */
        pb_gmarket.prototype.gid = 0;
    
        /**
         * Creates a new pb_gmarket instance using the specified properties.
         * @function create
         * @memberof pb_gmarket
         * @static
         * @param {Ipb_gmarket=} [properties] Properties to set
         * @returns {pb_gmarket} pb_gmarket instance
         */
        pb_gmarket.create = function create(properties) {
            return new pb_gmarket(properties);
        };
    
        /**
         * Encodes the specified pb_gmarket message. Does not implicitly {@link pb_gmarket.verify|verify} messages.
         * @function encode
         * @memberof pb_gmarket
         * @static
         * @param {Ipb_gmarket} message pb_gmarket message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_gmarket.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.id);
            if (message.num != null && Object.hasOwnProperty.call(message, "num"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.num);
            if (message.gid != null && Object.hasOwnProperty.call(message, "gid"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.gid);
            return writer;
        };
    
        /**
         * Encodes the specified pb_gmarket message, length delimited. Does not implicitly {@link pb_gmarket.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_gmarket
         * @static
         * @param {Ipb_gmarket} message pb_gmarket message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_gmarket.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_gmarket message from the specified reader or buffer.
         * @function decode
         * @memberof pb_gmarket
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_gmarket} pb_gmarket
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_gmarket.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_gmarket();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.id = reader.int32();
                        break;
                    }
                case 2: {
                        message.num = reader.int32();
                        break;
                    }
                case 3: {
                        message.gid = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("id"))
                throw $util.ProtocolError("missing required 'id'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a pb_gmarket message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_gmarket
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_gmarket} pb_gmarket
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_gmarket.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_gmarket message.
         * @function verify
         * @memberof pb_gmarket
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_gmarket.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.id))
                return "id: integer expected";
            if (message.num != null && message.hasOwnProperty("num"))
                if (!$util.isInteger(message.num))
                    return "num: integer expected";
            if (message.gid != null && message.hasOwnProperty("gid"))
                if (!$util.isInteger(message.gid))
                    return "gid: integer expected";
            return null;
        };
    
        /**
         * Creates a pb_gmarket message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_gmarket
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_gmarket} pb_gmarket
         */
        pb_gmarket.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_gmarket)
                return object;
            var message = new $root.pb_gmarket();
            if (object.id != null)
                message.id = object.id | 0;
            if (object.num != null)
                message.num = object.num | 0;
            if (object.gid != null)
                message.gid = object.gid | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a pb_gmarket message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_gmarket
         * @static
         * @param {pb_gmarket} message pb_gmarket
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_gmarket.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = 0;
                object.num = 0;
                object.gid = 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.num != null && message.hasOwnProperty("num"))
                object.num = message.num;
            if (message.gid != null && message.hasOwnProperty("gid"))
                object.gid = message.gid;
            return object;
        };
    
        /**
         * Converts this pb_gmarket to JSON.
         * @function toJSON
         * @memberof pb_gmarket
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_gmarket.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_gmarket
         * @function getTypeUrl
         * @memberof pb_gmarket
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_gmarket.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_gmarket";
        };
    
        return pb_gmarket;
    })();
    
    $root.pb_gvrank = (function() {
    
        /**
         * Properties of a pb_gvrank.
         * @exports Ipb_gvrank
         * @interface Ipb_gvrank
         * @property {number|Long} uid pb_gvrank uid
         * @property {string|null} [name] pb_gvrank name
         * @property {number|null} [lv] pb_gvrank lv
         * @property {number|null} [logo] pb_gvrank logo
         * @property {number|Long} hurt pb_gvrank hurt
         * @property {Ipb_bag|null} [reward] pb_gvrank reward
         * @property {number|null} [border] pb_gvrank border
         */
    
        /**
         * Constructs a new pb_gvrank.
         * @exports pb_gvrank
         * @classdesc Represents a pb_gvrank.
         * @implements Ipb_gvrank
         * @constructor
         * @param {Ipb_gvrank=} [properties] Properties to set
         */
        function pb_gvrank(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_gvrank uid.
         * @member {number|Long} uid
         * @memberof pb_gvrank
         * @instance
         */
        pb_gvrank.prototype.uid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * pb_gvrank name.
         * @member {string} name
         * @memberof pb_gvrank
         * @instance
         */
        pb_gvrank.prototype.name = "";
    
        /**
         * pb_gvrank lv.
         * @member {number} lv
         * @memberof pb_gvrank
         * @instance
         */
        pb_gvrank.prototype.lv = 0;
    
        /**
         * pb_gvrank logo.
         * @member {number} logo
         * @memberof pb_gvrank
         * @instance
         */
        pb_gvrank.prototype.logo = 0;
    
        /**
         * pb_gvrank hurt.
         * @member {number|Long} hurt
         * @memberof pb_gvrank
         * @instance
         */
        pb_gvrank.prototype.hurt = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * pb_gvrank reward.
         * @member {Ipb_bag|null|undefined} reward
         * @memberof pb_gvrank
         * @instance
         */
        pb_gvrank.prototype.reward = null;
    
        /**
         * pb_gvrank border.
         * @member {number} border
         * @memberof pb_gvrank
         * @instance
         */
        pb_gvrank.prototype.border = 0;
    
        /**
         * Creates a new pb_gvrank instance using the specified properties.
         * @function create
         * @memberof pb_gvrank
         * @static
         * @param {Ipb_gvrank=} [properties] Properties to set
         * @returns {pb_gvrank} pb_gvrank instance
         */
        pb_gvrank.create = function create(properties) {
            return new pb_gvrank(properties);
        };
    
        /**
         * Encodes the specified pb_gvrank message. Does not implicitly {@link pb_gvrank.verify|verify} messages.
         * @function encode
         * @memberof pb_gvrank
         * @static
         * @param {Ipb_gvrank} message pb_gvrank message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_gvrank.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int64(message.uid);
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
            if (message.lv != null && Object.hasOwnProperty.call(message, "lv"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.lv);
            if (message.logo != null && Object.hasOwnProperty.call(message, "logo"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.logo);
            writer.uint32(/* id 5, wireType 0 =*/40).int64(message.hurt);
            if (message.reward != null && Object.hasOwnProperty.call(message, "reward"))
                $root.pb_bag.encode(message.reward, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.border != null && Object.hasOwnProperty.call(message, "border"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.border);
            return writer;
        };
    
        /**
         * Encodes the specified pb_gvrank message, length delimited. Does not implicitly {@link pb_gvrank.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_gvrank
         * @static
         * @param {Ipb_gvrank} message pb_gvrank message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_gvrank.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_gvrank message from the specified reader or buffer.
         * @function decode
         * @memberof pb_gvrank
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_gvrank} pb_gvrank
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_gvrank.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_gvrank();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.uid = reader.int64();
                        break;
                    }
                case 2: {
                        message.name = reader.string();
                        break;
                    }
                case 3: {
                        message.lv = reader.int32();
                        break;
                    }
                case 4: {
                        message.logo = reader.int32();
                        break;
                    }
                case 5: {
                        message.hurt = reader.int64();
                        break;
                    }
                case 6: {
                        message.reward = $root.pb_bag.decode(reader, reader.uint32());
                        break;
                    }
                case 7: {
                        message.border = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("uid"))
                throw $util.ProtocolError("missing required 'uid'", { instance: message });
            if (!message.hasOwnProperty("hurt"))
                throw $util.ProtocolError("missing required 'hurt'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a pb_gvrank message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_gvrank
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_gvrank} pb_gvrank
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_gvrank.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_gvrank message.
         * @function verify
         * @memberof pb_gvrank
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_gvrank.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.uid) && !(message.uid && $util.isInteger(message.uid.low) && $util.isInteger(message.uid.high)))
                return "uid: integer|Long expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.lv != null && message.hasOwnProperty("lv"))
                if (!$util.isInteger(message.lv))
                    return "lv: integer expected";
            if (message.logo != null && message.hasOwnProperty("logo"))
                if (!$util.isInteger(message.logo))
                    return "logo: integer expected";
            if (!$util.isInteger(message.hurt) && !(message.hurt && $util.isInteger(message.hurt.low) && $util.isInteger(message.hurt.high)))
                return "hurt: integer|Long expected";
            if (message.reward != null && message.hasOwnProperty("reward")) {
                var error = $root.pb_bag.verify(message.reward);
                if (error)
                    return "reward." + error;
            }
            if (message.border != null && message.hasOwnProperty("border"))
                if (!$util.isInteger(message.border))
                    return "border: integer expected";
            return null;
        };
    
        /**
         * Creates a pb_gvrank message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_gvrank
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_gvrank} pb_gvrank
         */
        pb_gvrank.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_gvrank)
                return object;
            var message = new $root.pb_gvrank();
            if (object.uid != null)
                if ($util.Long)
                    (message.uid = $util.Long.fromValue(object.uid)).unsigned = false;
                else if (typeof object.uid === "string")
                    message.uid = parseInt(object.uid, 10);
                else if (typeof object.uid === "number")
                    message.uid = object.uid;
                else if (typeof object.uid === "object")
                    message.uid = new $util.LongBits(object.uid.low >>> 0, object.uid.high >>> 0).toNumber();
            if (object.name != null)
                message.name = String(object.name);
            if (object.lv != null)
                message.lv = object.lv | 0;
            if (object.logo != null)
                message.logo = object.logo | 0;
            if (object.hurt != null)
                if ($util.Long)
                    (message.hurt = $util.Long.fromValue(object.hurt)).unsigned = false;
                else if (typeof object.hurt === "string")
                    message.hurt = parseInt(object.hurt, 10);
                else if (typeof object.hurt === "number")
                    message.hurt = object.hurt;
                else if (typeof object.hurt === "object")
                    message.hurt = new $util.LongBits(object.hurt.low >>> 0, object.hurt.high >>> 0).toNumber();
            if (object.reward != null) {
                if (typeof object.reward !== "object")
                    throw TypeError(".pb_gvrank.reward: object expected");
                message.reward = $root.pb_bag.fromObject(object.reward);
            }
            if (object.border != null)
                message.border = object.border | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a pb_gvrank message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_gvrank
         * @static
         * @param {pb_gvrank} message pb_gvrank
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_gvrank.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.uid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.uid = options.longs === String ? "0" : 0;
                object.name = "";
                object.lv = 0;
                object.logo = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.hurt = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.hurt = options.longs === String ? "0" : 0;
                object.reward = null;
                object.border = 0;
            }
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (typeof message.uid === "number")
                    object.uid = options.longs === String ? String(message.uid) : message.uid;
                else
                    object.uid = options.longs === String ? $util.Long.prototype.toString.call(message.uid) : options.longs === Number ? new $util.LongBits(message.uid.low >>> 0, message.uid.high >>> 0).toNumber() : message.uid;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.lv != null && message.hasOwnProperty("lv"))
                object.lv = message.lv;
            if (message.logo != null && message.hasOwnProperty("logo"))
                object.logo = message.logo;
            if (message.hurt != null && message.hasOwnProperty("hurt"))
                if (typeof message.hurt === "number")
                    object.hurt = options.longs === String ? String(message.hurt) : message.hurt;
                else
                    object.hurt = options.longs === String ? $util.Long.prototype.toString.call(message.hurt) : options.longs === Number ? new $util.LongBits(message.hurt.low >>> 0, message.hurt.high >>> 0).toNumber() : message.hurt;
            if (message.reward != null && message.hasOwnProperty("reward"))
                object.reward = $root.pb_bag.toObject(message.reward, options);
            if (message.border != null && message.hasOwnProperty("border"))
                object.border = message.border;
            return object;
        };
    
        /**
         * Converts this pb_gvrank to JSON.
         * @function toJSON
         * @memberof pb_gvrank
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_gvrank.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_gvrank
         * @function getTypeUrl
         * @memberof pb_gvrank
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_gvrank.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_gvrank";
        };
    
        return pb_gvrank;
    })();
    
    $root.pb_gvrank_donate = (function() {
    
        /**
         * Properties of a pb_gvrank_donate.
         * @exports Ipb_gvrank_donate
         * @interface Ipb_gvrank_donate
         * @property {string} name pb_gvrank_donate name
         * @property {number} lv pb_gvrank_donate lv
         * @property {number} logo pb_gvrank_donate logo
         * @property {number|null} [num] pb_gvrank_donate num
         */
    
        /**
         * Constructs a new pb_gvrank_donate.
         * @exports pb_gvrank_donate
         * @classdesc Represents a pb_gvrank_donate.
         * @implements Ipb_gvrank_donate
         * @constructor
         * @param {Ipb_gvrank_donate=} [properties] Properties to set
         */
        function pb_gvrank_donate(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_gvrank_donate name.
         * @member {string} name
         * @memberof pb_gvrank_donate
         * @instance
         */
        pb_gvrank_donate.prototype.name = "";
    
        /**
         * pb_gvrank_donate lv.
         * @member {number} lv
         * @memberof pb_gvrank_donate
         * @instance
         */
        pb_gvrank_donate.prototype.lv = 0;
    
        /**
         * pb_gvrank_donate logo.
         * @member {number} logo
         * @memberof pb_gvrank_donate
         * @instance
         */
        pb_gvrank_donate.prototype.logo = 0;
    
        /**
         * pb_gvrank_donate num.
         * @member {number} num
         * @memberof pb_gvrank_donate
         * @instance
         */
        pb_gvrank_donate.prototype.num = 0;
    
        /**
         * Creates a new pb_gvrank_donate instance using the specified properties.
         * @function create
         * @memberof pb_gvrank_donate
         * @static
         * @param {Ipb_gvrank_donate=} [properties] Properties to set
         * @returns {pb_gvrank_donate} pb_gvrank_donate instance
         */
        pb_gvrank_donate.create = function create(properties) {
            return new pb_gvrank_donate(properties);
        };
    
        /**
         * Encodes the specified pb_gvrank_donate message. Does not implicitly {@link pb_gvrank_donate.verify|verify} messages.
         * @function encode
         * @memberof pb_gvrank_donate
         * @static
         * @param {Ipb_gvrank_donate} message pb_gvrank_donate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_gvrank_donate.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.lv);
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.logo);
            if (message.num != null && Object.hasOwnProperty.call(message, "num"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.num);
            return writer;
        };
    
        /**
         * Encodes the specified pb_gvrank_donate message, length delimited. Does not implicitly {@link pb_gvrank_donate.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_gvrank_donate
         * @static
         * @param {Ipb_gvrank_donate} message pb_gvrank_donate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_gvrank_donate.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_gvrank_donate message from the specified reader or buffer.
         * @function decode
         * @memberof pb_gvrank_donate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_gvrank_donate} pb_gvrank_donate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_gvrank_donate.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_gvrank_donate();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.name = reader.string();
                        break;
                    }
                case 2: {
                        message.lv = reader.int32();
                        break;
                    }
                case 3: {
                        message.logo = reader.int32();
                        break;
                    }
                case 4: {
                        message.num = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("name"))
                throw $util.ProtocolError("missing required 'name'", { instance: message });
            if (!message.hasOwnProperty("lv"))
                throw $util.ProtocolError("missing required 'lv'", { instance: message });
            if (!message.hasOwnProperty("logo"))
                throw $util.ProtocolError("missing required 'logo'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a pb_gvrank_donate message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_gvrank_donate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_gvrank_donate} pb_gvrank_donate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_gvrank_donate.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_gvrank_donate message.
         * @function verify
         * @memberof pb_gvrank_donate
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_gvrank_donate.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isString(message.name))
                return "name: string expected";
            if (!$util.isInteger(message.lv))
                return "lv: integer expected";
            if (!$util.isInteger(message.logo))
                return "logo: integer expected";
            if (message.num != null && message.hasOwnProperty("num"))
                if (!$util.isInteger(message.num))
                    return "num: integer expected";
            return null;
        };
    
        /**
         * Creates a pb_gvrank_donate message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_gvrank_donate
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_gvrank_donate} pb_gvrank_donate
         */
        pb_gvrank_donate.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_gvrank_donate)
                return object;
            var message = new $root.pb_gvrank_donate();
            if (object.name != null)
                message.name = String(object.name);
            if (object.lv != null)
                message.lv = object.lv | 0;
            if (object.logo != null)
                message.logo = object.logo | 0;
            if (object.num != null)
                message.num = object.num | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a pb_gvrank_donate message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_gvrank_donate
         * @static
         * @param {pb_gvrank_donate} message pb_gvrank_donate
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_gvrank_donate.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.name = "";
                object.lv = 0;
                object.logo = 0;
                object.num = 0;
            }
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.lv != null && message.hasOwnProperty("lv"))
                object.lv = message.lv;
            if (message.logo != null && message.hasOwnProperty("logo"))
                object.logo = message.logo;
            if (message.num != null && message.hasOwnProperty("num"))
                object.num = message.num;
            return object;
        };
    
        /**
         * Converts this pb_gvrank_donate to JSON.
         * @function toJSON
         * @memberof pb_gvrank_donate
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_gvrank_donate.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_gvrank_donate
         * @function getTypeUrl
         * @memberof pb_gvrank_donate
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_gvrank_donate.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_gvrank_donate";
        };
    
        return pb_gvrank_donate;
    })();
    
    $root.pb_bboss = (function() {
    
        /**
         * Properties of a pb_bboss.
         * @exports Ipb_bboss
         * @interface Ipb_bboss
         * @property {number} uid pb_bboss uid
         * @property {string|null} [name] pb_bboss name
         * @property {number|null} [lv] pb_bboss lv
         * @property {number|null} [logo] pb_bboss logo
         * @property {number|Long} hurt pb_bboss hurt
         * @property {number|null} [sid] pb_bboss sid
         */
    
        /**
         * Constructs a new pb_bboss.
         * @exports pb_bboss
         * @classdesc Represents a pb_bboss.
         * @implements Ipb_bboss
         * @constructor
         * @param {Ipb_bboss=} [properties] Properties to set
         */
        function pb_bboss(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_bboss uid.
         * @member {number} uid
         * @memberof pb_bboss
         * @instance
         */
        pb_bboss.prototype.uid = 0;
    
        /**
         * pb_bboss name.
         * @member {string} name
         * @memberof pb_bboss
         * @instance
         */
        pb_bboss.prototype.name = "";
    
        /**
         * pb_bboss lv.
         * @member {number} lv
         * @memberof pb_bboss
         * @instance
         */
        pb_bboss.prototype.lv = 0;
    
        /**
         * pb_bboss logo.
         * @member {number} logo
         * @memberof pb_bboss
         * @instance
         */
        pb_bboss.prototype.logo = 0;
    
        /**
         * pb_bboss hurt.
         * @member {number|Long} hurt
         * @memberof pb_bboss
         * @instance
         */
        pb_bboss.prototype.hurt = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
        /**
         * pb_bboss sid.
         * @member {number} sid
         * @memberof pb_bboss
         * @instance
         */
        pb_bboss.prototype.sid = 0;
    
        /**
         * Creates a new pb_bboss instance using the specified properties.
         * @function create
         * @memberof pb_bboss
         * @static
         * @param {Ipb_bboss=} [properties] Properties to set
         * @returns {pb_bboss} pb_bboss instance
         */
        pb_bboss.create = function create(properties) {
            return new pb_bboss(properties);
        };
    
        /**
         * Encodes the specified pb_bboss message. Does not implicitly {@link pb_bboss.verify|verify} messages.
         * @function encode
         * @memberof pb_bboss
         * @static
         * @param {Ipb_bboss} message pb_bboss message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_bboss.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.uid);
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
            if (message.lv != null && Object.hasOwnProperty.call(message, "lv"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.lv);
            if (message.logo != null && Object.hasOwnProperty.call(message, "logo"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.logo);
            writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.hurt);
            if (message.sid != null && Object.hasOwnProperty.call(message, "sid"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.sid);
            return writer;
        };
    
        /**
         * Encodes the specified pb_bboss message, length delimited. Does not implicitly {@link pb_bboss.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_bboss
         * @static
         * @param {Ipb_bboss} message pb_bboss message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_bboss.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_bboss message from the specified reader or buffer.
         * @function decode
         * @memberof pb_bboss
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_bboss} pb_bboss
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_bboss.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_bboss();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.uid = reader.int32();
                        break;
                    }
                case 2: {
                        message.name = reader.string();
                        break;
                    }
                case 3: {
                        message.lv = reader.int32();
                        break;
                    }
                case 4: {
                        message.logo = reader.int32();
                        break;
                    }
                case 5: {
                        message.hurt = reader.uint64();
                        break;
                    }
                case 6: {
                        message.sid = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("uid"))
                throw $util.ProtocolError("missing required 'uid'", { instance: message });
            if (!message.hasOwnProperty("hurt"))
                throw $util.ProtocolError("missing required 'hurt'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a pb_bboss message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_bboss
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_bboss} pb_bboss
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_bboss.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_bboss message.
         * @function verify
         * @memberof pb_bboss
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_bboss.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.uid))
                return "uid: integer expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.lv != null && message.hasOwnProperty("lv"))
                if (!$util.isInteger(message.lv))
                    return "lv: integer expected";
            if (message.logo != null && message.hasOwnProperty("logo"))
                if (!$util.isInteger(message.logo))
                    return "logo: integer expected";
            if (!$util.isInteger(message.hurt) && !(message.hurt && $util.isInteger(message.hurt.low) && $util.isInteger(message.hurt.high)))
                return "hurt: integer|Long expected";
            if (message.sid != null && message.hasOwnProperty("sid"))
                if (!$util.isInteger(message.sid))
                    return "sid: integer expected";
            return null;
        };
    
        /**
         * Creates a pb_bboss message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_bboss
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_bboss} pb_bboss
         */
        pb_bboss.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_bboss)
                return object;
            var message = new $root.pb_bboss();
            if (object.uid != null)
                message.uid = object.uid | 0;
            if (object.name != null)
                message.name = String(object.name);
            if (object.lv != null)
                message.lv = object.lv | 0;
            if (object.logo != null)
                message.logo = object.logo | 0;
            if (object.hurt != null)
                if ($util.Long)
                    (message.hurt = $util.Long.fromValue(object.hurt)).unsigned = true;
                else if (typeof object.hurt === "string")
                    message.hurt = parseInt(object.hurt, 10);
                else if (typeof object.hurt === "number")
                    message.hurt = object.hurt;
                else if (typeof object.hurt === "object")
                    message.hurt = new $util.LongBits(object.hurt.low >>> 0, object.hurt.high >>> 0).toNumber(true);
            if (object.sid != null)
                message.sid = object.sid | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a pb_bboss message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_bboss
         * @static
         * @param {pb_bboss} message pb_bboss
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_bboss.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.uid = 0;
                object.name = "";
                object.lv = 0;
                object.logo = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.hurt = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.hurt = options.longs === String ? "0" : 0;
                object.sid = 0;
            }
            if (message.uid != null && message.hasOwnProperty("uid"))
                object.uid = message.uid;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.lv != null && message.hasOwnProperty("lv"))
                object.lv = message.lv;
            if (message.logo != null && message.hasOwnProperty("logo"))
                object.logo = message.logo;
            if (message.hurt != null && message.hasOwnProperty("hurt"))
                if (typeof message.hurt === "number")
                    object.hurt = options.longs === String ? String(message.hurt) : message.hurt;
                else
                    object.hurt = options.longs === String ? $util.Long.prototype.toString.call(message.hurt) : options.longs === Number ? new $util.LongBits(message.hurt.low >>> 0, message.hurt.high >>> 0).toNumber(true) : message.hurt;
            if (message.sid != null && message.hasOwnProperty("sid"))
                object.sid = message.sid;
            return object;
        };
    
        /**
         * Converts this pb_bboss to JSON.
         * @function toJSON
         * @memberof pb_bboss
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_bboss.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_bboss
         * @function getTypeUrl
         * @memberof pb_bboss
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_bboss.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_bboss";
        };
    
        return pb_bboss;
    })();
    
    $root.pb_gskl = (function() {
    
        /**
         * Properties of a pb_gskl.
         * @exports Ipb_gskl
         * @interface Ipb_gskl
         * @property {number} id pb_gskl id
         * @property {number} lv pb_gskl lv
         */
    
        /**
         * Constructs a new pb_gskl.
         * @exports pb_gskl
         * @classdesc Represents a pb_gskl.
         * @implements Ipb_gskl
         * @constructor
         * @param {Ipb_gskl=} [properties] Properties to set
         */
        function pb_gskl(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_gskl id.
         * @member {number} id
         * @memberof pb_gskl
         * @instance
         */
        pb_gskl.prototype.id = 0;
    
        /**
         * pb_gskl lv.
         * @member {number} lv
         * @memberof pb_gskl
         * @instance
         */
        pb_gskl.prototype.lv = 0;
    
        /**
         * Creates a new pb_gskl instance using the specified properties.
         * @function create
         * @memberof pb_gskl
         * @static
         * @param {Ipb_gskl=} [properties] Properties to set
         * @returns {pb_gskl} pb_gskl instance
         */
        pb_gskl.create = function create(properties) {
            return new pb_gskl(properties);
        };
    
        /**
         * Encodes the specified pb_gskl message. Does not implicitly {@link pb_gskl.verify|verify} messages.
         * @function encode
         * @memberof pb_gskl
         * @static
         * @param {Ipb_gskl} message pb_gskl message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_gskl.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.id);
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.lv);
            return writer;
        };
    
        /**
         * Encodes the specified pb_gskl message, length delimited. Does not implicitly {@link pb_gskl.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_gskl
         * @static
         * @param {Ipb_gskl} message pb_gskl message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_gskl.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_gskl message from the specified reader or buffer.
         * @function decode
         * @memberof pb_gskl
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_gskl} pb_gskl
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_gskl.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_gskl();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.id = reader.int32();
                        break;
                    }
                case 2: {
                        message.lv = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("id"))
                throw $util.ProtocolError("missing required 'id'", { instance: message });
            if (!message.hasOwnProperty("lv"))
                throw $util.ProtocolError("missing required 'lv'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a pb_gskl message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_gskl
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_gskl} pb_gskl
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_gskl.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_gskl message.
         * @function verify
         * @memberof pb_gskl
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_gskl.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.id))
                return "id: integer expected";
            if (!$util.isInteger(message.lv))
                return "lv: integer expected";
            return null;
        };
    
        /**
         * Creates a pb_gskl message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_gskl
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_gskl} pb_gskl
         */
        pb_gskl.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_gskl)
                return object;
            var message = new $root.pb_gskl();
            if (object.id != null)
                message.id = object.id | 0;
            if (object.lv != null)
                message.lv = object.lv | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a pb_gskl message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_gskl
         * @static
         * @param {pb_gskl} message pb_gskl
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_gskl.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = 0;
                object.lv = 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.lv != null && message.hasOwnProperty("lv"))
                object.lv = message.lv;
            return object;
        };
    
        /**
         * Converts this pb_gskl to JSON.
         * @function toJSON
         * @memberof pb_gskl
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_gskl.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_gskl
         * @function getTypeUrl
         * @memberof pb_gskl
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_gskl.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_gskl";
        };
    
        return pb_gskl;
    })();
    
    $root.pb_bunit = (function() {
    
        /**
         * Properties of a pb_bunit.
         * @exports Ipb_bunit
         * @interface Ipb_bunit
         * @property {number|null} [hid] pb_bunit hid
         * @property {number|null} [id] pb_bunit id
         * @property {number|null} [lv] pb_bunit lv
         * @property {number|null} [star] pb_bunit star
         * @property {number|null} [hpp] pb_bunit hpp
         * @property {number|null} [pos] pb_bunit pos
         * @property {number|null} [wake] pb_bunit wake
         * @property {number|null} [revive] pb_bunit revive
         * @property {number|null} [skin] pb_bunit skin
         * @property {number|null} [flag] pb_bunit flag
         * @property {number|null} [qlv] pb_bunit qlv
         * @property {number|null} [core] pb_bunit core
         */
    
        /**
         * Constructs a new pb_bunit.
         * @exports pb_bunit
         * @classdesc Represents a pb_bunit.
         * @implements Ipb_bunit
         * @constructor
         * @param {Ipb_bunit=} [properties] Properties to set
         */
        function pb_bunit(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_bunit hid.
         * @member {number} hid
         * @memberof pb_bunit
         * @instance
         */
        pb_bunit.prototype.hid = 0;
    
        /**
         * pb_bunit id.
         * @member {number} id
         * @memberof pb_bunit
         * @instance
         */
        pb_bunit.prototype.id = 0;
    
        /**
         * pb_bunit lv.
         * @member {number} lv
         * @memberof pb_bunit
         * @instance
         */
        pb_bunit.prototype.lv = 0;
    
        /**
         * pb_bunit star.
         * @member {number} star
         * @memberof pb_bunit
         * @instance
         */
        pb_bunit.prototype.star = 0;
    
        /**
         * pb_bunit hpp.
         * @member {number} hpp
         * @memberof pb_bunit
         * @instance
         */
        pb_bunit.prototype.hpp = 0;
    
        /**
         * pb_bunit pos.
         * @member {number} pos
         * @memberof pb_bunit
         * @instance
         */
        pb_bunit.prototype.pos = 0;
    
        /**
         * pb_bunit wake.
         * @member {number} wake
         * @memberof pb_bunit
         * @instance
         */
        pb_bunit.prototype.wake = 0;
    
        /**
         * pb_bunit revive.
         * @member {number} revive
         * @memberof pb_bunit
         * @instance
         */
        pb_bunit.prototype.revive = 0;
    
        /**
         * pb_bunit skin.
         * @member {number} skin
         * @memberof pb_bunit
         * @instance
         */
        pb_bunit.prototype.skin = 0;
    
        /**
         * pb_bunit flag.
         * @member {number} flag
         * @memberof pb_bunit
         * @instance
         */
        pb_bunit.prototype.flag = 0;
    
        /**
         * pb_bunit qlv.
         * @member {number} qlv
         * @memberof pb_bunit
         * @instance
         */
        pb_bunit.prototype.qlv = 0;
    
        /**
         * pb_bunit core.
         * @member {number} core
         * @memberof pb_bunit
         * @instance
         */
        pb_bunit.prototype.core = 0;
    
        /**
         * Creates a new pb_bunit instance using the specified properties.
         * @function create
         * @memberof pb_bunit
         * @static
         * @param {Ipb_bunit=} [properties] Properties to set
         * @returns {pb_bunit} pb_bunit instance
         */
        pb_bunit.create = function create(properties) {
            return new pb_bunit(properties);
        };
    
        /**
         * Encodes the specified pb_bunit message. Does not implicitly {@link pb_bunit.verify|verify} messages.
         * @function encode
         * @memberof pb_bunit
         * @static
         * @param {Ipb_bunit} message pb_bunit message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_bunit.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.hid != null && Object.hasOwnProperty.call(message, "hid"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.hid);
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.id);
            if (message.lv != null && Object.hasOwnProperty.call(message, "lv"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.lv);
            if (message.star != null && Object.hasOwnProperty.call(message, "star"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.star);
            if (message.hpp != null && Object.hasOwnProperty.call(message, "hpp"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.hpp);
            if (message.pos != null && Object.hasOwnProperty.call(message, "pos"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.pos);
            if (message.wake != null && Object.hasOwnProperty.call(message, "wake"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.wake);
            if (message.revive != null && Object.hasOwnProperty.call(message, "revive"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.revive);
            if (message.skin != null && Object.hasOwnProperty.call(message, "skin"))
                writer.uint32(/* id 9, wireType 0 =*/72).int32(message.skin);
            if (message.flag != null && Object.hasOwnProperty.call(message, "flag"))
                writer.uint32(/* id 10, wireType 0 =*/80).int32(message.flag);
            if (message.qlv != null && Object.hasOwnProperty.call(message, "qlv"))
                writer.uint32(/* id 11, wireType 0 =*/88).int32(message.qlv);
            if (message.core != null && Object.hasOwnProperty.call(message, "core"))
                writer.uint32(/* id 12, wireType 0 =*/96).int32(message.core);
            return writer;
        };
    
        /**
         * Encodes the specified pb_bunit message, length delimited. Does not implicitly {@link pb_bunit.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_bunit
         * @static
         * @param {Ipb_bunit} message pb_bunit message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_bunit.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_bunit message from the specified reader or buffer.
         * @function decode
         * @memberof pb_bunit
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_bunit} pb_bunit
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_bunit.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_bunit();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.hid = reader.int32();
                        break;
                    }
                case 2: {
                        message.id = reader.int32();
                        break;
                    }
                case 3: {
                        message.lv = reader.int32();
                        break;
                    }
                case 4: {
                        message.star = reader.int32();
                        break;
                    }
                case 5: {
                        message.hpp = reader.int32();
                        break;
                    }
                case 6: {
                        message.pos = reader.int32();
                        break;
                    }
                case 7: {
                        message.wake = reader.int32();
                        break;
                    }
                case 8: {
                        message.revive = reader.int32();
                        break;
                    }
                case 9: {
                        message.skin = reader.int32();
                        break;
                    }
                case 10: {
                        message.flag = reader.int32();
                        break;
                    }
                case 11: {
                        message.qlv = reader.int32();
                        break;
                    }
                case 12: {
                        message.core = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a pb_bunit message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_bunit
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_bunit} pb_bunit
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_bunit.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_bunit message.
         * @function verify
         * @memberof pb_bunit
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_bunit.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.hid != null && message.hasOwnProperty("hid"))
                if (!$util.isInteger(message.hid))
                    return "hid: integer expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id))
                    return "id: integer expected";
            if (message.lv != null && message.hasOwnProperty("lv"))
                if (!$util.isInteger(message.lv))
                    return "lv: integer expected";
            if (message.star != null && message.hasOwnProperty("star"))
                if (!$util.isInteger(message.star))
                    return "star: integer expected";
            if (message.hpp != null && message.hasOwnProperty("hpp"))
                if (!$util.isInteger(message.hpp))
                    return "hpp: integer expected";
            if (message.pos != null && message.hasOwnProperty("pos"))
                if (!$util.isInteger(message.pos))
                    return "pos: integer expected";
            if (message.wake != null && message.hasOwnProperty("wake"))
                if (!$util.isInteger(message.wake))
                    return "wake: integer expected";
            if (message.revive != null && message.hasOwnProperty("revive"))
                if (!$util.isInteger(message.revive))
                    return "revive: integer expected";
            if (message.skin != null && message.hasOwnProperty("skin"))
                if (!$util.isInteger(message.skin))
                    return "skin: integer expected";
            if (message.flag != null && message.hasOwnProperty("flag"))
                if (!$util.isInteger(message.flag))
                    return "flag: integer expected";
            if (message.qlv != null && message.hasOwnProperty("qlv"))
                if (!$util.isInteger(message.qlv))
                    return "qlv: integer expected";
            if (message.core != null && message.hasOwnProperty("core"))
                if (!$util.isInteger(message.core))
                    return "core: integer expected";
            return null;
        };
    
        /**
         * Creates a pb_bunit message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_bunit
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_bunit} pb_bunit
         */
        pb_bunit.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_bunit)
                return object;
            var message = new $root.pb_bunit();
            if (object.hid != null)
                message.hid = object.hid | 0;
            if (object.id != null)
                message.id = object.id | 0;
            if (object.lv != null)
                message.lv = object.lv | 0;
            if (object.star != null)
                message.star = object.star | 0;
            if (object.hpp != null)
                message.hpp = object.hpp | 0;
            if (object.pos != null)
                message.pos = object.pos | 0;
            if (object.wake != null)
                message.wake = object.wake | 0;
            if (object.revive != null)
                message.revive = object.revive | 0;
            if (object.skin != null)
                message.skin = object.skin | 0;
            if (object.flag != null)
                message.flag = object.flag | 0;
            if (object.qlv != null)
                message.qlv = object.qlv | 0;
            if (object.core != null)
                message.core = object.core | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a pb_bunit message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_bunit
         * @static
         * @param {pb_bunit} message pb_bunit
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_bunit.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.hid = 0;
                object.id = 0;
                object.lv = 0;
                object.star = 0;
                object.hpp = 0;
                object.pos = 0;
                object.wake = 0;
                object.revive = 0;
                object.skin = 0;
                object.flag = 0;
                object.qlv = 0;
                object.core = 0;
            }
            if (message.hid != null && message.hasOwnProperty("hid"))
                object.hid = message.hid;
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.lv != null && message.hasOwnProperty("lv"))
                object.lv = message.lv;
            if (message.star != null && message.hasOwnProperty("star"))
                object.star = message.star;
            if (message.hpp != null && message.hasOwnProperty("hpp"))
                object.hpp = message.hpp;
            if (message.pos != null && message.hasOwnProperty("pos"))
                object.pos = message.pos;
            if (message.wake != null && message.hasOwnProperty("wake"))
                object.wake = message.wake;
            if (message.revive != null && message.hasOwnProperty("revive"))
                object.revive = message.revive;
            if (message.skin != null && message.hasOwnProperty("skin"))
                object.skin = message.skin;
            if (message.flag != null && message.hasOwnProperty("flag"))
                object.flag = message.flag;
            if (message.qlv != null && message.hasOwnProperty("qlv"))
                object.qlv = message.qlv;
            if (message.core != null && message.hasOwnProperty("core"))
                object.core = message.core;
            return object;
        };
    
        /**
         * Converts this pb_bunit to JSON.
         * @function toJSON
         * @memberof pb_bunit
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_bunit.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_bunit
         * @function getTypeUrl
         * @memberof pb_bunit
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_bunit.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_bunit";
        };
    
        return pb_bunit;
    })();
    
    $root.pb_benemy = (function() {
    
        /**
         * Properties of a pb_benemy.
         * @exports Ipb_benemy
         * @interface Ipb_benemy
         * @property {number} logo pb_benemy logo
         * @property {number} lv pb_benemy lv
         * @property {string} name pb_benemy name
         * @property {number|Long} power pb_benemy power
         * @property {number} sid pb_benemy sid
         * @property {Array.<Ipb_bunit>|null} [camp] pb_benemy camp
         * @property {number|null} [border] pb_benemy border
         */
    
        /**
         * Constructs a new pb_benemy.
         * @exports pb_benemy
         * @classdesc Represents a pb_benemy.
         * @implements Ipb_benemy
         * @constructor
         * @param {Ipb_benemy=} [properties] Properties to set
         */
        function pb_benemy(properties) {
            this.camp = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_benemy logo.
         * @member {number} logo
         * @memberof pb_benemy
         * @instance
         */
        pb_benemy.prototype.logo = 0;
    
        /**
         * pb_benemy lv.
         * @member {number} lv
         * @memberof pb_benemy
         * @instance
         */
        pb_benemy.prototype.lv = 0;
    
        /**
         * pb_benemy name.
         * @member {string} name
         * @memberof pb_benemy
         * @instance
         */
        pb_benemy.prototype.name = "";
    
        /**
         * pb_benemy power.
         * @member {number|Long} power
         * @memberof pb_benemy
         * @instance
         */
        pb_benemy.prototype.power = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * pb_benemy sid.
         * @member {number} sid
         * @memberof pb_benemy
         * @instance
         */
        pb_benemy.prototype.sid = 0;
    
        /**
         * pb_benemy camp.
         * @member {Array.<Ipb_bunit>} camp
         * @memberof pb_benemy
         * @instance
         */
        pb_benemy.prototype.camp = $util.emptyArray;
    
        /**
         * pb_benemy border.
         * @member {number} border
         * @memberof pb_benemy
         * @instance
         */
        pb_benemy.prototype.border = 0;
    
        /**
         * Creates a new pb_benemy instance using the specified properties.
         * @function create
         * @memberof pb_benemy
         * @static
         * @param {Ipb_benemy=} [properties] Properties to set
         * @returns {pb_benemy} pb_benemy instance
         */
        pb_benemy.create = function create(properties) {
            return new pb_benemy(properties);
        };
    
        /**
         * Encodes the specified pb_benemy message. Does not implicitly {@link pb_benemy.verify|verify} messages.
         * @function encode
         * @memberof pb_benemy
         * @static
         * @param {Ipb_benemy} message pb_benemy message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_benemy.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.logo);
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.lv);
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.name);
            writer.uint32(/* id 4, wireType 0 =*/32).int64(message.power);
            writer.uint32(/* id 5, wireType 0 =*/40).int32(message.sid);
            if (message.camp != null && message.camp.length)
                for (var i = 0; i < message.camp.length; ++i)
                    $root.pb_bunit.encode(message.camp[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.border != null && Object.hasOwnProperty.call(message, "border"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.border);
            return writer;
        };
    
        /**
         * Encodes the specified pb_benemy message, length delimited. Does not implicitly {@link pb_benemy.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_benemy
         * @static
         * @param {Ipb_benemy} message pb_benemy message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_benemy.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_benemy message from the specified reader or buffer.
         * @function decode
         * @memberof pb_benemy
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_benemy} pb_benemy
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_benemy.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_benemy();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.logo = reader.int32();
                        break;
                    }
                case 2: {
                        message.lv = reader.int32();
                        break;
                    }
                case 3: {
                        message.name = reader.string();
                        break;
                    }
                case 4: {
                        message.power = reader.int64();
                        break;
                    }
                case 5: {
                        message.sid = reader.int32();
                        break;
                    }
                case 6: {
                        if (!(message.camp && message.camp.length))
                            message.camp = [];
                        message.camp.push($root.pb_bunit.decode(reader, reader.uint32()));
                        break;
                    }
                case 7: {
                        message.border = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("logo"))
                throw $util.ProtocolError("missing required 'logo'", { instance: message });
            if (!message.hasOwnProperty("lv"))
                throw $util.ProtocolError("missing required 'lv'", { instance: message });
            if (!message.hasOwnProperty("name"))
                throw $util.ProtocolError("missing required 'name'", { instance: message });
            if (!message.hasOwnProperty("power"))
                throw $util.ProtocolError("missing required 'power'", { instance: message });
            if (!message.hasOwnProperty("sid"))
                throw $util.ProtocolError("missing required 'sid'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a pb_benemy message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_benemy
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_benemy} pb_benemy
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_benemy.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_benemy message.
         * @function verify
         * @memberof pb_benemy
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_benemy.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.logo))
                return "logo: integer expected";
            if (!$util.isInteger(message.lv))
                return "lv: integer expected";
            if (!$util.isString(message.name))
                return "name: string expected";
            if (!$util.isInteger(message.power) && !(message.power && $util.isInteger(message.power.low) && $util.isInteger(message.power.high)))
                return "power: integer|Long expected";
            if (!$util.isInteger(message.sid))
                return "sid: integer expected";
            if (message.camp != null && message.hasOwnProperty("camp")) {
                if (!Array.isArray(message.camp))
                    return "camp: array expected";
                for (var i = 0; i < message.camp.length; ++i) {
                    var error = $root.pb_bunit.verify(message.camp[i]);
                    if (error)
                        return "camp." + error;
                }
            }
            if (message.border != null && message.hasOwnProperty("border"))
                if (!$util.isInteger(message.border))
                    return "border: integer expected";
            return null;
        };
    
        /**
         * Creates a pb_benemy message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_benemy
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_benemy} pb_benemy
         */
        pb_benemy.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_benemy)
                return object;
            var message = new $root.pb_benemy();
            if (object.logo != null)
                message.logo = object.logo | 0;
            if (object.lv != null)
                message.lv = object.lv | 0;
            if (object.name != null)
                message.name = String(object.name);
            if (object.power != null)
                if ($util.Long)
                    (message.power = $util.Long.fromValue(object.power)).unsigned = false;
                else if (typeof object.power === "string")
                    message.power = parseInt(object.power, 10);
                else if (typeof object.power === "number")
                    message.power = object.power;
                else if (typeof object.power === "object")
                    message.power = new $util.LongBits(object.power.low >>> 0, object.power.high >>> 0).toNumber();
            if (object.sid != null)
                message.sid = object.sid | 0;
            if (object.camp) {
                if (!Array.isArray(object.camp))
                    throw TypeError(".pb_benemy.camp: array expected");
                message.camp = [];
                for (var i = 0; i < object.camp.length; ++i) {
                    if (typeof object.camp[i] !== "object")
                        throw TypeError(".pb_benemy.camp: object expected");
                    message.camp[i] = $root.pb_bunit.fromObject(object.camp[i]);
                }
            }
            if (object.border != null)
                message.border = object.border | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a pb_benemy message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_benemy
         * @static
         * @param {pb_benemy} message pb_benemy
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_benemy.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.camp = [];
            if (options.defaults) {
                object.logo = 0;
                object.lv = 0;
                object.name = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.power = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.power = options.longs === String ? "0" : 0;
                object.sid = 0;
                object.border = 0;
            }
            if (message.logo != null && message.hasOwnProperty("logo"))
                object.logo = message.logo;
            if (message.lv != null && message.hasOwnProperty("lv"))
                object.lv = message.lv;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.power != null && message.hasOwnProperty("power"))
                if (typeof message.power === "number")
                    object.power = options.longs === String ? String(message.power) : message.power;
                else
                    object.power = options.longs === String ? $util.Long.prototype.toString.call(message.power) : options.longs === Number ? new $util.LongBits(message.power.low >>> 0, message.power.high >>> 0).toNumber() : message.power;
            if (message.sid != null && message.hasOwnProperty("sid"))
                object.sid = message.sid;
            if (message.camp && message.camp.length) {
                object.camp = [];
                for (var j = 0; j < message.camp.length; ++j)
                    object.camp[j] = $root.pb_bunit.toObject(message.camp[j], options);
            }
            if (message.border != null && message.hasOwnProperty("border"))
                object.border = message.border;
            return object;
        };
    
        /**
         * Converts this pb_benemy to JSON.
         * @function toJSON
         * @memberof pb_benemy
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_benemy.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_benemy
         * @function getTypeUrl
         * @memberof pb_benemy
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_benemy.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_benemy";
        };
    
        return pb_benemy;
    })();
    
    $root.pb_ngwshold = (function() {
    
        /**
         * Properties of a pb_ngwshold.
         * @exports Ipb_ngwshold
         * @interface Ipb_ngwshold
         * @property {number|null} [left] pb_ngwshold left
         * @property {number|null} [total] pb_ngwshold total
         * @property {Array.<Ipb_ngwbuff>|null} [buffs] pb_ngwshold buffs
         * @property {number|Long|null} [power] pb_ngwshold power
         */
    
        /**
         * Constructs a new pb_ngwshold.
         * @exports pb_ngwshold
         * @classdesc Represents a pb_ngwshold.
         * @implements Ipb_ngwshold
         * @constructor
         * @param {Ipb_ngwshold=} [properties] Properties to set
         */
        function pb_ngwshold(properties) {
            this.buffs = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_ngwshold left.
         * @member {number} left
         * @memberof pb_ngwshold
         * @instance
         */
        pb_ngwshold.prototype.left = 0;
    
        /**
         * pb_ngwshold total.
         * @member {number} total
         * @memberof pb_ngwshold
         * @instance
         */
        pb_ngwshold.prototype.total = 0;
    
        /**
         * pb_ngwshold buffs.
         * @member {Array.<Ipb_ngwbuff>} buffs
         * @memberof pb_ngwshold
         * @instance
         */
        pb_ngwshold.prototype.buffs = $util.emptyArray;
    
        /**
         * pb_ngwshold power.
         * @member {number|Long} power
         * @memberof pb_ngwshold
         * @instance
         */
        pb_ngwshold.prototype.power = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * Creates a new pb_ngwshold instance using the specified properties.
         * @function create
         * @memberof pb_ngwshold
         * @static
         * @param {Ipb_ngwshold=} [properties] Properties to set
         * @returns {pb_ngwshold} pb_ngwshold instance
         */
        pb_ngwshold.create = function create(properties) {
            return new pb_ngwshold(properties);
        };
    
        /**
         * Encodes the specified pb_ngwshold message. Does not implicitly {@link pb_ngwshold.verify|verify} messages.
         * @function encode
         * @memberof pb_ngwshold
         * @static
         * @param {Ipb_ngwshold} message pb_ngwshold message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_ngwshold.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.left != null && Object.hasOwnProperty.call(message, "left"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.left);
            if (message.total != null && Object.hasOwnProperty.call(message, "total"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.total);
            if (message.buffs != null && message.buffs.length)
                for (var i = 0; i < message.buffs.length; ++i)
                    $root.pb_ngwbuff.encode(message.buffs[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.power != null && Object.hasOwnProperty.call(message, "power"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.power);
            return writer;
        };
    
        /**
         * Encodes the specified pb_ngwshold message, length delimited. Does not implicitly {@link pb_ngwshold.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_ngwshold
         * @static
         * @param {Ipb_ngwshold} message pb_ngwshold message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_ngwshold.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_ngwshold message from the specified reader or buffer.
         * @function decode
         * @memberof pb_ngwshold
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_ngwshold} pb_ngwshold
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_ngwshold.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_ngwshold();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.left = reader.int32();
                        break;
                    }
                case 2: {
                        message.total = reader.int32();
                        break;
                    }
                case 3: {
                        if (!(message.buffs && message.buffs.length))
                            message.buffs = [];
                        message.buffs.push($root.pb_ngwbuff.decode(reader, reader.uint32()));
                        break;
                    }
                case 4: {
                        message.power = reader.int64();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a pb_ngwshold message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_ngwshold
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_ngwshold} pb_ngwshold
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_ngwshold.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_ngwshold message.
         * @function verify
         * @memberof pb_ngwshold
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_ngwshold.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.left != null && message.hasOwnProperty("left"))
                if (!$util.isInteger(message.left))
                    return "left: integer expected";
            if (message.total != null && message.hasOwnProperty("total"))
                if (!$util.isInteger(message.total))
                    return "total: integer expected";
            if (message.buffs != null && message.hasOwnProperty("buffs")) {
                if (!Array.isArray(message.buffs))
                    return "buffs: array expected";
                for (var i = 0; i < message.buffs.length; ++i) {
                    var error = $root.pb_ngwbuff.verify(message.buffs[i]);
                    if (error)
                        return "buffs." + error;
                }
            }
            if (message.power != null && message.hasOwnProperty("power"))
                if (!$util.isInteger(message.power) && !(message.power && $util.isInteger(message.power.low) && $util.isInteger(message.power.high)))
                    return "power: integer|Long expected";
            return null;
        };
    
        /**
         * Creates a pb_ngwshold message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_ngwshold
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_ngwshold} pb_ngwshold
         */
        pb_ngwshold.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_ngwshold)
                return object;
            var message = new $root.pb_ngwshold();
            if (object.left != null)
                message.left = object.left | 0;
            if (object.total != null)
                message.total = object.total | 0;
            if (object.buffs) {
                if (!Array.isArray(object.buffs))
                    throw TypeError(".pb_ngwshold.buffs: array expected");
                message.buffs = [];
                for (var i = 0; i < object.buffs.length; ++i) {
                    if (typeof object.buffs[i] !== "object")
                        throw TypeError(".pb_ngwshold.buffs: object expected");
                    message.buffs[i] = $root.pb_ngwbuff.fromObject(object.buffs[i]);
                }
            }
            if (object.power != null)
                if ($util.Long)
                    (message.power = $util.Long.fromValue(object.power)).unsigned = false;
                else if (typeof object.power === "string")
                    message.power = parseInt(object.power, 10);
                else if (typeof object.power === "number")
                    message.power = object.power;
                else if (typeof object.power === "object")
                    message.power = new $util.LongBits(object.power.low >>> 0, object.power.high >>> 0).toNumber();
            return message;
        };
    
        /**
         * Creates a plain object from a pb_ngwshold message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_ngwshold
         * @static
         * @param {pb_ngwshold} message pb_ngwshold
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_ngwshold.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.buffs = [];
            if (options.defaults) {
                object.left = 0;
                object.total = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.power = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.power = options.longs === String ? "0" : 0;
            }
            if (message.left != null && message.hasOwnProperty("left"))
                object.left = message.left;
            if (message.total != null && message.hasOwnProperty("total"))
                object.total = message.total;
            if (message.buffs && message.buffs.length) {
                object.buffs = [];
                for (var j = 0; j < message.buffs.length; ++j)
                    object.buffs[j] = $root.pb_ngwbuff.toObject(message.buffs[j], options);
            }
            if (message.power != null && message.hasOwnProperty("power"))
                if (typeof message.power === "number")
                    object.power = options.longs === String ? String(message.power) : message.power;
                else
                    object.power = options.longs === String ? $util.Long.prototype.toString.call(message.power) : options.longs === Number ? new $util.LongBits(message.power.low >>> 0, message.power.high >>> 0).toNumber() : message.power;
            return object;
        };
    
        /**
         * Converts this pb_ngwshold to JSON.
         * @function toJSON
         * @memberof pb_ngwshold
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_ngwshold.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_ngwshold
         * @function getTypeUrl
         * @memberof pb_ngwshold
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_ngwshold.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_ngwshold";
        };
    
        return pb_ngwshold;
    })();
    
    $root.pb_ngwrank = (function() {
    
        /**
         * Properties of a pb_ngwrank.
         * @exports Ipb_ngwrank
         * @interface Ipb_ngwrank
         * @property {number|null} [gid] pb_ngwrank gid
         * @property {number|null} [score] pb_ngwrank score
         * @property {number|null} [seg] pb_ngwrank seg
         * @property {number|null} [time] pb_ngwrank time
         * @property {number|null} [logo] pb_ngwrank logo
         * @property {string|null} [name] pb_ngwrank name
         * @property {number|Long|null} [power] pb_ngwrank power
         */
    
        /**
         * Constructs a new pb_ngwrank.
         * @exports pb_ngwrank
         * @classdesc Represents a pb_ngwrank.
         * @implements Ipb_ngwrank
         * @constructor
         * @param {Ipb_ngwrank=} [properties] Properties to set
         */
        function pb_ngwrank(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_ngwrank gid.
         * @member {number} gid
         * @memberof pb_ngwrank
         * @instance
         */
        pb_ngwrank.prototype.gid = 0;
    
        /**
         * pb_ngwrank score.
         * @member {number} score
         * @memberof pb_ngwrank
         * @instance
         */
        pb_ngwrank.prototype.score = 0;
    
        /**
         * pb_ngwrank seg.
         * @member {number} seg
         * @memberof pb_ngwrank
         * @instance
         */
        pb_ngwrank.prototype.seg = 0;
    
        /**
         * pb_ngwrank time.
         * @member {number} time
         * @memberof pb_ngwrank
         * @instance
         */
        pb_ngwrank.prototype.time = 0;
    
        /**
         * pb_ngwrank logo.
         * @member {number} logo
         * @memberof pb_ngwrank
         * @instance
         */
        pb_ngwrank.prototype.logo = 0;
    
        /**
         * pb_ngwrank name.
         * @member {string} name
         * @memberof pb_ngwrank
         * @instance
         */
        pb_ngwrank.prototype.name = "";
    
        /**
         * pb_ngwrank power.
         * @member {number|Long} power
         * @memberof pb_ngwrank
         * @instance
         */
        pb_ngwrank.prototype.power = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * Creates a new pb_ngwrank instance using the specified properties.
         * @function create
         * @memberof pb_ngwrank
         * @static
         * @param {Ipb_ngwrank=} [properties] Properties to set
         * @returns {pb_ngwrank} pb_ngwrank instance
         */
        pb_ngwrank.create = function create(properties) {
            return new pb_ngwrank(properties);
        };
    
        /**
         * Encodes the specified pb_ngwrank message. Does not implicitly {@link pb_ngwrank.verify|verify} messages.
         * @function encode
         * @memberof pb_ngwrank
         * @static
         * @param {Ipb_ngwrank} message pb_ngwrank message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_ngwrank.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.gid != null && Object.hasOwnProperty.call(message, "gid"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.gid);
            if (message.score != null && Object.hasOwnProperty.call(message, "score"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.score);
            if (message.seg != null && Object.hasOwnProperty.call(message, "seg"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.seg);
            if (message.time != null && Object.hasOwnProperty.call(message, "time"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.time);
            if (message.logo != null && Object.hasOwnProperty.call(message, "logo"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.logo);
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.name);
            if (message.power != null && Object.hasOwnProperty.call(message, "power"))
                writer.uint32(/* id 7, wireType 0 =*/56).int64(message.power);
            return writer;
        };
    
        /**
         * Encodes the specified pb_ngwrank message, length delimited. Does not implicitly {@link pb_ngwrank.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_ngwrank
         * @static
         * @param {Ipb_ngwrank} message pb_ngwrank message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_ngwrank.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_ngwrank message from the specified reader or buffer.
         * @function decode
         * @memberof pb_ngwrank
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_ngwrank} pb_ngwrank
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_ngwrank.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_ngwrank();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.gid = reader.int32();
                        break;
                    }
                case 2: {
                        message.score = reader.int32();
                        break;
                    }
                case 3: {
                        message.seg = reader.int32();
                        break;
                    }
                case 4: {
                        message.time = reader.int32();
                        break;
                    }
                case 5: {
                        message.logo = reader.int32();
                        break;
                    }
                case 6: {
                        message.name = reader.string();
                        break;
                    }
                case 7: {
                        message.power = reader.int64();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a pb_ngwrank message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_ngwrank
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_ngwrank} pb_ngwrank
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_ngwrank.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_ngwrank message.
         * @function verify
         * @memberof pb_ngwrank
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_ngwrank.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.gid != null && message.hasOwnProperty("gid"))
                if (!$util.isInteger(message.gid))
                    return "gid: integer expected";
            if (message.score != null && message.hasOwnProperty("score"))
                if (!$util.isInteger(message.score))
                    return "score: integer expected";
            if (message.seg != null && message.hasOwnProperty("seg"))
                if (!$util.isInteger(message.seg))
                    return "seg: integer expected";
            if (message.time != null && message.hasOwnProperty("time"))
                if (!$util.isInteger(message.time))
                    return "time: integer expected";
            if (message.logo != null && message.hasOwnProperty("logo"))
                if (!$util.isInteger(message.logo))
                    return "logo: integer expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.power != null && message.hasOwnProperty("power"))
                if (!$util.isInteger(message.power) && !(message.power && $util.isInteger(message.power.low) && $util.isInteger(message.power.high)))
                    return "power: integer|Long expected";
            return null;
        };
    
        /**
         * Creates a pb_ngwrank message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_ngwrank
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_ngwrank} pb_ngwrank
         */
        pb_ngwrank.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_ngwrank)
                return object;
            var message = new $root.pb_ngwrank();
            if (object.gid != null)
                message.gid = object.gid | 0;
            if (object.score != null)
                message.score = object.score | 0;
            if (object.seg != null)
                message.seg = object.seg | 0;
            if (object.time != null)
                message.time = object.time | 0;
            if (object.logo != null)
                message.logo = object.logo | 0;
            if (object.name != null)
                message.name = String(object.name);
            if (object.power != null)
                if ($util.Long)
                    (message.power = $util.Long.fromValue(object.power)).unsigned = false;
                else if (typeof object.power === "string")
                    message.power = parseInt(object.power, 10);
                else if (typeof object.power === "number")
                    message.power = object.power;
                else if (typeof object.power === "object")
                    message.power = new $util.LongBits(object.power.low >>> 0, object.power.high >>> 0).toNumber();
            return message;
        };
    
        /**
         * Creates a plain object from a pb_ngwrank message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_ngwrank
         * @static
         * @param {pb_ngwrank} message pb_ngwrank
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_ngwrank.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.gid = 0;
                object.score = 0;
                object.seg = 0;
                object.time = 0;
                object.logo = 0;
                object.name = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.power = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.power = options.longs === String ? "0" : 0;
            }
            if (message.gid != null && message.hasOwnProperty("gid"))
                object.gid = message.gid;
            if (message.score != null && message.hasOwnProperty("score"))
                object.score = message.score;
            if (message.seg != null && message.hasOwnProperty("seg"))
                object.seg = message.seg;
            if (message.time != null && message.hasOwnProperty("time"))
                object.time = message.time;
            if (message.logo != null && message.hasOwnProperty("logo"))
                object.logo = message.logo;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.power != null && message.hasOwnProperty("power"))
                if (typeof message.power === "number")
                    object.power = options.longs === String ? String(message.power) : message.power;
                else
                    object.power = options.longs === String ? $util.Long.prototype.toString.call(message.power) : options.longs === Number ? new $util.LongBits(message.power.low >>> 0, message.power.high >>> 0).toNumber() : message.power;
            return object;
        };
    
        /**
         * Converts this pb_ngwrank to JSON.
         * @function toJSON
         * @memberof pb_ngwrank
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_ngwrank.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_ngwrank
         * @function getTypeUrl
         * @memberof pb_ngwrank
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_ngwrank.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_ngwrank";
        };
    
        return pb_ngwrank;
    })();
    
    $root.pb_ngwprank = (function() {
    
        /**
         * Properties of a pb_ngwprank.
         * @exports Ipb_ngwprank
         * @interface Ipb_ngwprank
         * @property {number|Long|null} [uid] pb_ngwprank uid
         * @property {string|null} [name] pb_ngwprank name
         * @property {number|null} [lv] pb_ngwprank lv
         * @property {number|null} [logo] pb_ngwprank logo
         * @property {number|null} [lbox] pb_ngwprank lbox
         * @property {string|null} [gname] pb_ngwprank gname
         * @property {number|null} [score] pb_ngwprank score
         * @property {number|null} [time] pb_ngwprank time
         * @property {number|Long|null} [power] pb_ngwprank power
         * @property {Array.<number>|null} [daily] pb_ngwprank daily
         */
    
        /**
         * Constructs a new pb_ngwprank.
         * @exports pb_ngwprank
         * @classdesc Represents a pb_ngwprank.
         * @implements Ipb_ngwprank
         * @constructor
         * @param {Ipb_ngwprank=} [properties] Properties to set
         */
        function pb_ngwprank(properties) {
            this.daily = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_ngwprank uid.
         * @member {number|Long} uid
         * @memberof pb_ngwprank
         * @instance
         */
        pb_ngwprank.prototype.uid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * pb_ngwprank name.
         * @member {string} name
         * @memberof pb_ngwprank
         * @instance
         */
        pb_ngwprank.prototype.name = "";
    
        /**
         * pb_ngwprank lv.
         * @member {number} lv
         * @memberof pb_ngwprank
         * @instance
         */
        pb_ngwprank.prototype.lv = 0;
    
        /**
         * pb_ngwprank logo.
         * @member {number} logo
         * @memberof pb_ngwprank
         * @instance
         */
        pb_ngwprank.prototype.logo = 0;
    
        /**
         * pb_ngwprank lbox.
         * @member {number} lbox
         * @memberof pb_ngwprank
         * @instance
         */
        pb_ngwprank.prototype.lbox = 0;
    
        /**
         * pb_ngwprank gname.
         * @member {string} gname
         * @memberof pb_ngwprank
         * @instance
         */
        pb_ngwprank.prototype.gname = "";
    
        /**
         * pb_ngwprank score.
         * @member {number} score
         * @memberof pb_ngwprank
         * @instance
         */
        pb_ngwprank.prototype.score = 0;
    
        /**
         * pb_ngwprank time.
         * @member {number} time
         * @memberof pb_ngwprank
         * @instance
         */
        pb_ngwprank.prototype.time = 0;
    
        /**
         * pb_ngwprank power.
         * @member {number|Long} power
         * @memberof pb_ngwprank
         * @instance
         */
        pb_ngwprank.prototype.power = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * pb_ngwprank daily.
         * @member {Array.<number>} daily
         * @memberof pb_ngwprank
         * @instance
         */
        pb_ngwprank.prototype.daily = $util.emptyArray;
    
        /**
         * Creates a new pb_ngwprank instance using the specified properties.
         * @function create
         * @memberof pb_ngwprank
         * @static
         * @param {Ipb_ngwprank=} [properties] Properties to set
         * @returns {pb_ngwprank} pb_ngwprank instance
         */
        pb_ngwprank.create = function create(properties) {
            return new pb_ngwprank(properties);
        };
    
        /**
         * Encodes the specified pb_ngwprank message. Does not implicitly {@link pb_ngwprank.verify|verify} messages.
         * @function encode
         * @memberof pb_ngwprank
         * @static
         * @param {Ipb_ngwprank} message pb_ngwprank message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_ngwprank.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.uid != null && Object.hasOwnProperty.call(message, "uid"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.uid);
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
            if (message.lv != null && Object.hasOwnProperty.call(message, "lv"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.lv);
            if (message.logo != null && Object.hasOwnProperty.call(message, "logo"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.logo);
            if (message.lbox != null && Object.hasOwnProperty.call(message, "lbox"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.lbox);
            if (message.gname != null && Object.hasOwnProperty.call(message, "gname"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.gname);
            if (message.score != null && Object.hasOwnProperty.call(message, "score"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.score);
            if (message.time != null && Object.hasOwnProperty.call(message, "time"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.time);
            if (message.power != null && Object.hasOwnProperty.call(message, "power"))
                writer.uint32(/* id 9, wireType 0 =*/72).int64(message.power);
            if (message.daily != null && message.daily.length)
                for (var i = 0; i < message.daily.length; ++i)
                    writer.uint32(/* id 10, wireType 0 =*/80).int32(message.daily[i]);
            return writer;
        };
    
        /**
         * Encodes the specified pb_ngwprank message, length delimited. Does not implicitly {@link pb_ngwprank.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_ngwprank
         * @static
         * @param {Ipb_ngwprank} message pb_ngwprank message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_ngwprank.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_ngwprank message from the specified reader or buffer.
         * @function decode
         * @memberof pb_ngwprank
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_ngwprank} pb_ngwprank
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_ngwprank.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_ngwprank();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.uid = reader.int64();
                        break;
                    }
                case 2: {
                        message.name = reader.string();
                        break;
                    }
                case 3: {
                        message.lv = reader.int32();
                        break;
                    }
                case 4: {
                        message.logo = reader.int32();
                        break;
                    }
                case 5: {
                        message.lbox = reader.int32();
                        break;
                    }
                case 6: {
                        message.gname = reader.string();
                        break;
                    }
                case 7: {
                        message.score = reader.int32();
                        break;
                    }
                case 8: {
                        message.time = reader.int32();
                        break;
                    }
                case 9: {
                        message.power = reader.int64();
                        break;
                    }
                case 10: {
                        if (!(message.daily && message.daily.length))
                            message.daily = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.daily.push(reader.int32());
                        } else
                            message.daily.push(reader.int32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a pb_ngwprank message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_ngwprank
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_ngwprank} pb_ngwprank
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_ngwprank.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_ngwprank message.
         * @function verify
         * @memberof pb_ngwprank
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_ngwprank.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (!$util.isInteger(message.uid) && !(message.uid && $util.isInteger(message.uid.low) && $util.isInteger(message.uid.high)))
                    return "uid: integer|Long expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.lv != null && message.hasOwnProperty("lv"))
                if (!$util.isInteger(message.lv))
                    return "lv: integer expected";
            if (message.logo != null && message.hasOwnProperty("logo"))
                if (!$util.isInteger(message.logo))
                    return "logo: integer expected";
            if (message.lbox != null && message.hasOwnProperty("lbox"))
                if (!$util.isInteger(message.lbox))
                    return "lbox: integer expected";
            if (message.gname != null && message.hasOwnProperty("gname"))
                if (!$util.isString(message.gname))
                    return "gname: string expected";
            if (message.score != null && message.hasOwnProperty("score"))
                if (!$util.isInteger(message.score))
                    return "score: integer expected";
            if (message.time != null && message.hasOwnProperty("time"))
                if (!$util.isInteger(message.time))
                    return "time: integer expected";
            if (message.power != null && message.hasOwnProperty("power"))
                if (!$util.isInteger(message.power) && !(message.power && $util.isInteger(message.power.low) && $util.isInteger(message.power.high)))
                    return "power: integer|Long expected";
            if (message.daily != null && message.hasOwnProperty("daily")) {
                if (!Array.isArray(message.daily))
                    return "daily: array expected";
                for (var i = 0; i < message.daily.length; ++i)
                    if (!$util.isInteger(message.daily[i]))
                        return "daily: integer[] expected";
            }
            return null;
        };
    
        /**
         * Creates a pb_ngwprank message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_ngwprank
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_ngwprank} pb_ngwprank
         */
        pb_ngwprank.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_ngwprank)
                return object;
            var message = new $root.pb_ngwprank();
            if (object.uid != null)
                if ($util.Long)
                    (message.uid = $util.Long.fromValue(object.uid)).unsigned = false;
                else if (typeof object.uid === "string")
                    message.uid = parseInt(object.uid, 10);
                else if (typeof object.uid === "number")
                    message.uid = object.uid;
                else if (typeof object.uid === "object")
                    message.uid = new $util.LongBits(object.uid.low >>> 0, object.uid.high >>> 0).toNumber();
            if (object.name != null)
                message.name = String(object.name);
            if (object.lv != null)
                message.lv = object.lv | 0;
            if (object.logo != null)
                message.logo = object.logo | 0;
            if (object.lbox != null)
                message.lbox = object.lbox | 0;
            if (object.gname != null)
                message.gname = String(object.gname);
            if (object.score != null)
                message.score = object.score | 0;
            if (object.time != null)
                message.time = object.time | 0;
            if (object.power != null)
                if ($util.Long)
                    (message.power = $util.Long.fromValue(object.power)).unsigned = false;
                else if (typeof object.power === "string")
                    message.power = parseInt(object.power, 10);
                else if (typeof object.power === "number")
                    message.power = object.power;
                else if (typeof object.power === "object")
                    message.power = new $util.LongBits(object.power.low >>> 0, object.power.high >>> 0).toNumber();
            if (object.daily) {
                if (!Array.isArray(object.daily))
                    throw TypeError(".pb_ngwprank.daily: array expected");
                message.daily = [];
                for (var i = 0; i < object.daily.length; ++i)
                    message.daily[i] = object.daily[i] | 0;
            }
            return message;
        };
    
        /**
         * Creates a plain object from a pb_ngwprank message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_ngwprank
         * @static
         * @param {pb_ngwprank} message pb_ngwprank
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_ngwprank.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.daily = [];
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.uid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.uid = options.longs === String ? "0" : 0;
                object.name = "";
                object.lv = 0;
                object.logo = 0;
                object.lbox = 0;
                object.gname = "";
                object.score = 0;
                object.time = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.power = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.power = options.longs === String ? "0" : 0;
            }
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (typeof message.uid === "number")
                    object.uid = options.longs === String ? String(message.uid) : message.uid;
                else
                    object.uid = options.longs === String ? $util.Long.prototype.toString.call(message.uid) : options.longs === Number ? new $util.LongBits(message.uid.low >>> 0, message.uid.high >>> 0).toNumber() : message.uid;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.lv != null && message.hasOwnProperty("lv"))
                object.lv = message.lv;
            if (message.logo != null && message.hasOwnProperty("logo"))
                object.logo = message.logo;
            if (message.lbox != null && message.hasOwnProperty("lbox"))
                object.lbox = message.lbox;
            if (message.gname != null && message.hasOwnProperty("gname"))
                object.gname = message.gname;
            if (message.score != null && message.hasOwnProperty("score"))
                object.score = message.score;
            if (message.time != null && message.hasOwnProperty("time"))
                object.time = message.time;
            if (message.power != null && message.hasOwnProperty("power"))
                if (typeof message.power === "number")
                    object.power = options.longs === String ? String(message.power) : message.power;
                else
                    object.power = options.longs === String ? $util.Long.prototype.toString.call(message.power) : options.longs === Number ? new $util.LongBits(message.power.low >>> 0, message.power.high >>> 0).toNumber() : message.power;
            if (message.daily && message.daily.length) {
                object.daily = [];
                for (var j = 0; j < message.daily.length; ++j)
                    object.daily[j] = message.daily[j];
            }
            return object;
        };
    
        /**
         * Converts this pb_ngwprank to JSON.
         * @function toJSON
         * @memberof pb_ngwprank
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_ngwprank.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_ngwprank
         * @function getTypeUrl
         * @memberof pb_ngwprank
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_ngwprank.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_ngwprank";
        };
    
        return pb_ngwprank;
    })();
    
    $root.pb_ngwbuff = (function() {
    
        /**
         * Properties of a pb_ngwbuff.
         * @exports Ipb_ngwbuff
         * @interface Ipb_ngwbuff
         * @property {number|null} [id] pb_ngwbuff id
         * @property {number|null} [num] pb_ngwbuff num
         */
    
        /**
         * Constructs a new pb_ngwbuff.
         * @exports pb_ngwbuff
         * @classdesc Represents a pb_ngwbuff.
         * @implements Ipb_ngwbuff
         * @constructor
         * @param {Ipb_ngwbuff=} [properties] Properties to set
         */
        function pb_ngwbuff(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_ngwbuff id.
         * @member {number} id
         * @memberof pb_ngwbuff
         * @instance
         */
        pb_ngwbuff.prototype.id = 0;
    
        /**
         * pb_ngwbuff num.
         * @member {number} num
         * @memberof pb_ngwbuff
         * @instance
         */
        pb_ngwbuff.prototype.num = 0;
    
        /**
         * Creates a new pb_ngwbuff instance using the specified properties.
         * @function create
         * @memberof pb_ngwbuff
         * @static
         * @param {Ipb_ngwbuff=} [properties] Properties to set
         * @returns {pb_ngwbuff} pb_ngwbuff instance
         */
        pb_ngwbuff.create = function create(properties) {
            return new pb_ngwbuff(properties);
        };
    
        /**
         * Encodes the specified pb_ngwbuff message. Does not implicitly {@link pb_ngwbuff.verify|verify} messages.
         * @function encode
         * @memberof pb_ngwbuff
         * @static
         * @param {Ipb_ngwbuff} message pb_ngwbuff message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_ngwbuff.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.id);
            if (message.num != null && Object.hasOwnProperty.call(message, "num"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.num);
            return writer;
        };
    
        /**
         * Encodes the specified pb_ngwbuff message, length delimited. Does not implicitly {@link pb_ngwbuff.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_ngwbuff
         * @static
         * @param {Ipb_ngwbuff} message pb_ngwbuff message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_ngwbuff.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_ngwbuff message from the specified reader or buffer.
         * @function decode
         * @memberof pb_ngwbuff
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_ngwbuff} pb_ngwbuff
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_ngwbuff.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_ngwbuff();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.id = reader.int32();
                        break;
                    }
                case 2: {
                        message.num = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a pb_ngwbuff message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_ngwbuff
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_ngwbuff} pb_ngwbuff
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_ngwbuff.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_ngwbuff message.
         * @function verify
         * @memberof pb_ngwbuff
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_ngwbuff.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id))
                    return "id: integer expected";
            if (message.num != null && message.hasOwnProperty("num"))
                if (!$util.isInteger(message.num))
                    return "num: integer expected";
            return null;
        };
    
        /**
         * Creates a pb_ngwbuff message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_ngwbuff
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_ngwbuff} pb_ngwbuff
         */
        pb_ngwbuff.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_ngwbuff)
                return object;
            var message = new $root.pb_ngwbuff();
            if (object.id != null)
                message.id = object.id | 0;
            if (object.num != null)
                message.num = object.num | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a pb_ngwbuff message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_ngwbuff
         * @static
         * @param {pb_ngwbuff} message pb_ngwbuff
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_ngwbuff.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = 0;
                object.num = 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.num != null && message.hasOwnProperty("num"))
                object.num = message.num;
            return object;
        };
    
        /**
         * Converts this pb_ngwbuff to JSON.
         * @function toJSON
         * @memberof pb_ngwbuff
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_ngwbuff.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_ngwbuff
         * @function getTypeUrl
         * @memberof pb_ngwbuff
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_ngwbuff.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_ngwbuff";
        };
    
        return pb_ngwbuff;
    })();
    
    $root.pb_ngwmbr = (function() {
    
        /**
         * Properties of a pb_ngwmbr.
         * @exports Ipb_ngwmbr
         * @interface Ipb_ngwmbr
         * @property {number|null} [idx] pb_ngwmbr idx
         * @property {number|null} [logo] pb_ngwmbr logo
         * @property {string|null} [gname] pb_ngwmbr gname
         * @property {number|Long|null} [power] pb_ngwmbr power
         * @property {number|null} [lv] pb_ngwmbr lv
         * @property {number|null} [lbox] pb_ngwmbr lbox
         * @property {Array.<Ipb_unit>|null} [unit] pb_ngwmbr unit
         * @property {number|Long|null} [uid] pb_ngwmbr uid
         * @property {number|null} [gid] pb_ngwmbr gid
         * @property {number|null} [win] pb_ngwmbr win
         */
    
        /**
         * Constructs a new pb_ngwmbr.
         * @exports pb_ngwmbr
         * @classdesc Represents a pb_ngwmbr.
         * @implements Ipb_ngwmbr
         * @constructor
         * @param {Ipb_ngwmbr=} [properties] Properties to set
         */
        function pb_ngwmbr(properties) {
            this.unit = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_ngwmbr idx.
         * @member {number} idx
         * @memberof pb_ngwmbr
         * @instance
         */
        pb_ngwmbr.prototype.idx = 0;
    
        /**
         * pb_ngwmbr logo.
         * @member {number} logo
         * @memberof pb_ngwmbr
         * @instance
         */
        pb_ngwmbr.prototype.logo = 0;
    
        /**
         * pb_ngwmbr gname.
         * @member {string} gname
         * @memberof pb_ngwmbr
         * @instance
         */
        pb_ngwmbr.prototype.gname = "";
    
        /**
         * pb_ngwmbr power.
         * @member {number|Long} power
         * @memberof pb_ngwmbr
         * @instance
         */
        pb_ngwmbr.prototype.power = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * pb_ngwmbr lv.
         * @member {number} lv
         * @memberof pb_ngwmbr
         * @instance
         */
        pb_ngwmbr.prototype.lv = 0;
    
        /**
         * pb_ngwmbr lbox.
         * @member {number} lbox
         * @memberof pb_ngwmbr
         * @instance
         */
        pb_ngwmbr.prototype.lbox = 0;
    
        /**
         * pb_ngwmbr unit.
         * @member {Array.<Ipb_unit>} unit
         * @memberof pb_ngwmbr
         * @instance
         */
        pb_ngwmbr.prototype.unit = $util.emptyArray;
    
        /**
         * pb_ngwmbr uid.
         * @member {number|Long} uid
         * @memberof pb_ngwmbr
         * @instance
         */
        pb_ngwmbr.prototype.uid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * pb_ngwmbr gid.
         * @member {number} gid
         * @memberof pb_ngwmbr
         * @instance
         */
        pb_ngwmbr.prototype.gid = 0;
    
        /**
         * pb_ngwmbr win.
         * @member {number} win
         * @memberof pb_ngwmbr
         * @instance
         */
        pb_ngwmbr.prototype.win = 0;
    
        /**
         * Creates a new pb_ngwmbr instance using the specified properties.
         * @function create
         * @memberof pb_ngwmbr
         * @static
         * @param {Ipb_ngwmbr=} [properties] Properties to set
         * @returns {pb_ngwmbr} pb_ngwmbr instance
         */
        pb_ngwmbr.create = function create(properties) {
            return new pb_ngwmbr(properties);
        };
    
        /**
         * Encodes the specified pb_ngwmbr message. Does not implicitly {@link pb_ngwmbr.verify|verify} messages.
         * @function encode
         * @memberof pb_ngwmbr
         * @static
         * @param {Ipb_ngwmbr} message pb_ngwmbr message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_ngwmbr.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.idx != null && Object.hasOwnProperty.call(message, "idx"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.idx);
            if (message.logo != null && Object.hasOwnProperty.call(message, "logo"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.logo);
            if (message.gname != null && Object.hasOwnProperty.call(message, "gname"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.gname);
            if (message.power != null && Object.hasOwnProperty.call(message, "power"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.power);
            if (message.lv != null && Object.hasOwnProperty.call(message, "lv"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.lv);
            if (message.lbox != null && Object.hasOwnProperty.call(message, "lbox"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.lbox);
            if (message.unit != null && message.unit.length)
                for (var i = 0; i < message.unit.length; ++i)
                    $root.pb_unit.encode(message.unit[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.uid != null && Object.hasOwnProperty.call(message, "uid"))
                writer.uint32(/* id 8, wireType 0 =*/64).int64(message.uid);
            if (message.gid != null && Object.hasOwnProperty.call(message, "gid"))
                writer.uint32(/* id 9, wireType 0 =*/72).int32(message.gid);
            if (message.win != null && Object.hasOwnProperty.call(message, "win"))
                writer.uint32(/* id 10, wireType 0 =*/80).int32(message.win);
            return writer;
        };
    
        /**
         * Encodes the specified pb_ngwmbr message, length delimited. Does not implicitly {@link pb_ngwmbr.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_ngwmbr
         * @static
         * @param {Ipb_ngwmbr} message pb_ngwmbr message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_ngwmbr.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_ngwmbr message from the specified reader or buffer.
         * @function decode
         * @memberof pb_ngwmbr
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_ngwmbr} pb_ngwmbr
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_ngwmbr.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_ngwmbr();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.idx = reader.int32();
                        break;
                    }
                case 2: {
                        message.logo = reader.int32();
                        break;
                    }
                case 3: {
                        message.gname = reader.string();
                        break;
                    }
                case 4: {
                        message.power = reader.int64();
                        break;
                    }
                case 5: {
                        message.lv = reader.int32();
                        break;
                    }
                case 6: {
                        message.lbox = reader.int32();
                        break;
                    }
                case 7: {
                        if (!(message.unit && message.unit.length))
                            message.unit = [];
                        message.unit.push($root.pb_unit.decode(reader, reader.uint32()));
                        break;
                    }
                case 8: {
                        message.uid = reader.int64();
                        break;
                    }
                case 9: {
                        message.gid = reader.int32();
                        break;
                    }
                case 10: {
                        message.win = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a pb_ngwmbr message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_ngwmbr
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_ngwmbr} pb_ngwmbr
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_ngwmbr.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_ngwmbr message.
         * @function verify
         * @memberof pb_ngwmbr
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_ngwmbr.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.idx != null && message.hasOwnProperty("idx"))
                if (!$util.isInteger(message.idx))
                    return "idx: integer expected";
            if (message.logo != null && message.hasOwnProperty("logo"))
                if (!$util.isInteger(message.logo))
                    return "logo: integer expected";
            if (message.gname != null && message.hasOwnProperty("gname"))
                if (!$util.isString(message.gname))
                    return "gname: string expected";
            if (message.power != null && message.hasOwnProperty("power"))
                if (!$util.isInteger(message.power) && !(message.power && $util.isInteger(message.power.low) && $util.isInteger(message.power.high)))
                    return "power: integer|Long expected";
            if (message.lv != null && message.hasOwnProperty("lv"))
                if (!$util.isInteger(message.lv))
                    return "lv: integer expected";
            if (message.lbox != null && message.hasOwnProperty("lbox"))
                if (!$util.isInteger(message.lbox))
                    return "lbox: integer expected";
            if (message.unit != null && message.hasOwnProperty("unit")) {
                if (!Array.isArray(message.unit))
                    return "unit: array expected";
                for (var i = 0; i < message.unit.length; ++i) {
                    var error = $root.pb_unit.verify(message.unit[i]);
                    if (error)
                        return "unit." + error;
                }
            }
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (!$util.isInteger(message.uid) && !(message.uid && $util.isInteger(message.uid.low) && $util.isInteger(message.uid.high)))
                    return "uid: integer|Long expected";
            if (message.gid != null && message.hasOwnProperty("gid"))
                if (!$util.isInteger(message.gid))
                    return "gid: integer expected";
            if (message.win != null && message.hasOwnProperty("win"))
                if (!$util.isInteger(message.win))
                    return "win: integer expected";
            return null;
        };
    
        /**
         * Creates a pb_ngwmbr message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_ngwmbr
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_ngwmbr} pb_ngwmbr
         */
        pb_ngwmbr.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_ngwmbr)
                return object;
            var message = new $root.pb_ngwmbr();
            if (object.idx != null)
                message.idx = object.idx | 0;
            if (object.logo != null)
                message.logo = object.logo | 0;
            if (object.gname != null)
                message.gname = String(object.gname);
            if (object.power != null)
                if ($util.Long)
                    (message.power = $util.Long.fromValue(object.power)).unsigned = false;
                else if (typeof object.power === "string")
                    message.power = parseInt(object.power, 10);
                else if (typeof object.power === "number")
                    message.power = object.power;
                else if (typeof object.power === "object")
                    message.power = new $util.LongBits(object.power.low >>> 0, object.power.high >>> 0).toNumber();
            if (object.lv != null)
                message.lv = object.lv | 0;
            if (object.lbox != null)
                message.lbox = object.lbox | 0;
            if (object.unit) {
                if (!Array.isArray(object.unit))
                    throw TypeError(".pb_ngwmbr.unit: array expected");
                message.unit = [];
                for (var i = 0; i < object.unit.length; ++i) {
                    if (typeof object.unit[i] !== "object")
                        throw TypeError(".pb_ngwmbr.unit: object expected");
                    message.unit[i] = $root.pb_unit.fromObject(object.unit[i]);
                }
            }
            if (object.uid != null)
                if ($util.Long)
                    (message.uid = $util.Long.fromValue(object.uid)).unsigned = false;
                else if (typeof object.uid === "string")
                    message.uid = parseInt(object.uid, 10);
                else if (typeof object.uid === "number")
                    message.uid = object.uid;
                else if (typeof object.uid === "object")
                    message.uid = new $util.LongBits(object.uid.low >>> 0, object.uid.high >>> 0).toNumber();
            if (object.gid != null)
                message.gid = object.gid | 0;
            if (object.win != null)
                message.win = object.win | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a pb_ngwmbr message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_ngwmbr
         * @static
         * @param {pb_ngwmbr} message pb_ngwmbr
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_ngwmbr.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.unit = [];
            if (options.defaults) {
                object.idx = 0;
                object.logo = 0;
                object.gname = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.power = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.power = options.longs === String ? "0" : 0;
                object.lv = 0;
                object.lbox = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.uid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.uid = options.longs === String ? "0" : 0;
                object.gid = 0;
                object.win = 0;
            }
            if (message.idx != null && message.hasOwnProperty("idx"))
                object.idx = message.idx;
            if (message.logo != null && message.hasOwnProperty("logo"))
                object.logo = message.logo;
            if (message.gname != null && message.hasOwnProperty("gname"))
                object.gname = message.gname;
            if (message.power != null && message.hasOwnProperty("power"))
                if (typeof message.power === "number")
                    object.power = options.longs === String ? String(message.power) : message.power;
                else
                    object.power = options.longs === String ? $util.Long.prototype.toString.call(message.power) : options.longs === Number ? new $util.LongBits(message.power.low >>> 0, message.power.high >>> 0).toNumber() : message.power;
            if (message.lv != null && message.hasOwnProperty("lv"))
                object.lv = message.lv;
            if (message.lbox != null && message.hasOwnProperty("lbox"))
                object.lbox = message.lbox;
            if (message.unit && message.unit.length) {
                object.unit = [];
                for (var j = 0; j < message.unit.length; ++j)
                    object.unit[j] = $root.pb_unit.toObject(message.unit[j], options);
            }
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (typeof message.uid === "number")
                    object.uid = options.longs === String ? String(message.uid) : message.uid;
                else
                    object.uid = options.longs === String ? $util.Long.prototype.toString.call(message.uid) : options.longs === Number ? new $util.LongBits(message.uid.low >>> 0, message.uid.high >>> 0).toNumber() : message.uid;
            if (message.gid != null && message.hasOwnProperty("gid"))
                object.gid = message.gid;
            if (message.win != null && message.hasOwnProperty("win"))
                object.win = message.win;
            return object;
        };
    
        /**
         * Converts this pb_ngwmbr to JSON.
         * @function toJSON
         * @memberof pb_ngwmbr
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_ngwmbr.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_ngwmbr
         * @function getTypeUrl
         * @memberof pb_ngwmbr
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_ngwmbr.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_ngwmbr";
        };
    
        return pb_ngwmbr;
    })();
    
    $root.pb_clink = (function() {
    
        /**
         * Properties of a pb_clink.
         * @exports Ipb_clink
         * @interface Ipb_clink
         * @property {number|null} [cd] pb_clink cd
         * @property {number|null} [atk] pb_clink atk
         * @property {number|null} [def] pb_clink def
         * @property {number|null} [win] pb_clink win
         * @property {number|Long|null} [vid] pb_clink vid
         */
    
        /**
         * Constructs a new pb_clink.
         * @exports pb_clink
         * @classdesc Represents a pb_clink.
         * @implements Ipb_clink
         * @constructor
         * @param {Ipb_clink=} [properties] Properties to set
         */
        function pb_clink(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_clink cd.
         * @member {number} cd
         * @memberof pb_clink
         * @instance
         */
        pb_clink.prototype.cd = 0;
    
        /**
         * pb_clink atk.
         * @member {number} atk
         * @memberof pb_clink
         * @instance
         */
        pb_clink.prototype.atk = 0;
    
        /**
         * pb_clink def.
         * @member {number} def
         * @memberof pb_clink
         * @instance
         */
        pb_clink.prototype.def = 0;
    
        /**
         * pb_clink win.
         * @member {number} win
         * @memberof pb_clink
         * @instance
         */
        pb_clink.prototype.win = 0;
    
        /**
         * pb_clink vid.
         * @member {number|Long} vid
         * @memberof pb_clink
         * @instance
         */
        pb_clink.prototype.vid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * Creates a new pb_clink instance using the specified properties.
         * @function create
         * @memberof pb_clink
         * @static
         * @param {Ipb_clink=} [properties] Properties to set
         * @returns {pb_clink} pb_clink instance
         */
        pb_clink.create = function create(properties) {
            return new pb_clink(properties);
        };
    
        /**
         * Encodes the specified pb_clink message. Does not implicitly {@link pb_clink.verify|verify} messages.
         * @function encode
         * @memberof pb_clink
         * @static
         * @param {Ipb_clink} message pb_clink message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_clink.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.cd != null && Object.hasOwnProperty.call(message, "cd"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.cd);
            if (message.atk != null && Object.hasOwnProperty.call(message, "atk"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.atk);
            if (message.def != null && Object.hasOwnProperty.call(message, "def"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.def);
            if (message.win != null && Object.hasOwnProperty.call(message, "win"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.win);
            if (message.vid != null && Object.hasOwnProperty.call(message, "vid"))
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.vid);
            return writer;
        };
    
        /**
         * Encodes the specified pb_clink message, length delimited. Does not implicitly {@link pb_clink.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_clink
         * @static
         * @param {Ipb_clink} message pb_clink message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_clink.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_clink message from the specified reader or buffer.
         * @function decode
         * @memberof pb_clink
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_clink} pb_clink
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_clink.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_clink();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.cd = reader.int32();
                        break;
                    }
                case 2: {
                        message.atk = reader.int32();
                        break;
                    }
                case 3: {
                        message.def = reader.int32();
                        break;
                    }
                case 4: {
                        message.win = reader.int32();
                        break;
                    }
                case 5: {
                        message.vid = reader.int64();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a pb_clink message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_clink
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_clink} pb_clink
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_clink.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_clink message.
         * @function verify
         * @memberof pb_clink
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_clink.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.cd != null && message.hasOwnProperty("cd"))
                if (!$util.isInteger(message.cd))
                    return "cd: integer expected";
            if (message.atk != null && message.hasOwnProperty("atk"))
                if (!$util.isInteger(message.atk))
                    return "atk: integer expected";
            if (message.def != null && message.hasOwnProperty("def"))
                if (!$util.isInteger(message.def))
                    return "def: integer expected";
            if (message.win != null && message.hasOwnProperty("win"))
                if (!$util.isInteger(message.win))
                    return "win: integer expected";
            if (message.vid != null && message.hasOwnProperty("vid"))
                if (!$util.isInteger(message.vid) && !(message.vid && $util.isInteger(message.vid.low) && $util.isInteger(message.vid.high)))
                    return "vid: integer|Long expected";
            return null;
        };
    
        /**
         * Creates a pb_clink message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_clink
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_clink} pb_clink
         */
        pb_clink.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_clink)
                return object;
            var message = new $root.pb_clink();
            if (object.cd != null)
                message.cd = object.cd | 0;
            if (object.atk != null)
                message.atk = object.atk | 0;
            if (object.def != null)
                message.def = object.def | 0;
            if (object.win != null)
                message.win = object.win | 0;
            if (object.vid != null)
                if ($util.Long)
                    (message.vid = $util.Long.fromValue(object.vid)).unsigned = false;
                else if (typeof object.vid === "string")
                    message.vid = parseInt(object.vid, 10);
                else if (typeof object.vid === "number")
                    message.vid = object.vid;
                else if (typeof object.vid === "object")
                    message.vid = new $util.LongBits(object.vid.low >>> 0, object.vid.high >>> 0).toNumber();
            return message;
        };
    
        /**
         * Creates a plain object from a pb_clink message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_clink
         * @static
         * @param {pb_clink} message pb_clink
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_clink.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.cd = 0;
                object.atk = 0;
                object.def = 0;
                object.win = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.vid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.vid = options.longs === String ? "0" : 0;
            }
            if (message.cd != null && message.hasOwnProperty("cd"))
                object.cd = message.cd;
            if (message.atk != null && message.hasOwnProperty("atk"))
                object.atk = message.atk;
            if (message.def != null && message.hasOwnProperty("def"))
                object.def = message.def;
            if (message.win != null && message.hasOwnProperty("win"))
                object.win = message.win;
            if (message.vid != null && message.hasOwnProperty("vid"))
                if (typeof message.vid === "number")
                    object.vid = options.longs === String ? String(message.vid) : message.vid;
                else
                    object.vid = options.longs === String ? $util.Long.prototype.toString.call(message.vid) : options.longs === Number ? new $util.LongBits(message.vid.low >>> 0, message.vid.high >>> 0).toNumber() : message.vid;
            return object;
        };
    
        /**
         * Converts this pb_clink to JSON.
         * @function toJSON
         * @memberof pb_clink
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_clink.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_clink
         * @function getTypeUrl
         * @memberof pb_clink
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_clink.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_clink";
        };
    
        return pb_clink;
    })();
    
    $root.pb_cgw_info = (function() {
    
        /**
         * Properties of a pb_cgw_info.
         * @exports Ipb_cgw_info
         * @interface Ipb_cgw_info
         * @property {number|null} [id] pb_cgw_info id
         * @property {number|null} [logo] pb_cgw_info logo
         * @property {number|Long|null} [power] pb_cgw_info power
         * @property {string|null} [name] pb_cgw_info name
         */
    
        /**
         * Constructs a new pb_cgw_info.
         * @exports pb_cgw_info
         * @classdesc Represents a pb_cgw_info.
         * @implements Ipb_cgw_info
         * @constructor
         * @param {Ipb_cgw_info=} [properties] Properties to set
         */
        function pb_cgw_info(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_cgw_info id.
         * @member {number} id
         * @memberof pb_cgw_info
         * @instance
         */
        pb_cgw_info.prototype.id = 0;
    
        /**
         * pb_cgw_info logo.
         * @member {number} logo
         * @memberof pb_cgw_info
         * @instance
         */
        pb_cgw_info.prototype.logo = 0;
    
        /**
         * pb_cgw_info power.
         * @member {number|Long} power
         * @memberof pb_cgw_info
         * @instance
         */
        pb_cgw_info.prototype.power = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * pb_cgw_info name.
         * @member {string} name
         * @memberof pb_cgw_info
         * @instance
         */
        pb_cgw_info.prototype.name = "";
    
        /**
         * Creates a new pb_cgw_info instance using the specified properties.
         * @function create
         * @memberof pb_cgw_info
         * @static
         * @param {Ipb_cgw_info=} [properties] Properties to set
         * @returns {pb_cgw_info} pb_cgw_info instance
         */
        pb_cgw_info.create = function create(properties) {
            return new pb_cgw_info(properties);
        };
    
        /**
         * Encodes the specified pb_cgw_info message. Does not implicitly {@link pb_cgw_info.verify|verify} messages.
         * @function encode
         * @memberof pb_cgw_info
         * @static
         * @param {Ipb_cgw_info} message pb_cgw_info message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_cgw_info.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.id);
            if (message.logo != null && Object.hasOwnProperty.call(message, "logo"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.logo);
            if (message.power != null && Object.hasOwnProperty.call(message, "power"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.power);
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.name);
            return writer;
        };
    
        /**
         * Encodes the specified pb_cgw_info message, length delimited. Does not implicitly {@link pb_cgw_info.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_cgw_info
         * @static
         * @param {Ipb_cgw_info} message pb_cgw_info message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_cgw_info.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_cgw_info message from the specified reader or buffer.
         * @function decode
         * @memberof pb_cgw_info
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_cgw_info} pb_cgw_info
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_cgw_info.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_cgw_info();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.id = reader.int32();
                        break;
                    }
                case 2: {
                        message.logo = reader.int32();
                        break;
                    }
                case 3: {
                        message.power = reader.int64();
                        break;
                    }
                case 4: {
                        message.name = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a pb_cgw_info message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_cgw_info
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_cgw_info} pb_cgw_info
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_cgw_info.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_cgw_info message.
         * @function verify
         * @memberof pb_cgw_info
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_cgw_info.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id))
                    return "id: integer expected";
            if (message.logo != null && message.hasOwnProperty("logo"))
                if (!$util.isInteger(message.logo))
                    return "logo: integer expected";
            if (message.power != null && message.hasOwnProperty("power"))
                if (!$util.isInteger(message.power) && !(message.power && $util.isInteger(message.power.low) && $util.isInteger(message.power.high)))
                    return "power: integer|Long expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            return null;
        };
    
        /**
         * Creates a pb_cgw_info message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_cgw_info
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_cgw_info} pb_cgw_info
         */
        pb_cgw_info.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_cgw_info)
                return object;
            var message = new $root.pb_cgw_info();
            if (object.id != null)
                message.id = object.id | 0;
            if (object.logo != null)
                message.logo = object.logo | 0;
            if (object.power != null)
                if ($util.Long)
                    (message.power = $util.Long.fromValue(object.power)).unsigned = false;
                else if (typeof object.power === "string")
                    message.power = parseInt(object.power, 10);
                else if (typeof object.power === "number")
                    message.power = object.power;
                else if (typeof object.power === "object")
                    message.power = new $util.LongBits(object.power.low >>> 0, object.power.high >>> 0).toNumber();
            if (object.name != null)
                message.name = String(object.name);
            return message;
        };
    
        /**
         * Creates a plain object from a pb_cgw_info message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_cgw_info
         * @static
         * @param {pb_cgw_info} message pb_cgw_info
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_cgw_info.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = 0;
                object.logo = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.power = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.power = options.longs === String ? "0" : 0;
                object.name = "";
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.logo != null && message.hasOwnProperty("logo"))
                object.logo = message.logo;
            if (message.power != null && message.hasOwnProperty("power"))
                if (typeof message.power === "number")
                    object.power = options.longs === String ? String(message.power) : message.power;
                else
                    object.power = options.longs === String ? $util.Long.prototype.toString.call(message.power) : options.longs === Number ? new $util.LongBits(message.power.low >>> 0, message.power.high >>> 0).toNumber() : message.power;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            return object;
        };
    
        /**
         * Converts this pb_cgw_info to JSON.
         * @function toJSON
         * @memberof pb_cgw_info
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_cgw_info.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_cgw_info
         * @function getTypeUrl
         * @memberof pb_cgw_info
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_cgw_info.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_cgw_info";
        };
    
        return pb_cgw_info;
    })();
    
    $root.pb_cgw_mbr = (function() {
    
        /**
         * Properties of a pb_cgw_mbr.
         * @exports Ipb_cgw_mbr
         * @interface Ipb_cgw_mbr
         * @property {number|Long|null} [uid] pb_cgw_mbr uid
         * @property {number|null} [logo] pb_cgw_mbr logo
         * @property {number|null} [lv] pb_cgw_mbr lv
         * @property {number|null} [lbox] pb_cgw_mbr lbox
         * @property {string|null} [name] pb_cgw_mbr name
         * @property {Array.<Ipb_unit>|null} [camp] pb_cgw_mbr camp
         */
    
        /**
         * Constructs a new pb_cgw_mbr.
         * @exports pb_cgw_mbr
         * @classdesc Represents a pb_cgw_mbr.
         * @implements Ipb_cgw_mbr
         * @constructor
         * @param {Ipb_cgw_mbr=} [properties] Properties to set
         */
        function pb_cgw_mbr(properties) {
            this.camp = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_cgw_mbr uid.
         * @member {number|Long} uid
         * @memberof pb_cgw_mbr
         * @instance
         */
        pb_cgw_mbr.prototype.uid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * pb_cgw_mbr logo.
         * @member {number} logo
         * @memberof pb_cgw_mbr
         * @instance
         */
        pb_cgw_mbr.prototype.logo = 0;
    
        /**
         * pb_cgw_mbr lv.
         * @member {number} lv
         * @memberof pb_cgw_mbr
         * @instance
         */
        pb_cgw_mbr.prototype.lv = 0;
    
        /**
         * pb_cgw_mbr lbox.
         * @member {number} lbox
         * @memberof pb_cgw_mbr
         * @instance
         */
        pb_cgw_mbr.prototype.lbox = 0;
    
        /**
         * pb_cgw_mbr name.
         * @member {string} name
         * @memberof pb_cgw_mbr
         * @instance
         */
        pb_cgw_mbr.prototype.name = "";
    
        /**
         * pb_cgw_mbr camp.
         * @member {Array.<Ipb_unit>} camp
         * @memberof pb_cgw_mbr
         * @instance
         */
        pb_cgw_mbr.prototype.camp = $util.emptyArray;
    
        /**
         * Creates a new pb_cgw_mbr instance using the specified properties.
         * @function create
         * @memberof pb_cgw_mbr
         * @static
         * @param {Ipb_cgw_mbr=} [properties] Properties to set
         * @returns {pb_cgw_mbr} pb_cgw_mbr instance
         */
        pb_cgw_mbr.create = function create(properties) {
            return new pb_cgw_mbr(properties);
        };
    
        /**
         * Encodes the specified pb_cgw_mbr message. Does not implicitly {@link pb_cgw_mbr.verify|verify} messages.
         * @function encode
         * @memberof pb_cgw_mbr
         * @static
         * @param {Ipb_cgw_mbr} message pb_cgw_mbr message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_cgw_mbr.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.uid != null && Object.hasOwnProperty.call(message, "uid"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.uid);
            if (message.logo != null && Object.hasOwnProperty.call(message, "logo"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.logo);
            if (message.lv != null && Object.hasOwnProperty.call(message, "lv"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.lv);
            if (message.lbox != null && Object.hasOwnProperty.call(message, "lbox"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.lbox);
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.name);
            if (message.camp != null && message.camp.length)
                for (var i = 0; i < message.camp.length; ++i)
                    $root.pb_unit.encode(message.camp[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified pb_cgw_mbr message, length delimited. Does not implicitly {@link pb_cgw_mbr.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_cgw_mbr
         * @static
         * @param {Ipb_cgw_mbr} message pb_cgw_mbr message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_cgw_mbr.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_cgw_mbr message from the specified reader or buffer.
         * @function decode
         * @memberof pb_cgw_mbr
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_cgw_mbr} pb_cgw_mbr
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_cgw_mbr.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_cgw_mbr();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.uid = reader.int64();
                        break;
                    }
                case 2: {
                        message.logo = reader.int32();
                        break;
                    }
                case 3: {
                        message.lv = reader.int32();
                        break;
                    }
                case 4: {
                        message.lbox = reader.int32();
                        break;
                    }
                case 5: {
                        message.name = reader.string();
                        break;
                    }
                case 6: {
                        if (!(message.camp && message.camp.length))
                            message.camp = [];
                        message.camp.push($root.pb_unit.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a pb_cgw_mbr message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_cgw_mbr
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_cgw_mbr} pb_cgw_mbr
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_cgw_mbr.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_cgw_mbr message.
         * @function verify
         * @memberof pb_cgw_mbr
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_cgw_mbr.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (!$util.isInteger(message.uid) && !(message.uid && $util.isInteger(message.uid.low) && $util.isInteger(message.uid.high)))
                    return "uid: integer|Long expected";
            if (message.logo != null && message.hasOwnProperty("logo"))
                if (!$util.isInteger(message.logo))
                    return "logo: integer expected";
            if (message.lv != null && message.hasOwnProperty("lv"))
                if (!$util.isInteger(message.lv))
                    return "lv: integer expected";
            if (message.lbox != null && message.hasOwnProperty("lbox"))
                if (!$util.isInteger(message.lbox))
                    return "lbox: integer expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.camp != null && message.hasOwnProperty("camp")) {
                if (!Array.isArray(message.camp))
                    return "camp: array expected";
                for (var i = 0; i < message.camp.length; ++i) {
                    var error = $root.pb_unit.verify(message.camp[i]);
                    if (error)
                        return "camp." + error;
                }
            }
            return null;
        };
    
        /**
         * Creates a pb_cgw_mbr message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_cgw_mbr
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_cgw_mbr} pb_cgw_mbr
         */
        pb_cgw_mbr.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_cgw_mbr)
                return object;
            var message = new $root.pb_cgw_mbr();
            if (object.uid != null)
                if ($util.Long)
                    (message.uid = $util.Long.fromValue(object.uid)).unsigned = false;
                else if (typeof object.uid === "string")
                    message.uid = parseInt(object.uid, 10);
                else if (typeof object.uid === "number")
                    message.uid = object.uid;
                else if (typeof object.uid === "object")
                    message.uid = new $util.LongBits(object.uid.low >>> 0, object.uid.high >>> 0).toNumber();
            if (object.logo != null)
                message.logo = object.logo | 0;
            if (object.lv != null)
                message.lv = object.lv | 0;
            if (object.lbox != null)
                message.lbox = object.lbox | 0;
            if (object.name != null)
                message.name = String(object.name);
            if (object.camp) {
                if (!Array.isArray(object.camp))
                    throw TypeError(".pb_cgw_mbr.camp: array expected");
                message.camp = [];
                for (var i = 0; i < object.camp.length; ++i) {
                    if (typeof object.camp[i] !== "object")
                        throw TypeError(".pb_cgw_mbr.camp: object expected");
                    message.camp[i] = $root.pb_unit.fromObject(object.camp[i]);
                }
            }
            return message;
        };
    
        /**
         * Creates a plain object from a pb_cgw_mbr message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_cgw_mbr
         * @static
         * @param {pb_cgw_mbr} message pb_cgw_mbr
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_cgw_mbr.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.camp = [];
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.uid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.uid = options.longs === String ? "0" : 0;
                object.logo = 0;
                object.lv = 0;
                object.lbox = 0;
                object.name = "";
            }
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (typeof message.uid === "number")
                    object.uid = options.longs === String ? String(message.uid) : message.uid;
                else
                    object.uid = options.longs === String ? $util.Long.prototype.toString.call(message.uid) : options.longs === Number ? new $util.LongBits(message.uid.low >>> 0, message.uid.high >>> 0).toNumber() : message.uid;
            if (message.logo != null && message.hasOwnProperty("logo"))
                object.logo = message.logo;
            if (message.lv != null && message.hasOwnProperty("lv"))
                object.lv = message.lv;
            if (message.lbox != null && message.hasOwnProperty("lbox"))
                object.lbox = message.lbox;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.camp && message.camp.length) {
                object.camp = [];
                for (var j = 0; j < message.camp.length; ++j)
                    object.camp[j] = $root.pb_unit.toObject(message.camp[j], options);
            }
            return object;
        };
    
        /**
         * Converts this pb_cgw_mbr to JSON.
         * @function toJSON
         * @memberof pb_cgw_mbr
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_cgw_mbr.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_cgw_mbr
         * @function getTypeUrl
         * @memberof pb_cgw_mbr
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_cgw_mbr.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_cgw_mbr";
        };
    
        return pb_cgw_mbr;
    })();
    
    $root.pb_cgw_record = (function() {
    
        /**
         * Properties of a pb_cgw_record.
         * @exports Ipb_cgw_record
         * @interface Ipb_cgw_record
         * @property {number|null} [gid] pb_cgw_record gid
         * @property {number|null} [logo] pb_cgw_record logo
         * @property {number|null} [vid] pb_cgw_record vid
         * @property {number|null} [cd] pb_cgw_record cd
         * @property {number|null} [flag] pb_cgw_record flag
         * @property {number|Long|null} [power] pb_cgw_record power
         * @property {string|null} [name] pb_cgw_record name
         * @property {boolean|null} [atk] pb_cgw_record atk
         * @property {boolean|null} [win] pb_cgw_record win
         * @property {number|Long|null} [spower] pb_cgw_record spower
         */
    
        /**
         * Constructs a new pb_cgw_record.
         * @exports pb_cgw_record
         * @classdesc Represents a pb_cgw_record.
         * @implements Ipb_cgw_record
         * @constructor
         * @param {Ipb_cgw_record=} [properties] Properties to set
         */
        function pb_cgw_record(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_cgw_record gid.
         * @member {number} gid
         * @memberof pb_cgw_record
         * @instance
         */
        pb_cgw_record.prototype.gid = 0;
    
        /**
         * pb_cgw_record logo.
         * @member {number} logo
         * @memberof pb_cgw_record
         * @instance
         */
        pb_cgw_record.prototype.logo = 0;
    
        /**
         * pb_cgw_record vid.
         * @member {number} vid
         * @memberof pb_cgw_record
         * @instance
         */
        pb_cgw_record.prototype.vid = 0;
    
        /**
         * pb_cgw_record cd.
         * @member {number} cd
         * @memberof pb_cgw_record
         * @instance
         */
        pb_cgw_record.prototype.cd = 0;
    
        /**
         * pb_cgw_record flag.
         * @member {number} flag
         * @memberof pb_cgw_record
         * @instance
         */
        pb_cgw_record.prototype.flag = 0;
    
        /**
         * pb_cgw_record power.
         * @member {number|Long} power
         * @memberof pb_cgw_record
         * @instance
         */
        pb_cgw_record.prototype.power = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * pb_cgw_record name.
         * @member {string} name
         * @memberof pb_cgw_record
         * @instance
         */
        pb_cgw_record.prototype.name = "";
    
        /**
         * pb_cgw_record atk.
         * @member {boolean} atk
         * @memberof pb_cgw_record
         * @instance
         */
        pb_cgw_record.prototype.atk = false;
    
        /**
         * pb_cgw_record win.
         * @member {boolean} win
         * @memberof pb_cgw_record
         * @instance
         */
        pb_cgw_record.prototype.win = false;
    
        /**
         * pb_cgw_record spower.
         * @member {number|Long} spower
         * @memberof pb_cgw_record
         * @instance
         */
        pb_cgw_record.prototype.spower = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * Creates a new pb_cgw_record instance using the specified properties.
         * @function create
         * @memberof pb_cgw_record
         * @static
         * @param {Ipb_cgw_record=} [properties] Properties to set
         * @returns {pb_cgw_record} pb_cgw_record instance
         */
        pb_cgw_record.create = function create(properties) {
            return new pb_cgw_record(properties);
        };
    
        /**
         * Encodes the specified pb_cgw_record message. Does not implicitly {@link pb_cgw_record.verify|verify} messages.
         * @function encode
         * @memberof pb_cgw_record
         * @static
         * @param {Ipb_cgw_record} message pb_cgw_record message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_cgw_record.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.gid != null && Object.hasOwnProperty.call(message, "gid"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.gid);
            if (message.logo != null && Object.hasOwnProperty.call(message, "logo"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.logo);
            if (message.vid != null && Object.hasOwnProperty.call(message, "vid"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.vid);
            if (message.cd != null && Object.hasOwnProperty.call(message, "cd"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.cd);
            if (message.flag != null && Object.hasOwnProperty.call(message, "flag"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.flag);
            if (message.power != null && Object.hasOwnProperty.call(message, "power"))
                writer.uint32(/* id 6, wireType 0 =*/48).int64(message.power);
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.name);
            if (message.atk != null && Object.hasOwnProperty.call(message, "atk"))
                writer.uint32(/* id 8, wireType 0 =*/64).bool(message.atk);
            if (message.win != null && Object.hasOwnProperty.call(message, "win"))
                writer.uint32(/* id 9, wireType 0 =*/72).bool(message.win);
            if (message.spower != null && Object.hasOwnProperty.call(message, "spower"))
                writer.uint32(/* id 10, wireType 0 =*/80).int64(message.spower);
            return writer;
        };
    
        /**
         * Encodes the specified pb_cgw_record message, length delimited. Does not implicitly {@link pb_cgw_record.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_cgw_record
         * @static
         * @param {Ipb_cgw_record} message pb_cgw_record message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_cgw_record.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_cgw_record message from the specified reader or buffer.
         * @function decode
         * @memberof pb_cgw_record
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_cgw_record} pb_cgw_record
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_cgw_record.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_cgw_record();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.gid = reader.int32();
                        break;
                    }
                case 2: {
                        message.logo = reader.int32();
                        break;
                    }
                case 3: {
                        message.vid = reader.int32();
                        break;
                    }
                case 4: {
                        message.cd = reader.int32();
                        break;
                    }
                case 5: {
                        message.flag = reader.int32();
                        break;
                    }
                case 6: {
                        message.power = reader.int64();
                        break;
                    }
                case 7: {
                        message.name = reader.string();
                        break;
                    }
                case 8: {
                        message.atk = reader.bool();
                        break;
                    }
                case 9: {
                        message.win = reader.bool();
                        break;
                    }
                case 10: {
                        message.spower = reader.int64();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a pb_cgw_record message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_cgw_record
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_cgw_record} pb_cgw_record
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_cgw_record.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_cgw_record message.
         * @function verify
         * @memberof pb_cgw_record
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_cgw_record.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.gid != null && message.hasOwnProperty("gid"))
                if (!$util.isInteger(message.gid))
                    return "gid: integer expected";
            if (message.logo != null && message.hasOwnProperty("logo"))
                if (!$util.isInteger(message.logo))
                    return "logo: integer expected";
            if (message.vid != null && message.hasOwnProperty("vid"))
                if (!$util.isInteger(message.vid))
                    return "vid: integer expected";
            if (message.cd != null && message.hasOwnProperty("cd"))
                if (!$util.isInteger(message.cd))
                    return "cd: integer expected";
            if (message.flag != null && message.hasOwnProperty("flag"))
                if (!$util.isInteger(message.flag))
                    return "flag: integer expected";
            if (message.power != null && message.hasOwnProperty("power"))
                if (!$util.isInteger(message.power) && !(message.power && $util.isInteger(message.power.low) && $util.isInteger(message.power.high)))
                    return "power: integer|Long expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.atk != null && message.hasOwnProperty("atk"))
                if (typeof message.atk !== "boolean")
                    return "atk: boolean expected";
            if (message.win != null && message.hasOwnProperty("win"))
                if (typeof message.win !== "boolean")
                    return "win: boolean expected";
            if (message.spower != null && message.hasOwnProperty("spower"))
                if (!$util.isInteger(message.spower) && !(message.spower && $util.isInteger(message.spower.low) && $util.isInteger(message.spower.high)))
                    return "spower: integer|Long expected";
            return null;
        };
    
        /**
         * Creates a pb_cgw_record message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_cgw_record
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_cgw_record} pb_cgw_record
         */
        pb_cgw_record.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_cgw_record)
                return object;
            var message = new $root.pb_cgw_record();
            if (object.gid != null)
                message.gid = object.gid | 0;
            if (object.logo != null)
                message.logo = object.logo | 0;
            if (object.vid != null)
                message.vid = object.vid | 0;
            if (object.cd != null)
                message.cd = object.cd | 0;
            if (object.flag != null)
                message.flag = object.flag | 0;
            if (object.power != null)
                if ($util.Long)
                    (message.power = $util.Long.fromValue(object.power)).unsigned = false;
                else if (typeof object.power === "string")
                    message.power = parseInt(object.power, 10);
                else if (typeof object.power === "number")
                    message.power = object.power;
                else if (typeof object.power === "object")
                    message.power = new $util.LongBits(object.power.low >>> 0, object.power.high >>> 0).toNumber();
            if (object.name != null)
                message.name = String(object.name);
            if (object.atk != null)
                message.atk = Boolean(object.atk);
            if (object.win != null)
                message.win = Boolean(object.win);
            if (object.spower != null)
                if ($util.Long)
                    (message.spower = $util.Long.fromValue(object.spower)).unsigned = false;
                else if (typeof object.spower === "string")
                    message.spower = parseInt(object.spower, 10);
                else if (typeof object.spower === "number")
                    message.spower = object.spower;
                else if (typeof object.spower === "object")
                    message.spower = new $util.LongBits(object.spower.low >>> 0, object.spower.high >>> 0).toNumber();
            return message;
        };
    
        /**
         * Creates a plain object from a pb_cgw_record message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_cgw_record
         * @static
         * @param {pb_cgw_record} message pb_cgw_record
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_cgw_record.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.gid = 0;
                object.logo = 0;
                object.vid = 0;
                object.cd = 0;
                object.flag = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.power = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.power = options.longs === String ? "0" : 0;
                object.name = "";
                object.atk = false;
                object.win = false;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.spower = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.spower = options.longs === String ? "0" : 0;
            }
            if (message.gid != null && message.hasOwnProperty("gid"))
                object.gid = message.gid;
            if (message.logo != null && message.hasOwnProperty("logo"))
                object.logo = message.logo;
            if (message.vid != null && message.hasOwnProperty("vid"))
                object.vid = message.vid;
            if (message.cd != null && message.hasOwnProperty("cd"))
                object.cd = message.cd;
            if (message.flag != null && message.hasOwnProperty("flag"))
                object.flag = message.flag;
            if (message.power != null && message.hasOwnProperty("power"))
                if (typeof message.power === "number")
                    object.power = options.longs === String ? String(message.power) : message.power;
                else
                    object.power = options.longs === String ? $util.Long.prototype.toString.call(message.power) : options.longs === Number ? new $util.LongBits(message.power.low >>> 0, message.power.high >>> 0).toNumber() : message.power;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.atk != null && message.hasOwnProperty("atk"))
                object.atk = message.atk;
            if (message.win != null && message.hasOwnProperty("win"))
                object.win = message.win;
            if (message.spower != null && message.hasOwnProperty("spower"))
                if (typeof message.spower === "number")
                    object.spower = options.longs === String ? String(message.spower) : message.spower;
                else
                    object.spower = options.longs === String ? $util.Long.prototype.toString.call(message.spower) : options.longs === Number ? new $util.LongBits(message.spower.low >>> 0, message.spower.high >>> 0).toNumber() : message.spower;
            return object;
        };
    
        /**
         * Converts this pb_cgw_record to JSON.
         * @function toJSON
         * @memberof pb_cgw_record
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_cgw_record.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_cgw_record
         * @function getTypeUrl
         * @memberof pb_cgw_record
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_cgw_record.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_cgw_record";
        };
    
        return pb_cgw_record;
    })();
    
    $root.pb_cgw_log = (function() {
    
        /**
         * Properties of a pb_cgw_log.
         * @exports Ipb_cgw_log
         * @interface Ipb_cgw_log
         * @property {Ipb_cgw_mbr|null} [atk] pb_cgw_log atk
         * @property {Ipb_cgw_mbr|null} [def] pb_cgw_log def
         * @property {boolean|null} [win] pb_cgw_log win
         */
    
        /**
         * Constructs a new pb_cgw_log.
         * @exports pb_cgw_log
         * @classdesc Represents a pb_cgw_log.
         * @implements Ipb_cgw_log
         * @constructor
         * @param {Ipb_cgw_log=} [properties] Properties to set
         */
        function pb_cgw_log(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_cgw_log atk.
         * @member {Ipb_cgw_mbr|null|undefined} atk
         * @memberof pb_cgw_log
         * @instance
         */
        pb_cgw_log.prototype.atk = null;
    
        /**
         * pb_cgw_log def.
         * @member {Ipb_cgw_mbr|null|undefined} def
         * @memberof pb_cgw_log
         * @instance
         */
        pb_cgw_log.prototype.def = null;
    
        /**
         * pb_cgw_log win.
         * @member {boolean} win
         * @memberof pb_cgw_log
         * @instance
         */
        pb_cgw_log.prototype.win = false;
    
        /**
         * Creates a new pb_cgw_log instance using the specified properties.
         * @function create
         * @memberof pb_cgw_log
         * @static
         * @param {Ipb_cgw_log=} [properties] Properties to set
         * @returns {pb_cgw_log} pb_cgw_log instance
         */
        pb_cgw_log.create = function create(properties) {
            return new pb_cgw_log(properties);
        };
    
        /**
         * Encodes the specified pb_cgw_log message. Does not implicitly {@link pb_cgw_log.verify|verify} messages.
         * @function encode
         * @memberof pb_cgw_log
         * @static
         * @param {Ipb_cgw_log} message pb_cgw_log message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_cgw_log.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.atk != null && Object.hasOwnProperty.call(message, "atk"))
                $root.pb_cgw_mbr.encode(message.atk, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.def != null && Object.hasOwnProperty.call(message, "def"))
                $root.pb_cgw_mbr.encode(message.def, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.win != null && Object.hasOwnProperty.call(message, "win"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.win);
            return writer;
        };
    
        /**
         * Encodes the specified pb_cgw_log message, length delimited. Does not implicitly {@link pb_cgw_log.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_cgw_log
         * @static
         * @param {Ipb_cgw_log} message pb_cgw_log message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_cgw_log.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_cgw_log message from the specified reader or buffer.
         * @function decode
         * @memberof pb_cgw_log
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_cgw_log} pb_cgw_log
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_cgw_log.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_cgw_log();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.atk = $root.pb_cgw_mbr.decode(reader, reader.uint32());
                        break;
                    }
                case 2: {
                        message.def = $root.pb_cgw_mbr.decode(reader, reader.uint32());
                        break;
                    }
                case 3: {
                        message.win = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a pb_cgw_log message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_cgw_log
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_cgw_log} pb_cgw_log
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_cgw_log.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_cgw_log message.
         * @function verify
         * @memberof pb_cgw_log
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_cgw_log.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.atk != null && message.hasOwnProperty("atk")) {
                var error = $root.pb_cgw_mbr.verify(message.atk);
                if (error)
                    return "atk." + error;
            }
            if (message.def != null && message.hasOwnProperty("def")) {
                var error = $root.pb_cgw_mbr.verify(message.def);
                if (error)
                    return "def." + error;
            }
            if (message.win != null && message.hasOwnProperty("win"))
                if (typeof message.win !== "boolean")
                    return "win: boolean expected";
            return null;
        };
    
        /**
         * Creates a pb_cgw_log message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_cgw_log
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_cgw_log} pb_cgw_log
         */
        pb_cgw_log.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_cgw_log)
                return object;
            var message = new $root.pb_cgw_log();
            if (object.atk != null) {
                if (typeof object.atk !== "object")
                    throw TypeError(".pb_cgw_log.atk: object expected");
                message.atk = $root.pb_cgw_mbr.fromObject(object.atk);
            }
            if (object.def != null) {
                if (typeof object.def !== "object")
                    throw TypeError(".pb_cgw_log.def: object expected");
                message.def = $root.pb_cgw_mbr.fromObject(object.def);
            }
            if (object.win != null)
                message.win = Boolean(object.win);
            return message;
        };
    
        /**
         * Creates a plain object from a pb_cgw_log message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_cgw_log
         * @static
         * @param {pb_cgw_log} message pb_cgw_log
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_cgw_log.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.atk = null;
                object.def = null;
                object.win = false;
            }
            if (message.atk != null && message.hasOwnProperty("atk"))
                object.atk = $root.pb_cgw_mbr.toObject(message.atk, options);
            if (message.def != null && message.hasOwnProperty("def"))
                object.def = $root.pb_cgw_mbr.toObject(message.def, options);
            if (message.win != null && message.hasOwnProperty("win"))
                object.win = message.win;
            return object;
        };
    
        /**
         * Converts this pb_cgw_log to JSON.
         * @function toJSON
         * @memberof pb_cgw_log
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_cgw_log.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_cgw_log
         * @function getTypeUrl
         * @memberof pb_cgw_log
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_cgw_log.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_cgw_log";
        };
    
        return pb_cgw_log;
    })();
    
    $root.pb_ngw_sweep = (function() {
    
        /**
         * Properties of a pb_ngw_sweep.
         * @exports Ipb_ngw_sweep
         * @interface Ipb_ngw_sweep
         * @property {number|null} [status] pb_ngw_sweep status
         * @property {number|null} [id] pb_ngw_sweep id
         * @property {number|null} [destroy] pb_ngw_sweep destroy
         */
    
        /**
         * Constructs a new pb_ngw_sweep.
         * @exports pb_ngw_sweep
         * @classdesc Represents a pb_ngw_sweep.
         * @implements Ipb_ngw_sweep
         * @constructor
         * @param {Ipb_ngw_sweep=} [properties] Properties to set
         */
        function pb_ngw_sweep(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_ngw_sweep status.
         * @member {number} status
         * @memberof pb_ngw_sweep
         * @instance
         */
        pb_ngw_sweep.prototype.status = 0;
    
        /**
         * pb_ngw_sweep id.
         * @member {number} id
         * @memberof pb_ngw_sweep
         * @instance
         */
        pb_ngw_sweep.prototype.id = 0;
    
        /**
         * pb_ngw_sweep destroy.
         * @member {number} destroy
         * @memberof pb_ngw_sweep
         * @instance
         */
        pb_ngw_sweep.prototype.destroy = 0;
    
        /**
         * Creates a new pb_ngw_sweep instance using the specified properties.
         * @function create
         * @memberof pb_ngw_sweep
         * @static
         * @param {Ipb_ngw_sweep=} [properties] Properties to set
         * @returns {pb_ngw_sweep} pb_ngw_sweep instance
         */
        pb_ngw_sweep.create = function create(properties) {
            return new pb_ngw_sweep(properties);
        };
    
        /**
         * Encodes the specified pb_ngw_sweep message. Does not implicitly {@link pb_ngw_sweep.verify|verify} messages.
         * @function encode
         * @memberof pb_ngw_sweep
         * @static
         * @param {Ipb_ngw_sweep} message pb_ngw_sweep message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_ngw_sweep.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.status);
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.id);
            if (message.destroy != null && Object.hasOwnProperty.call(message, "destroy"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.destroy);
            return writer;
        };
    
        /**
         * Encodes the specified pb_ngw_sweep message, length delimited. Does not implicitly {@link pb_ngw_sweep.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_ngw_sweep
         * @static
         * @param {Ipb_ngw_sweep} message pb_ngw_sweep message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_ngw_sweep.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_ngw_sweep message from the specified reader or buffer.
         * @function decode
         * @memberof pb_ngw_sweep
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_ngw_sweep} pb_ngw_sweep
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_ngw_sweep.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_ngw_sweep();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.status = reader.int32();
                        break;
                    }
                case 2: {
                        message.id = reader.int32();
                        break;
                    }
                case 3: {
                        message.destroy = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a pb_ngw_sweep message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_ngw_sweep
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_ngw_sweep} pb_ngw_sweep
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_ngw_sweep.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_ngw_sweep message.
         * @function verify
         * @memberof pb_ngw_sweep
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_ngw_sweep.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.status != null && message.hasOwnProperty("status"))
                if (!$util.isInteger(message.status))
                    return "status: integer expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id))
                    return "id: integer expected";
            if (message.destroy != null && message.hasOwnProperty("destroy"))
                if (!$util.isInteger(message.destroy))
                    return "destroy: integer expected";
            return null;
        };
    
        /**
         * Creates a pb_ngw_sweep message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_ngw_sweep
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_ngw_sweep} pb_ngw_sweep
         */
        pb_ngw_sweep.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_ngw_sweep)
                return object;
            var message = new $root.pb_ngw_sweep();
            if (object.status != null)
                message.status = object.status | 0;
            if (object.id != null)
                message.id = object.id | 0;
            if (object.destroy != null)
                message.destroy = object.destroy | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a pb_ngw_sweep message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_ngw_sweep
         * @static
         * @param {pb_ngw_sweep} message pb_ngw_sweep
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_ngw_sweep.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.status = 0;
                object.id = 0;
                object.destroy = 0;
            }
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = message.status;
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.destroy != null && message.hasOwnProperty("destroy"))
                object.destroy = message.destroy;
            return object;
        };
    
        /**
         * Converts this pb_ngw_sweep to JSON.
         * @function toJSON
         * @memberof pb_ngw_sweep
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_ngw_sweep.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_ngw_sweep
         * @function getTypeUrl
         * @memberof pb_ngw_sweep
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_ngw_sweep.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_ngw_sweep";
        };
    
        return pb_ngw_sweep;
    })();
    
    $root.pb_cd = (function() {
    
        /**
         * Properties of a pb_cd.
         * @exports Ipb_cd
         * @interface Ipb_cd
         * @property {number} id pb_cd id
         * @property {number} cd pb_cd cd
         */
    
        /**
         * Constructs a new pb_cd.
         * @exports pb_cd
         * @classdesc Represents a pb_cd.
         * @implements Ipb_cd
         * @constructor
         * @param {Ipb_cd=} [properties] Properties to set
         */
        function pb_cd(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_cd id.
         * @member {number} id
         * @memberof pb_cd
         * @instance
         */
        pb_cd.prototype.id = 0;
    
        /**
         * pb_cd cd.
         * @member {number} cd
         * @memberof pb_cd
         * @instance
         */
        pb_cd.prototype.cd = 0;
    
        /**
         * Creates a new pb_cd instance using the specified properties.
         * @function create
         * @memberof pb_cd
         * @static
         * @param {Ipb_cd=} [properties] Properties to set
         * @returns {pb_cd} pb_cd instance
         */
        pb_cd.create = function create(properties) {
            return new pb_cd(properties);
        };
    
        /**
         * Encodes the specified pb_cd message. Does not implicitly {@link pb_cd.verify|verify} messages.
         * @function encode
         * @memberof pb_cd
         * @static
         * @param {Ipb_cd} message pb_cd message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_cd.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.id);
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.cd);
            return writer;
        };
    
        /**
         * Encodes the specified pb_cd message, length delimited. Does not implicitly {@link pb_cd.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_cd
         * @static
         * @param {Ipb_cd} message pb_cd message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_cd.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_cd message from the specified reader or buffer.
         * @function decode
         * @memberof pb_cd
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_cd} pb_cd
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_cd.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_cd();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.id = reader.int32();
                        break;
                    }
                case 2: {
                        message.cd = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("id"))
                throw $util.ProtocolError("missing required 'id'", { instance: message });
            if (!message.hasOwnProperty("cd"))
                throw $util.ProtocolError("missing required 'cd'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a pb_cd message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_cd
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_cd} pb_cd
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_cd.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_cd message.
         * @function verify
         * @memberof pb_cd
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_cd.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.id))
                return "id: integer expected";
            if (!$util.isInteger(message.cd))
                return "cd: integer expected";
            return null;
        };
    
        /**
         * Creates a pb_cd message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_cd
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_cd} pb_cd
         */
        pb_cd.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_cd)
                return object;
            var message = new $root.pb_cd();
            if (object.id != null)
                message.id = object.id | 0;
            if (object.cd != null)
                message.cd = object.cd | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a pb_cd message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_cd
         * @static
         * @param {pb_cd} message pb_cd
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_cd.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = 0;
                object.cd = 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.cd != null && message.hasOwnProperty("cd"))
                object.cd = message.cd;
            return object;
        };
    
        /**
         * Converts this pb_cd to JSON.
         * @function toJSON
         * @memberof pb_cd
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_cd.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_cd
         * @function getTypeUrl
         * @memberof pb_cd
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_cd.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_cd";
        };
    
        return pb_cd;
    })();
    
    $root.pb_gpvpteam = (function() {
    
        /**
         * Properties of a pb_gpvpteam.
         * @exports Ipb_gpvpteam
         * @interface Ipb_gpvpteam
         * @property {number|null} [leader] pb_gpvpteam leader
         * @property {Array.<Ipb_pmbr>|null} [mbrs] pb_gpvpteam mbrs
         * @property {number|null} [sid] pb_gpvpteam sid
         * @property {number|null} [score] pb_gpvpteam score
         * @property {number|null} [rank] pb_gpvpteam rank
         * @property {number|Long|null} [power] pb_gpvpteam power
         * @property {string|null} [name] pb_gpvpteam name
         * @property {number|Long|null} [needPower] pb_gpvpteam needPower
         * @property {string|null} [password] pb_gpvpteam password
         * @property {number|null} [id] pb_gpvpteam id
         * @property {boolean|null} [reg] pb_gpvpteam reg
         * @property {number|null} [enegy] pb_gpvpteam enegy
         * @property {number|null} [enggyCd] pb_gpvpteam enggyCd
         */
    
        /**
         * Constructs a new pb_gpvpteam.
         * @exports pb_gpvpteam
         * @classdesc Represents a pb_gpvpteam.
         * @implements Ipb_gpvpteam
         * @constructor
         * @param {Ipb_gpvpteam=} [properties] Properties to set
         */
        function pb_gpvpteam(properties) {
            this.mbrs = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_gpvpteam leader.
         * @member {number} leader
         * @memberof pb_gpvpteam
         * @instance
         */
        pb_gpvpteam.prototype.leader = 0;
    
        /**
         * pb_gpvpteam mbrs.
         * @member {Array.<Ipb_pmbr>} mbrs
         * @memberof pb_gpvpteam
         * @instance
         */
        pb_gpvpteam.prototype.mbrs = $util.emptyArray;
    
        /**
         * pb_gpvpteam sid.
         * @member {number} sid
         * @memberof pb_gpvpteam
         * @instance
         */
        pb_gpvpteam.prototype.sid = 0;
    
        /**
         * pb_gpvpteam score.
         * @member {number} score
         * @memberof pb_gpvpteam
         * @instance
         */
        pb_gpvpteam.prototype.score = 0;
    
        /**
         * pb_gpvpteam rank.
         * @member {number} rank
         * @memberof pb_gpvpteam
         * @instance
         */
        pb_gpvpteam.prototype.rank = 0;
    
        /**
         * pb_gpvpteam power.
         * @member {number|Long} power
         * @memberof pb_gpvpteam
         * @instance
         */
        pb_gpvpteam.prototype.power = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * pb_gpvpteam name.
         * @member {string} name
         * @memberof pb_gpvpteam
         * @instance
         */
        pb_gpvpteam.prototype.name = "";
    
        /**
         * pb_gpvpteam needPower.
         * @member {number|Long} needPower
         * @memberof pb_gpvpteam
         * @instance
         */
        pb_gpvpteam.prototype.needPower = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * pb_gpvpteam password.
         * @member {string} password
         * @memberof pb_gpvpteam
         * @instance
         */
        pb_gpvpteam.prototype.password = "";
    
        /**
         * pb_gpvpteam id.
         * @member {number} id
         * @memberof pb_gpvpteam
         * @instance
         */
        pb_gpvpteam.prototype.id = 0;
    
        /**
         * pb_gpvpteam reg.
         * @member {boolean} reg
         * @memberof pb_gpvpteam
         * @instance
         */
        pb_gpvpteam.prototype.reg = false;
    
        /**
         * pb_gpvpteam enegy.
         * @member {number} enegy
         * @memberof pb_gpvpteam
         * @instance
         */
        pb_gpvpteam.prototype.enegy = 0;
    
        /**
         * pb_gpvpteam enggyCd.
         * @member {number} enggyCd
         * @memberof pb_gpvpteam
         * @instance
         */
        pb_gpvpteam.prototype.enggyCd = 0;
    
        /**
         * Creates a new pb_gpvpteam instance using the specified properties.
         * @function create
         * @memberof pb_gpvpteam
         * @static
         * @param {Ipb_gpvpteam=} [properties] Properties to set
         * @returns {pb_gpvpteam} pb_gpvpteam instance
         */
        pb_gpvpteam.create = function create(properties) {
            return new pb_gpvpteam(properties);
        };
    
        /**
         * Encodes the specified pb_gpvpteam message. Does not implicitly {@link pb_gpvpteam.verify|verify} messages.
         * @function encode
         * @memberof pb_gpvpteam
         * @static
         * @param {Ipb_gpvpteam} message pb_gpvpteam message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_gpvpteam.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.leader != null && Object.hasOwnProperty.call(message, "leader"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.leader);
            if (message.mbrs != null && message.mbrs.length)
                for (var i = 0; i < message.mbrs.length; ++i)
                    $root.pb_pmbr.encode(message.mbrs[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.sid != null && Object.hasOwnProperty.call(message, "sid"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.sid);
            if (message.score != null && Object.hasOwnProperty.call(message, "score"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.score);
            if (message.rank != null && Object.hasOwnProperty.call(message, "rank"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.rank);
            if (message.power != null && Object.hasOwnProperty.call(message, "power"))
                writer.uint32(/* id 6, wireType 0 =*/48).int64(message.power);
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.name);
            if (message.needPower != null && Object.hasOwnProperty.call(message, "needPower"))
                writer.uint32(/* id 8, wireType 0 =*/64).int64(message.needPower);
            if (message.password != null && Object.hasOwnProperty.call(message, "password"))
                writer.uint32(/* id 9, wireType 2 =*/74).string(message.password);
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 10, wireType 0 =*/80).int32(message.id);
            if (message.reg != null && Object.hasOwnProperty.call(message, "reg"))
                writer.uint32(/* id 11, wireType 0 =*/88).bool(message.reg);
            if (message.enegy != null && Object.hasOwnProperty.call(message, "enegy"))
                writer.uint32(/* id 12, wireType 0 =*/96).int32(message.enegy);
            if (message.enggyCd != null && Object.hasOwnProperty.call(message, "enggyCd"))
                writer.uint32(/* id 13, wireType 0 =*/104).int32(message.enggyCd);
            return writer;
        };
    
        /**
         * Encodes the specified pb_gpvpteam message, length delimited. Does not implicitly {@link pb_gpvpteam.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_gpvpteam
         * @static
         * @param {Ipb_gpvpteam} message pb_gpvpteam message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_gpvpteam.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_gpvpteam message from the specified reader or buffer.
         * @function decode
         * @memberof pb_gpvpteam
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_gpvpteam} pb_gpvpteam
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_gpvpteam.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_gpvpteam();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.leader = reader.int32();
                        break;
                    }
                case 2: {
                        if (!(message.mbrs && message.mbrs.length))
                            message.mbrs = [];
                        message.mbrs.push($root.pb_pmbr.decode(reader, reader.uint32()));
                        break;
                    }
                case 3: {
                        message.sid = reader.int32();
                        break;
                    }
                case 4: {
                        message.score = reader.int32();
                        break;
                    }
                case 5: {
                        message.rank = reader.int32();
                        break;
                    }
                case 6: {
                        message.power = reader.int64();
                        break;
                    }
                case 7: {
                        message.name = reader.string();
                        break;
                    }
                case 8: {
                        message.needPower = reader.int64();
                        break;
                    }
                case 9: {
                        message.password = reader.string();
                        break;
                    }
                case 10: {
                        message.id = reader.int32();
                        break;
                    }
                case 11: {
                        message.reg = reader.bool();
                        break;
                    }
                case 12: {
                        message.enegy = reader.int32();
                        break;
                    }
                case 13: {
                        message.enggyCd = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a pb_gpvpteam message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_gpvpteam
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_gpvpteam} pb_gpvpteam
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_gpvpteam.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_gpvpteam message.
         * @function verify
         * @memberof pb_gpvpteam
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_gpvpteam.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.leader != null && message.hasOwnProperty("leader"))
                if (!$util.isInteger(message.leader))
                    return "leader: integer expected";
            if (message.mbrs != null && message.hasOwnProperty("mbrs")) {
                if (!Array.isArray(message.mbrs))
                    return "mbrs: array expected";
                for (var i = 0; i < message.mbrs.length; ++i) {
                    var error = $root.pb_pmbr.verify(message.mbrs[i]);
                    if (error)
                        return "mbrs." + error;
                }
            }
            if (message.sid != null && message.hasOwnProperty("sid"))
                if (!$util.isInteger(message.sid))
                    return "sid: integer expected";
            if (message.score != null && message.hasOwnProperty("score"))
                if (!$util.isInteger(message.score))
                    return "score: integer expected";
            if (message.rank != null && message.hasOwnProperty("rank"))
                if (!$util.isInteger(message.rank))
                    return "rank: integer expected";
            if (message.power != null && message.hasOwnProperty("power"))
                if (!$util.isInteger(message.power) && !(message.power && $util.isInteger(message.power.low) && $util.isInteger(message.power.high)))
                    return "power: integer|Long expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.needPower != null && message.hasOwnProperty("needPower"))
                if (!$util.isInteger(message.needPower) && !(message.needPower && $util.isInteger(message.needPower.low) && $util.isInteger(message.needPower.high)))
                    return "needPower: integer|Long expected";
            if (message.password != null && message.hasOwnProperty("password"))
                if (!$util.isString(message.password))
                    return "password: string expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id))
                    return "id: integer expected";
            if (message.reg != null && message.hasOwnProperty("reg"))
                if (typeof message.reg !== "boolean")
                    return "reg: boolean expected";
            if (message.enegy != null && message.hasOwnProperty("enegy"))
                if (!$util.isInteger(message.enegy))
                    return "enegy: integer expected";
            if (message.enggyCd != null && message.hasOwnProperty("enggyCd"))
                if (!$util.isInteger(message.enggyCd))
                    return "enggyCd: integer expected";
            return null;
        };
    
        /**
         * Creates a pb_gpvpteam message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_gpvpteam
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_gpvpteam} pb_gpvpteam
         */
        pb_gpvpteam.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_gpvpteam)
                return object;
            var message = new $root.pb_gpvpteam();
            if (object.leader != null)
                message.leader = object.leader | 0;
            if (object.mbrs) {
                if (!Array.isArray(object.mbrs))
                    throw TypeError(".pb_gpvpteam.mbrs: array expected");
                message.mbrs = [];
                for (var i = 0; i < object.mbrs.length; ++i) {
                    if (typeof object.mbrs[i] !== "object")
                        throw TypeError(".pb_gpvpteam.mbrs: object expected");
                    message.mbrs[i] = $root.pb_pmbr.fromObject(object.mbrs[i]);
                }
            }
            if (object.sid != null)
                message.sid = object.sid | 0;
            if (object.score != null)
                message.score = object.score | 0;
            if (object.rank != null)
                message.rank = object.rank | 0;
            if (object.power != null)
                if ($util.Long)
                    (message.power = $util.Long.fromValue(object.power)).unsigned = false;
                else if (typeof object.power === "string")
                    message.power = parseInt(object.power, 10);
                else if (typeof object.power === "number")
                    message.power = object.power;
                else if (typeof object.power === "object")
                    message.power = new $util.LongBits(object.power.low >>> 0, object.power.high >>> 0).toNumber();
            if (object.name != null)
                message.name = String(object.name);
            if (object.needPower != null)
                if ($util.Long)
                    (message.needPower = $util.Long.fromValue(object.needPower)).unsigned = false;
                else if (typeof object.needPower === "string")
                    message.needPower = parseInt(object.needPower, 10);
                else if (typeof object.needPower === "number")
                    message.needPower = object.needPower;
                else if (typeof object.needPower === "object")
                    message.needPower = new $util.LongBits(object.needPower.low >>> 0, object.needPower.high >>> 0).toNumber();
            if (object.password != null)
                message.password = String(object.password);
            if (object.id != null)
                message.id = object.id | 0;
            if (object.reg != null)
                message.reg = Boolean(object.reg);
            if (object.enegy != null)
                message.enegy = object.enegy | 0;
            if (object.enggyCd != null)
                message.enggyCd = object.enggyCd | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a pb_gpvpteam message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_gpvpteam
         * @static
         * @param {pb_gpvpteam} message pb_gpvpteam
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_gpvpteam.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.mbrs = [];
            if (options.defaults) {
                object.leader = 0;
                object.sid = 0;
                object.score = 0;
                object.rank = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.power = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.power = options.longs === String ? "0" : 0;
                object.name = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.needPower = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.needPower = options.longs === String ? "0" : 0;
                object.password = "";
                object.id = 0;
                object.reg = false;
                object.enegy = 0;
                object.enggyCd = 0;
            }
            if (message.leader != null && message.hasOwnProperty("leader"))
                object.leader = message.leader;
            if (message.mbrs && message.mbrs.length) {
                object.mbrs = [];
                for (var j = 0; j < message.mbrs.length; ++j)
                    object.mbrs[j] = $root.pb_pmbr.toObject(message.mbrs[j], options);
            }
            if (message.sid != null && message.hasOwnProperty("sid"))
                object.sid = message.sid;
            if (message.score != null && message.hasOwnProperty("score"))
                object.score = message.score;
            if (message.rank != null && message.hasOwnProperty("rank"))
                object.rank = message.rank;
            if (message.power != null && message.hasOwnProperty("power"))
                if (typeof message.power === "number")
                    object.power = options.longs === String ? String(message.power) : message.power;
                else
                    object.power = options.longs === String ? $util.Long.prototype.toString.call(message.power) : options.longs === Number ? new $util.LongBits(message.power.low >>> 0, message.power.high >>> 0).toNumber() : message.power;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.needPower != null && message.hasOwnProperty("needPower"))
                if (typeof message.needPower === "number")
                    object.needPower = options.longs === String ? String(message.needPower) : message.needPower;
                else
                    object.needPower = options.longs === String ? $util.Long.prototype.toString.call(message.needPower) : options.longs === Number ? new $util.LongBits(message.needPower.low >>> 0, message.needPower.high >>> 0).toNumber() : message.needPower;
            if (message.password != null && message.hasOwnProperty("password"))
                object.password = message.password;
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.reg != null && message.hasOwnProperty("reg"))
                object.reg = message.reg;
            if (message.enegy != null && message.hasOwnProperty("enegy"))
                object.enegy = message.enegy;
            if (message.enggyCd != null && message.hasOwnProperty("enggyCd"))
                object.enggyCd = message.enggyCd;
            return object;
        };
    
        /**
         * Converts this pb_gpvpteam to JSON.
         * @function toJSON
         * @memberof pb_gpvpteam
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_gpvpteam.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_gpvpteam
         * @function getTypeUrl
         * @memberof pb_gpvpteam
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_gpvpteam.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_gpvpteam";
        };
    
        return pb_gpvpteam;
    })();
    
    $root.pb_gpvplog = (function() {
    
        /**
         * Properties of a pb_gpvplog.
         * @exports Ipb_gpvplog
         * @interface Ipb_gpvplog
         * @property {number} logId pb_gpvplog logId
         * @property {Ipb_gpvpteam} enemy pb_gpvplog enemy
         * @property {number|null} [score] pb_gpvplog score
         * @property {boolean|null} [win] pb_gpvplog win
         * @property {number|null} [time] pb_gpvplog time
         */
    
        /**
         * Constructs a new pb_gpvplog.
         * @exports pb_gpvplog
         * @classdesc Represents a pb_gpvplog.
         * @implements Ipb_gpvplog
         * @constructor
         * @param {Ipb_gpvplog=} [properties] Properties to set
         */
        function pb_gpvplog(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_gpvplog logId.
         * @member {number} logId
         * @memberof pb_gpvplog
         * @instance
         */
        pb_gpvplog.prototype.logId = 0;
    
        /**
         * pb_gpvplog enemy.
         * @member {Ipb_gpvpteam} enemy
         * @memberof pb_gpvplog
         * @instance
         */
        pb_gpvplog.prototype.enemy = null;
    
        /**
         * pb_gpvplog score.
         * @member {number} score
         * @memberof pb_gpvplog
         * @instance
         */
        pb_gpvplog.prototype.score = 0;
    
        /**
         * pb_gpvplog win.
         * @member {boolean} win
         * @memberof pb_gpvplog
         * @instance
         */
        pb_gpvplog.prototype.win = false;
    
        /**
         * pb_gpvplog time.
         * @member {number} time
         * @memberof pb_gpvplog
         * @instance
         */
        pb_gpvplog.prototype.time = 0;
    
        /**
         * Creates a new pb_gpvplog instance using the specified properties.
         * @function create
         * @memberof pb_gpvplog
         * @static
         * @param {Ipb_gpvplog=} [properties] Properties to set
         * @returns {pb_gpvplog} pb_gpvplog instance
         */
        pb_gpvplog.create = function create(properties) {
            return new pb_gpvplog(properties);
        };
    
        /**
         * Encodes the specified pb_gpvplog message. Does not implicitly {@link pb_gpvplog.verify|verify} messages.
         * @function encode
         * @memberof pb_gpvplog
         * @static
         * @param {Ipb_gpvplog} message pb_gpvplog message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_gpvplog.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.logId);
            $root.pb_gpvpteam.encode(message.enemy, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.score != null && Object.hasOwnProperty.call(message, "score"))
                writer.uint32(/* id 3, wireType 0 =*/24).sint32(message.score);
            if (message.win != null && Object.hasOwnProperty.call(message, "win"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.win);
            if (message.time != null && Object.hasOwnProperty.call(message, "time"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.time);
            return writer;
        };
    
        /**
         * Encodes the specified pb_gpvplog message, length delimited. Does not implicitly {@link pb_gpvplog.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_gpvplog
         * @static
         * @param {Ipb_gpvplog} message pb_gpvplog message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_gpvplog.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_gpvplog message from the specified reader or buffer.
         * @function decode
         * @memberof pb_gpvplog
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_gpvplog} pb_gpvplog
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_gpvplog.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_gpvplog();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.logId = reader.int32();
                        break;
                    }
                case 2: {
                        message.enemy = $root.pb_gpvpteam.decode(reader, reader.uint32());
                        break;
                    }
                case 3: {
                        message.score = reader.sint32();
                        break;
                    }
                case 4: {
                        message.win = reader.bool();
                        break;
                    }
                case 5: {
                        message.time = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("logId"))
                throw $util.ProtocolError("missing required 'logId'", { instance: message });
            if (!message.hasOwnProperty("enemy"))
                throw $util.ProtocolError("missing required 'enemy'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a pb_gpvplog message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_gpvplog
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_gpvplog} pb_gpvplog
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_gpvplog.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_gpvplog message.
         * @function verify
         * @memberof pb_gpvplog
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_gpvplog.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.logId))
                return "logId: integer expected";
            {
                var error = $root.pb_gpvpteam.verify(message.enemy);
                if (error)
                    return "enemy." + error;
            }
            if (message.score != null && message.hasOwnProperty("score"))
                if (!$util.isInteger(message.score))
                    return "score: integer expected";
            if (message.win != null && message.hasOwnProperty("win"))
                if (typeof message.win !== "boolean")
                    return "win: boolean expected";
            if (message.time != null && message.hasOwnProperty("time"))
                if (!$util.isInteger(message.time))
                    return "time: integer expected";
            return null;
        };
    
        /**
         * Creates a pb_gpvplog message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_gpvplog
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_gpvplog} pb_gpvplog
         */
        pb_gpvplog.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_gpvplog)
                return object;
            var message = new $root.pb_gpvplog();
            if (object.logId != null)
                message.logId = object.logId | 0;
            if (object.enemy != null) {
                if (typeof object.enemy !== "object")
                    throw TypeError(".pb_gpvplog.enemy: object expected");
                message.enemy = $root.pb_gpvpteam.fromObject(object.enemy);
            }
            if (object.score != null)
                message.score = object.score | 0;
            if (object.win != null)
                message.win = Boolean(object.win);
            if (object.time != null)
                message.time = object.time | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a pb_gpvplog message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_gpvplog
         * @static
         * @param {pb_gpvplog} message pb_gpvplog
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_gpvplog.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.logId = 0;
                object.enemy = null;
                object.score = 0;
                object.win = false;
                object.time = 0;
            }
            if (message.logId != null && message.hasOwnProperty("logId"))
                object.logId = message.logId;
            if (message.enemy != null && message.hasOwnProperty("enemy"))
                object.enemy = $root.pb_gpvpteam.toObject(message.enemy, options);
            if (message.score != null && message.hasOwnProperty("score"))
                object.score = message.score;
            if (message.win != null && message.hasOwnProperty("win"))
                object.win = message.win;
            if (message.time != null && message.hasOwnProperty("time"))
                object.time = message.time;
            return object;
        };
    
        /**
         * Converts this pb_gpvplog to JSON.
         * @function toJSON
         * @memberof pb_gpvplog
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_gpvplog.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_gpvplog
         * @function getTypeUrl
         * @memberof pb_gpvplog
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_gpvplog.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_gpvplog";
        };
    
        return pb_gpvplog;
    })();
    
    $root.pb_gpvp_wlog = (function() {
    
        /**
         * Properties of a pb_gpvp_wlog.
         * @exports Ipb_gpvp_wlog
         * @interface Ipb_gpvp_wlog
         * @property {Ipb_gpvpteam} atk pb_gpvp_wlog atk
         * @property {Ipb_gpvpteam} def pb_gpvp_wlog def
         * @property {Array.<boolean>|null} [wins] pb_gpvp_wlog wins
         * @property {Array.<number>|null} [vids] pb_gpvp_wlog vids
         */
    
        /**
         * Constructs a new pb_gpvp_wlog.
         * @exports pb_gpvp_wlog
         * @classdesc Represents a pb_gpvp_wlog.
         * @implements Ipb_gpvp_wlog
         * @constructor
         * @param {Ipb_gpvp_wlog=} [properties] Properties to set
         */
        function pb_gpvp_wlog(properties) {
            this.wins = [];
            this.vids = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_gpvp_wlog atk.
         * @member {Ipb_gpvpteam} atk
         * @memberof pb_gpvp_wlog
         * @instance
         */
        pb_gpvp_wlog.prototype.atk = null;
    
        /**
         * pb_gpvp_wlog def.
         * @member {Ipb_gpvpteam} def
         * @memberof pb_gpvp_wlog
         * @instance
         */
        pb_gpvp_wlog.prototype.def = null;
    
        /**
         * pb_gpvp_wlog wins.
         * @member {Array.<boolean>} wins
         * @memberof pb_gpvp_wlog
         * @instance
         */
        pb_gpvp_wlog.prototype.wins = $util.emptyArray;
    
        /**
         * pb_gpvp_wlog vids.
         * @member {Array.<number>} vids
         * @memberof pb_gpvp_wlog
         * @instance
         */
        pb_gpvp_wlog.prototype.vids = $util.emptyArray;
    
        /**
         * Creates a new pb_gpvp_wlog instance using the specified properties.
         * @function create
         * @memberof pb_gpvp_wlog
         * @static
         * @param {Ipb_gpvp_wlog=} [properties] Properties to set
         * @returns {pb_gpvp_wlog} pb_gpvp_wlog instance
         */
        pb_gpvp_wlog.create = function create(properties) {
            return new pb_gpvp_wlog(properties);
        };
    
        /**
         * Encodes the specified pb_gpvp_wlog message. Does not implicitly {@link pb_gpvp_wlog.verify|verify} messages.
         * @function encode
         * @memberof pb_gpvp_wlog
         * @static
         * @param {Ipb_gpvp_wlog} message pb_gpvp_wlog message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_gpvp_wlog.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.pb_gpvpteam.encode(message.atk, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            $root.pb_gpvpteam.encode(message.def, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.wins != null && message.wins.length)
                for (var i = 0; i < message.wins.length; ++i)
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.wins[i]);
            if (message.vids != null && message.vids.length)
                for (var i = 0; i < message.vids.length; ++i)
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.vids[i]);
            return writer;
        };
    
        /**
         * Encodes the specified pb_gpvp_wlog message, length delimited. Does not implicitly {@link pb_gpvp_wlog.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_gpvp_wlog
         * @static
         * @param {Ipb_gpvp_wlog} message pb_gpvp_wlog message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_gpvp_wlog.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_gpvp_wlog message from the specified reader or buffer.
         * @function decode
         * @memberof pb_gpvp_wlog
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_gpvp_wlog} pb_gpvp_wlog
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_gpvp_wlog.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_gpvp_wlog();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.atk = $root.pb_gpvpteam.decode(reader, reader.uint32());
                        break;
                    }
                case 2: {
                        message.def = $root.pb_gpvpteam.decode(reader, reader.uint32());
                        break;
                    }
                case 3: {
                        if (!(message.wins && message.wins.length))
                            message.wins = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.wins.push(reader.bool());
                        } else
                            message.wins.push(reader.bool());
                        break;
                    }
                case 4: {
                        if (!(message.vids && message.vids.length))
                            message.vids = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.vids.push(reader.int32());
                        } else
                            message.vids.push(reader.int32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("atk"))
                throw $util.ProtocolError("missing required 'atk'", { instance: message });
            if (!message.hasOwnProperty("def"))
                throw $util.ProtocolError("missing required 'def'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a pb_gpvp_wlog message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_gpvp_wlog
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_gpvp_wlog} pb_gpvp_wlog
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_gpvp_wlog.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_gpvp_wlog message.
         * @function verify
         * @memberof pb_gpvp_wlog
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_gpvp_wlog.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            {
                var error = $root.pb_gpvpteam.verify(message.atk);
                if (error)
                    return "atk." + error;
            }
            {
                var error = $root.pb_gpvpteam.verify(message.def);
                if (error)
                    return "def." + error;
            }
            if (message.wins != null && message.hasOwnProperty("wins")) {
                if (!Array.isArray(message.wins))
                    return "wins: array expected";
                for (var i = 0; i < message.wins.length; ++i)
                    if (typeof message.wins[i] !== "boolean")
                        return "wins: boolean[] expected";
            }
            if (message.vids != null && message.hasOwnProperty("vids")) {
                if (!Array.isArray(message.vids))
                    return "vids: array expected";
                for (var i = 0; i < message.vids.length; ++i)
                    if (!$util.isInteger(message.vids[i]))
                        return "vids: integer[] expected";
            }
            return null;
        };
    
        /**
         * Creates a pb_gpvp_wlog message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_gpvp_wlog
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_gpvp_wlog} pb_gpvp_wlog
         */
        pb_gpvp_wlog.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_gpvp_wlog)
                return object;
            var message = new $root.pb_gpvp_wlog();
            if (object.atk != null) {
                if (typeof object.atk !== "object")
                    throw TypeError(".pb_gpvp_wlog.atk: object expected");
                message.atk = $root.pb_gpvpteam.fromObject(object.atk);
            }
            if (object.def != null) {
                if (typeof object.def !== "object")
                    throw TypeError(".pb_gpvp_wlog.def: object expected");
                message.def = $root.pb_gpvpteam.fromObject(object.def);
            }
            if (object.wins) {
                if (!Array.isArray(object.wins))
                    throw TypeError(".pb_gpvp_wlog.wins: array expected");
                message.wins = [];
                for (var i = 0; i < object.wins.length; ++i)
                    message.wins[i] = Boolean(object.wins[i]);
            }
            if (object.vids) {
                if (!Array.isArray(object.vids))
                    throw TypeError(".pb_gpvp_wlog.vids: array expected");
                message.vids = [];
                for (var i = 0; i < object.vids.length; ++i)
                    message.vids[i] = object.vids[i] | 0;
            }
            return message;
        };
    
        /**
         * Creates a plain object from a pb_gpvp_wlog message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_gpvp_wlog
         * @static
         * @param {pb_gpvp_wlog} message pb_gpvp_wlog
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_gpvp_wlog.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.wins = [];
                object.vids = [];
            }
            if (options.defaults) {
                object.atk = null;
                object.def = null;
            }
            if (message.atk != null && message.hasOwnProperty("atk"))
                object.atk = $root.pb_gpvpteam.toObject(message.atk, options);
            if (message.def != null && message.hasOwnProperty("def"))
                object.def = $root.pb_gpvpteam.toObject(message.def, options);
            if (message.wins && message.wins.length) {
                object.wins = [];
                for (var j = 0; j < message.wins.length; ++j)
                    object.wins[j] = message.wins[j];
            }
            if (message.vids && message.vids.length) {
                object.vids = [];
                for (var j = 0; j < message.vids.length; ++j)
                    object.vids[j] = message.vids[j];
            }
            return object;
        };
    
        /**
         * Converts this pb_gpvp_wlog to JSON.
         * @function toJSON
         * @memberof pb_gpvp_wlog
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_gpvp_wlog.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_gpvp_wlog
         * @function getTypeUrl
         * @memberof pb_gpvp_wlog
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_gpvp_wlog.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_gpvp_wlog";
        };
    
        return pb_gpvp_wlog;
    })();
    
    $root.pb_pet = (function() {
    
        /**
         * Properties of a pb_pet.
         * @exports Ipb_pet
         * @interface Ipb_pet
         * @property {number} id pb_pet id
         * @property {number} lv pb_pet lv
         * @property {number} star pb_pet star
         * @property {Array.<number>|null} [skl] pb_pet skl
         */
    
        /**
         * Constructs a new pb_pet.
         * @exports pb_pet
         * @classdesc Represents a pb_pet.
         * @implements Ipb_pet
         * @constructor
         * @param {Ipb_pet=} [properties] Properties to set
         */
        function pb_pet(properties) {
            this.skl = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_pet id.
         * @member {number} id
         * @memberof pb_pet
         * @instance
         */
        pb_pet.prototype.id = 0;
    
        /**
         * pb_pet lv.
         * @member {number} lv
         * @memberof pb_pet
         * @instance
         */
        pb_pet.prototype.lv = 0;
    
        /**
         * pb_pet star.
         * @member {number} star
         * @memberof pb_pet
         * @instance
         */
        pb_pet.prototype.star = 0;
    
        /**
         * pb_pet skl.
         * @member {Array.<number>} skl
         * @memberof pb_pet
         * @instance
         */
        pb_pet.prototype.skl = $util.emptyArray;
    
        /**
         * Creates a new pb_pet instance using the specified properties.
         * @function create
         * @memberof pb_pet
         * @static
         * @param {Ipb_pet=} [properties] Properties to set
         * @returns {pb_pet} pb_pet instance
         */
        pb_pet.create = function create(properties) {
            return new pb_pet(properties);
        };
    
        /**
         * Encodes the specified pb_pet message. Does not implicitly {@link pb_pet.verify|verify} messages.
         * @function encode
         * @memberof pb_pet
         * @static
         * @param {Ipb_pet} message pb_pet message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_pet.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.id);
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.lv);
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.star);
            if (message.skl != null && message.skl.length)
                for (var i = 0; i < message.skl.length; ++i)
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.skl[i]);
            return writer;
        };
    
        /**
         * Encodes the specified pb_pet message, length delimited. Does not implicitly {@link pb_pet.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_pet
         * @static
         * @param {Ipb_pet} message pb_pet message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_pet.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_pet message from the specified reader or buffer.
         * @function decode
         * @memberof pb_pet
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_pet} pb_pet
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_pet.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_pet();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.id = reader.int32();
                        break;
                    }
                case 2: {
                        message.lv = reader.int32();
                        break;
                    }
                case 3: {
                        message.star = reader.int32();
                        break;
                    }
                case 4: {
                        if (!(message.skl && message.skl.length))
                            message.skl = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.skl.push(reader.int32());
                        } else
                            message.skl.push(reader.int32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("id"))
                throw $util.ProtocolError("missing required 'id'", { instance: message });
            if (!message.hasOwnProperty("lv"))
                throw $util.ProtocolError("missing required 'lv'", { instance: message });
            if (!message.hasOwnProperty("star"))
                throw $util.ProtocolError("missing required 'star'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a pb_pet message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_pet
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_pet} pb_pet
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_pet.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_pet message.
         * @function verify
         * @memberof pb_pet
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_pet.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.id))
                return "id: integer expected";
            if (!$util.isInteger(message.lv))
                return "lv: integer expected";
            if (!$util.isInteger(message.star))
                return "star: integer expected";
            if (message.skl != null && message.hasOwnProperty("skl")) {
                if (!Array.isArray(message.skl))
                    return "skl: array expected";
                for (var i = 0; i < message.skl.length; ++i)
                    if (!$util.isInteger(message.skl[i]))
                        return "skl: integer[] expected";
            }
            return null;
        };
    
        /**
         * Creates a pb_pet message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_pet
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_pet} pb_pet
         */
        pb_pet.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_pet)
                return object;
            var message = new $root.pb_pet();
            if (object.id != null)
                message.id = object.id | 0;
            if (object.lv != null)
                message.lv = object.lv | 0;
            if (object.star != null)
                message.star = object.star | 0;
            if (object.skl) {
                if (!Array.isArray(object.skl))
                    throw TypeError(".pb_pet.skl: array expected");
                message.skl = [];
                for (var i = 0; i < object.skl.length; ++i)
                    message.skl[i] = object.skl[i] | 0;
            }
            return message;
        };
    
        /**
         * Creates a plain object from a pb_pet message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_pet
         * @static
         * @param {pb_pet} message pb_pet
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_pet.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.skl = [];
            if (options.defaults) {
                object.id = 0;
                object.lv = 0;
                object.star = 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.lv != null && message.hasOwnProperty("lv"))
                object.lv = message.lv;
            if (message.star != null && message.hasOwnProperty("star"))
                object.star = message.star;
            if (message.skl && message.skl.length) {
                object.skl = [];
                for (var j = 0; j < message.skl.length; ++j)
                    object.skl[j] = message.skl[j];
            }
            return object;
        };
    
        /**
         * Converts this pb_pet to JSON.
         * @function toJSON
         * @memberof pb_pet
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_pet.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_pet
         * @function getTypeUrl
         * @memberof pb_pet
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_pet.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_pet";
        };
    
        return pb_pet;
    })();
    
    $root.pb_spkunit = (function() {
    
        /**
         * Properties of a pb_spkunit.
         * @exports Ipb_spkunit
         * @interface Ipb_spkunit
         * @property {Ipb_unit|null} [base] pb_spkunit base
         * @property {Array.<Ipb_item>|null} [buf] pb_spkunit buf
         */
    
        /**
         * Constructs a new pb_spkunit.
         * @exports pb_spkunit
         * @classdesc Represents a pb_spkunit.
         * @implements Ipb_spkunit
         * @constructor
         * @param {Ipb_spkunit=} [properties] Properties to set
         */
        function pb_spkunit(properties) {
            this.buf = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_spkunit base.
         * @member {Ipb_unit|null|undefined} base
         * @memberof pb_spkunit
         * @instance
         */
        pb_spkunit.prototype.base = null;
    
        /**
         * pb_spkunit buf.
         * @member {Array.<Ipb_item>} buf
         * @memberof pb_spkunit
         * @instance
         */
        pb_spkunit.prototype.buf = $util.emptyArray;
    
        /**
         * Creates a new pb_spkunit instance using the specified properties.
         * @function create
         * @memberof pb_spkunit
         * @static
         * @param {Ipb_spkunit=} [properties] Properties to set
         * @returns {pb_spkunit} pb_spkunit instance
         */
        pb_spkunit.create = function create(properties) {
            return new pb_spkunit(properties);
        };
    
        /**
         * Encodes the specified pb_spkunit message. Does not implicitly {@link pb_spkunit.verify|verify} messages.
         * @function encode
         * @memberof pb_spkunit
         * @static
         * @param {Ipb_spkunit} message pb_spkunit message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_spkunit.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.base != null && Object.hasOwnProperty.call(message, "base"))
                $root.pb_unit.encode(message.base, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.buf != null && message.buf.length)
                for (var i = 0; i < message.buf.length; ++i)
                    $root.pb_item.encode(message.buf[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified pb_spkunit message, length delimited. Does not implicitly {@link pb_spkunit.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_spkunit
         * @static
         * @param {Ipb_spkunit} message pb_spkunit message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_spkunit.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_spkunit message from the specified reader or buffer.
         * @function decode
         * @memberof pb_spkunit
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_spkunit} pb_spkunit
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_spkunit.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_spkunit();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.base = $root.pb_unit.decode(reader, reader.uint32());
                        break;
                    }
                case 2: {
                        if (!(message.buf && message.buf.length))
                            message.buf = [];
                        message.buf.push($root.pb_item.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a pb_spkunit message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_spkunit
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_spkunit} pb_spkunit
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_spkunit.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_spkunit message.
         * @function verify
         * @memberof pb_spkunit
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_spkunit.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.base != null && message.hasOwnProperty("base")) {
                var error = $root.pb_unit.verify(message.base);
                if (error)
                    return "base." + error;
            }
            if (message.buf != null && message.hasOwnProperty("buf")) {
                if (!Array.isArray(message.buf))
                    return "buf: array expected";
                for (var i = 0; i < message.buf.length; ++i) {
                    var error = $root.pb_item.verify(message.buf[i]);
                    if (error)
                        return "buf." + error;
                }
            }
            return null;
        };
    
        /**
         * Creates a pb_spkunit message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_spkunit
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_spkunit} pb_spkunit
         */
        pb_spkunit.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_spkunit)
                return object;
            var message = new $root.pb_spkunit();
            if (object.base != null) {
                if (typeof object.base !== "object")
                    throw TypeError(".pb_spkunit.base: object expected");
                message.base = $root.pb_unit.fromObject(object.base);
            }
            if (object.buf) {
                if (!Array.isArray(object.buf))
                    throw TypeError(".pb_spkunit.buf: array expected");
                message.buf = [];
                for (var i = 0; i < object.buf.length; ++i) {
                    if (typeof object.buf[i] !== "object")
                        throw TypeError(".pb_spkunit.buf: object expected");
                    message.buf[i] = $root.pb_item.fromObject(object.buf[i]);
                }
            }
            return message;
        };
    
        /**
         * Creates a plain object from a pb_spkunit message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_spkunit
         * @static
         * @param {pb_spkunit} message pb_spkunit
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_spkunit.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.buf = [];
            if (options.defaults)
                object.base = null;
            if (message.base != null && message.hasOwnProperty("base"))
                object.base = $root.pb_unit.toObject(message.base, options);
            if (message.buf && message.buf.length) {
                object.buf = [];
                for (var j = 0; j < message.buf.length; ++j)
                    object.buf[j] = $root.pb_item.toObject(message.buf[j], options);
            }
            return object;
        };
    
        /**
         * Converts this pb_spkunit to JSON.
         * @function toJSON
         * @memberof pb_spkunit
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_spkunit.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_spkunit
         * @function getTypeUrl
         * @memberof pb_spkunit
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_spkunit.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_spkunit";
        };
    
        return pb_spkunit;
    })();
    
    $root.pb_spkmbr = (function() {
    
        /**
         * Properties of a pb_spkmbr.
         * @exports Ipb_spkmbr
         * @interface Ipb_spkmbr
         * @property {number} uid pb_spkmbr uid
         * @property {number} lv pb_spkmbr lv
         * @property {number} wave pb_spkmbr wave
         * @property {number} time pb_spkmbr time
         * @property {number} logo pb_spkmbr logo
         * @property {string} name pb_spkmbr name
         * @property {number|null} [border] pb_spkmbr border
         */
    
        /**
         * Constructs a new pb_spkmbr.
         * @exports pb_spkmbr
         * @classdesc Represents a pb_spkmbr.
         * @implements Ipb_spkmbr
         * @constructor
         * @param {Ipb_spkmbr=} [properties] Properties to set
         */
        function pb_spkmbr(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_spkmbr uid.
         * @member {number} uid
         * @memberof pb_spkmbr
         * @instance
         */
        pb_spkmbr.prototype.uid = 0;
    
        /**
         * pb_spkmbr lv.
         * @member {number} lv
         * @memberof pb_spkmbr
         * @instance
         */
        pb_spkmbr.prototype.lv = 0;
    
        /**
         * pb_spkmbr wave.
         * @member {number} wave
         * @memberof pb_spkmbr
         * @instance
         */
        pb_spkmbr.prototype.wave = 0;
    
        /**
         * pb_spkmbr time.
         * @member {number} time
         * @memberof pb_spkmbr
         * @instance
         */
        pb_spkmbr.prototype.time = 0;
    
        /**
         * pb_spkmbr logo.
         * @member {number} logo
         * @memberof pb_spkmbr
         * @instance
         */
        pb_spkmbr.prototype.logo = 0;
    
        /**
         * pb_spkmbr name.
         * @member {string} name
         * @memberof pb_spkmbr
         * @instance
         */
        pb_spkmbr.prototype.name = "";
    
        /**
         * pb_spkmbr border.
         * @member {number} border
         * @memberof pb_spkmbr
         * @instance
         */
        pb_spkmbr.prototype.border = 0;
    
        /**
         * Creates a new pb_spkmbr instance using the specified properties.
         * @function create
         * @memberof pb_spkmbr
         * @static
         * @param {Ipb_spkmbr=} [properties] Properties to set
         * @returns {pb_spkmbr} pb_spkmbr instance
         */
        pb_spkmbr.create = function create(properties) {
            return new pb_spkmbr(properties);
        };
    
        /**
         * Encodes the specified pb_spkmbr message. Does not implicitly {@link pb_spkmbr.verify|verify} messages.
         * @function encode
         * @memberof pb_spkmbr
         * @static
         * @param {Ipb_spkmbr} message pb_spkmbr message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_spkmbr.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.uid);
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.lv);
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.wave);
            writer.uint32(/* id 4, wireType 0 =*/32).int32(message.time);
            writer.uint32(/* id 5, wireType 0 =*/40).int32(message.logo);
            writer.uint32(/* id 6, wireType 2 =*/50).string(message.name);
            if (message.border != null && Object.hasOwnProperty.call(message, "border"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.border);
            return writer;
        };
    
        /**
         * Encodes the specified pb_spkmbr message, length delimited. Does not implicitly {@link pb_spkmbr.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_spkmbr
         * @static
         * @param {Ipb_spkmbr} message pb_spkmbr message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_spkmbr.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_spkmbr message from the specified reader or buffer.
         * @function decode
         * @memberof pb_spkmbr
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_spkmbr} pb_spkmbr
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_spkmbr.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_spkmbr();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.uid = reader.int32();
                        break;
                    }
                case 2: {
                        message.lv = reader.int32();
                        break;
                    }
                case 3: {
                        message.wave = reader.int32();
                        break;
                    }
                case 4: {
                        message.time = reader.int32();
                        break;
                    }
                case 5: {
                        message.logo = reader.int32();
                        break;
                    }
                case 6: {
                        message.name = reader.string();
                        break;
                    }
                case 7: {
                        message.border = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("uid"))
                throw $util.ProtocolError("missing required 'uid'", { instance: message });
            if (!message.hasOwnProperty("lv"))
                throw $util.ProtocolError("missing required 'lv'", { instance: message });
            if (!message.hasOwnProperty("wave"))
                throw $util.ProtocolError("missing required 'wave'", { instance: message });
            if (!message.hasOwnProperty("time"))
                throw $util.ProtocolError("missing required 'time'", { instance: message });
            if (!message.hasOwnProperty("logo"))
                throw $util.ProtocolError("missing required 'logo'", { instance: message });
            if (!message.hasOwnProperty("name"))
                throw $util.ProtocolError("missing required 'name'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a pb_spkmbr message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_spkmbr
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_spkmbr} pb_spkmbr
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_spkmbr.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_spkmbr message.
         * @function verify
         * @memberof pb_spkmbr
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_spkmbr.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.uid))
                return "uid: integer expected";
            if (!$util.isInteger(message.lv))
                return "lv: integer expected";
            if (!$util.isInteger(message.wave))
                return "wave: integer expected";
            if (!$util.isInteger(message.time))
                return "time: integer expected";
            if (!$util.isInteger(message.logo))
                return "logo: integer expected";
            if (!$util.isString(message.name))
                return "name: string expected";
            if (message.border != null && message.hasOwnProperty("border"))
                if (!$util.isInteger(message.border))
                    return "border: integer expected";
            return null;
        };
    
        /**
         * Creates a pb_spkmbr message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_spkmbr
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_spkmbr} pb_spkmbr
         */
        pb_spkmbr.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_spkmbr)
                return object;
            var message = new $root.pb_spkmbr();
            if (object.uid != null)
                message.uid = object.uid | 0;
            if (object.lv != null)
                message.lv = object.lv | 0;
            if (object.wave != null)
                message.wave = object.wave | 0;
            if (object.time != null)
                message.time = object.time | 0;
            if (object.logo != null)
                message.logo = object.logo | 0;
            if (object.name != null)
                message.name = String(object.name);
            if (object.border != null)
                message.border = object.border | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a pb_spkmbr message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_spkmbr
         * @static
         * @param {pb_spkmbr} message pb_spkmbr
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_spkmbr.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.uid = 0;
                object.lv = 0;
                object.wave = 0;
                object.time = 0;
                object.logo = 0;
                object.name = "";
                object.border = 0;
            }
            if (message.uid != null && message.hasOwnProperty("uid"))
                object.uid = message.uid;
            if (message.lv != null && message.hasOwnProperty("lv"))
                object.lv = message.lv;
            if (message.wave != null && message.hasOwnProperty("wave"))
                object.wave = message.wave;
            if (message.time != null && message.hasOwnProperty("time"))
                object.time = message.time;
            if (message.logo != null && message.hasOwnProperty("logo"))
                object.logo = message.logo;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.border != null && message.hasOwnProperty("border"))
                object.border = message.border;
            return object;
        };
    
        /**
         * Converts this pb_spkmbr to JSON.
         * @function toJSON
         * @memberof pb_spkmbr
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_spkmbr.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_spkmbr
         * @function getTypeUrl
         * @memberof pb_spkmbr
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_spkmbr.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_spkmbr";
        };
    
        return pb_spkmbr;
    })();
    
    $root.pb_holy = (function() {
    
        /**
         * Properties of a pb_holy.
         * @exports Ipb_holy
         * @interface Ipb_holy
         * @property {number} id pb_holy id
         * @property {number} pos pb_holy pos
         * @property {number|null} [val] pb_holy val
         */
    
        /**
         * Constructs a new pb_holy.
         * @exports pb_holy
         * @classdesc Represents a pb_holy.
         * @implements Ipb_holy
         * @constructor
         * @param {Ipb_holy=} [properties] Properties to set
         */
        function pb_holy(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_holy id.
         * @member {number} id
         * @memberof pb_holy
         * @instance
         */
        pb_holy.prototype.id = 0;
    
        /**
         * pb_holy pos.
         * @member {number} pos
         * @memberof pb_holy
         * @instance
         */
        pb_holy.prototype.pos = 0;
    
        /**
         * pb_holy val.
         * @member {number} val
         * @memberof pb_holy
         * @instance
         */
        pb_holy.prototype.val = 0;
    
        /**
         * Creates a new pb_holy instance using the specified properties.
         * @function create
         * @memberof pb_holy
         * @static
         * @param {Ipb_holy=} [properties] Properties to set
         * @returns {pb_holy} pb_holy instance
         */
        pb_holy.create = function create(properties) {
            return new pb_holy(properties);
        };
    
        /**
         * Encodes the specified pb_holy message. Does not implicitly {@link pb_holy.verify|verify} messages.
         * @function encode
         * @memberof pb_holy
         * @static
         * @param {Ipb_holy} message pb_holy message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_holy.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.id);
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.pos);
            if (message.val != null && Object.hasOwnProperty.call(message, "val"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.val);
            return writer;
        };
    
        /**
         * Encodes the specified pb_holy message, length delimited. Does not implicitly {@link pb_holy.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_holy
         * @static
         * @param {Ipb_holy} message pb_holy message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_holy.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_holy message from the specified reader or buffer.
         * @function decode
         * @memberof pb_holy
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_holy} pb_holy
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_holy.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_holy();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.id = reader.int32();
                        break;
                    }
                case 2: {
                        message.pos = reader.int32();
                        break;
                    }
                case 3: {
                        message.val = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("id"))
                throw $util.ProtocolError("missing required 'id'", { instance: message });
            if (!message.hasOwnProperty("pos"))
                throw $util.ProtocolError("missing required 'pos'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a pb_holy message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_holy
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_holy} pb_holy
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_holy.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_holy message.
         * @function verify
         * @memberof pb_holy
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_holy.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.id))
                return "id: integer expected";
            if (!$util.isInteger(message.pos))
                return "pos: integer expected";
            if (message.val != null && message.hasOwnProperty("val"))
                if (!$util.isInteger(message.val))
                    return "val: integer expected";
            return null;
        };
    
        /**
         * Creates a pb_holy message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_holy
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_holy} pb_holy
         */
        pb_holy.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_holy)
                return object;
            var message = new $root.pb_holy();
            if (object.id != null)
                message.id = object.id | 0;
            if (object.pos != null)
                message.pos = object.pos | 0;
            if (object.val != null)
                message.val = object.val | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a pb_holy message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_holy
         * @static
         * @param {pb_holy} message pb_holy
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_holy.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = 0;
                object.pos = 0;
                object.val = 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.pos != null && message.hasOwnProperty("pos"))
                object.pos = message.pos;
            if (message.val != null && message.hasOwnProperty("val"))
                object.val = message.val;
            return object;
        };
    
        /**
         * Converts this pb_holy to JSON.
         * @function toJSON
         * @memberof pb_holy
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_holy.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_holy
         * @function getTypeUrl
         * @memberof pb_holy
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_holy.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_holy";
        };
    
        return pb_holy;
    })();
    
    $root.pb_mine = (function() {
    
        /**
         * Properties of a pb_mine.
         * @exports Ipb_mine
         * @interface Ipb_mine
         * @property {number} id pb_mine id
         * @property {number} pos pb_mine pos
         * @property {number} val pb_mine val
         */
    
        /**
         * Constructs a new pb_mine.
         * @exports pb_mine
         * @classdesc Represents a pb_mine.
         * @implements Ipb_mine
         * @constructor
         * @param {Ipb_mine=} [properties] Properties to set
         */
        function pb_mine(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_mine id.
         * @member {number} id
         * @memberof pb_mine
         * @instance
         */
        pb_mine.prototype.id = 0;
    
        /**
         * pb_mine pos.
         * @member {number} pos
         * @memberof pb_mine
         * @instance
         */
        pb_mine.prototype.pos = 0;
    
        /**
         * pb_mine val.
         * @member {number} val
         * @memberof pb_mine
         * @instance
         */
        pb_mine.prototype.val = 0;
    
        /**
         * Creates a new pb_mine instance using the specified properties.
         * @function create
         * @memberof pb_mine
         * @static
         * @param {Ipb_mine=} [properties] Properties to set
         * @returns {pb_mine} pb_mine instance
         */
        pb_mine.create = function create(properties) {
            return new pb_mine(properties);
        };
    
        /**
         * Encodes the specified pb_mine message. Does not implicitly {@link pb_mine.verify|verify} messages.
         * @function encode
         * @memberof pb_mine
         * @static
         * @param {Ipb_mine} message pb_mine message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_mine.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.id);
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.pos);
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.val);
            return writer;
        };
    
        /**
         * Encodes the specified pb_mine message, length delimited. Does not implicitly {@link pb_mine.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_mine
         * @static
         * @param {Ipb_mine} message pb_mine message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_mine.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_mine message from the specified reader or buffer.
         * @function decode
         * @memberof pb_mine
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_mine} pb_mine
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_mine.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_mine();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.id = reader.int32();
                        break;
                    }
                case 2: {
                        message.pos = reader.int32();
                        break;
                    }
                case 3: {
                        message.val = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("id"))
                throw $util.ProtocolError("missing required 'id'", { instance: message });
            if (!message.hasOwnProperty("pos"))
                throw $util.ProtocolError("missing required 'pos'", { instance: message });
            if (!message.hasOwnProperty("val"))
                throw $util.ProtocolError("missing required 'val'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a pb_mine message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_mine
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_mine} pb_mine
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_mine.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_mine message.
         * @function verify
         * @memberof pb_mine
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_mine.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.id))
                return "id: integer expected";
            if (!$util.isInteger(message.pos))
                return "pos: integer expected";
            if (!$util.isInteger(message.val))
                return "val: integer expected";
            return null;
        };
    
        /**
         * Creates a pb_mine message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_mine
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_mine} pb_mine
         */
        pb_mine.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_mine)
                return object;
            var message = new $root.pb_mine();
            if (object.id != null)
                message.id = object.id | 0;
            if (object.pos != null)
                message.pos = object.pos | 0;
            if (object.val != null)
                message.val = object.val | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a pb_mine message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_mine
         * @static
         * @param {pb_mine} message pb_mine
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_mine.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = 0;
                object.pos = 0;
                object.val = 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.pos != null && message.hasOwnProperty("pos"))
                object.pos = message.pos;
            if (message.val != null && message.hasOwnProperty("val"))
                object.val = message.val;
            return object;
        };
    
        /**
         * Converts this pb_mine to JSON.
         * @function toJSON
         * @memberof pb_mine
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_mine.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_mine
         * @function getTypeUrl
         * @memberof pb_mine
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_mine.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_mine";
        };
    
        return pb_mine;
    })();
    
    $root.pb_land = (function() {
    
        /**
         * Properties of a pb_land.
         * @exports Ipb_land
         * @interface Ipb_land
         * @property {number} id pb_land id
         * @property {number} pos pb_land pos
         * @property {number|null} [cd] pb_land cd
         * @property {number|null} [cdk] pb_land cdk
         * @property {boolean|null} [dead] pb_land dead
         */
    
        /**
         * Constructs a new pb_land.
         * @exports pb_land
         * @classdesc Represents a pb_land.
         * @implements Ipb_land
         * @constructor
         * @param {Ipb_land=} [properties] Properties to set
         */
        function pb_land(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_land id.
         * @member {number} id
         * @memberof pb_land
         * @instance
         */
        pb_land.prototype.id = 0;
    
        /**
         * pb_land pos.
         * @member {number} pos
         * @memberof pb_land
         * @instance
         */
        pb_land.prototype.pos = 0;
    
        /**
         * pb_land cd.
         * @member {number} cd
         * @memberof pb_land
         * @instance
         */
        pb_land.prototype.cd = 0;
    
        /**
         * pb_land cdk.
         * @member {number} cdk
         * @memberof pb_land
         * @instance
         */
        pb_land.prototype.cdk = 0;
    
        /**
         * pb_land dead.
         * @member {boolean} dead
         * @memberof pb_land
         * @instance
         */
        pb_land.prototype.dead = false;
    
        /**
         * Creates a new pb_land instance using the specified properties.
         * @function create
         * @memberof pb_land
         * @static
         * @param {Ipb_land=} [properties] Properties to set
         * @returns {pb_land} pb_land instance
         */
        pb_land.create = function create(properties) {
            return new pb_land(properties);
        };
    
        /**
         * Encodes the specified pb_land message. Does not implicitly {@link pb_land.verify|verify} messages.
         * @function encode
         * @memberof pb_land
         * @static
         * @param {Ipb_land} message pb_land message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_land.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.id);
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.pos);
            if (message.cd != null && Object.hasOwnProperty.call(message, "cd"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.cd);
            if (message.cdk != null && Object.hasOwnProperty.call(message, "cdk"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.cdk);
            if (message.dead != null && Object.hasOwnProperty.call(message, "dead"))
                writer.uint32(/* id 5, wireType 0 =*/40).bool(message.dead);
            return writer;
        };
    
        /**
         * Encodes the specified pb_land message, length delimited. Does not implicitly {@link pb_land.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_land
         * @static
         * @param {Ipb_land} message pb_land message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_land.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_land message from the specified reader or buffer.
         * @function decode
         * @memberof pb_land
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_land} pb_land
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_land.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_land();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.id = reader.int32();
                        break;
                    }
                case 2: {
                        message.pos = reader.int32();
                        break;
                    }
                case 3: {
                        message.cd = reader.int32();
                        break;
                    }
                case 4: {
                        message.cdk = reader.int32();
                        break;
                    }
                case 5: {
                        message.dead = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("id"))
                throw $util.ProtocolError("missing required 'id'", { instance: message });
            if (!message.hasOwnProperty("pos"))
                throw $util.ProtocolError("missing required 'pos'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a pb_land message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_land
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_land} pb_land
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_land.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_land message.
         * @function verify
         * @memberof pb_land
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_land.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.id))
                return "id: integer expected";
            if (!$util.isInteger(message.pos))
                return "pos: integer expected";
            if (message.cd != null && message.hasOwnProperty("cd"))
                if (!$util.isInteger(message.cd))
                    return "cd: integer expected";
            if (message.cdk != null && message.hasOwnProperty("cdk"))
                if (!$util.isInteger(message.cdk))
                    return "cdk: integer expected";
            if (message.dead != null && message.hasOwnProperty("dead"))
                if (typeof message.dead !== "boolean")
                    return "dead: boolean expected";
            return null;
        };
    
        /**
         * Creates a pb_land message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_land
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_land} pb_land
         */
        pb_land.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_land)
                return object;
            var message = new $root.pb_land();
            if (object.id != null)
                message.id = object.id | 0;
            if (object.pos != null)
                message.pos = object.pos | 0;
            if (object.cd != null)
                message.cd = object.cd | 0;
            if (object.cdk != null)
                message.cdk = object.cdk | 0;
            if (object.dead != null)
                message.dead = Boolean(object.dead);
            return message;
        };
    
        /**
         * Creates a plain object from a pb_land message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_land
         * @static
         * @param {pb_land} message pb_land
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_land.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = 0;
                object.pos = 0;
                object.cd = 0;
                object.cdk = 0;
                object.dead = false;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.pos != null && message.hasOwnProperty("pos"))
                object.pos = message.pos;
            if (message.cd != null && message.hasOwnProperty("cd"))
                object.cd = message.cd;
            if (message.cdk != null && message.hasOwnProperty("cdk"))
                object.cdk = message.cdk;
            if (message.dead != null && message.hasOwnProperty("dead"))
                object.dead = message.dead;
            return object;
        };
    
        /**
         * Converts this pb_land to JSON.
         * @function toJSON
         * @memberof pb_land
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_land.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_land
         * @function getTypeUrl
         * @memberof pb_land
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_land.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_land";
        };
    
        return pb_land;
    })();
    
    $root.pb_vit = (function() {
    
        /**
         * Properties of a pb_vit.
         * @exports Ipb_vit
         * @interface Ipb_vit
         * @property {number} vit pb_vit vit
         * @property {number|null} [buy] pb_vit buy
         */
    
        /**
         * Constructs a new pb_vit.
         * @exports pb_vit
         * @classdesc Represents a pb_vit.
         * @implements Ipb_vit
         * @constructor
         * @param {Ipb_vit=} [properties] Properties to set
         */
        function pb_vit(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_vit vit.
         * @member {number} vit
         * @memberof pb_vit
         * @instance
         */
        pb_vit.prototype.vit = 0;
    
        /**
         * pb_vit buy.
         * @member {number} buy
         * @memberof pb_vit
         * @instance
         */
        pb_vit.prototype.buy = 0;
    
        /**
         * Creates a new pb_vit instance using the specified properties.
         * @function create
         * @memberof pb_vit
         * @static
         * @param {Ipb_vit=} [properties] Properties to set
         * @returns {pb_vit} pb_vit instance
         */
        pb_vit.create = function create(properties) {
            return new pb_vit(properties);
        };
    
        /**
         * Encodes the specified pb_vit message. Does not implicitly {@link pb_vit.verify|verify} messages.
         * @function encode
         * @memberof pb_vit
         * @static
         * @param {Ipb_vit} message pb_vit message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_vit.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.vit);
            if (message.buy != null && Object.hasOwnProperty.call(message, "buy"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.buy);
            return writer;
        };
    
        /**
         * Encodes the specified pb_vit message, length delimited. Does not implicitly {@link pb_vit.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_vit
         * @static
         * @param {Ipb_vit} message pb_vit message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_vit.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_vit message from the specified reader or buffer.
         * @function decode
         * @memberof pb_vit
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_vit} pb_vit
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_vit.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_vit();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.vit = reader.int32();
                        break;
                    }
                case 2: {
                        message.buy = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("vit"))
                throw $util.ProtocolError("missing required 'vit'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a pb_vit message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_vit
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_vit} pb_vit
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_vit.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_vit message.
         * @function verify
         * @memberof pb_vit
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_vit.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.vit))
                return "vit: integer expected";
            if (message.buy != null && message.hasOwnProperty("buy"))
                if (!$util.isInteger(message.buy))
                    return "buy: integer expected";
            return null;
        };
    
        /**
         * Creates a pb_vit message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_vit
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_vit} pb_vit
         */
        pb_vit.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_vit)
                return object;
            var message = new $root.pb_vit();
            if (object.vit != null)
                message.vit = object.vit | 0;
            if (object.buy != null)
                message.buy = object.buy | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a pb_vit message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_vit
         * @static
         * @param {pb_vit} message pb_vit
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_vit.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.vit = 0;
                object.buy = 0;
            }
            if (message.vit != null && message.hasOwnProperty("vit"))
                object.vit = message.vit;
            if (message.buy != null && message.hasOwnProperty("buy"))
                object.buy = message.buy;
            return object;
        };
    
        /**
         * Converts this pb_vit to JSON.
         * @function toJSON
         * @memberof pb_vit
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_vit.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_vit
         * @function getTypeUrl
         * @memberof pb_vit
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_vit.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_vit";
        };
    
        return pb_vit;
    })();
    
    $root.pb_ievent = (function() {
    
        /**
         * Properties of a pb_ievent.
         * @exports Ipb_ievent
         * @interface Ipb_ievent
         * @property {number} id pb_ievent id
         * @property {number|null} [cd] pb_ievent cd
         * @property {string|null} [ext] pb_ievent ext
         * @property {number|null} [sid] pb_ievent sid
         * @property {Ipb_bag|null} [reward] pb_ievent reward
         */
    
        /**
         * Constructs a new pb_ievent.
         * @exports pb_ievent
         * @classdesc Represents a pb_ievent.
         * @implements Ipb_ievent
         * @constructor
         * @param {Ipb_ievent=} [properties] Properties to set
         */
        function pb_ievent(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_ievent id.
         * @member {number} id
         * @memberof pb_ievent
         * @instance
         */
        pb_ievent.prototype.id = 0;
    
        /**
         * pb_ievent cd.
         * @member {number} cd
         * @memberof pb_ievent
         * @instance
         */
        pb_ievent.prototype.cd = 0;
    
        /**
         * pb_ievent ext.
         * @member {string} ext
         * @memberof pb_ievent
         * @instance
         */
        pb_ievent.prototype.ext = "";
    
        /**
         * pb_ievent sid.
         * @member {number} sid
         * @memberof pb_ievent
         * @instance
         */
        pb_ievent.prototype.sid = 0;
    
        /**
         * pb_ievent reward.
         * @member {Ipb_bag|null|undefined} reward
         * @memberof pb_ievent
         * @instance
         */
        pb_ievent.prototype.reward = null;
    
        /**
         * Creates a new pb_ievent instance using the specified properties.
         * @function create
         * @memberof pb_ievent
         * @static
         * @param {Ipb_ievent=} [properties] Properties to set
         * @returns {pb_ievent} pb_ievent instance
         */
        pb_ievent.create = function create(properties) {
            return new pb_ievent(properties);
        };
    
        /**
         * Encodes the specified pb_ievent message. Does not implicitly {@link pb_ievent.verify|verify} messages.
         * @function encode
         * @memberof pb_ievent
         * @static
         * @param {Ipb_ievent} message pb_ievent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_ievent.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.id);
            if (message.cd != null && Object.hasOwnProperty.call(message, "cd"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.cd);
            if (message.ext != null && Object.hasOwnProperty.call(message, "ext"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.ext);
            if (message.sid != null && Object.hasOwnProperty.call(message, "sid"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.sid);
            if (message.reward != null && Object.hasOwnProperty.call(message, "reward"))
                $root.pb_bag.encode(message.reward, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified pb_ievent message, length delimited. Does not implicitly {@link pb_ievent.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_ievent
         * @static
         * @param {Ipb_ievent} message pb_ievent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_ievent.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_ievent message from the specified reader or buffer.
         * @function decode
         * @memberof pb_ievent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_ievent} pb_ievent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_ievent.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_ievent();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.id = reader.int32();
                        break;
                    }
                case 2: {
                        message.cd = reader.int32();
                        break;
                    }
                case 3: {
                        message.ext = reader.string();
                        break;
                    }
                case 4: {
                        message.sid = reader.int32();
                        break;
                    }
                case 5: {
                        message.reward = $root.pb_bag.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("id"))
                throw $util.ProtocolError("missing required 'id'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a pb_ievent message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_ievent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_ievent} pb_ievent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_ievent.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_ievent message.
         * @function verify
         * @memberof pb_ievent
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_ievent.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.id))
                return "id: integer expected";
            if (message.cd != null && message.hasOwnProperty("cd"))
                if (!$util.isInteger(message.cd))
                    return "cd: integer expected";
            if (message.ext != null && message.hasOwnProperty("ext"))
                if (!$util.isString(message.ext))
                    return "ext: string expected";
            if (message.sid != null && message.hasOwnProperty("sid"))
                if (!$util.isInteger(message.sid))
                    return "sid: integer expected";
            if (message.reward != null && message.hasOwnProperty("reward")) {
                var error = $root.pb_bag.verify(message.reward);
                if (error)
                    return "reward." + error;
            }
            return null;
        };
    
        /**
         * Creates a pb_ievent message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_ievent
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_ievent} pb_ievent
         */
        pb_ievent.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_ievent)
                return object;
            var message = new $root.pb_ievent();
            if (object.id != null)
                message.id = object.id | 0;
            if (object.cd != null)
                message.cd = object.cd | 0;
            if (object.ext != null)
                message.ext = String(object.ext);
            if (object.sid != null)
                message.sid = object.sid | 0;
            if (object.reward != null) {
                if (typeof object.reward !== "object")
                    throw TypeError(".pb_ievent.reward: object expected");
                message.reward = $root.pb_bag.fromObject(object.reward);
            }
            return message;
        };
    
        /**
         * Creates a plain object from a pb_ievent message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_ievent
         * @static
         * @param {pb_ievent} message pb_ievent
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_ievent.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = 0;
                object.cd = 0;
                object.ext = "";
                object.sid = 0;
                object.reward = null;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.cd != null && message.hasOwnProperty("cd"))
                object.cd = message.cd;
            if (message.ext != null && message.hasOwnProperty("ext"))
                object.ext = message.ext;
            if (message.sid != null && message.hasOwnProperty("sid"))
                object.sid = message.sid;
            if (message.reward != null && message.hasOwnProperty("reward"))
                object.reward = $root.pb_bag.toObject(message.reward, options);
            return object;
        };
    
        /**
         * Converts this pb_ievent to JSON.
         * @function toJSON
         * @memberof pb_ievent
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_ievent.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_ievent
         * @function getTypeUrl
         * @memberof pb_ievent
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_ievent.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_ievent";
        };
    
        return pb_ievent;
    })();
    
    $root.pb_iadt = (function() {
    
        /**
         * Properties of a pb_iadt.
         * @exports Ipb_iadt
         * @interface Ipb_iadt
         * @property {number|null} [dist] pb_iadt dist
         * @property {Array.<Ipb_ievent>|null} [mevts] pb_iadt mevts
         * @property {Array.<Ipb_ievent>|null} [pevts] pb_iadt pevts
         * @property {number|null} [vit] pb_iadt vit
         * @property {number|null} [vitcd] pb_iadt vitcd
         * @property {Ipb_bag|null} [reward] pb_iadt reward
         * @property {number|null} [rt] pb_iadt rt
         * @property {number|null} [num] pb_iadt num
         */
    
        /**
         * Constructs a new pb_iadt.
         * @exports pb_iadt
         * @classdesc Represents a pb_iadt.
         * @implements Ipb_iadt
         * @constructor
         * @param {Ipb_iadt=} [properties] Properties to set
         */
        function pb_iadt(properties) {
            this.mevts = [];
            this.pevts = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_iadt dist.
         * @member {number} dist
         * @memberof pb_iadt
         * @instance
         */
        pb_iadt.prototype.dist = 0;
    
        /**
         * pb_iadt mevts.
         * @member {Array.<Ipb_ievent>} mevts
         * @memberof pb_iadt
         * @instance
         */
        pb_iadt.prototype.mevts = $util.emptyArray;
    
        /**
         * pb_iadt pevts.
         * @member {Array.<Ipb_ievent>} pevts
         * @memberof pb_iadt
         * @instance
         */
        pb_iadt.prototype.pevts = $util.emptyArray;
    
        /**
         * pb_iadt vit.
         * @member {number} vit
         * @memberof pb_iadt
         * @instance
         */
        pb_iadt.prototype.vit = 0;
    
        /**
         * pb_iadt vitcd.
         * @member {number} vitcd
         * @memberof pb_iadt
         * @instance
         */
        pb_iadt.prototype.vitcd = 0;
    
        /**
         * pb_iadt reward.
         * @member {Ipb_bag|null|undefined} reward
         * @memberof pb_iadt
         * @instance
         */
        pb_iadt.prototype.reward = null;
    
        /**
         * pb_iadt rt.
         * @member {number} rt
         * @memberof pb_iadt
         * @instance
         */
        pb_iadt.prototype.rt = 0;
    
        /**
         * pb_iadt num.
         * @member {number} num
         * @memberof pb_iadt
         * @instance
         */
        pb_iadt.prototype.num = 0;
    
        /**
         * Creates a new pb_iadt instance using the specified properties.
         * @function create
         * @memberof pb_iadt
         * @static
         * @param {Ipb_iadt=} [properties] Properties to set
         * @returns {pb_iadt} pb_iadt instance
         */
        pb_iadt.create = function create(properties) {
            return new pb_iadt(properties);
        };
    
        /**
         * Encodes the specified pb_iadt message. Does not implicitly {@link pb_iadt.verify|verify} messages.
         * @function encode
         * @memberof pb_iadt
         * @static
         * @param {Ipb_iadt} message pb_iadt message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_iadt.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.dist != null && Object.hasOwnProperty.call(message, "dist"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.dist);
            if (message.mevts != null && message.mevts.length)
                for (var i = 0; i < message.mevts.length; ++i)
                    $root.pb_ievent.encode(message.mevts[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.pevts != null && message.pevts.length)
                for (var i = 0; i < message.pevts.length; ++i)
                    $root.pb_ievent.encode(message.pevts[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.vit != null && Object.hasOwnProperty.call(message, "vit"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.vit);
            if (message.vitcd != null && Object.hasOwnProperty.call(message, "vitcd"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.vitcd);
            if (message.reward != null && Object.hasOwnProperty.call(message, "reward"))
                $root.pb_bag.encode(message.reward, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.rt != null && Object.hasOwnProperty.call(message, "rt"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.rt);
            if (message.num != null && Object.hasOwnProperty.call(message, "num"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.num);
            return writer;
        };
    
        /**
         * Encodes the specified pb_iadt message, length delimited. Does not implicitly {@link pb_iadt.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_iadt
         * @static
         * @param {Ipb_iadt} message pb_iadt message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_iadt.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_iadt message from the specified reader or buffer.
         * @function decode
         * @memberof pb_iadt
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_iadt} pb_iadt
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_iadt.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_iadt();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.dist = reader.int32();
                        break;
                    }
                case 2: {
                        if (!(message.mevts && message.mevts.length))
                            message.mevts = [];
                        message.mevts.push($root.pb_ievent.decode(reader, reader.uint32()));
                        break;
                    }
                case 3: {
                        if (!(message.pevts && message.pevts.length))
                            message.pevts = [];
                        message.pevts.push($root.pb_ievent.decode(reader, reader.uint32()));
                        break;
                    }
                case 4: {
                        message.vit = reader.int32();
                        break;
                    }
                case 5: {
                        message.vitcd = reader.int32();
                        break;
                    }
                case 6: {
                        message.reward = $root.pb_bag.decode(reader, reader.uint32());
                        break;
                    }
                case 7: {
                        message.rt = reader.int32();
                        break;
                    }
                case 8: {
                        message.num = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a pb_iadt message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_iadt
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_iadt} pb_iadt
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_iadt.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_iadt message.
         * @function verify
         * @memberof pb_iadt
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_iadt.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.dist != null && message.hasOwnProperty("dist"))
                if (!$util.isInteger(message.dist))
                    return "dist: integer expected";
            if (message.mevts != null && message.hasOwnProperty("mevts")) {
                if (!Array.isArray(message.mevts))
                    return "mevts: array expected";
                for (var i = 0; i < message.mevts.length; ++i) {
                    var error = $root.pb_ievent.verify(message.mevts[i]);
                    if (error)
                        return "mevts." + error;
                }
            }
            if (message.pevts != null && message.hasOwnProperty("pevts")) {
                if (!Array.isArray(message.pevts))
                    return "pevts: array expected";
                for (var i = 0; i < message.pevts.length; ++i) {
                    var error = $root.pb_ievent.verify(message.pevts[i]);
                    if (error)
                        return "pevts." + error;
                }
            }
            if (message.vit != null && message.hasOwnProperty("vit"))
                if (!$util.isInteger(message.vit))
                    return "vit: integer expected";
            if (message.vitcd != null && message.hasOwnProperty("vitcd"))
                if (!$util.isInteger(message.vitcd))
                    return "vitcd: integer expected";
            if (message.reward != null && message.hasOwnProperty("reward")) {
                var error = $root.pb_bag.verify(message.reward);
                if (error)
                    return "reward." + error;
            }
            if (message.rt != null && message.hasOwnProperty("rt"))
                if (!$util.isInteger(message.rt))
                    return "rt: integer expected";
            if (message.num != null && message.hasOwnProperty("num"))
                if (!$util.isInteger(message.num))
                    return "num: integer expected";
            return null;
        };
    
        /**
         * Creates a pb_iadt message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_iadt
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_iadt} pb_iadt
         */
        pb_iadt.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_iadt)
                return object;
            var message = new $root.pb_iadt();
            if (object.dist != null)
                message.dist = object.dist | 0;
            if (object.mevts) {
                if (!Array.isArray(object.mevts))
                    throw TypeError(".pb_iadt.mevts: array expected");
                message.mevts = [];
                for (var i = 0; i < object.mevts.length; ++i) {
                    if (typeof object.mevts[i] !== "object")
                        throw TypeError(".pb_iadt.mevts: object expected");
                    message.mevts[i] = $root.pb_ievent.fromObject(object.mevts[i]);
                }
            }
            if (object.pevts) {
                if (!Array.isArray(object.pevts))
                    throw TypeError(".pb_iadt.pevts: array expected");
                message.pevts = [];
                for (var i = 0; i < object.pevts.length; ++i) {
                    if (typeof object.pevts[i] !== "object")
                        throw TypeError(".pb_iadt.pevts: object expected");
                    message.pevts[i] = $root.pb_ievent.fromObject(object.pevts[i]);
                }
            }
            if (object.vit != null)
                message.vit = object.vit | 0;
            if (object.vitcd != null)
                message.vitcd = object.vitcd | 0;
            if (object.reward != null) {
                if (typeof object.reward !== "object")
                    throw TypeError(".pb_iadt.reward: object expected");
                message.reward = $root.pb_bag.fromObject(object.reward);
            }
            if (object.rt != null)
                message.rt = object.rt | 0;
            if (object.num != null)
                message.num = object.num | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a pb_iadt message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_iadt
         * @static
         * @param {pb_iadt} message pb_iadt
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_iadt.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.mevts = [];
                object.pevts = [];
            }
            if (options.defaults) {
                object.dist = 0;
                object.vit = 0;
                object.vitcd = 0;
                object.reward = null;
                object.rt = 0;
                object.num = 0;
            }
            if (message.dist != null && message.hasOwnProperty("dist"))
                object.dist = message.dist;
            if (message.mevts && message.mevts.length) {
                object.mevts = [];
                for (var j = 0; j < message.mevts.length; ++j)
                    object.mevts[j] = $root.pb_ievent.toObject(message.mevts[j], options);
            }
            if (message.pevts && message.pevts.length) {
                object.pevts = [];
                for (var j = 0; j < message.pevts.length; ++j)
                    object.pevts[j] = $root.pb_ievent.toObject(message.pevts[j], options);
            }
            if (message.vit != null && message.hasOwnProperty("vit"))
                object.vit = message.vit;
            if (message.vitcd != null && message.hasOwnProperty("vitcd"))
                object.vitcd = message.vitcd;
            if (message.reward != null && message.hasOwnProperty("reward"))
                object.reward = $root.pb_bag.toObject(message.reward, options);
            if (message.rt != null && message.hasOwnProperty("rt"))
                object.rt = message.rt;
            if (message.num != null && message.hasOwnProperty("num"))
                object.num = message.num;
            return object;
        };
    
        /**
         * Converts this pb_iadt to JSON.
         * @function toJSON
         * @memberof pb_iadt
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_iadt.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_iadt
         * @function getTypeUrl
         * @memberof pb_iadt
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_iadt.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_iadt";
        };
    
        return pb_iadt;
    })();
    
    $root.pb_iboat = (function() {
    
        /**
         * Properties of a pb_iboat.
         * @exports Ipb_iboat
         * @interface Ipb_iboat
         * @property {string|null} [name] pb_iboat name
         * @property {number|null} [exp] pb_iboat exp
         * @property {number|null} [arm] pb_iboat arm
         * @property {number|null} [spd] pb_iboat spd
         * @property {Array.<number>|null} [skls] pb_iboat skls
         */
    
        /**
         * Constructs a new pb_iboat.
         * @exports pb_iboat
         * @classdesc Represents a pb_iboat.
         * @implements Ipb_iboat
         * @constructor
         * @param {Ipb_iboat=} [properties] Properties to set
         */
        function pb_iboat(properties) {
            this.skls = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_iboat name.
         * @member {string} name
         * @memberof pb_iboat
         * @instance
         */
        pb_iboat.prototype.name = "";
    
        /**
         * pb_iboat exp.
         * @member {number} exp
         * @memberof pb_iboat
         * @instance
         */
        pb_iboat.prototype.exp = 0;
    
        /**
         * pb_iboat arm.
         * @member {number} arm
         * @memberof pb_iboat
         * @instance
         */
        pb_iboat.prototype.arm = 0;
    
        /**
         * pb_iboat spd.
         * @member {number} spd
         * @memberof pb_iboat
         * @instance
         */
        pb_iboat.prototype.spd = 0;
    
        /**
         * pb_iboat skls.
         * @member {Array.<number>} skls
         * @memberof pb_iboat
         * @instance
         */
        pb_iboat.prototype.skls = $util.emptyArray;
    
        /**
         * Creates a new pb_iboat instance using the specified properties.
         * @function create
         * @memberof pb_iboat
         * @static
         * @param {Ipb_iboat=} [properties] Properties to set
         * @returns {pb_iboat} pb_iboat instance
         */
        pb_iboat.create = function create(properties) {
            return new pb_iboat(properties);
        };
    
        /**
         * Encodes the specified pb_iboat message. Does not implicitly {@link pb_iboat.verify|verify} messages.
         * @function encode
         * @memberof pb_iboat
         * @static
         * @param {Ipb_iboat} message pb_iboat message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_iboat.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
            if (message.exp != null && Object.hasOwnProperty.call(message, "exp"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.exp);
            if (message.arm != null && Object.hasOwnProperty.call(message, "arm"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.arm);
            if (message.spd != null && Object.hasOwnProperty.call(message, "spd"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.spd);
            if (message.skls != null && message.skls.length)
                for (var i = 0; i < message.skls.length; ++i)
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.skls[i]);
            return writer;
        };
    
        /**
         * Encodes the specified pb_iboat message, length delimited. Does not implicitly {@link pb_iboat.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_iboat
         * @static
         * @param {Ipb_iboat} message pb_iboat message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_iboat.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_iboat message from the specified reader or buffer.
         * @function decode
         * @memberof pb_iboat
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_iboat} pb_iboat
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_iboat.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_iboat();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.name = reader.string();
                        break;
                    }
                case 2: {
                        message.exp = reader.int32();
                        break;
                    }
                case 3: {
                        message.arm = reader.int32();
                        break;
                    }
                case 4: {
                        message.spd = reader.int32();
                        break;
                    }
                case 5: {
                        if (!(message.skls && message.skls.length))
                            message.skls = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.skls.push(reader.int32());
                        } else
                            message.skls.push(reader.int32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a pb_iboat message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_iboat
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_iboat} pb_iboat
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_iboat.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_iboat message.
         * @function verify
         * @memberof pb_iboat
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_iboat.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.exp != null && message.hasOwnProperty("exp"))
                if (!$util.isInteger(message.exp))
                    return "exp: integer expected";
            if (message.arm != null && message.hasOwnProperty("arm"))
                if (!$util.isInteger(message.arm))
                    return "arm: integer expected";
            if (message.spd != null && message.hasOwnProperty("spd"))
                if (!$util.isInteger(message.spd))
                    return "spd: integer expected";
            if (message.skls != null && message.hasOwnProperty("skls")) {
                if (!Array.isArray(message.skls))
                    return "skls: array expected";
                for (var i = 0; i < message.skls.length; ++i)
                    if (!$util.isInteger(message.skls[i]))
                        return "skls: integer[] expected";
            }
            return null;
        };
    
        /**
         * Creates a pb_iboat message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_iboat
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_iboat} pb_iboat
         */
        pb_iboat.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_iboat)
                return object;
            var message = new $root.pb_iboat();
            if (object.name != null)
                message.name = String(object.name);
            if (object.exp != null)
                message.exp = object.exp | 0;
            if (object.arm != null)
                message.arm = object.arm | 0;
            if (object.spd != null)
                message.spd = object.spd | 0;
            if (object.skls) {
                if (!Array.isArray(object.skls))
                    throw TypeError(".pb_iboat.skls: array expected");
                message.skls = [];
                for (var i = 0; i < object.skls.length; ++i)
                    message.skls[i] = object.skls[i] | 0;
            }
            return message;
        };
    
        /**
         * Creates a plain object from a pb_iboat message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_iboat
         * @static
         * @param {pb_iboat} message pb_iboat
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_iboat.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.skls = [];
            if (options.defaults) {
                object.name = "";
                object.exp = 0;
                object.arm = 0;
                object.spd = 0;
            }
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.exp != null && message.hasOwnProperty("exp"))
                object.exp = message.exp;
            if (message.arm != null && message.hasOwnProperty("arm"))
                object.arm = message.arm;
            if (message.spd != null && message.hasOwnProperty("spd"))
                object.spd = message.spd;
            if (message.skls && message.skls.length) {
                object.skls = [];
                for (var j = 0; j < message.skls.length; ++j)
                    object.skls[j] = message.skls[j];
            }
            return object;
        };
    
        /**
         * Converts this pb_iboat to JSON.
         * @function toJSON
         * @memberof pb_iboat
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_iboat.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_iboat
         * @function getTypeUrl
         * @memberof pb_iboat
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_iboat.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_iboat";
        };
    
        return pb_iboat;
    })();
    
    $root.pb_ipro = (function() {
    
        /**
         * Properties of a pb_ipro.
         * @exports Ipb_ipro
         * @interface Ipb_ipro
         * @property {number|null} [id] pb_ipro id
         * @property {number|null} [num] pb_ipro num
         * @property {number|null} [cd] pb_ipro cd
         */
    
        /**
         * Constructs a new pb_ipro.
         * @exports pb_ipro
         * @classdesc Represents a pb_ipro.
         * @implements Ipb_ipro
         * @constructor
         * @param {Ipb_ipro=} [properties] Properties to set
         */
        function pb_ipro(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_ipro id.
         * @member {number} id
         * @memberof pb_ipro
         * @instance
         */
        pb_ipro.prototype.id = 0;
    
        /**
         * pb_ipro num.
         * @member {number} num
         * @memberof pb_ipro
         * @instance
         */
        pb_ipro.prototype.num = 0;
    
        /**
         * pb_ipro cd.
         * @member {number} cd
         * @memberof pb_ipro
         * @instance
         */
        pb_ipro.prototype.cd = 0;
    
        /**
         * Creates a new pb_ipro instance using the specified properties.
         * @function create
         * @memberof pb_ipro
         * @static
         * @param {Ipb_ipro=} [properties] Properties to set
         * @returns {pb_ipro} pb_ipro instance
         */
        pb_ipro.create = function create(properties) {
            return new pb_ipro(properties);
        };
    
        /**
         * Encodes the specified pb_ipro message. Does not implicitly {@link pb_ipro.verify|verify} messages.
         * @function encode
         * @memberof pb_ipro
         * @static
         * @param {Ipb_ipro} message pb_ipro message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_ipro.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.id);
            if (message.num != null && Object.hasOwnProperty.call(message, "num"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.num);
            if (message.cd != null && Object.hasOwnProperty.call(message, "cd"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.cd);
            return writer;
        };
    
        /**
         * Encodes the specified pb_ipro message, length delimited. Does not implicitly {@link pb_ipro.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_ipro
         * @static
         * @param {Ipb_ipro} message pb_ipro message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_ipro.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_ipro message from the specified reader or buffer.
         * @function decode
         * @memberof pb_ipro
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_ipro} pb_ipro
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_ipro.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_ipro();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.id = reader.int32();
                        break;
                    }
                case 2: {
                        message.num = reader.int32();
                        break;
                    }
                case 3: {
                        message.cd = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a pb_ipro message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_ipro
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_ipro} pb_ipro
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_ipro.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_ipro message.
         * @function verify
         * @memberof pb_ipro
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_ipro.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id))
                    return "id: integer expected";
            if (message.num != null && message.hasOwnProperty("num"))
                if (!$util.isInteger(message.num))
                    return "num: integer expected";
            if (message.cd != null && message.hasOwnProperty("cd"))
                if (!$util.isInteger(message.cd))
                    return "cd: integer expected";
            return null;
        };
    
        /**
         * Creates a pb_ipro message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_ipro
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_ipro} pb_ipro
         */
        pb_ipro.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_ipro)
                return object;
            var message = new $root.pb_ipro();
            if (object.id != null)
                message.id = object.id | 0;
            if (object.num != null)
                message.num = object.num | 0;
            if (object.cd != null)
                message.cd = object.cd | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a pb_ipro message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_ipro
         * @static
         * @param {pb_ipro} message pb_ipro
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_ipro.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = 0;
                object.num = 0;
                object.cd = 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.num != null && message.hasOwnProperty("num"))
                object.num = message.num;
            if (message.cd != null && message.hasOwnProperty("cd"))
                object.cd = message.cd;
            return object;
        };
    
        /**
         * Converts this pb_ipro to JSON.
         * @function toJSON
         * @memberof pb_ipro
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_ipro.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_ipro
         * @function getTypeUrl
         * @memberof pb_ipro
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_ipro.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_ipro";
        };
    
        return pb_ipro;
    })();
    
    $root.pb_identity = (function() {
    
        /**
         * Properties of a pb_identity.
         * @exports Ipb_identity
         * @interface Ipb_identity
         * @property {number|null} [onlineTime] pb_identity onlineTime
         * @property {number|null} [adult] pb_identity adult
         * @property {string|null} [locale] pb_identity locale
         * @property {number|null} [age] pb_identity age
         * @property {number|null} [mrecharge] pb_identity mrecharge
         */
    
        /**
         * Constructs a new pb_identity.
         * @exports pb_identity
         * @classdesc Represents a pb_identity.
         * @implements Ipb_identity
         * @constructor
         * @param {Ipb_identity=} [properties] Properties to set
         */
        function pb_identity(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_identity onlineTime.
         * @member {number} onlineTime
         * @memberof pb_identity
         * @instance
         */
        pb_identity.prototype.onlineTime = 0;
    
        /**
         * pb_identity adult.
         * @member {number} adult
         * @memberof pb_identity
         * @instance
         */
        pb_identity.prototype.adult = 0;
    
        /**
         * pb_identity locale.
         * @member {string} locale
         * @memberof pb_identity
         * @instance
         */
        pb_identity.prototype.locale = "";
    
        /**
         * pb_identity age.
         * @member {number} age
         * @memberof pb_identity
         * @instance
         */
        pb_identity.prototype.age = 0;
    
        /**
         * pb_identity mrecharge.
         * @member {number} mrecharge
         * @memberof pb_identity
         * @instance
         */
        pb_identity.prototype.mrecharge = 0;
    
        /**
         * Creates a new pb_identity instance using the specified properties.
         * @function create
         * @memberof pb_identity
         * @static
         * @param {Ipb_identity=} [properties] Properties to set
         * @returns {pb_identity} pb_identity instance
         */
        pb_identity.create = function create(properties) {
            return new pb_identity(properties);
        };
    
        /**
         * Encodes the specified pb_identity message. Does not implicitly {@link pb_identity.verify|verify} messages.
         * @function encode
         * @memberof pb_identity
         * @static
         * @param {Ipb_identity} message pb_identity message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_identity.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.onlineTime != null && Object.hasOwnProperty.call(message, "onlineTime"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.onlineTime);
            if (message.adult != null && Object.hasOwnProperty.call(message, "adult"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.adult);
            if (message.locale != null && Object.hasOwnProperty.call(message, "locale"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.locale);
            if (message.age != null && Object.hasOwnProperty.call(message, "age"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.age);
            if (message.mrecharge != null && Object.hasOwnProperty.call(message, "mrecharge"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.mrecharge);
            return writer;
        };
    
        /**
         * Encodes the specified pb_identity message, length delimited. Does not implicitly {@link pb_identity.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_identity
         * @static
         * @param {Ipb_identity} message pb_identity message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_identity.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_identity message from the specified reader or buffer.
         * @function decode
         * @memberof pb_identity
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_identity} pb_identity
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_identity.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_identity();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.onlineTime = reader.int32();
                        break;
                    }
                case 2: {
                        message.adult = reader.int32();
                        break;
                    }
                case 3: {
                        message.locale = reader.string();
                        break;
                    }
                case 4: {
                        message.age = reader.int32();
                        break;
                    }
                case 5: {
                        message.mrecharge = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a pb_identity message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_identity
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_identity} pb_identity
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_identity.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_identity message.
         * @function verify
         * @memberof pb_identity
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_identity.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.onlineTime != null && message.hasOwnProperty("onlineTime"))
                if (!$util.isInteger(message.onlineTime))
                    return "onlineTime: integer expected";
            if (message.adult != null && message.hasOwnProperty("adult"))
                if (!$util.isInteger(message.adult))
                    return "adult: integer expected";
            if (message.locale != null && message.hasOwnProperty("locale"))
                if (!$util.isString(message.locale))
                    return "locale: string expected";
            if (message.age != null && message.hasOwnProperty("age"))
                if (!$util.isInteger(message.age))
                    return "age: integer expected";
            if (message.mrecharge != null && message.hasOwnProperty("mrecharge"))
                if (!$util.isInteger(message.mrecharge))
                    return "mrecharge: integer expected";
            return null;
        };
    
        /**
         * Creates a pb_identity message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_identity
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_identity} pb_identity
         */
        pb_identity.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_identity)
                return object;
            var message = new $root.pb_identity();
            if (object.onlineTime != null)
                message.onlineTime = object.onlineTime | 0;
            if (object.adult != null)
                message.adult = object.adult | 0;
            if (object.locale != null)
                message.locale = String(object.locale);
            if (object.age != null)
                message.age = object.age | 0;
            if (object.mrecharge != null)
                message.mrecharge = object.mrecharge | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a pb_identity message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_identity
         * @static
         * @param {pb_identity} message pb_identity
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_identity.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.onlineTime = 0;
                object.adult = 0;
                object.locale = "";
                object.age = 0;
                object.mrecharge = 0;
            }
            if (message.onlineTime != null && message.hasOwnProperty("onlineTime"))
                object.onlineTime = message.onlineTime;
            if (message.adult != null && message.hasOwnProperty("adult"))
                object.adult = message.adult;
            if (message.locale != null && message.hasOwnProperty("locale"))
                object.locale = message.locale;
            if (message.age != null && message.hasOwnProperty("age"))
                object.age = message.age;
            if (message.mrecharge != null && message.hasOwnProperty("mrecharge"))
                object.mrecharge = message.mrecharge;
            return object;
        };
    
        /**
         * Converts this pb_identity to JSON.
         * @function toJSON
         * @memberof pb_identity
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_identity.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_identity
         * @function getTypeUrl
         * @memberof pb_identity
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_identity.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_identity";
        };
    
        return pb_identity;
    })();
    
    $root.pb_sact = (function() {
    
        /**
         * Properties of a pb_sact.
         * @exports Ipb_sact
         * @interface Ipb_sact
         * @property {Array.<Ipb_sact_item>|null} [acts] pb_sact acts
         */
    
        /**
         * Constructs a new pb_sact.
         * @exports pb_sact
         * @classdesc Represents a pb_sact.
         * @implements Ipb_sact
         * @constructor
         * @param {Ipb_sact=} [properties] Properties to set
         */
        function pb_sact(properties) {
            this.acts = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_sact acts.
         * @member {Array.<Ipb_sact_item>} acts
         * @memberof pb_sact
         * @instance
         */
        pb_sact.prototype.acts = $util.emptyArray;
    
        /**
         * Creates a new pb_sact instance using the specified properties.
         * @function create
         * @memberof pb_sact
         * @static
         * @param {Ipb_sact=} [properties] Properties to set
         * @returns {pb_sact} pb_sact instance
         */
        pb_sact.create = function create(properties) {
            return new pb_sact(properties);
        };
    
        /**
         * Encodes the specified pb_sact message. Does not implicitly {@link pb_sact.verify|verify} messages.
         * @function encode
         * @memberof pb_sact
         * @static
         * @param {Ipb_sact} message pb_sact message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_sact.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.acts != null && message.acts.length)
                for (var i = 0; i < message.acts.length; ++i)
                    $root.pb_sact_item.encode(message.acts[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified pb_sact message, length delimited. Does not implicitly {@link pb_sact.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_sact
         * @static
         * @param {Ipb_sact} message pb_sact message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_sact.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_sact message from the specified reader or buffer.
         * @function decode
         * @memberof pb_sact
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_sact} pb_sact
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_sact.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_sact();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.acts && message.acts.length))
                            message.acts = [];
                        message.acts.push($root.pb_sact_item.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a pb_sact message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_sact
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_sact} pb_sact
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_sact.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_sact message.
         * @function verify
         * @memberof pb_sact
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_sact.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.acts != null && message.hasOwnProperty("acts")) {
                if (!Array.isArray(message.acts))
                    return "acts: array expected";
                for (var i = 0; i < message.acts.length; ++i) {
                    var error = $root.pb_sact_item.verify(message.acts[i]);
                    if (error)
                        return "acts." + error;
                }
            }
            return null;
        };
    
        /**
         * Creates a pb_sact message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_sact
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_sact} pb_sact
         */
        pb_sact.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_sact)
                return object;
            var message = new $root.pb_sact();
            if (object.acts) {
                if (!Array.isArray(object.acts))
                    throw TypeError(".pb_sact.acts: array expected");
                message.acts = [];
                for (var i = 0; i < object.acts.length; ++i) {
                    if (typeof object.acts[i] !== "object")
                        throw TypeError(".pb_sact.acts: object expected");
                    message.acts[i] = $root.pb_sact_item.fromObject(object.acts[i]);
                }
            }
            return message;
        };
    
        /**
         * Creates a plain object from a pb_sact message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_sact
         * @static
         * @param {pb_sact} message pb_sact
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_sact.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.acts = [];
            if (message.acts && message.acts.length) {
                object.acts = [];
                for (var j = 0; j < message.acts.length; ++j)
                    object.acts[j] = $root.pb_sact_item.toObject(message.acts[j], options);
            }
            return object;
        };
    
        /**
         * Converts this pb_sact to JSON.
         * @function toJSON
         * @memberof pb_sact
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_sact.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_sact
         * @function getTypeUrl
         * @memberof pb_sact
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_sact.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_sact";
        };
    
        return pb_sact;
    })();
    
    $root.pb_ract = (function() {
    
        /**
         * Properties of a pb_ract.
         * @exports Ipb_ract
         * @interface Ipb_ract
         * @property {Array.<Ipb_ract_item>|null} [acts] pb_ract acts
         * @property {number|null} [show] pb_ract show
         */
    
        /**
         * Constructs a new pb_ract.
         * @exports pb_ract
         * @classdesc Represents a pb_ract.
         * @implements Ipb_ract
         * @constructor
         * @param {Ipb_ract=} [properties] Properties to set
         */
        function pb_ract(properties) {
            this.acts = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_ract acts.
         * @member {Array.<Ipb_ract_item>} acts
         * @memberof pb_ract
         * @instance
         */
        pb_ract.prototype.acts = $util.emptyArray;
    
        /**
         * pb_ract show.
         * @member {number} show
         * @memberof pb_ract
         * @instance
         */
        pb_ract.prototype.show = 0;
    
        /**
         * Creates a new pb_ract instance using the specified properties.
         * @function create
         * @memberof pb_ract
         * @static
         * @param {Ipb_ract=} [properties] Properties to set
         * @returns {pb_ract} pb_ract instance
         */
        pb_ract.create = function create(properties) {
            return new pb_ract(properties);
        };
    
        /**
         * Encodes the specified pb_ract message. Does not implicitly {@link pb_ract.verify|verify} messages.
         * @function encode
         * @memberof pb_ract
         * @static
         * @param {Ipb_ract} message pb_ract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_ract.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.acts != null && message.acts.length)
                for (var i = 0; i < message.acts.length; ++i)
                    $root.pb_ract_item.encode(message.acts[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.show != null && Object.hasOwnProperty.call(message, "show"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.show);
            return writer;
        };
    
        /**
         * Encodes the specified pb_ract message, length delimited. Does not implicitly {@link pb_ract.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_ract
         * @static
         * @param {Ipb_ract} message pb_ract message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_ract.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_ract message from the specified reader or buffer.
         * @function decode
         * @memberof pb_ract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_ract} pb_ract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_ract.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_ract();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.acts && message.acts.length))
                            message.acts = [];
                        message.acts.push($root.pb_ract_item.decode(reader, reader.uint32()));
                        break;
                    }
                case 2: {
                        message.show = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a pb_ract message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_ract
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_ract} pb_ract
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_ract.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_ract message.
         * @function verify
         * @memberof pb_ract
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_ract.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.acts != null && message.hasOwnProperty("acts")) {
                if (!Array.isArray(message.acts))
                    return "acts: array expected";
                for (var i = 0; i < message.acts.length; ++i) {
                    var error = $root.pb_ract_item.verify(message.acts[i]);
                    if (error)
                        return "acts." + error;
                }
            }
            if (message.show != null && message.hasOwnProperty("show"))
                if (!$util.isInteger(message.show))
                    return "show: integer expected";
            return null;
        };
    
        /**
         * Creates a pb_ract message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_ract
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_ract} pb_ract
         */
        pb_ract.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_ract)
                return object;
            var message = new $root.pb_ract();
            if (object.acts) {
                if (!Array.isArray(object.acts))
                    throw TypeError(".pb_ract.acts: array expected");
                message.acts = [];
                for (var i = 0; i < object.acts.length; ++i) {
                    if (typeof object.acts[i] !== "object")
                        throw TypeError(".pb_ract.acts: object expected");
                    message.acts[i] = $root.pb_ract_item.fromObject(object.acts[i]);
                }
            }
            if (object.show != null)
                message.show = object.show | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a pb_ract message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_ract
         * @static
         * @param {pb_ract} message pb_ract
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_ract.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.acts = [];
            if (options.defaults)
                object.show = 0;
            if (message.acts && message.acts.length) {
                object.acts = [];
                for (var j = 0; j < message.acts.length; ++j)
                    object.acts[j] = $root.pb_ract_item.toObject(message.acts[j], options);
            }
            if (message.show != null && message.hasOwnProperty("show"))
                object.show = message.show;
            return object;
        };
    
        /**
         * Converts this pb_ract to JSON.
         * @function toJSON
         * @memberof pb_ract
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_ract.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_ract
         * @function getTypeUrl
         * @memberof pb_ract
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_ract.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_ract";
        };
    
        return pb_ract;
    })();
    
    $root.pb_brave_box = (function() {
    
        /**
         * Properties of a pb_brave_box.
         * @exports Ipb_brave_box
         * @interface Ipb_brave_box
         * @property {number} id pb_brave_box id
         */
    
        /**
         * Constructs a new pb_brave_box.
         * @exports pb_brave_box
         * @classdesc Represents a pb_brave_box.
         * @implements Ipb_brave_box
         * @constructor
         * @param {Ipb_brave_box=} [properties] Properties to set
         */
        function pb_brave_box(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_brave_box id.
         * @member {number} id
         * @memberof pb_brave_box
         * @instance
         */
        pb_brave_box.prototype.id = 0;
    
        /**
         * Creates a new pb_brave_box instance using the specified properties.
         * @function create
         * @memberof pb_brave_box
         * @static
         * @param {Ipb_brave_box=} [properties] Properties to set
         * @returns {pb_brave_box} pb_brave_box instance
         */
        pb_brave_box.create = function create(properties) {
            return new pb_brave_box(properties);
        };
    
        /**
         * Encodes the specified pb_brave_box message. Does not implicitly {@link pb_brave_box.verify|verify} messages.
         * @function encode
         * @memberof pb_brave_box
         * @static
         * @param {Ipb_brave_box} message pb_brave_box message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_brave_box.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.id);
            return writer;
        };
    
        /**
         * Encodes the specified pb_brave_box message, length delimited. Does not implicitly {@link pb_brave_box.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_brave_box
         * @static
         * @param {Ipb_brave_box} message pb_brave_box message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_brave_box.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_brave_box message from the specified reader or buffer.
         * @function decode
         * @memberof pb_brave_box
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_brave_box} pb_brave_box
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_brave_box.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_brave_box();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.id = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("id"))
                throw $util.ProtocolError("missing required 'id'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a pb_brave_box message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_brave_box
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_brave_box} pb_brave_box
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_brave_box.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_brave_box message.
         * @function verify
         * @memberof pb_brave_box
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_brave_box.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.id))
                return "id: integer expected";
            return null;
        };
    
        /**
         * Creates a pb_brave_box message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_brave_box
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_brave_box} pb_brave_box
         */
        pb_brave_box.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_brave_box)
                return object;
            var message = new $root.pb_brave_box();
            if (object.id != null)
                message.id = object.id | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a pb_brave_box message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_brave_box
         * @static
         * @param {pb_brave_box} message pb_brave_box
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_brave_box.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.id = 0;
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            return object;
        };
    
        /**
         * Converts this pb_brave_box to JSON.
         * @function toJSON
         * @memberof pb_brave_box
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_brave_box.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_brave_box
         * @function getTypeUrl
         * @memberof pb_brave_box
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_brave_box.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_brave_box";
        };
    
        return pb_brave_box;
    })();
    
    $root.pb_brave_buff = (function() {
    
        /**
         * Properties of a pb_brave_buff.
         * @exports Ipb_brave_buff
         * @interface Ipb_brave_buff
         * @property {number} id pb_brave_buff id
         * @property {number} num pb_brave_buff num
         */
    
        /**
         * Constructs a new pb_brave_buff.
         * @exports pb_brave_buff
         * @classdesc Represents a pb_brave_buff.
         * @implements Ipb_brave_buff
         * @constructor
         * @param {Ipb_brave_buff=} [properties] Properties to set
         */
        function pb_brave_buff(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_brave_buff id.
         * @member {number} id
         * @memberof pb_brave_buff
         * @instance
         */
        pb_brave_buff.prototype.id = 0;
    
        /**
         * pb_brave_buff num.
         * @member {number} num
         * @memberof pb_brave_buff
         * @instance
         */
        pb_brave_buff.prototype.num = 0;
    
        /**
         * Creates a new pb_brave_buff instance using the specified properties.
         * @function create
         * @memberof pb_brave_buff
         * @static
         * @param {Ipb_brave_buff=} [properties] Properties to set
         * @returns {pb_brave_buff} pb_brave_buff instance
         */
        pb_brave_buff.create = function create(properties) {
            return new pb_brave_buff(properties);
        };
    
        /**
         * Encodes the specified pb_brave_buff message. Does not implicitly {@link pb_brave_buff.verify|verify} messages.
         * @function encode
         * @memberof pb_brave_buff
         * @static
         * @param {Ipb_brave_buff} message pb_brave_buff message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_brave_buff.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.id);
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.num);
            return writer;
        };
    
        /**
         * Encodes the specified pb_brave_buff message, length delimited. Does not implicitly {@link pb_brave_buff.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_brave_buff
         * @static
         * @param {Ipb_brave_buff} message pb_brave_buff message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_brave_buff.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_brave_buff message from the specified reader or buffer.
         * @function decode
         * @memberof pb_brave_buff
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_brave_buff} pb_brave_buff
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_brave_buff.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_brave_buff();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.id = reader.int32();
                        break;
                    }
                case 2: {
                        message.num = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("id"))
                throw $util.ProtocolError("missing required 'id'", { instance: message });
            if (!message.hasOwnProperty("num"))
                throw $util.ProtocolError("missing required 'num'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a pb_brave_buff message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_brave_buff
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_brave_buff} pb_brave_buff
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_brave_buff.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_brave_buff message.
         * @function verify
         * @memberof pb_brave_buff
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_brave_buff.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.id))
                return "id: integer expected";
            if (!$util.isInteger(message.num))
                return "num: integer expected";
            return null;
        };
    
        /**
         * Creates a pb_brave_buff message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_brave_buff
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_brave_buff} pb_brave_buff
         */
        pb_brave_buff.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_brave_buff)
                return object;
            var message = new $root.pb_brave_buff();
            if (object.id != null)
                message.id = object.id | 0;
            if (object.num != null)
                message.num = object.num | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a pb_brave_buff message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_brave_buff
         * @static
         * @param {pb_brave_buff} message pb_brave_buff
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_brave_buff.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = 0;
                object.num = 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.num != null && message.hasOwnProperty("num"))
                object.num = message.num;
            return object;
        };
    
        /**
         * Converts this pb_brave_buff to JSON.
         * @function toJSON
         * @memberof pb_brave_buff
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_brave_buff.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_brave_buff
         * @function getTypeUrl
         * @memberof pb_brave_buff
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_brave_buff.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_brave_buff";
        };
    
        return pb_brave_buff;
    })();
    
    $root.pb_re_sync = (function() {
    
        /**
         * Properties of a pb_re_sync.
         * @exports Ipb_re_sync
         * @interface Ipb_re_sync
         * @property {number|null} [role] pb_re_sync role
         * @property {number|null} [giftId] pb_re_sync giftId
         * @property {number|null} [backGift] pb_re_sync backGift
         * @property {number|null} [bindTimes] pb_re_sync bindTimes
         * @property {number|null} [helpTimes] pb_re_sync helpTimes
         * @property {number|null} [backCd] pb_re_sync backCd
         * @property {number|null} [bind] pb_re_sync bind
         * @property {Array.<Ipb_re_task>|null} [sTasks] pb_re_sync sTasks
         * @property {Array.<Ipb_re_task>|null} [hTasks] pb_re_sync hTasks
         * @property {number|null} [cd] pb_re_sync cd
         * @property {number|null} [cd2] pb_re_sync cd2
         * @property {Array.<Ipb_re_apply>|null} [applys] pb_re_sync applys
         * @property {string|null} [code] pb_re_sync code
         * @property {Array.<Ipb_re_bind_player>|null} [players] pb_re_sync players
         */
    
        /**
         * Constructs a new pb_re_sync.
         * @exports pb_re_sync
         * @classdesc Represents a pb_re_sync.
         * @implements Ipb_re_sync
         * @constructor
         * @param {Ipb_re_sync=} [properties] Properties to set
         */
        function pb_re_sync(properties) {
            this.sTasks = [];
            this.hTasks = [];
            this.applys = [];
            this.players = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_re_sync role.
         * @member {number} role
         * @memberof pb_re_sync
         * @instance
         */
        pb_re_sync.prototype.role = 0;
    
        /**
         * pb_re_sync giftId.
         * @member {number} giftId
         * @memberof pb_re_sync
         * @instance
         */
        pb_re_sync.prototype.giftId = 0;
    
        /**
         * pb_re_sync backGift.
         * @member {number} backGift
         * @memberof pb_re_sync
         * @instance
         */
        pb_re_sync.prototype.backGift = 0;
    
        /**
         * pb_re_sync bindTimes.
         * @member {number} bindTimes
         * @memberof pb_re_sync
         * @instance
         */
        pb_re_sync.prototype.bindTimes = 0;
    
        /**
         * pb_re_sync helpTimes.
         * @member {number} helpTimes
         * @memberof pb_re_sync
         * @instance
         */
        pb_re_sync.prototype.helpTimes = 0;
    
        /**
         * pb_re_sync backCd.
         * @member {number} backCd
         * @memberof pb_re_sync
         * @instance
         */
        pb_re_sync.prototype.backCd = 0;
    
        /**
         * pb_re_sync bind.
         * @member {number} bind
         * @memberof pb_re_sync
         * @instance
         */
        pb_re_sync.prototype.bind = 0;
    
        /**
         * pb_re_sync sTasks.
         * @member {Array.<Ipb_re_task>} sTasks
         * @memberof pb_re_sync
         * @instance
         */
        pb_re_sync.prototype.sTasks = $util.emptyArray;
    
        /**
         * pb_re_sync hTasks.
         * @member {Array.<Ipb_re_task>} hTasks
         * @memberof pb_re_sync
         * @instance
         */
        pb_re_sync.prototype.hTasks = $util.emptyArray;
    
        /**
         * pb_re_sync cd.
         * @member {number} cd
         * @memberof pb_re_sync
         * @instance
         */
        pb_re_sync.prototype.cd = 0;
    
        /**
         * pb_re_sync cd2.
         * @member {number} cd2
         * @memberof pb_re_sync
         * @instance
         */
        pb_re_sync.prototype.cd2 = 0;
    
        /**
         * pb_re_sync applys.
         * @member {Array.<Ipb_re_apply>} applys
         * @memberof pb_re_sync
         * @instance
         */
        pb_re_sync.prototype.applys = $util.emptyArray;
    
        /**
         * pb_re_sync code.
         * @member {string} code
         * @memberof pb_re_sync
         * @instance
         */
        pb_re_sync.prototype.code = "";
    
        /**
         * pb_re_sync players.
         * @member {Array.<Ipb_re_bind_player>} players
         * @memberof pb_re_sync
         * @instance
         */
        pb_re_sync.prototype.players = $util.emptyArray;
    
        /**
         * Creates a new pb_re_sync instance using the specified properties.
         * @function create
         * @memberof pb_re_sync
         * @static
         * @param {Ipb_re_sync=} [properties] Properties to set
         * @returns {pb_re_sync} pb_re_sync instance
         */
        pb_re_sync.create = function create(properties) {
            return new pb_re_sync(properties);
        };
    
        /**
         * Encodes the specified pb_re_sync message. Does not implicitly {@link pb_re_sync.verify|verify} messages.
         * @function encode
         * @memberof pb_re_sync
         * @static
         * @param {Ipb_re_sync} message pb_re_sync message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_re_sync.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.role != null && Object.hasOwnProperty.call(message, "role"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.role);
            if (message.giftId != null && Object.hasOwnProperty.call(message, "giftId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.giftId);
            if (message.backGift != null && Object.hasOwnProperty.call(message, "backGift"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.backGift);
            if (message.bindTimes != null && Object.hasOwnProperty.call(message, "bindTimes"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.bindTimes);
            if (message.helpTimes != null && Object.hasOwnProperty.call(message, "helpTimes"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.helpTimes);
            if (message.backCd != null && Object.hasOwnProperty.call(message, "backCd"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.backCd);
            if (message.bind != null && Object.hasOwnProperty.call(message, "bind"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.bind);
            if (message.sTasks != null && message.sTasks.length)
                for (var i = 0; i < message.sTasks.length; ++i)
                    $root.pb_re_task.encode(message.sTasks[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message.hTasks != null && message.hTasks.length)
                for (var i = 0; i < message.hTasks.length; ++i)
                    $root.pb_re_task.encode(message.hTasks[i], writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
            if (message.cd != null && Object.hasOwnProperty.call(message, "cd"))
                writer.uint32(/* id 10, wireType 0 =*/80).int32(message.cd);
            if (message.cd2 != null && Object.hasOwnProperty.call(message, "cd2"))
                writer.uint32(/* id 11, wireType 0 =*/88).int32(message.cd2);
            if (message.applys != null && message.applys.length)
                for (var i = 0; i < message.applys.length; ++i)
                    $root.pb_re_apply.encode(message.applys[i], writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
            if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                writer.uint32(/* id 13, wireType 2 =*/106).string(message.code);
            if (message.players != null && message.players.length)
                for (var i = 0; i < message.players.length; ++i)
                    $root.pb_re_bind_player.encode(message.players[i], writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified pb_re_sync message, length delimited. Does not implicitly {@link pb_re_sync.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_re_sync
         * @static
         * @param {Ipb_re_sync} message pb_re_sync message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_re_sync.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_re_sync message from the specified reader or buffer.
         * @function decode
         * @memberof pb_re_sync
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_re_sync} pb_re_sync
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_re_sync.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_re_sync();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.role = reader.int32();
                        break;
                    }
                case 2: {
                        message.giftId = reader.int32();
                        break;
                    }
                case 3: {
                        message.backGift = reader.int32();
                        break;
                    }
                case 4: {
                        message.bindTimes = reader.int32();
                        break;
                    }
                case 5: {
                        message.helpTimes = reader.int32();
                        break;
                    }
                case 6: {
                        message.backCd = reader.int32();
                        break;
                    }
                case 7: {
                        message.bind = reader.int32();
                        break;
                    }
                case 8: {
                        if (!(message.sTasks && message.sTasks.length))
                            message.sTasks = [];
                        message.sTasks.push($root.pb_re_task.decode(reader, reader.uint32()));
                        break;
                    }
                case 9: {
                        if (!(message.hTasks && message.hTasks.length))
                            message.hTasks = [];
                        message.hTasks.push($root.pb_re_task.decode(reader, reader.uint32()));
                        break;
                    }
                case 10: {
                        message.cd = reader.int32();
                        break;
                    }
                case 11: {
                        message.cd2 = reader.int32();
                        break;
                    }
                case 12: {
                        if (!(message.applys && message.applys.length))
                            message.applys = [];
                        message.applys.push($root.pb_re_apply.decode(reader, reader.uint32()));
                        break;
                    }
                case 13: {
                        message.code = reader.string();
                        break;
                    }
                case 14: {
                        if (!(message.players && message.players.length))
                            message.players = [];
                        message.players.push($root.pb_re_bind_player.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a pb_re_sync message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_re_sync
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_re_sync} pb_re_sync
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_re_sync.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_re_sync message.
         * @function verify
         * @memberof pb_re_sync
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_re_sync.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.role != null && message.hasOwnProperty("role"))
                if (!$util.isInteger(message.role))
                    return "role: integer expected";
            if (message.giftId != null && message.hasOwnProperty("giftId"))
                if (!$util.isInteger(message.giftId))
                    return "giftId: integer expected";
            if (message.backGift != null && message.hasOwnProperty("backGift"))
                if (!$util.isInteger(message.backGift))
                    return "backGift: integer expected";
            if (message.bindTimes != null && message.hasOwnProperty("bindTimes"))
                if (!$util.isInteger(message.bindTimes))
                    return "bindTimes: integer expected";
            if (message.helpTimes != null && message.hasOwnProperty("helpTimes"))
                if (!$util.isInteger(message.helpTimes))
                    return "helpTimes: integer expected";
            if (message.backCd != null && message.hasOwnProperty("backCd"))
                if (!$util.isInteger(message.backCd))
                    return "backCd: integer expected";
            if (message.bind != null && message.hasOwnProperty("bind"))
                if (!$util.isInteger(message.bind))
                    return "bind: integer expected";
            if (message.sTasks != null && message.hasOwnProperty("sTasks")) {
                if (!Array.isArray(message.sTasks))
                    return "sTasks: array expected";
                for (var i = 0; i < message.sTasks.length; ++i) {
                    var error = $root.pb_re_task.verify(message.sTasks[i]);
                    if (error)
                        return "sTasks." + error;
                }
            }
            if (message.hTasks != null && message.hasOwnProperty("hTasks")) {
                if (!Array.isArray(message.hTasks))
                    return "hTasks: array expected";
                for (var i = 0; i < message.hTasks.length; ++i) {
                    var error = $root.pb_re_task.verify(message.hTasks[i]);
                    if (error)
                        return "hTasks." + error;
                }
            }
            if (message.cd != null && message.hasOwnProperty("cd"))
                if (!$util.isInteger(message.cd))
                    return "cd: integer expected";
            if (message.cd2 != null && message.hasOwnProperty("cd2"))
                if (!$util.isInteger(message.cd2))
                    return "cd2: integer expected";
            if (message.applys != null && message.hasOwnProperty("applys")) {
                if (!Array.isArray(message.applys))
                    return "applys: array expected";
                for (var i = 0; i < message.applys.length; ++i) {
                    var error = $root.pb_re_apply.verify(message.applys[i]);
                    if (error)
                        return "applys." + error;
                }
            }
            if (message.code != null && message.hasOwnProperty("code"))
                if (!$util.isString(message.code))
                    return "code: string expected";
            if (message.players != null && message.hasOwnProperty("players")) {
                if (!Array.isArray(message.players))
                    return "players: array expected";
                for (var i = 0; i < message.players.length; ++i) {
                    var error = $root.pb_re_bind_player.verify(message.players[i]);
                    if (error)
                        return "players." + error;
                }
            }
            return null;
        };
    
        /**
         * Creates a pb_re_sync message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_re_sync
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_re_sync} pb_re_sync
         */
        pb_re_sync.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_re_sync)
                return object;
            var message = new $root.pb_re_sync();
            if (object.role != null)
                message.role = object.role | 0;
            if (object.giftId != null)
                message.giftId = object.giftId | 0;
            if (object.backGift != null)
                message.backGift = object.backGift | 0;
            if (object.bindTimes != null)
                message.bindTimes = object.bindTimes | 0;
            if (object.helpTimes != null)
                message.helpTimes = object.helpTimes | 0;
            if (object.backCd != null)
                message.backCd = object.backCd | 0;
            if (object.bind != null)
                message.bind = object.bind | 0;
            if (object.sTasks) {
                if (!Array.isArray(object.sTasks))
                    throw TypeError(".pb_re_sync.sTasks: array expected");
                message.sTasks = [];
                for (var i = 0; i < object.sTasks.length; ++i) {
                    if (typeof object.sTasks[i] !== "object")
                        throw TypeError(".pb_re_sync.sTasks: object expected");
                    message.sTasks[i] = $root.pb_re_task.fromObject(object.sTasks[i]);
                }
            }
            if (object.hTasks) {
                if (!Array.isArray(object.hTasks))
                    throw TypeError(".pb_re_sync.hTasks: array expected");
                message.hTasks = [];
                for (var i = 0; i < object.hTasks.length; ++i) {
                    if (typeof object.hTasks[i] !== "object")
                        throw TypeError(".pb_re_sync.hTasks: object expected");
                    message.hTasks[i] = $root.pb_re_task.fromObject(object.hTasks[i]);
                }
            }
            if (object.cd != null)
                message.cd = object.cd | 0;
            if (object.cd2 != null)
                message.cd2 = object.cd2 | 0;
            if (object.applys) {
                if (!Array.isArray(object.applys))
                    throw TypeError(".pb_re_sync.applys: array expected");
                message.applys = [];
                for (var i = 0; i < object.applys.length; ++i) {
                    if (typeof object.applys[i] !== "object")
                        throw TypeError(".pb_re_sync.applys: object expected");
                    message.applys[i] = $root.pb_re_apply.fromObject(object.applys[i]);
                }
            }
            if (object.code != null)
                message.code = String(object.code);
            if (object.players) {
                if (!Array.isArray(object.players))
                    throw TypeError(".pb_re_sync.players: array expected");
                message.players = [];
                for (var i = 0; i < object.players.length; ++i) {
                    if (typeof object.players[i] !== "object")
                        throw TypeError(".pb_re_sync.players: object expected");
                    message.players[i] = $root.pb_re_bind_player.fromObject(object.players[i]);
                }
            }
            return message;
        };
    
        /**
         * Creates a plain object from a pb_re_sync message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_re_sync
         * @static
         * @param {pb_re_sync} message pb_re_sync
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_re_sync.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.sTasks = [];
                object.hTasks = [];
                object.applys = [];
                object.players = [];
            }
            if (options.defaults) {
                object.role = 0;
                object.giftId = 0;
                object.backGift = 0;
                object.bindTimes = 0;
                object.helpTimes = 0;
                object.backCd = 0;
                object.bind = 0;
                object.cd = 0;
                object.cd2 = 0;
                object.code = "";
            }
            if (message.role != null && message.hasOwnProperty("role"))
                object.role = message.role;
            if (message.giftId != null && message.hasOwnProperty("giftId"))
                object.giftId = message.giftId;
            if (message.backGift != null && message.hasOwnProperty("backGift"))
                object.backGift = message.backGift;
            if (message.bindTimes != null && message.hasOwnProperty("bindTimes"))
                object.bindTimes = message.bindTimes;
            if (message.helpTimes != null && message.hasOwnProperty("helpTimes"))
                object.helpTimes = message.helpTimes;
            if (message.backCd != null && message.hasOwnProperty("backCd"))
                object.backCd = message.backCd;
            if (message.bind != null && message.hasOwnProperty("bind"))
                object.bind = message.bind;
            if (message.sTasks && message.sTasks.length) {
                object.sTasks = [];
                for (var j = 0; j < message.sTasks.length; ++j)
                    object.sTasks[j] = $root.pb_re_task.toObject(message.sTasks[j], options);
            }
            if (message.hTasks && message.hTasks.length) {
                object.hTasks = [];
                for (var j = 0; j < message.hTasks.length; ++j)
                    object.hTasks[j] = $root.pb_re_task.toObject(message.hTasks[j], options);
            }
            if (message.cd != null && message.hasOwnProperty("cd"))
                object.cd = message.cd;
            if (message.cd2 != null && message.hasOwnProperty("cd2"))
                object.cd2 = message.cd2;
            if (message.applys && message.applys.length) {
                object.applys = [];
                for (var j = 0; j < message.applys.length; ++j)
                    object.applys[j] = $root.pb_re_apply.toObject(message.applys[j], options);
            }
            if (message.code != null && message.hasOwnProperty("code"))
                object.code = message.code;
            if (message.players && message.players.length) {
                object.players = [];
                for (var j = 0; j < message.players.length; ++j)
                    object.players[j] = $root.pb_re_bind_player.toObject(message.players[j], options);
            }
            return object;
        };
    
        /**
         * Converts this pb_re_sync to JSON.
         * @function toJSON
         * @memberof pb_re_sync
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_re_sync.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_re_sync
         * @function getTypeUrl
         * @memberof pb_re_sync
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_re_sync.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_re_sync";
        };
    
        return pb_re_sync;
    })();
    
    $root.pb_re_bind_player = (function() {
    
        /**
         * Properties of a pb_re_bind_player.
         * @exports Ipb_re_bind_player
         * @interface Ipb_re_bind_player
         * @property {number|null} [logo] pb_re_bind_player logo
         * @property {number|null} [uid] pb_re_bind_player uid
         * @property {string|null} [name] pb_re_bind_player name
         * @property {number|null} [bind] pb_re_bind_player bind
         */
    
        /**
         * Constructs a new pb_re_bind_player.
         * @exports pb_re_bind_player
         * @classdesc Represents a pb_re_bind_player.
         * @implements Ipb_re_bind_player
         * @constructor
         * @param {Ipb_re_bind_player=} [properties] Properties to set
         */
        function pb_re_bind_player(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_re_bind_player logo.
         * @member {number} logo
         * @memberof pb_re_bind_player
         * @instance
         */
        pb_re_bind_player.prototype.logo = 0;
    
        /**
         * pb_re_bind_player uid.
         * @member {number} uid
         * @memberof pb_re_bind_player
         * @instance
         */
        pb_re_bind_player.prototype.uid = 0;
    
        /**
         * pb_re_bind_player name.
         * @member {string} name
         * @memberof pb_re_bind_player
         * @instance
         */
        pb_re_bind_player.prototype.name = "";
    
        /**
         * pb_re_bind_player bind.
         * @member {number} bind
         * @memberof pb_re_bind_player
         * @instance
         */
        pb_re_bind_player.prototype.bind = 0;
    
        /**
         * Creates a new pb_re_bind_player instance using the specified properties.
         * @function create
         * @memberof pb_re_bind_player
         * @static
         * @param {Ipb_re_bind_player=} [properties] Properties to set
         * @returns {pb_re_bind_player} pb_re_bind_player instance
         */
        pb_re_bind_player.create = function create(properties) {
            return new pb_re_bind_player(properties);
        };
    
        /**
         * Encodes the specified pb_re_bind_player message. Does not implicitly {@link pb_re_bind_player.verify|verify} messages.
         * @function encode
         * @memberof pb_re_bind_player
         * @static
         * @param {Ipb_re_bind_player} message pb_re_bind_player message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_re_bind_player.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.logo != null && Object.hasOwnProperty.call(message, "logo"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.logo);
            if (message.uid != null && Object.hasOwnProperty.call(message, "uid"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.uid);
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.name);
            if (message.bind != null && Object.hasOwnProperty.call(message, "bind"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.bind);
            return writer;
        };
    
        /**
         * Encodes the specified pb_re_bind_player message, length delimited. Does not implicitly {@link pb_re_bind_player.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_re_bind_player
         * @static
         * @param {Ipb_re_bind_player} message pb_re_bind_player message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_re_bind_player.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_re_bind_player message from the specified reader or buffer.
         * @function decode
         * @memberof pb_re_bind_player
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_re_bind_player} pb_re_bind_player
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_re_bind_player.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_re_bind_player();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.logo = reader.int32();
                        break;
                    }
                case 2: {
                        message.uid = reader.int32();
                        break;
                    }
                case 3: {
                        message.name = reader.string();
                        break;
                    }
                case 4: {
                        message.bind = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a pb_re_bind_player message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_re_bind_player
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_re_bind_player} pb_re_bind_player
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_re_bind_player.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_re_bind_player message.
         * @function verify
         * @memberof pb_re_bind_player
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_re_bind_player.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.logo != null && message.hasOwnProperty("logo"))
                if (!$util.isInteger(message.logo))
                    return "logo: integer expected";
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (!$util.isInteger(message.uid))
                    return "uid: integer expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.bind != null && message.hasOwnProperty("bind"))
                if (!$util.isInteger(message.bind))
                    return "bind: integer expected";
            return null;
        };
    
        /**
         * Creates a pb_re_bind_player message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_re_bind_player
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_re_bind_player} pb_re_bind_player
         */
        pb_re_bind_player.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_re_bind_player)
                return object;
            var message = new $root.pb_re_bind_player();
            if (object.logo != null)
                message.logo = object.logo | 0;
            if (object.uid != null)
                message.uid = object.uid | 0;
            if (object.name != null)
                message.name = String(object.name);
            if (object.bind != null)
                message.bind = object.bind | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a pb_re_bind_player message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_re_bind_player
         * @static
         * @param {pb_re_bind_player} message pb_re_bind_player
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_re_bind_player.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.logo = 0;
                object.uid = 0;
                object.name = "";
                object.bind = 0;
            }
            if (message.logo != null && message.hasOwnProperty("logo"))
                object.logo = message.logo;
            if (message.uid != null && message.hasOwnProperty("uid"))
                object.uid = message.uid;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.bind != null && message.hasOwnProperty("bind"))
                object.bind = message.bind;
            return object;
        };
    
        /**
         * Converts this pb_re_bind_player to JSON.
         * @function toJSON
         * @memberof pb_re_bind_player
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_re_bind_player.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_re_bind_player
         * @function getTypeUrl
         * @memberof pb_re_bind_player
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_re_bind_player.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_re_bind_player";
        };
    
        return pb_re_bind_player;
    })();
    
    $root.pb_re_apply = (function() {
    
        /**
         * Properties of a pb_re_apply.
         * @exports Ipb_re_apply
         * @interface Ipb_re_apply
         * @property {number} logo pb_re_apply logo
         * @property {number|Long|null} [uid] pb_re_apply uid
         * @property {string|null} [name] pb_re_apply name
         * @property {number|null} [cd] pb_re_apply cd
         */
    
        /**
         * Constructs a new pb_re_apply.
         * @exports pb_re_apply
         * @classdesc Represents a pb_re_apply.
         * @implements Ipb_re_apply
         * @constructor
         * @param {Ipb_re_apply=} [properties] Properties to set
         */
        function pb_re_apply(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_re_apply logo.
         * @member {number} logo
         * @memberof pb_re_apply
         * @instance
         */
        pb_re_apply.prototype.logo = 0;
    
        /**
         * pb_re_apply uid.
         * @member {number|Long} uid
         * @memberof pb_re_apply
         * @instance
         */
        pb_re_apply.prototype.uid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * pb_re_apply name.
         * @member {string} name
         * @memberof pb_re_apply
         * @instance
         */
        pb_re_apply.prototype.name = "";
    
        /**
         * pb_re_apply cd.
         * @member {number} cd
         * @memberof pb_re_apply
         * @instance
         */
        pb_re_apply.prototype.cd = 0;
    
        /**
         * Creates a new pb_re_apply instance using the specified properties.
         * @function create
         * @memberof pb_re_apply
         * @static
         * @param {Ipb_re_apply=} [properties] Properties to set
         * @returns {pb_re_apply} pb_re_apply instance
         */
        pb_re_apply.create = function create(properties) {
            return new pb_re_apply(properties);
        };
    
        /**
         * Encodes the specified pb_re_apply message. Does not implicitly {@link pb_re_apply.verify|verify} messages.
         * @function encode
         * @memberof pb_re_apply
         * @static
         * @param {Ipb_re_apply} message pb_re_apply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_re_apply.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.logo);
            if (message.uid != null && Object.hasOwnProperty.call(message, "uid"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.uid);
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.name);
            if (message.cd != null && Object.hasOwnProperty.call(message, "cd"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.cd);
            return writer;
        };
    
        /**
         * Encodes the specified pb_re_apply message, length delimited. Does not implicitly {@link pb_re_apply.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_re_apply
         * @static
         * @param {Ipb_re_apply} message pb_re_apply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_re_apply.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_re_apply message from the specified reader or buffer.
         * @function decode
         * @memberof pb_re_apply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_re_apply} pb_re_apply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_re_apply.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_re_apply();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.logo = reader.int32();
                        break;
                    }
                case 2: {
                        message.uid = reader.int64();
                        break;
                    }
                case 3: {
                        message.name = reader.string();
                        break;
                    }
                case 4: {
                        message.cd = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("logo"))
                throw $util.ProtocolError("missing required 'logo'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a pb_re_apply message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_re_apply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_re_apply} pb_re_apply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_re_apply.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_re_apply message.
         * @function verify
         * @memberof pb_re_apply
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_re_apply.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.logo))
                return "logo: integer expected";
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (!$util.isInteger(message.uid) && !(message.uid && $util.isInteger(message.uid.low) && $util.isInteger(message.uid.high)))
                    return "uid: integer|Long expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.cd != null && message.hasOwnProperty("cd"))
                if (!$util.isInteger(message.cd))
                    return "cd: integer expected";
            return null;
        };
    
        /**
         * Creates a pb_re_apply message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_re_apply
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_re_apply} pb_re_apply
         */
        pb_re_apply.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_re_apply)
                return object;
            var message = new $root.pb_re_apply();
            if (object.logo != null)
                message.logo = object.logo | 0;
            if (object.uid != null)
                if ($util.Long)
                    (message.uid = $util.Long.fromValue(object.uid)).unsigned = false;
                else if (typeof object.uid === "string")
                    message.uid = parseInt(object.uid, 10);
                else if (typeof object.uid === "number")
                    message.uid = object.uid;
                else if (typeof object.uid === "object")
                    message.uid = new $util.LongBits(object.uid.low >>> 0, object.uid.high >>> 0).toNumber();
            if (object.name != null)
                message.name = String(object.name);
            if (object.cd != null)
                message.cd = object.cd | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a pb_re_apply message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_re_apply
         * @static
         * @param {pb_re_apply} message pb_re_apply
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_re_apply.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.logo = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.uid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.uid = options.longs === String ? "0" : 0;
                object.name = "";
                object.cd = 0;
            }
            if (message.logo != null && message.hasOwnProperty("logo"))
                object.logo = message.logo;
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (typeof message.uid === "number")
                    object.uid = options.longs === String ? String(message.uid) : message.uid;
                else
                    object.uid = options.longs === String ? $util.Long.prototype.toString.call(message.uid) : options.longs === Number ? new $util.LongBits(message.uid.low >>> 0, message.uid.high >>> 0).toNumber() : message.uid;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.cd != null && message.hasOwnProperty("cd"))
                object.cd = message.cd;
            return object;
        };
    
        /**
         * Converts this pb_re_apply to JSON.
         * @function toJSON
         * @memberof pb_re_apply
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_re_apply.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_re_apply
         * @function getTypeUrl
         * @memberof pb_re_apply
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_re_apply.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_re_apply";
        };
    
        return pb_re_apply;
    })();
    
    $root.pb_re_task = (function() {
    
        /**
         * Properties of a pb_re_task.
         * @exports Ipb_re_task
         * @interface Ipb_re_task
         * @property {number} id pb_re_task id
         * @property {number|null} [num1] pb_re_task num1
         * @property {number|null} [num2] pb_re_task num2
         */
    
        /**
         * Constructs a new pb_re_task.
         * @exports pb_re_task
         * @classdesc Represents a pb_re_task.
         * @implements Ipb_re_task
         * @constructor
         * @param {Ipb_re_task=} [properties] Properties to set
         */
        function pb_re_task(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_re_task id.
         * @member {number} id
         * @memberof pb_re_task
         * @instance
         */
        pb_re_task.prototype.id = 0;
    
        /**
         * pb_re_task num1.
         * @member {number} num1
         * @memberof pb_re_task
         * @instance
         */
        pb_re_task.prototype.num1 = 0;
    
        /**
         * pb_re_task num2.
         * @member {number} num2
         * @memberof pb_re_task
         * @instance
         */
        pb_re_task.prototype.num2 = 0;
    
        /**
         * Creates a new pb_re_task instance using the specified properties.
         * @function create
         * @memberof pb_re_task
         * @static
         * @param {Ipb_re_task=} [properties] Properties to set
         * @returns {pb_re_task} pb_re_task instance
         */
        pb_re_task.create = function create(properties) {
            return new pb_re_task(properties);
        };
    
        /**
         * Encodes the specified pb_re_task message. Does not implicitly {@link pb_re_task.verify|verify} messages.
         * @function encode
         * @memberof pb_re_task
         * @static
         * @param {Ipb_re_task} message pb_re_task message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_re_task.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.id);
            if (message.num1 != null && Object.hasOwnProperty.call(message, "num1"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.num1);
            if (message.num2 != null && Object.hasOwnProperty.call(message, "num2"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.num2);
            return writer;
        };
    
        /**
         * Encodes the specified pb_re_task message, length delimited. Does not implicitly {@link pb_re_task.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_re_task
         * @static
         * @param {Ipb_re_task} message pb_re_task message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_re_task.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_re_task message from the specified reader or buffer.
         * @function decode
         * @memberof pb_re_task
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_re_task} pb_re_task
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_re_task.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_re_task();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.id = reader.int32();
                        break;
                    }
                case 2: {
                        message.num1 = reader.int32();
                        break;
                    }
                case 3: {
                        message.num2 = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("id"))
                throw $util.ProtocolError("missing required 'id'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a pb_re_task message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_re_task
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_re_task} pb_re_task
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_re_task.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_re_task message.
         * @function verify
         * @memberof pb_re_task
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_re_task.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.id))
                return "id: integer expected";
            if (message.num1 != null && message.hasOwnProperty("num1"))
                if (!$util.isInteger(message.num1))
                    return "num1: integer expected";
            if (message.num2 != null && message.hasOwnProperty("num2"))
                if (!$util.isInteger(message.num2))
                    return "num2: integer expected";
            return null;
        };
    
        /**
         * Creates a pb_re_task message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_re_task
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_re_task} pb_re_task
         */
        pb_re_task.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_re_task)
                return object;
            var message = new $root.pb_re_task();
            if (object.id != null)
                message.id = object.id | 0;
            if (object.num1 != null)
                message.num1 = object.num1 | 0;
            if (object.num2 != null)
                message.num2 = object.num2 | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a pb_re_task message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_re_task
         * @static
         * @param {pb_re_task} message pb_re_task
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_re_task.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = 0;
                object.num1 = 0;
                object.num2 = 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.num1 != null && message.hasOwnProperty("num1"))
                object.num1 = message.num1;
            if (message.num2 != null && message.hasOwnProperty("num2"))
                object.num2 = message.num2;
            return object;
        };
    
        /**
         * Converts this pb_re_task to JSON.
         * @function toJSON
         * @memberof pb_re_task
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_re_task.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_re_task
         * @function getTypeUrl
         * @memberof pb_re_task
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_re_task.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_re_task";
        };
    
        return pb_re_task;
    })();
    
    $root.pb_vbuff = (function() {
    
        /**
         * Properties of a pb_vbuff.
         * @exports Ipb_vbuff
         * @interface Ipb_vbuff
         * @property {number|null} [id] pb_vbuff id
         * @property {number|null} [type] pb_vbuff type
         */
    
        /**
         * Constructs a new pb_vbuff.
         * @exports pb_vbuff
         * @classdesc Represents a pb_vbuff.
         * @implements Ipb_vbuff
         * @constructor
         * @param {Ipb_vbuff=} [properties] Properties to set
         */
        function pb_vbuff(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_vbuff id.
         * @member {number} id
         * @memberof pb_vbuff
         * @instance
         */
        pb_vbuff.prototype.id = 0;
    
        /**
         * pb_vbuff type.
         * @member {number} type
         * @memberof pb_vbuff
         * @instance
         */
        pb_vbuff.prototype.type = 0;
    
        /**
         * Creates a new pb_vbuff instance using the specified properties.
         * @function create
         * @memberof pb_vbuff
         * @static
         * @param {Ipb_vbuff=} [properties] Properties to set
         * @returns {pb_vbuff} pb_vbuff instance
         */
        pb_vbuff.create = function create(properties) {
            return new pb_vbuff(properties);
        };
    
        /**
         * Encodes the specified pb_vbuff message. Does not implicitly {@link pb_vbuff.verify|verify} messages.
         * @function encode
         * @memberof pb_vbuff
         * @static
         * @param {Ipb_vbuff} message pb_vbuff message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_vbuff.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.id);
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.type);
            return writer;
        };
    
        /**
         * Encodes the specified pb_vbuff message, length delimited. Does not implicitly {@link pb_vbuff.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_vbuff
         * @static
         * @param {Ipb_vbuff} message pb_vbuff message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_vbuff.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_vbuff message from the specified reader or buffer.
         * @function decode
         * @memberof pb_vbuff
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_vbuff} pb_vbuff
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_vbuff.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_vbuff();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.id = reader.int32();
                        break;
                    }
                case 2: {
                        message.type = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a pb_vbuff message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_vbuff
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_vbuff} pb_vbuff
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_vbuff.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_vbuff message.
         * @function verify
         * @memberof pb_vbuff
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_vbuff.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id))
                    return "id: integer expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isInteger(message.type))
                    return "type: integer expected";
            return null;
        };
    
        /**
         * Creates a pb_vbuff message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_vbuff
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_vbuff} pb_vbuff
         */
        pb_vbuff.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_vbuff)
                return object;
            var message = new $root.pb_vbuff();
            if (object.id != null)
                message.id = object.id | 0;
            if (object.type != null)
                message.type = object.type | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a pb_vbuff message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_vbuff
         * @static
         * @param {pb_vbuff} message pb_vbuff
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_vbuff.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = 0;
                object.type = 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            return object;
        };
    
        /**
         * Converts this pb_vbuff to JSON.
         * @function toJSON
         * @memberof pb_vbuff
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_vbuff.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_vbuff
         * @function getTypeUrl
         * @memberof pb_vbuff
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_vbuff.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_vbuff";
        };
    
        return pb_vbuff;
    })();
    
    $root.pb_stele = (function() {
    
        /**
         * Properties of a pb_stele.
         * @exports Ipb_stele
         * @interface Ipb_stele
         * @property {number|null} [hook] pb_stele hook
         * @property {number|null} [solo] pb_stele solo
         * @property {number|null} [crush] pb_stele crush
         * @property {number|null} [tower] pb_stele tower
         * @property {Array.<number>|null} [sealland] pb_stele sealland
         * @property {number|null} [st] pb_stele st
         */
    
        /**
         * Constructs a new pb_stele.
         * @exports pb_stele
         * @classdesc Represents a pb_stele.
         * @implements Ipb_stele
         * @constructor
         * @param {Ipb_stele=} [properties] Properties to set
         */
        function pb_stele(properties) {
            this.sealland = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_stele hook.
         * @member {number} hook
         * @memberof pb_stele
         * @instance
         */
        pb_stele.prototype.hook = 0;
    
        /**
         * pb_stele solo.
         * @member {number} solo
         * @memberof pb_stele
         * @instance
         */
        pb_stele.prototype.solo = 0;
    
        /**
         * pb_stele crush.
         * @member {number} crush
         * @memberof pb_stele
         * @instance
         */
        pb_stele.prototype.crush = 0;
    
        /**
         * pb_stele tower.
         * @member {number} tower
         * @memberof pb_stele
         * @instance
         */
        pb_stele.prototype.tower = 0;
    
        /**
         * pb_stele sealland.
         * @member {Array.<number>} sealland
         * @memberof pb_stele
         * @instance
         */
        pb_stele.prototype.sealland = $util.emptyArray;
    
        /**
         * pb_stele st.
         * @member {number} st
         * @memberof pb_stele
         * @instance
         */
        pb_stele.prototype.st = 0;
    
        /**
         * Creates a new pb_stele instance using the specified properties.
         * @function create
         * @memberof pb_stele
         * @static
         * @param {Ipb_stele=} [properties] Properties to set
         * @returns {pb_stele} pb_stele instance
         */
        pb_stele.create = function create(properties) {
            return new pb_stele(properties);
        };
    
        /**
         * Encodes the specified pb_stele message. Does not implicitly {@link pb_stele.verify|verify} messages.
         * @function encode
         * @memberof pb_stele
         * @static
         * @param {Ipb_stele} message pb_stele message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_stele.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.hook != null && Object.hasOwnProperty.call(message, "hook"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.hook);
            if (message.solo != null && Object.hasOwnProperty.call(message, "solo"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.solo);
            if (message.crush != null && Object.hasOwnProperty.call(message, "crush"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.crush);
            if (message.tower != null && Object.hasOwnProperty.call(message, "tower"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.tower);
            if (message.sealland != null && message.sealland.length)
                for (var i = 0; i < message.sealland.length; ++i)
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.sealland[i]);
            if (message.st != null && Object.hasOwnProperty.call(message, "st"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.st);
            return writer;
        };
    
        /**
         * Encodes the specified pb_stele message, length delimited. Does not implicitly {@link pb_stele.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_stele
         * @static
         * @param {Ipb_stele} message pb_stele message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_stele.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_stele message from the specified reader or buffer.
         * @function decode
         * @memberof pb_stele
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_stele} pb_stele
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_stele.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_stele();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.hook = reader.int32();
                        break;
                    }
                case 2: {
                        message.solo = reader.int32();
                        break;
                    }
                case 3: {
                        message.crush = reader.int32();
                        break;
                    }
                case 4: {
                        message.tower = reader.int32();
                        break;
                    }
                case 5: {
                        if (!(message.sealland && message.sealland.length))
                            message.sealland = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.sealland.push(reader.int32());
                        } else
                            message.sealland.push(reader.int32());
                        break;
                    }
                case 6: {
                        message.st = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a pb_stele message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_stele
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_stele} pb_stele
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_stele.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_stele message.
         * @function verify
         * @memberof pb_stele
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_stele.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.hook != null && message.hasOwnProperty("hook"))
                if (!$util.isInteger(message.hook))
                    return "hook: integer expected";
            if (message.solo != null && message.hasOwnProperty("solo"))
                if (!$util.isInteger(message.solo))
                    return "solo: integer expected";
            if (message.crush != null && message.hasOwnProperty("crush"))
                if (!$util.isInteger(message.crush))
                    return "crush: integer expected";
            if (message.tower != null && message.hasOwnProperty("tower"))
                if (!$util.isInteger(message.tower))
                    return "tower: integer expected";
            if (message.sealland != null && message.hasOwnProperty("sealland")) {
                if (!Array.isArray(message.sealland))
                    return "sealland: array expected";
                for (var i = 0; i < message.sealland.length; ++i)
                    if (!$util.isInteger(message.sealland[i]))
                        return "sealland: integer[] expected";
            }
            if (message.st != null && message.hasOwnProperty("st"))
                if (!$util.isInteger(message.st))
                    return "st: integer expected";
            return null;
        };
    
        /**
         * Creates a pb_stele message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_stele
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_stele} pb_stele
         */
        pb_stele.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_stele)
                return object;
            var message = new $root.pb_stele();
            if (object.hook != null)
                message.hook = object.hook | 0;
            if (object.solo != null)
                message.solo = object.solo | 0;
            if (object.crush != null)
                message.crush = object.crush | 0;
            if (object.tower != null)
                message.tower = object.tower | 0;
            if (object.sealland) {
                if (!Array.isArray(object.sealland))
                    throw TypeError(".pb_stele.sealland: array expected");
                message.sealland = [];
                for (var i = 0; i < object.sealland.length; ++i)
                    message.sealland[i] = object.sealland[i] | 0;
            }
            if (object.st != null)
                message.st = object.st | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a pb_stele message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_stele
         * @static
         * @param {pb_stele} message pb_stele
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_stele.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.sealland = [];
            if (options.defaults) {
                object.hook = 0;
                object.solo = 0;
                object.crush = 0;
                object.tower = 0;
                object.st = 0;
            }
            if (message.hook != null && message.hasOwnProperty("hook"))
                object.hook = message.hook;
            if (message.solo != null && message.hasOwnProperty("solo"))
                object.solo = message.solo;
            if (message.crush != null && message.hasOwnProperty("crush"))
                object.crush = message.crush;
            if (message.tower != null && message.hasOwnProperty("tower"))
                object.tower = message.tower;
            if (message.sealland && message.sealland.length) {
                object.sealland = [];
                for (var j = 0; j < message.sealland.length; ++j)
                    object.sealland[j] = message.sealland[j];
            }
            if (message.st != null && message.hasOwnProperty("st"))
                object.st = message.st;
            return object;
        };
    
        /**
         * Converts this pb_stele to JSON.
         * @function toJSON
         * @memberof pb_stele
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_stele.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_stele
         * @function getTypeUrl
         * @memberof pb_stele
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_stele.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_stele";
        };
    
        return pb_stele;
    })();
    
    $root.pb_midas = (function() {
    
        /**
         * Properties of a pb_midas.
         * @exports Ipb_midas
         * @interface Ipb_midas
         * @property {number} type pb_midas type
         * @property {number} cd pb_midas cd
         * @property {number} index pb_midas index
         */
    
        /**
         * Constructs a new pb_midas.
         * @exports pb_midas
         * @classdesc Represents a pb_midas.
         * @implements Ipb_midas
         * @constructor
         * @param {Ipb_midas=} [properties] Properties to set
         */
        function pb_midas(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_midas type.
         * @member {number} type
         * @memberof pb_midas
         * @instance
         */
        pb_midas.prototype.type = 0;
    
        /**
         * pb_midas cd.
         * @member {number} cd
         * @memberof pb_midas
         * @instance
         */
        pb_midas.prototype.cd = 0;
    
        /**
         * pb_midas index.
         * @member {number} index
         * @memberof pb_midas
         * @instance
         */
        pb_midas.prototype.index = 0;
    
        /**
         * Creates a new pb_midas instance using the specified properties.
         * @function create
         * @memberof pb_midas
         * @static
         * @param {Ipb_midas=} [properties] Properties to set
         * @returns {pb_midas} pb_midas instance
         */
        pb_midas.create = function create(properties) {
            return new pb_midas(properties);
        };
    
        /**
         * Encodes the specified pb_midas message. Does not implicitly {@link pb_midas.verify|verify} messages.
         * @function encode
         * @memberof pb_midas
         * @static
         * @param {Ipb_midas} message pb_midas message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_midas.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.cd);
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.index);
            return writer;
        };
    
        /**
         * Encodes the specified pb_midas message, length delimited. Does not implicitly {@link pb_midas.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_midas
         * @static
         * @param {Ipb_midas} message pb_midas message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_midas.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_midas message from the specified reader or buffer.
         * @function decode
         * @memberof pb_midas
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_midas} pb_midas
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_midas.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_midas();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.type = reader.int32();
                        break;
                    }
                case 2: {
                        message.cd = reader.int32();
                        break;
                    }
                case 3: {
                        message.index = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("type"))
                throw $util.ProtocolError("missing required 'type'", { instance: message });
            if (!message.hasOwnProperty("cd"))
                throw $util.ProtocolError("missing required 'cd'", { instance: message });
            if (!message.hasOwnProperty("index"))
                throw $util.ProtocolError("missing required 'index'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a pb_midas message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_midas
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_midas} pb_midas
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_midas.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_midas message.
         * @function verify
         * @memberof pb_midas
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_midas.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.type))
                return "type: integer expected";
            if (!$util.isInteger(message.cd))
                return "cd: integer expected";
            if (!$util.isInteger(message.index))
                return "index: integer expected";
            return null;
        };
    
        /**
         * Creates a pb_midas message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_midas
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_midas} pb_midas
         */
        pb_midas.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_midas)
                return object;
            var message = new $root.pb_midas();
            if (object.type != null)
                message.type = object.type | 0;
            if (object.cd != null)
                message.cd = object.cd | 0;
            if (object.index != null)
                message.index = object.index | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a pb_midas message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_midas
         * @static
         * @param {pb_midas} message pb_midas
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_midas.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.type = 0;
                object.cd = 0;
                object.index = 0;
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            if (message.cd != null && message.hasOwnProperty("cd"))
                object.cd = message.cd;
            if (message.index != null && message.hasOwnProperty("index"))
                object.index = message.index;
            return object;
        };
    
        /**
         * Converts this pb_midas to JSON.
         * @function toJSON
         * @memberof pb_midas
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_midas.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_midas
         * @function getTypeUrl
         * @memberof pb_midas
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_midas.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_midas";
        };
    
        return pb_midas;
    })();
    
    $root.pb_gve = (function() {
    
        /**
         * Properties of a pb_gve.
         * @exports Ipb_gve
         * @interface Ipb_gve
         * @property {number|null} [id] pb_gve id
         * @property {number|null} [exp] pb_gve exp
         * @property {Array.<number>|null} [record] pb_gve record
         * @property {number|null} [fight] pb_gve fight
         */
    
        /**
         * Constructs a new pb_gve.
         * @exports pb_gve
         * @classdesc Represents a pb_gve.
         * @implements Ipb_gve
         * @constructor
         * @param {Ipb_gve=} [properties] Properties to set
         */
        function pb_gve(properties) {
            this.record = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_gve id.
         * @member {number} id
         * @memberof pb_gve
         * @instance
         */
        pb_gve.prototype.id = 0;
    
        /**
         * pb_gve exp.
         * @member {number} exp
         * @memberof pb_gve
         * @instance
         */
        pb_gve.prototype.exp = 0;
    
        /**
         * pb_gve record.
         * @member {Array.<number>} record
         * @memberof pb_gve
         * @instance
         */
        pb_gve.prototype.record = $util.emptyArray;
    
        /**
         * pb_gve fight.
         * @member {number} fight
         * @memberof pb_gve
         * @instance
         */
        pb_gve.prototype.fight = 0;
    
        /**
         * Creates a new pb_gve instance using the specified properties.
         * @function create
         * @memberof pb_gve
         * @static
         * @param {Ipb_gve=} [properties] Properties to set
         * @returns {pb_gve} pb_gve instance
         */
        pb_gve.create = function create(properties) {
            return new pb_gve(properties);
        };
    
        /**
         * Encodes the specified pb_gve message. Does not implicitly {@link pb_gve.verify|verify} messages.
         * @function encode
         * @memberof pb_gve
         * @static
         * @param {Ipb_gve} message pb_gve message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_gve.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.id);
            if (message.exp != null && Object.hasOwnProperty.call(message, "exp"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.exp);
            if (message.record != null && message.record.length)
                for (var i = 0; i < message.record.length; ++i)
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.record[i]);
            if (message.fight != null && Object.hasOwnProperty.call(message, "fight"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.fight);
            return writer;
        };
    
        /**
         * Encodes the specified pb_gve message, length delimited. Does not implicitly {@link pb_gve.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_gve
         * @static
         * @param {Ipb_gve} message pb_gve message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_gve.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_gve message from the specified reader or buffer.
         * @function decode
         * @memberof pb_gve
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_gve} pb_gve
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_gve.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_gve();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.id = reader.int32();
                        break;
                    }
                case 2: {
                        message.exp = reader.int32();
                        break;
                    }
                case 3: {
                        if (!(message.record && message.record.length))
                            message.record = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.record.push(reader.int32());
                        } else
                            message.record.push(reader.int32());
                        break;
                    }
                case 4: {
                        message.fight = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a pb_gve message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_gve
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_gve} pb_gve
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_gve.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_gve message.
         * @function verify
         * @memberof pb_gve
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_gve.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id))
                    return "id: integer expected";
            if (message.exp != null && message.hasOwnProperty("exp"))
                if (!$util.isInteger(message.exp))
                    return "exp: integer expected";
            if (message.record != null && message.hasOwnProperty("record")) {
                if (!Array.isArray(message.record))
                    return "record: array expected";
                for (var i = 0; i < message.record.length; ++i)
                    if (!$util.isInteger(message.record[i]))
                        return "record: integer[] expected";
            }
            if (message.fight != null && message.hasOwnProperty("fight"))
                if (!$util.isInteger(message.fight))
                    return "fight: integer expected";
            return null;
        };
    
        /**
         * Creates a pb_gve message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_gve
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_gve} pb_gve
         */
        pb_gve.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_gve)
                return object;
            var message = new $root.pb_gve();
            if (object.id != null)
                message.id = object.id | 0;
            if (object.exp != null)
                message.exp = object.exp | 0;
            if (object.record) {
                if (!Array.isArray(object.record))
                    throw TypeError(".pb_gve.record: array expected");
                message.record = [];
                for (var i = 0; i < object.record.length; ++i)
                    message.record[i] = object.record[i] | 0;
            }
            if (object.fight != null)
                message.fight = object.fight | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a pb_gve message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_gve
         * @static
         * @param {pb_gve} message pb_gve
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_gve.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.record = [];
            if (options.defaults) {
                object.id = 0;
                object.exp = 0;
                object.fight = 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.exp != null && message.hasOwnProperty("exp"))
                object.exp = message.exp;
            if (message.record && message.record.length) {
                object.record = [];
                for (var j = 0; j < message.record.length; ++j)
                    object.record[j] = message.record[j];
            }
            if (message.fight != null && message.hasOwnProperty("fight"))
                object.fight = message.fight;
            return object;
        };
    
        /**
         * Converts this pb_gve to JSON.
         * @function toJSON
         * @memberof pb_gve
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_gve.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_gve
         * @function getTypeUrl
         * @memberof pb_gve
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_gve.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_gve";
        };
    
        return pb_gve;
    })();
    
    $root.pb_gve_rank = (function() {
    
        /**
         * Properties of a pb_gve_rank.
         * @exports Ipb_gve_rank
         * @interface Ipb_gve_rank
         * @property {number|null} [id] pb_gve_rank id
         * @property {string|null} [name] pb_gve_rank name
         * @property {number|null} [exp] pb_gve_rank exp
         * @property {number|null} [texp] pb_gve_rank texp
         */
    
        /**
         * Constructs a new pb_gve_rank.
         * @exports pb_gve_rank
         * @classdesc Represents a pb_gve_rank.
         * @implements Ipb_gve_rank
         * @constructor
         * @param {Ipb_gve_rank=} [properties] Properties to set
         */
        function pb_gve_rank(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_gve_rank id.
         * @member {number} id
         * @memberof pb_gve_rank
         * @instance
         */
        pb_gve_rank.prototype.id = 0;
    
        /**
         * pb_gve_rank name.
         * @member {string} name
         * @memberof pb_gve_rank
         * @instance
         */
        pb_gve_rank.prototype.name = "";
    
        /**
         * pb_gve_rank exp.
         * @member {number} exp
         * @memberof pb_gve_rank
         * @instance
         */
        pb_gve_rank.prototype.exp = 0;
    
        /**
         * pb_gve_rank texp.
         * @member {number} texp
         * @memberof pb_gve_rank
         * @instance
         */
        pb_gve_rank.prototype.texp = 0;
    
        /**
         * Creates a new pb_gve_rank instance using the specified properties.
         * @function create
         * @memberof pb_gve_rank
         * @static
         * @param {Ipb_gve_rank=} [properties] Properties to set
         * @returns {pb_gve_rank} pb_gve_rank instance
         */
        pb_gve_rank.create = function create(properties) {
            return new pb_gve_rank(properties);
        };
    
        /**
         * Encodes the specified pb_gve_rank message. Does not implicitly {@link pb_gve_rank.verify|verify} messages.
         * @function encode
         * @memberof pb_gve_rank
         * @static
         * @param {Ipb_gve_rank} message pb_gve_rank message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_gve_rank.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.id);
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
            if (message.exp != null && Object.hasOwnProperty.call(message, "exp"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.exp);
            if (message.texp != null && Object.hasOwnProperty.call(message, "texp"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.texp);
            return writer;
        };
    
        /**
         * Encodes the specified pb_gve_rank message, length delimited. Does not implicitly {@link pb_gve_rank.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_gve_rank
         * @static
         * @param {Ipb_gve_rank} message pb_gve_rank message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_gve_rank.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_gve_rank message from the specified reader or buffer.
         * @function decode
         * @memberof pb_gve_rank
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_gve_rank} pb_gve_rank
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_gve_rank.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_gve_rank();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.id = reader.int32();
                        break;
                    }
                case 2: {
                        message.name = reader.string();
                        break;
                    }
                case 3: {
                        message.exp = reader.int32();
                        break;
                    }
                case 4: {
                        message.texp = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a pb_gve_rank message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_gve_rank
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_gve_rank} pb_gve_rank
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_gve_rank.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_gve_rank message.
         * @function verify
         * @memberof pb_gve_rank
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_gve_rank.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id))
                    return "id: integer expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.exp != null && message.hasOwnProperty("exp"))
                if (!$util.isInteger(message.exp))
                    return "exp: integer expected";
            if (message.texp != null && message.hasOwnProperty("texp"))
                if (!$util.isInteger(message.texp))
                    return "texp: integer expected";
            return null;
        };
    
        /**
         * Creates a pb_gve_rank message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_gve_rank
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_gve_rank} pb_gve_rank
         */
        pb_gve_rank.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_gve_rank)
                return object;
            var message = new $root.pb_gve_rank();
            if (object.id != null)
                message.id = object.id | 0;
            if (object.name != null)
                message.name = String(object.name);
            if (object.exp != null)
                message.exp = object.exp | 0;
            if (object.texp != null)
                message.texp = object.texp | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a pb_gve_rank message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_gve_rank
         * @static
         * @param {pb_gve_rank} message pb_gve_rank
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_gve_rank.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = 0;
                object.name = "";
                object.exp = 0;
                object.texp = 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.exp != null && message.hasOwnProperty("exp"))
                object.exp = message.exp;
            if (message.texp != null && message.hasOwnProperty("texp"))
                object.texp = message.texp;
            return object;
        };
    
        /**
         * Converts this pb_gve_rank to JSON.
         * @function toJSON
         * @memberof pb_gve_rank
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_gve_rank.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_gve_rank
         * @function getTypeUrl
         * @memberof pb_gve_rank
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_gve_rank.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_gve_rank";
        };
    
        return pb_gve_rank;
    })();
    
    $root.pb_act_block = (function() {
    
        /**
         * Properties of a pb_act_block.
         * @exports Ipb_act_block
         * @interface Ipb_act_block
         * @property {number|null} [pos] pb_act_block pos
         * @property {number|null} [eventid] pb_act_block eventid
         */
    
        /**
         * Constructs a new pb_act_block.
         * @exports pb_act_block
         * @classdesc Represents a pb_act_block.
         * @implements Ipb_act_block
         * @constructor
         * @param {Ipb_act_block=} [properties] Properties to set
         */
        function pb_act_block(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_act_block pos.
         * @member {number} pos
         * @memberof pb_act_block
         * @instance
         */
        pb_act_block.prototype.pos = 0;
    
        /**
         * pb_act_block eventid.
         * @member {number} eventid
         * @memberof pb_act_block
         * @instance
         */
        pb_act_block.prototype.eventid = 0;
    
        /**
         * Creates a new pb_act_block instance using the specified properties.
         * @function create
         * @memberof pb_act_block
         * @static
         * @param {Ipb_act_block=} [properties] Properties to set
         * @returns {pb_act_block} pb_act_block instance
         */
        pb_act_block.create = function create(properties) {
            return new pb_act_block(properties);
        };
    
        /**
         * Encodes the specified pb_act_block message. Does not implicitly {@link pb_act_block.verify|verify} messages.
         * @function encode
         * @memberof pb_act_block
         * @static
         * @param {Ipb_act_block} message pb_act_block message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_act_block.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.pos != null && Object.hasOwnProperty.call(message, "pos"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.pos);
            if (message.eventid != null && Object.hasOwnProperty.call(message, "eventid"))
                writer.uint32(/* id 2, wireType 0 =*/16).sint32(message.eventid);
            return writer;
        };
    
        /**
         * Encodes the specified pb_act_block message, length delimited. Does not implicitly {@link pb_act_block.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_act_block
         * @static
         * @param {Ipb_act_block} message pb_act_block message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_act_block.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_act_block message from the specified reader or buffer.
         * @function decode
         * @memberof pb_act_block
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_act_block} pb_act_block
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_act_block.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_act_block();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.pos = reader.int32();
                        break;
                    }
                case 2: {
                        message.eventid = reader.sint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a pb_act_block message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_act_block
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_act_block} pb_act_block
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_act_block.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_act_block message.
         * @function verify
         * @memberof pb_act_block
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_act_block.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.pos != null && message.hasOwnProperty("pos"))
                if (!$util.isInteger(message.pos))
                    return "pos: integer expected";
            if (message.eventid != null && message.hasOwnProperty("eventid"))
                if (!$util.isInteger(message.eventid))
                    return "eventid: integer expected";
            return null;
        };
    
        /**
         * Creates a pb_act_block message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_act_block
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_act_block} pb_act_block
         */
        pb_act_block.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_act_block)
                return object;
            var message = new $root.pb_act_block();
            if (object.pos != null)
                message.pos = object.pos | 0;
            if (object.eventid != null)
                message.eventid = object.eventid | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a pb_act_block message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_act_block
         * @static
         * @param {pb_act_block} message pb_act_block
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_act_block.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.pos = 0;
                object.eventid = 0;
            }
            if (message.pos != null && message.hasOwnProperty("pos"))
                object.pos = message.pos;
            if (message.eventid != null && message.hasOwnProperty("eventid"))
                object.eventid = message.eventid;
            return object;
        };
    
        /**
         * Converts this pb_act_block to JSON.
         * @function toJSON
         * @memberof pb_act_block
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_act_block.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_act_block
         * @function getTypeUrl
         * @memberof pb_act_block
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_act_block.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_act_block";
        };
    
        return pb_act_block;
    })();
    
    $root.pb_act_maze = (function() {
    
        /**
         * Properties of a pb_act_maze.
         * @exports Ipb_act_maze
         * @interface Ipb_act_maze
         * @property {number|null} [floor] pb_act_maze floor
         * @property {Array.<Ipb_act_block>|null} [events] pb_act_maze events
         * @property {number|null} [heroid] pb_act_maze heroid
         * @property {number|null} [skill] pb_act_maze skill
         * @property {number|null} [skillLv] pb_act_maze skillLv
         * @property {number|null} [change] pb_act_maze change
         * @property {number|null} [treasures] pb_act_maze treasures
         * @property {number|null} [buff] pb_act_maze buff
         * @property {number|null} [type] pb_act_maze type
         * @property {number|null} [pos] pb_act_maze pos
         * @property {number|null} [buyNum] pb_act_maze buyNum
         * @property {boolean|null} [getFrag] pb_act_maze getFrag
         */
    
        /**
         * Constructs a new pb_act_maze.
         * @exports pb_act_maze
         * @classdesc Represents a pb_act_maze.
         * @implements Ipb_act_maze
         * @constructor
         * @param {Ipb_act_maze=} [properties] Properties to set
         */
        function pb_act_maze(properties) {
            this.events = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_act_maze floor.
         * @member {number} floor
         * @memberof pb_act_maze
         * @instance
         */
        pb_act_maze.prototype.floor = 0;
    
        /**
         * pb_act_maze events.
         * @member {Array.<Ipb_act_block>} events
         * @memberof pb_act_maze
         * @instance
         */
        pb_act_maze.prototype.events = $util.emptyArray;
    
        /**
         * pb_act_maze heroid.
         * @member {number} heroid
         * @memberof pb_act_maze
         * @instance
         */
        pb_act_maze.prototype.heroid = 0;
    
        /**
         * pb_act_maze skill.
         * @member {number} skill
         * @memberof pb_act_maze
         * @instance
         */
        pb_act_maze.prototype.skill = 0;
    
        /**
         * pb_act_maze skillLv.
         * @member {number} skillLv
         * @memberof pb_act_maze
         * @instance
         */
        pb_act_maze.prototype.skillLv = 0;
    
        /**
         * pb_act_maze change.
         * @member {number} change
         * @memberof pb_act_maze
         * @instance
         */
        pb_act_maze.prototype.change = 0;
    
        /**
         * pb_act_maze treasures.
         * @member {number} treasures
         * @memberof pb_act_maze
         * @instance
         */
        pb_act_maze.prototype.treasures = 0;
    
        /**
         * pb_act_maze buff.
         * @member {number} buff
         * @memberof pb_act_maze
         * @instance
         */
        pb_act_maze.prototype.buff = 0;
    
        /**
         * pb_act_maze type.
         * @member {number} type
         * @memberof pb_act_maze
         * @instance
         */
        pb_act_maze.prototype.type = 0;
    
        /**
         * pb_act_maze pos.
         * @member {number} pos
         * @memberof pb_act_maze
         * @instance
         */
        pb_act_maze.prototype.pos = 0;
    
        /**
         * pb_act_maze buyNum.
         * @member {number} buyNum
         * @memberof pb_act_maze
         * @instance
         */
        pb_act_maze.prototype.buyNum = 0;
    
        /**
         * pb_act_maze getFrag.
         * @member {boolean} getFrag
         * @memberof pb_act_maze
         * @instance
         */
        pb_act_maze.prototype.getFrag = false;
    
        /**
         * Creates a new pb_act_maze instance using the specified properties.
         * @function create
         * @memberof pb_act_maze
         * @static
         * @param {Ipb_act_maze=} [properties] Properties to set
         * @returns {pb_act_maze} pb_act_maze instance
         */
        pb_act_maze.create = function create(properties) {
            return new pb_act_maze(properties);
        };
    
        /**
         * Encodes the specified pb_act_maze message. Does not implicitly {@link pb_act_maze.verify|verify} messages.
         * @function encode
         * @memberof pb_act_maze
         * @static
         * @param {Ipb_act_maze} message pb_act_maze message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_act_maze.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.floor != null && Object.hasOwnProperty.call(message, "floor"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.floor);
            if (message.events != null && message.events.length)
                for (var i = 0; i < message.events.length; ++i)
                    $root.pb_act_block.encode(message.events[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.heroid != null && Object.hasOwnProperty.call(message, "heroid"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.heroid);
            if (message.skill != null && Object.hasOwnProperty.call(message, "skill"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.skill);
            if (message.skillLv != null && Object.hasOwnProperty.call(message, "skillLv"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.skillLv);
            if (message.change != null && Object.hasOwnProperty.call(message, "change"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.change);
            if (message.treasures != null && Object.hasOwnProperty.call(message, "treasures"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.treasures);
            if (message.buff != null && Object.hasOwnProperty.call(message, "buff"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.buff);
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 9, wireType 0 =*/72).int32(message.type);
            if (message.pos != null && Object.hasOwnProperty.call(message, "pos"))
                writer.uint32(/* id 10, wireType 0 =*/80).int32(message.pos);
            if (message.buyNum != null && Object.hasOwnProperty.call(message, "buyNum"))
                writer.uint32(/* id 11, wireType 0 =*/88).int32(message.buyNum);
            if (message.getFrag != null && Object.hasOwnProperty.call(message, "getFrag"))
                writer.uint32(/* id 12, wireType 0 =*/96).bool(message.getFrag);
            return writer;
        };
    
        /**
         * Encodes the specified pb_act_maze message, length delimited. Does not implicitly {@link pb_act_maze.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_act_maze
         * @static
         * @param {Ipb_act_maze} message pb_act_maze message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_act_maze.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_act_maze message from the specified reader or buffer.
         * @function decode
         * @memberof pb_act_maze
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_act_maze} pb_act_maze
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_act_maze.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_act_maze();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.floor = reader.int32();
                        break;
                    }
                case 2: {
                        if (!(message.events && message.events.length))
                            message.events = [];
                        message.events.push($root.pb_act_block.decode(reader, reader.uint32()));
                        break;
                    }
                case 3: {
                        message.heroid = reader.int32();
                        break;
                    }
                case 4: {
                        message.skill = reader.int32();
                        break;
                    }
                case 5: {
                        message.skillLv = reader.int32();
                        break;
                    }
                case 6: {
                        message.change = reader.int32();
                        break;
                    }
                case 7: {
                        message.treasures = reader.int32();
                        break;
                    }
                case 8: {
                        message.buff = reader.int32();
                        break;
                    }
                case 9: {
                        message.type = reader.int32();
                        break;
                    }
                case 10: {
                        message.pos = reader.int32();
                        break;
                    }
                case 11: {
                        message.buyNum = reader.int32();
                        break;
                    }
                case 12: {
                        message.getFrag = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a pb_act_maze message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_act_maze
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_act_maze} pb_act_maze
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_act_maze.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_act_maze message.
         * @function verify
         * @memberof pb_act_maze
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_act_maze.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.floor != null && message.hasOwnProperty("floor"))
                if (!$util.isInteger(message.floor))
                    return "floor: integer expected";
            if (message.events != null && message.hasOwnProperty("events")) {
                if (!Array.isArray(message.events))
                    return "events: array expected";
                for (var i = 0; i < message.events.length; ++i) {
                    var error = $root.pb_act_block.verify(message.events[i]);
                    if (error)
                        return "events." + error;
                }
            }
            if (message.heroid != null && message.hasOwnProperty("heroid"))
                if (!$util.isInteger(message.heroid))
                    return "heroid: integer expected";
            if (message.skill != null && message.hasOwnProperty("skill"))
                if (!$util.isInteger(message.skill))
                    return "skill: integer expected";
            if (message.skillLv != null && message.hasOwnProperty("skillLv"))
                if (!$util.isInteger(message.skillLv))
                    return "skillLv: integer expected";
            if (message.change != null && message.hasOwnProperty("change"))
                if (!$util.isInteger(message.change))
                    return "change: integer expected";
            if (message.treasures != null && message.hasOwnProperty("treasures"))
                if (!$util.isInteger(message.treasures))
                    return "treasures: integer expected";
            if (message.buff != null && message.hasOwnProperty("buff"))
                if (!$util.isInteger(message.buff))
                    return "buff: integer expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isInteger(message.type))
                    return "type: integer expected";
            if (message.pos != null && message.hasOwnProperty("pos"))
                if (!$util.isInteger(message.pos))
                    return "pos: integer expected";
            if (message.buyNum != null && message.hasOwnProperty("buyNum"))
                if (!$util.isInteger(message.buyNum))
                    return "buyNum: integer expected";
            if (message.getFrag != null && message.hasOwnProperty("getFrag"))
                if (typeof message.getFrag !== "boolean")
                    return "getFrag: boolean expected";
            return null;
        };
    
        /**
         * Creates a pb_act_maze message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_act_maze
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_act_maze} pb_act_maze
         */
        pb_act_maze.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_act_maze)
                return object;
            var message = new $root.pb_act_maze();
            if (object.floor != null)
                message.floor = object.floor | 0;
            if (object.events) {
                if (!Array.isArray(object.events))
                    throw TypeError(".pb_act_maze.events: array expected");
                message.events = [];
                for (var i = 0; i < object.events.length; ++i) {
                    if (typeof object.events[i] !== "object")
                        throw TypeError(".pb_act_maze.events: object expected");
                    message.events[i] = $root.pb_act_block.fromObject(object.events[i]);
                }
            }
            if (object.heroid != null)
                message.heroid = object.heroid | 0;
            if (object.skill != null)
                message.skill = object.skill | 0;
            if (object.skillLv != null)
                message.skillLv = object.skillLv | 0;
            if (object.change != null)
                message.change = object.change | 0;
            if (object.treasures != null)
                message.treasures = object.treasures | 0;
            if (object.buff != null)
                message.buff = object.buff | 0;
            if (object.type != null)
                message.type = object.type | 0;
            if (object.pos != null)
                message.pos = object.pos | 0;
            if (object.buyNum != null)
                message.buyNum = object.buyNum | 0;
            if (object.getFrag != null)
                message.getFrag = Boolean(object.getFrag);
            return message;
        };
    
        /**
         * Creates a plain object from a pb_act_maze message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_act_maze
         * @static
         * @param {pb_act_maze} message pb_act_maze
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_act_maze.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.events = [];
            if (options.defaults) {
                object.floor = 0;
                object.heroid = 0;
                object.skill = 0;
                object.skillLv = 0;
                object.change = 0;
                object.treasures = 0;
                object.buff = 0;
                object.type = 0;
                object.pos = 0;
                object.buyNum = 0;
                object.getFrag = false;
            }
            if (message.floor != null && message.hasOwnProperty("floor"))
                object.floor = message.floor;
            if (message.events && message.events.length) {
                object.events = [];
                for (var j = 0; j < message.events.length; ++j)
                    object.events[j] = $root.pb_act_block.toObject(message.events[j], options);
            }
            if (message.heroid != null && message.hasOwnProperty("heroid"))
                object.heroid = message.heroid;
            if (message.skill != null && message.hasOwnProperty("skill"))
                object.skill = message.skill;
            if (message.skillLv != null && message.hasOwnProperty("skillLv"))
                object.skillLv = message.skillLv;
            if (message.change != null && message.hasOwnProperty("change"))
                object.change = message.change;
            if (message.treasures != null && message.hasOwnProperty("treasures"))
                object.treasures = message.treasures;
            if (message.buff != null && message.hasOwnProperty("buff"))
                object.buff = message.buff;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            if (message.pos != null && message.hasOwnProperty("pos"))
                object.pos = message.pos;
            if (message.buyNum != null && message.hasOwnProperty("buyNum"))
                object.buyNum = message.buyNum;
            if (message.getFrag != null && message.hasOwnProperty("getFrag"))
                object.getFrag = message.getFrag;
            return object;
        };
    
        /**
         * Converts this pb_act_maze to JSON.
         * @function toJSON
         * @memberof pb_act_maze
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_act_maze.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_act_maze
         * @function getTypeUrl
         * @memberof pb_act_maze
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_act_maze.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_act_maze";
        };
    
        return pb_act_maze;
    })();
    
    $root.pb_ntask = (function() {
    
        /**
         * Properties of a pb_ntask.
         * @exports Ipb_ntask
         * @interface Ipb_ntask
         * @property {number} id pb_ntask id
         * @property {number|Long} count pb_ntask count
         * @property {number} status pb_ntask status
         * @property {Array.<Ipb_nextra>|null} [extra] pb_ntask extra
         */
    
        /**
         * Constructs a new pb_ntask.
         * @exports pb_ntask
         * @classdesc Represents a pb_ntask.
         * @implements Ipb_ntask
         * @constructor
         * @param {Ipb_ntask=} [properties] Properties to set
         */
        function pb_ntask(properties) {
            this.extra = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_ntask id.
         * @member {number} id
         * @memberof pb_ntask
         * @instance
         */
        pb_ntask.prototype.id = 0;
    
        /**
         * pb_ntask count.
         * @member {number|Long} count
         * @memberof pb_ntask
         * @instance
         */
        pb_ntask.prototype.count = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * pb_ntask status.
         * @member {number} status
         * @memberof pb_ntask
         * @instance
         */
        pb_ntask.prototype.status = 0;
    
        /**
         * pb_ntask extra.
         * @member {Array.<Ipb_nextra>} extra
         * @memberof pb_ntask
         * @instance
         */
        pb_ntask.prototype.extra = $util.emptyArray;
    
        /**
         * Creates a new pb_ntask instance using the specified properties.
         * @function create
         * @memberof pb_ntask
         * @static
         * @param {Ipb_ntask=} [properties] Properties to set
         * @returns {pb_ntask} pb_ntask instance
         */
        pb_ntask.create = function create(properties) {
            return new pb_ntask(properties);
        };
    
        /**
         * Encodes the specified pb_ntask message. Does not implicitly {@link pb_ntask.verify|verify} messages.
         * @function encode
         * @memberof pb_ntask
         * @static
         * @param {Ipb_ntask} message pb_ntask message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_ntask.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.id);
            writer.uint32(/* id 2, wireType 0 =*/16).int64(message.count);
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.status);
            if (message.extra != null && message.extra.length)
                for (var i = 0; i < message.extra.length; ++i)
                    $root.pb_nextra.encode(message.extra[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified pb_ntask message, length delimited. Does not implicitly {@link pb_ntask.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_ntask
         * @static
         * @param {Ipb_ntask} message pb_ntask message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_ntask.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_ntask message from the specified reader or buffer.
         * @function decode
         * @memberof pb_ntask
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_ntask} pb_ntask
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_ntask.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_ntask();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.id = reader.int32();
                        break;
                    }
                case 2: {
                        message.count = reader.int64();
                        break;
                    }
                case 3: {
                        message.status = reader.int32();
                        break;
                    }
                case 4: {
                        if (!(message.extra && message.extra.length))
                            message.extra = [];
                        message.extra.push($root.pb_nextra.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("id"))
                throw $util.ProtocolError("missing required 'id'", { instance: message });
            if (!message.hasOwnProperty("count"))
                throw $util.ProtocolError("missing required 'count'", { instance: message });
            if (!message.hasOwnProperty("status"))
                throw $util.ProtocolError("missing required 'status'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a pb_ntask message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_ntask
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_ntask} pb_ntask
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_ntask.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_ntask message.
         * @function verify
         * @memberof pb_ntask
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_ntask.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.id))
                return "id: integer expected";
            if (!$util.isInteger(message.count) && !(message.count && $util.isInteger(message.count.low) && $util.isInteger(message.count.high)))
                return "count: integer|Long expected";
            if (!$util.isInteger(message.status))
                return "status: integer expected";
            if (message.extra != null && message.hasOwnProperty("extra")) {
                if (!Array.isArray(message.extra))
                    return "extra: array expected";
                for (var i = 0; i < message.extra.length; ++i) {
                    var error = $root.pb_nextra.verify(message.extra[i]);
                    if (error)
                        return "extra." + error;
                }
            }
            return null;
        };
    
        /**
         * Creates a pb_ntask message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_ntask
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_ntask} pb_ntask
         */
        pb_ntask.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_ntask)
                return object;
            var message = new $root.pb_ntask();
            if (object.id != null)
                message.id = object.id | 0;
            if (object.count != null)
                if ($util.Long)
                    (message.count = $util.Long.fromValue(object.count)).unsigned = false;
                else if (typeof object.count === "string")
                    message.count = parseInt(object.count, 10);
                else if (typeof object.count === "number")
                    message.count = object.count;
                else if (typeof object.count === "object")
                    message.count = new $util.LongBits(object.count.low >>> 0, object.count.high >>> 0).toNumber();
            if (object.status != null)
                message.status = object.status | 0;
            if (object.extra) {
                if (!Array.isArray(object.extra))
                    throw TypeError(".pb_ntask.extra: array expected");
                message.extra = [];
                for (var i = 0; i < object.extra.length; ++i) {
                    if (typeof object.extra[i] !== "object")
                        throw TypeError(".pb_ntask.extra: object expected");
                    message.extra[i] = $root.pb_nextra.fromObject(object.extra[i]);
                }
            }
            return message;
        };
    
        /**
         * Creates a plain object from a pb_ntask message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_ntask
         * @static
         * @param {pb_ntask} message pb_ntask
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_ntask.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.extra = [];
            if (options.defaults) {
                object.id = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.count = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.count = options.longs === String ? "0" : 0;
                object.status = 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.count != null && message.hasOwnProperty("count"))
                if (typeof message.count === "number")
                    object.count = options.longs === String ? String(message.count) : message.count;
                else
                    object.count = options.longs === String ? $util.Long.prototype.toString.call(message.count) : options.longs === Number ? new $util.LongBits(message.count.low >>> 0, message.count.high >>> 0).toNumber() : message.count;
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = message.status;
            if (message.extra && message.extra.length) {
                object.extra = [];
                for (var j = 0; j < message.extra.length; ++j)
                    object.extra[j] = $root.pb_nextra.toObject(message.extra[j], options);
            }
            return object;
        };
    
        /**
         * Converts this pb_ntask to JSON.
         * @function toJSON
         * @memberof pb_ntask
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_ntask.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_ntask
         * @function getTypeUrl
         * @memberof pb_ntask
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_ntask.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_ntask";
        };
    
        return pb_ntask;
    })();
    
    $root.pb_nextra = (function() {
    
        /**
         * Properties of a pb_nextra.
         * @exports Ipb_nextra
         * @interface Ipb_nextra
         * @property {Array.<number>|null} [id] pb_nextra id
         */
    
        /**
         * Constructs a new pb_nextra.
         * @exports pb_nextra
         * @classdesc Represents a pb_nextra.
         * @implements Ipb_nextra
         * @constructor
         * @param {Ipb_nextra=} [properties] Properties to set
         */
        function pb_nextra(properties) {
            this.id = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_nextra id.
         * @member {Array.<number>} id
         * @memberof pb_nextra
         * @instance
         */
        pb_nextra.prototype.id = $util.emptyArray;
    
        /**
         * Creates a new pb_nextra instance using the specified properties.
         * @function create
         * @memberof pb_nextra
         * @static
         * @param {Ipb_nextra=} [properties] Properties to set
         * @returns {pb_nextra} pb_nextra instance
         */
        pb_nextra.create = function create(properties) {
            return new pb_nextra(properties);
        };
    
        /**
         * Encodes the specified pb_nextra message. Does not implicitly {@link pb_nextra.verify|verify} messages.
         * @function encode
         * @memberof pb_nextra
         * @static
         * @param {Ipb_nextra} message pb_nextra message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_nextra.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && message.id.length)
                for (var i = 0; i < message.id.length; ++i)
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.id[i]);
            return writer;
        };
    
        /**
         * Encodes the specified pb_nextra message, length delimited. Does not implicitly {@link pb_nextra.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_nextra
         * @static
         * @param {Ipb_nextra} message pb_nextra message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_nextra.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_nextra message from the specified reader or buffer.
         * @function decode
         * @memberof pb_nextra
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_nextra} pb_nextra
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_nextra.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_nextra();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.id && message.id.length))
                            message.id = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.id.push(reader.int32());
                        } else
                            message.id.push(reader.int32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a pb_nextra message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_nextra
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_nextra} pb_nextra
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_nextra.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_nextra message.
         * @function verify
         * @memberof pb_nextra
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_nextra.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id")) {
                if (!Array.isArray(message.id))
                    return "id: array expected";
                for (var i = 0; i < message.id.length; ++i)
                    if (!$util.isInteger(message.id[i]))
                        return "id: integer[] expected";
            }
            return null;
        };
    
        /**
         * Creates a pb_nextra message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_nextra
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_nextra} pb_nextra
         */
        pb_nextra.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_nextra)
                return object;
            var message = new $root.pb_nextra();
            if (object.id) {
                if (!Array.isArray(object.id))
                    throw TypeError(".pb_nextra.id: array expected");
                message.id = [];
                for (var i = 0; i < object.id.length; ++i)
                    message.id[i] = object.id[i] | 0;
            }
            return message;
        };
    
        /**
         * Creates a plain object from a pb_nextra message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_nextra
         * @static
         * @param {pb_nextra} message pb_nextra
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_nextra.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.id = [];
            if (message.id && message.id.length) {
                object.id = [];
                for (var j = 0; j < message.id.length; ++j)
                    object.id[j] = message.id[j];
            }
            return object;
        };
    
        /**
         * Converts this pb_nextra to JSON.
         * @function toJSON
         * @memberof pb_nextra
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_nextra.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_nextra
         * @function getTypeUrl
         * @memberof pb_nextra
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_nextra.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_nextra";
        };
    
        return pb_nextra;
    })();
    
    $root.pb_nt_sync = (function() {
    
        /**
         * Properties of a pb_nt_sync.
         * @exports Ipb_nt_sync
         * @interface Ipb_nt_sync
         * @property {number} type pb_nt_sync type
         * @property {Array.<number|Long>|null} [value] pb_nt_sync value
         */
    
        /**
         * Constructs a new pb_nt_sync.
         * @exports pb_nt_sync
         * @classdesc Represents a pb_nt_sync.
         * @implements Ipb_nt_sync
         * @constructor
         * @param {Ipb_nt_sync=} [properties] Properties to set
         */
        function pb_nt_sync(properties) {
            this.value = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_nt_sync type.
         * @member {number} type
         * @memberof pb_nt_sync
         * @instance
         */
        pb_nt_sync.prototype.type = 0;
    
        /**
         * pb_nt_sync value.
         * @member {Array.<number|Long>} value
         * @memberof pb_nt_sync
         * @instance
         */
        pb_nt_sync.prototype.value = $util.emptyArray;
    
        /**
         * Creates a new pb_nt_sync instance using the specified properties.
         * @function create
         * @memberof pb_nt_sync
         * @static
         * @param {Ipb_nt_sync=} [properties] Properties to set
         * @returns {pb_nt_sync} pb_nt_sync instance
         */
        pb_nt_sync.create = function create(properties) {
            return new pb_nt_sync(properties);
        };
    
        /**
         * Encodes the specified pb_nt_sync message. Does not implicitly {@link pb_nt_sync.verify|verify} messages.
         * @function encode
         * @memberof pb_nt_sync
         * @static
         * @param {Ipb_nt_sync} message pb_nt_sync message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_nt_sync.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).sint32(message.type);
            if (message.value != null && message.value.length)
                for (var i = 0; i < message.value.length; ++i)
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.value[i]);
            return writer;
        };
    
        /**
         * Encodes the specified pb_nt_sync message, length delimited. Does not implicitly {@link pb_nt_sync.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_nt_sync
         * @static
         * @param {Ipb_nt_sync} message pb_nt_sync message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_nt_sync.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_nt_sync message from the specified reader or buffer.
         * @function decode
         * @memberof pb_nt_sync
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_nt_sync} pb_nt_sync
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_nt_sync.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_nt_sync();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.type = reader.sint32();
                        break;
                    }
                case 2: {
                        if (!(message.value && message.value.length))
                            message.value = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.value.push(reader.int64());
                        } else
                            message.value.push(reader.int64());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("type"))
                throw $util.ProtocolError("missing required 'type'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a pb_nt_sync message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_nt_sync
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_nt_sync} pb_nt_sync
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_nt_sync.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_nt_sync message.
         * @function verify
         * @memberof pb_nt_sync
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_nt_sync.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.type))
                return "type: integer expected";
            if (message.value != null && message.hasOwnProperty("value")) {
                if (!Array.isArray(message.value))
                    return "value: array expected";
                for (var i = 0; i < message.value.length; ++i)
                    if (!$util.isInteger(message.value[i]) && !(message.value[i] && $util.isInteger(message.value[i].low) && $util.isInteger(message.value[i].high)))
                        return "value: integer|Long[] expected";
            }
            return null;
        };
    
        /**
         * Creates a pb_nt_sync message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_nt_sync
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_nt_sync} pb_nt_sync
         */
        pb_nt_sync.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_nt_sync)
                return object;
            var message = new $root.pb_nt_sync();
            if (object.type != null)
                message.type = object.type | 0;
            if (object.value) {
                if (!Array.isArray(object.value))
                    throw TypeError(".pb_nt_sync.value: array expected");
                message.value = [];
                for (var i = 0; i < object.value.length; ++i)
                    if ($util.Long)
                        (message.value[i] = $util.Long.fromValue(object.value[i])).unsigned = false;
                    else if (typeof object.value[i] === "string")
                        message.value[i] = parseInt(object.value[i], 10);
                    else if (typeof object.value[i] === "number")
                        message.value[i] = object.value[i];
                    else if (typeof object.value[i] === "object")
                        message.value[i] = new $util.LongBits(object.value[i].low >>> 0, object.value[i].high >>> 0).toNumber();
            }
            return message;
        };
    
        /**
         * Creates a plain object from a pb_nt_sync message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_nt_sync
         * @static
         * @param {pb_nt_sync} message pb_nt_sync
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_nt_sync.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.value = [];
            if (options.defaults)
                object.type = 0;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            if (message.value && message.value.length) {
                object.value = [];
                for (var j = 0; j < message.value.length; ++j)
                    if (typeof message.value[j] === "number")
                        object.value[j] = options.longs === String ? String(message.value[j]) : message.value[j];
                    else
                        object.value[j] = options.longs === String ? $util.Long.prototype.toString.call(message.value[j]) : options.longs === Number ? new $util.LongBits(message.value[j].low >>> 0, message.value[j].high >>> 0).toNumber() : message.value[j];
            }
            return object;
        };
    
        /**
         * Converts this pb_nt_sync to JSON.
         * @function toJSON
         * @memberof pb_nt_sync
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_nt_sync.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_nt_sync
         * @function getTypeUrl
         * @memberof pb_nt_sync
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_nt_sync.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_nt_sync";
        };
    
        return pb_nt_sync;
    })();
    
    $root.pb_room = (function() {
    
        /**
         * Properties of a pb_room.
         * @exports Ipb_room
         * @interface Ipb_room
         * @property {number|null} [id] pb_room id
         * @property {number|null} [pos] pb_room pos
         * @property {number|null} [skinid] pb_room skinid
         * @property {number|null} [hid] pb_room hid
         */
    
        /**
         * Constructs a new pb_room.
         * @exports pb_room
         * @classdesc Represents a pb_room.
         * @implements Ipb_room
         * @constructor
         * @param {Ipb_room=} [properties] Properties to set
         */
        function pb_room(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_room id.
         * @member {number} id
         * @memberof pb_room
         * @instance
         */
        pb_room.prototype.id = 0;
    
        /**
         * pb_room pos.
         * @member {number} pos
         * @memberof pb_room
         * @instance
         */
        pb_room.prototype.pos = 0;
    
        /**
         * pb_room skinid.
         * @member {number} skinid
         * @memberof pb_room
         * @instance
         */
        pb_room.prototype.skinid = 0;
    
        /**
         * pb_room hid.
         * @member {number} hid
         * @memberof pb_room
         * @instance
         */
        pb_room.prototype.hid = 0;
    
        /**
         * Creates a new pb_room instance using the specified properties.
         * @function create
         * @memberof pb_room
         * @static
         * @param {Ipb_room=} [properties] Properties to set
         * @returns {pb_room} pb_room instance
         */
        pb_room.create = function create(properties) {
            return new pb_room(properties);
        };
    
        /**
         * Encodes the specified pb_room message. Does not implicitly {@link pb_room.verify|verify} messages.
         * @function encode
         * @memberof pb_room
         * @static
         * @param {Ipb_room} message pb_room message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_room.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.id);
            if (message.pos != null && Object.hasOwnProperty.call(message, "pos"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.pos);
            if (message.skinid != null && Object.hasOwnProperty.call(message, "skinid"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.skinid);
            if (message.hid != null && Object.hasOwnProperty.call(message, "hid"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.hid);
            return writer;
        };
    
        /**
         * Encodes the specified pb_room message, length delimited. Does not implicitly {@link pb_room.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_room
         * @static
         * @param {Ipb_room} message pb_room message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_room.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_room message from the specified reader or buffer.
         * @function decode
         * @memberof pb_room
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_room} pb_room
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_room.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_room();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.id = reader.int32();
                        break;
                    }
                case 2: {
                        message.pos = reader.int32();
                        break;
                    }
                case 3: {
                        message.skinid = reader.int32();
                        break;
                    }
                case 4: {
                        message.hid = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a pb_room message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_room
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_room} pb_room
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_room.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_room message.
         * @function verify
         * @memberof pb_room
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_room.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id))
                    return "id: integer expected";
            if (message.pos != null && message.hasOwnProperty("pos"))
                if (!$util.isInteger(message.pos))
                    return "pos: integer expected";
            if (message.skinid != null && message.hasOwnProperty("skinid"))
                if (!$util.isInteger(message.skinid))
                    return "skinid: integer expected";
            if (message.hid != null && message.hasOwnProperty("hid"))
                if (!$util.isInteger(message.hid))
                    return "hid: integer expected";
            return null;
        };
    
        /**
         * Creates a pb_room message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_room
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_room} pb_room
         */
        pb_room.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_room)
                return object;
            var message = new $root.pb_room();
            if (object.id != null)
                message.id = object.id | 0;
            if (object.pos != null)
                message.pos = object.pos | 0;
            if (object.skinid != null)
                message.skinid = object.skinid | 0;
            if (object.hid != null)
                message.hid = object.hid | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a pb_room message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_room
         * @static
         * @param {pb_room} message pb_room
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_room.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = 0;
                object.pos = 0;
                object.skinid = 0;
                object.hid = 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.pos != null && message.hasOwnProperty("pos"))
                object.pos = message.pos;
            if (message.skinid != null && message.hasOwnProperty("skinid"))
                object.skinid = message.skinid;
            if (message.hid != null && message.hasOwnProperty("hid"))
                object.hid = message.hid;
            return object;
        };
    
        /**
         * Converts this pb_room to JSON.
         * @function toJSON
         * @memberof pb_room
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_room.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_room
         * @function getTypeUrl
         * @memberof pb_room
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_room.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_room";
        };
    
        return pb_room;
    })();
    
    $root.pb_home_land = (function() {
    
        /**
         * Properties of a pb_home_land.
         * @exports Ipb_home_land
         * @interface Ipb_home_land
         * @property {number|null} [landId] pb_home_land landId
         * @property {string|null} [name] pb_home_land name
         * @property {Array.<Ipb_room>|null} [rooms] pb_home_land rooms
         * @property {number|null} [owner] pb_home_land owner
         */
    
        /**
         * Constructs a new pb_home_land.
         * @exports pb_home_land
         * @classdesc Represents a pb_home_land.
         * @implements Ipb_home_land
         * @constructor
         * @param {Ipb_home_land=} [properties] Properties to set
         */
        function pb_home_land(properties) {
            this.rooms = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_home_land landId.
         * @member {number} landId
         * @memberof pb_home_land
         * @instance
         */
        pb_home_land.prototype.landId = 0;
    
        /**
         * pb_home_land name.
         * @member {string} name
         * @memberof pb_home_land
         * @instance
         */
        pb_home_land.prototype.name = "";
    
        /**
         * pb_home_land rooms.
         * @member {Array.<Ipb_room>} rooms
         * @memberof pb_home_land
         * @instance
         */
        pb_home_land.prototype.rooms = $util.emptyArray;
    
        /**
         * pb_home_land owner.
         * @member {number} owner
         * @memberof pb_home_land
         * @instance
         */
        pb_home_land.prototype.owner = 0;
    
        /**
         * Creates a new pb_home_land instance using the specified properties.
         * @function create
         * @memberof pb_home_land
         * @static
         * @param {Ipb_home_land=} [properties] Properties to set
         * @returns {pb_home_land} pb_home_land instance
         */
        pb_home_land.create = function create(properties) {
            return new pb_home_land(properties);
        };
    
        /**
         * Encodes the specified pb_home_land message. Does not implicitly {@link pb_home_land.verify|verify} messages.
         * @function encode
         * @memberof pb_home_land
         * @static
         * @param {Ipb_home_land} message pb_home_land message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_home_land.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.landId != null && Object.hasOwnProperty.call(message, "landId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.landId);
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
            if (message.rooms != null && message.rooms.length)
                for (var i = 0; i < message.rooms.length; ++i)
                    $root.pb_room.encode(message.rooms[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.owner != null && Object.hasOwnProperty.call(message, "owner"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.owner);
            return writer;
        };
    
        /**
         * Encodes the specified pb_home_land message, length delimited. Does not implicitly {@link pb_home_land.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_home_land
         * @static
         * @param {Ipb_home_land} message pb_home_land message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_home_land.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_home_land message from the specified reader or buffer.
         * @function decode
         * @memberof pb_home_land
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_home_land} pb_home_land
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_home_land.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_home_land();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.landId = reader.int32();
                        break;
                    }
                case 2: {
                        message.name = reader.string();
                        break;
                    }
                case 3: {
                        if (!(message.rooms && message.rooms.length))
                            message.rooms = [];
                        message.rooms.push($root.pb_room.decode(reader, reader.uint32()));
                        break;
                    }
                case 4: {
                        message.owner = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a pb_home_land message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_home_land
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_home_land} pb_home_land
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_home_land.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_home_land message.
         * @function verify
         * @memberof pb_home_land
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_home_land.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.landId != null && message.hasOwnProperty("landId"))
                if (!$util.isInteger(message.landId))
                    return "landId: integer expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.rooms != null && message.hasOwnProperty("rooms")) {
                if (!Array.isArray(message.rooms))
                    return "rooms: array expected";
                for (var i = 0; i < message.rooms.length; ++i) {
                    var error = $root.pb_room.verify(message.rooms[i]);
                    if (error)
                        return "rooms." + error;
                }
            }
            if (message.owner != null && message.hasOwnProperty("owner"))
                if (!$util.isInteger(message.owner))
                    return "owner: integer expected";
            return null;
        };
    
        /**
         * Creates a pb_home_land message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_home_land
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_home_land} pb_home_land
         */
        pb_home_land.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_home_land)
                return object;
            var message = new $root.pb_home_land();
            if (object.landId != null)
                message.landId = object.landId | 0;
            if (object.name != null)
                message.name = String(object.name);
            if (object.rooms) {
                if (!Array.isArray(object.rooms))
                    throw TypeError(".pb_home_land.rooms: array expected");
                message.rooms = [];
                for (var i = 0; i < object.rooms.length; ++i) {
                    if (typeof object.rooms[i] !== "object")
                        throw TypeError(".pb_home_land.rooms: object expected");
                    message.rooms[i] = $root.pb_room.fromObject(object.rooms[i]);
                }
            }
            if (object.owner != null)
                message.owner = object.owner | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a pb_home_land message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_home_land
         * @static
         * @param {pb_home_land} message pb_home_land
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_home_land.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.rooms = [];
            if (options.defaults) {
                object.landId = 0;
                object.name = "";
                object.owner = 0;
            }
            if (message.landId != null && message.hasOwnProperty("landId"))
                object.landId = message.landId;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.rooms && message.rooms.length) {
                object.rooms = [];
                for (var j = 0; j < message.rooms.length; ++j)
                    object.rooms[j] = $root.pb_room.toObject(message.rooms[j], options);
            }
            if (message.owner != null && message.hasOwnProperty("owner"))
                object.owner = message.owner;
            return object;
        };
    
        /**
         * Converts this pb_home_land to JSON.
         * @function toJSON
         * @memberof pb_home_land
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_home_land.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_home_land
         * @function getTypeUrl
         * @memberof pb_home_land
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_home_land.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_home_land";
        };
    
        return pb_home_land;
    })();
    
    $root.pb_block = (function() {
    
        /**
         * Properties of a pb_block.
         * @exports Ipb_block
         * @interface Ipb_block
         * @property {number|null} [type] pb_block type
         * @property {number|null} [from] pb_block from
         * @property {number|null} [to] pb_block to
         */
    
        /**
         * Constructs a new pb_block.
         * @exports pb_block
         * @classdesc Represents a pb_block.
         * @implements Ipb_block
         * @constructor
         * @param {Ipb_block=} [properties] Properties to set
         */
        function pb_block(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_block type.
         * @member {number} type
         * @memberof pb_block
         * @instance
         */
        pb_block.prototype.type = 0;
    
        /**
         * pb_block from.
         * @member {number} from
         * @memberof pb_block
         * @instance
         */
        pb_block.prototype.from = 0;
    
        /**
         * pb_block to.
         * @member {number} to
         * @memberof pb_block
         * @instance
         */
        pb_block.prototype.to = 0;
    
        /**
         * Creates a new pb_block instance using the specified properties.
         * @function create
         * @memberof pb_block
         * @static
         * @param {Ipb_block=} [properties] Properties to set
         * @returns {pb_block} pb_block instance
         */
        pb_block.create = function create(properties) {
            return new pb_block(properties);
        };
    
        /**
         * Encodes the specified pb_block message. Does not implicitly {@link pb_block.verify|verify} messages.
         * @function encode
         * @memberof pb_block
         * @static
         * @param {Ipb_block} message pb_block message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_block.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            if (message.from != null && Object.hasOwnProperty.call(message, "from"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.from);
            if (message.to != null && Object.hasOwnProperty.call(message, "to"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.to);
            return writer;
        };
    
        /**
         * Encodes the specified pb_block message, length delimited. Does not implicitly {@link pb_block.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_block
         * @static
         * @param {Ipb_block} message pb_block message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_block.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_block message from the specified reader or buffer.
         * @function decode
         * @memberof pb_block
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_block} pb_block
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_block.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_block();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.type = reader.int32();
                        break;
                    }
                case 2: {
                        message.from = reader.int32();
                        break;
                    }
                case 3: {
                        message.to = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a pb_block message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_block
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_block} pb_block
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_block.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_block message.
         * @function verify
         * @memberof pb_block
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_block.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isInteger(message.type))
                    return "type: integer expected";
            if (message.from != null && message.hasOwnProperty("from"))
                if (!$util.isInteger(message.from))
                    return "from: integer expected";
            if (message.to != null && message.hasOwnProperty("to"))
                if (!$util.isInteger(message.to))
                    return "to: integer expected";
            return null;
        };
    
        /**
         * Creates a pb_block message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_block
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_block} pb_block
         */
        pb_block.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_block)
                return object;
            var message = new $root.pb_block();
            if (object.type != null)
                message.type = object.type | 0;
            if (object.from != null)
                message.from = object.from | 0;
            if (object.to != null)
                message.to = object.to | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a pb_block message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_block
         * @static
         * @param {pb_block} message pb_block
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_block.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.type = 0;
                object.from = 0;
                object.to = 0;
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            if (message.from != null && message.hasOwnProperty("from"))
                object.from = message.from;
            if (message.to != null && message.hasOwnProperty("to"))
                object.to = message.to;
            return object;
        };
    
        /**
         * Converts this pb_block to JSON.
         * @function toJSON
         * @memberof pb_block
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_block.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_block
         * @function getTypeUrl
         * @memberof pb_block
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_block.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_block";
        };
    
        return pb_block;
    })();
    
    $root.pb_living = (function() {
    
        /**
         * Properties of a pb_living.
         * @exports Ipb_living
         * @interface Ipb_living
         * @property {number|null} [type] pb_living type
         * @property {number|null} [hid] pb_living hid
         */
    
        /**
         * Constructs a new pb_living.
         * @exports pb_living
         * @classdesc Represents a pb_living.
         * @implements Ipb_living
         * @constructor
         * @param {Ipb_living=} [properties] Properties to set
         */
        function pb_living(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_living type.
         * @member {number} type
         * @memberof pb_living
         * @instance
         */
        pb_living.prototype.type = 0;
    
        /**
         * pb_living hid.
         * @member {number} hid
         * @memberof pb_living
         * @instance
         */
        pb_living.prototype.hid = 0;
    
        /**
         * Creates a new pb_living instance using the specified properties.
         * @function create
         * @memberof pb_living
         * @static
         * @param {Ipb_living=} [properties] Properties to set
         * @returns {pb_living} pb_living instance
         */
        pb_living.create = function create(properties) {
            return new pb_living(properties);
        };
    
        /**
         * Encodes the specified pb_living message. Does not implicitly {@link pb_living.verify|verify} messages.
         * @function encode
         * @memberof pb_living
         * @static
         * @param {Ipb_living} message pb_living message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_living.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            if (message.hid != null && Object.hasOwnProperty.call(message, "hid"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.hid);
            return writer;
        };
    
        /**
         * Encodes the specified pb_living message, length delimited. Does not implicitly {@link pb_living.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_living
         * @static
         * @param {Ipb_living} message pb_living message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_living.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_living message from the specified reader or buffer.
         * @function decode
         * @memberof pb_living
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_living} pb_living
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_living.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_living();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.type = reader.int32();
                        break;
                    }
                case 2: {
                        message.hid = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a pb_living message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_living
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_living} pb_living
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_living.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_living message.
         * @function verify
         * @memberof pb_living
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_living.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isInteger(message.type))
                    return "type: integer expected";
            if (message.hid != null && message.hasOwnProperty("hid"))
                if (!$util.isInteger(message.hid))
                    return "hid: integer expected";
            return null;
        };
    
        /**
         * Creates a pb_living message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_living
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_living} pb_living
         */
        pb_living.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_living)
                return object;
            var message = new $root.pb_living();
            if (object.type != null)
                message.type = object.type | 0;
            if (object.hid != null)
                message.hid = object.hid | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a pb_living message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_living
         * @static
         * @param {pb_living} message pb_living
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_living.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.type = 0;
                object.hid = 0;
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            if (message.hid != null && message.hasOwnProperty("hid"))
                object.hid = message.hid;
            return object;
        };
    
        /**
         * Converts this pb_living to JSON.
         * @function toJSON
         * @memberof pb_living
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_living.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_living
         * @function getTypeUrl
         * @memberof pb_living
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_living.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_living";
        };
    
        return pb_living;
    })();
    
    $root.pb_buildings = (function() {
    
        /**
         * Properties of a pb_buildings.
         * @exports Ipb_buildings
         * @interface Ipb_buildings
         * @property {number} id pb_buildings id
         * @property {number} pos pb_buildings pos
         * @property {number} skinid pb_buildings skinid
         * @property {number|null} [collectTime] pb_buildings collectTime
         * @property {number|null} [store] pb_buildings store
         */
    
        /**
         * Constructs a new pb_buildings.
         * @exports pb_buildings
         * @classdesc Represents a pb_buildings.
         * @implements Ipb_buildings
         * @constructor
         * @param {Ipb_buildings=} [properties] Properties to set
         */
        function pb_buildings(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_buildings id.
         * @member {number} id
         * @memberof pb_buildings
         * @instance
         */
        pb_buildings.prototype.id = 0;
    
        /**
         * pb_buildings pos.
         * @member {number} pos
         * @memberof pb_buildings
         * @instance
         */
        pb_buildings.prototype.pos = 0;
    
        /**
         * pb_buildings skinid.
         * @member {number} skinid
         * @memberof pb_buildings
         * @instance
         */
        pb_buildings.prototype.skinid = 0;
    
        /**
         * pb_buildings collectTime.
         * @member {number} collectTime
         * @memberof pb_buildings
         * @instance
         */
        pb_buildings.prototype.collectTime = 0;
    
        /**
         * pb_buildings store.
         * @member {number} store
         * @memberof pb_buildings
         * @instance
         */
        pb_buildings.prototype.store = 0;
    
        /**
         * Creates a new pb_buildings instance using the specified properties.
         * @function create
         * @memberof pb_buildings
         * @static
         * @param {Ipb_buildings=} [properties] Properties to set
         * @returns {pb_buildings} pb_buildings instance
         */
        pb_buildings.create = function create(properties) {
            return new pb_buildings(properties);
        };
    
        /**
         * Encodes the specified pb_buildings message. Does not implicitly {@link pb_buildings.verify|verify} messages.
         * @function encode
         * @memberof pb_buildings
         * @static
         * @param {Ipb_buildings} message pb_buildings message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_buildings.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.id);
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.pos);
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.skinid);
            if (message.collectTime != null && Object.hasOwnProperty.call(message, "collectTime"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.collectTime);
            if (message.store != null && Object.hasOwnProperty.call(message, "store"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.store);
            return writer;
        };
    
        /**
         * Encodes the specified pb_buildings message, length delimited. Does not implicitly {@link pb_buildings.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_buildings
         * @static
         * @param {Ipb_buildings} message pb_buildings message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_buildings.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_buildings message from the specified reader or buffer.
         * @function decode
         * @memberof pb_buildings
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_buildings} pb_buildings
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_buildings.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_buildings();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.id = reader.int32();
                        break;
                    }
                case 2: {
                        message.pos = reader.int32();
                        break;
                    }
                case 3: {
                        message.skinid = reader.int32();
                        break;
                    }
                case 4: {
                        message.collectTime = reader.int32();
                        break;
                    }
                case 5: {
                        message.store = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("id"))
                throw $util.ProtocolError("missing required 'id'", { instance: message });
            if (!message.hasOwnProperty("pos"))
                throw $util.ProtocolError("missing required 'pos'", { instance: message });
            if (!message.hasOwnProperty("skinid"))
                throw $util.ProtocolError("missing required 'skinid'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a pb_buildings message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_buildings
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_buildings} pb_buildings
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_buildings.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_buildings message.
         * @function verify
         * @memberof pb_buildings
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_buildings.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.id))
                return "id: integer expected";
            if (!$util.isInteger(message.pos))
                return "pos: integer expected";
            if (!$util.isInteger(message.skinid))
                return "skinid: integer expected";
            if (message.collectTime != null && message.hasOwnProperty("collectTime"))
                if (!$util.isInteger(message.collectTime))
                    return "collectTime: integer expected";
            if (message.store != null && message.hasOwnProperty("store"))
                if (!$util.isInteger(message.store))
                    return "store: integer expected";
            return null;
        };
    
        /**
         * Creates a pb_buildings message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_buildings
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_buildings} pb_buildings
         */
        pb_buildings.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_buildings)
                return object;
            var message = new $root.pb_buildings();
            if (object.id != null)
                message.id = object.id | 0;
            if (object.pos != null)
                message.pos = object.pos | 0;
            if (object.skinid != null)
                message.skinid = object.skinid | 0;
            if (object.collectTime != null)
                message.collectTime = object.collectTime | 0;
            if (object.store != null)
                message.store = object.store | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a pb_buildings message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_buildings
         * @static
         * @param {pb_buildings} message pb_buildings
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_buildings.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = 0;
                object.pos = 0;
                object.skinid = 0;
                object.collectTime = 0;
                object.store = 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.pos != null && message.hasOwnProperty("pos"))
                object.pos = message.pos;
            if (message.skinid != null && message.hasOwnProperty("skinid"))
                object.skinid = message.skinid;
            if (message.collectTime != null && message.hasOwnProperty("collectTime"))
                object.collectTime = message.collectTime;
            if (message.store != null && message.hasOwnProperty("store"))
                object.store = message.store;
            return object;
        };
    
        /**
         * Converts this pb_buildings to JSON.
         * @function toJSON
         * @memberof pb_buildings
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_buildings.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_buildings
         * @function getTypeUrl
         * @memberof pb_buildings
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_buildings.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_buildings";
        };
    
        return pb_buildings;
    })();
    
    $root.pb_home_roomer = (function() {
    
        /**
         * Properties of a pb_home_roomer.
         * @exports Ipb_home_roomer
         * @interface Ipb_home_roomer
         * @property {number|null} [roomId] pb_home_roomer roomId
         * @property {number|null} [hid] pb_home_roomer hid
         * @property {number|null} [skinid] pb_home_roomer skinid
         */
    
        /**
         * Constructs a new pb_home_roomer.
         * @exports pb_home_roomer
         * @classdesc Represents a pb_home_roomer.
         * @implements Ipb_home_roomer
         * @constructor
         * @param {Ipb_home_roomer=} [properties] Properties to set
         */
        function pb_home_roomer(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_home_roomer roomId.
         * @member {number} roomId
         * @memberof pb_home_roomer
         * @instance
         */
        pb_home_roomer.prototype.roomId = 0;
    
        /**
         * pb_home_roomer hid.
         * @member {number} hid
         * @memberof pb_home_roomer
         * @instance
         */
        pb_home_roomer.prototype.hid = 0;
    
        /**
         * pb_home_roomer skinid.
         * @member {number} skinid
         * @memberof pb_home_roomer
         * @instance
         */
        pb_home_roomer.prototype.skinid = 0;
    
        /**
         * Creates a new pb_home_roomer instance using the specified properties.
         * @function create
         * @memberof pb_home_roomer
         * @static
         * @param {Ipb_home_roomer=} [properties] Properties to set
         * @returns {pb_home_roomer} pb_home_roomer instance
         */
        pb_home_roomer.create = function create(properties) {
            return new pb_home_roomer(properties);
        };
    
        /**
         * Encodes the specified pb_home_roomer message. Does not implicitly {@link pb_home_roomer.verify|verify} messages.
         * @function encode
         * @memberof pb_home_roomer
         * @static
         * @param {Ipb_home_roomer} message pb_home_roomer message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_home_roomer.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.roomId != null && Object.hasOwnProperty.call(message, "roomId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.roomId);
            if (message.hid != null && Object.hasOwnProperty.call(message, "hid"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.hid);
            if (message.skinid != null && Object.hasOwnProperty.call(message, "skinid"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.skinid);
            return writer;
        };
    
        /**
         * Encodes the specified pb_home_roomer message, length delimited. Does not implicitly {@link pb_home_roomer.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_home_roomer
         * @static
         * @param {Ipb_home_roomer} message pb_home_roomer message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_home_roomer.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_home_roomer message from the specified reader or buffer.
         * @function decode
         * @memberof pb_home_roomer
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_home_roomer} pb_home_roomer
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_home_roomer.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_home_roomer();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.roomId = reader.int32();
                        break;
                    }
                case 2: {
                        message.hid = reader.int32();
                        break;
                    }
                case 3: {
                        message.skinid = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a pb_home_roomer message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_home_roomer
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_home_roomer} pb_home_roomer
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_home_roomer.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_home_roomer message.
         * @function verify
         * @memberof pb_home_roomer
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_home_roomer.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.roomId != null && message.hasOwnProperty("roomId"))
                if (!$util.isInteger(message.roomId))
                    return "roomId: integer expected";
            if (message.hid != null && message.hasOwnProperty("hid"))
                if (!$util.isInteger(message.hid))
                    return "hid: integer expected";
            if (message.skinid != null && message.hasOwnProperty("skinid"))
                if (!$util.isInteger(message.skinid))
                    return "skinid: integer expected";
            return null;
        };
    
        /**
         * Creates a pb_home_roomer message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_home_roomer
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_home_roomer} pb_home_roomer
         */
        pb_home_roomer.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_home_roomer)
                return object;
            var message = new $root.pb_home_roomer();
            if (object.roomId != null)
                message.roomId = object.roomId | 0;
            if (object.hid != null)
                message.hid = object.hid | 0;
            if (object.skinid != null)
                message.skinid = object.skinid | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a pb_home_roomer message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_home_roomer
         * @static
         * @param {pb_home_roomer} message pb_home_roomer
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_home_roomer.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.roomId = 0;
                object.hid = 0;
                object.skinid = 0;
            }
            if (message.roomId != null && message.hasOwnProperty("roomId"))
                object.roomId = message.roomId;
            if (message.hid != null && message.hasOwnProperty("hid"))
                object.hid = message.hid;
            if (message.skinid != null && message.hasOwnProperty("skinid"))
                object.skinid = message.skinid;
            return object;
        };
    
        /**
         * Converts this pb_home_roomer to JSON.
         * @function toJSON
         * @memberof pb_home_roomer
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_home_roomer.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_home_roomer
         * @function getTypeUrl
         * @memberof pb_home_roomer
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_home_roomer.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_home_roomer";
        };
    
        return pb_home_roomer;
    })();
    
    $root.pb_home_heroes = (function() {
    
        /**
         * Properties of a pb_home_heroes.
         * @exports Ipb_home_heroes
         * @interface Ipb_home_heroes
         * @property {number|null} [hid] pb_home_heroes hid
         * @property {number|null} [landId] pb_home_heroes landId
         * @property {Array.<Ipb_home_roomer>|null} [roomers] pb_home_heroes roomers
         */
    
        /**
         * Constructs a new pb_home_heroes.
         * @exports pb_home_heroes
         * @classdesc Represents a pb_home_heroes.
         * @implements Ipb_home_heroes
         * @constructor
         * @param {Ipb_home_heroes=} [properties] Properties to set
         */
        function pb_home_heroes(properties) {
            this.roomers = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_home_heroes hid.
         * @member {number} hid
         * @memberof pb_home_heroes
         * @instance
         */
        pb_home_heroes.prototype.hid = 0;
    
        /**
         * pb_home_heroes landId.
         * @member {number} landId
         * @memberof pb_home_heroes
         * @instance
         */
        pb_home_heroes.prototype.landId = 0;
    
        /**
         * pb_home_heroes roomers.
         * @member {Array.<Ipb_home_roomer>} roomers
         * @memberof pb_home_heroes
         * @instance
         */
        pb_home_heroes.prototype.roomers = $util.emptyArray;
    
        /**
         * Creates a new pb_home_heroes instance using the specified properties.
         * @function create
         * @memberof pb_home_heroes
         * @static
         * @param {Ipb_home_heroes=} [properties] Properties to set
         * @returns {pb_home_heroes} pb_home_heroes instance
         */
        pb_home_heroes.create = function create(properties) {
            return new pb_home_heroes(properties);
        };
    
        /**
         * Encodes the specified pb_home_heroes message. Does not implicitly {@link pb_home_heroes.verify|verify} messages.
         * @function encode
         * @memberof pb_home_heroes
         * @static
         * @param {Ipb_home_heroes} message pb_home_heroes message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_home_heroes.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.hid != null && Object.hasOwnProperty.call(message, "hid"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.hid);
            if (message.landId != null && Object.hasOwnProperty.call(message, "landId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.landId);
            if (message.roomers != null && message.roomers.length)
                for (var i = 0; i < message.roomers.length; ++i)
                    $root.pb_home_roomer.encode(message.roomers[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified pb_home_heroes message, length delimited. Does not implicitly {@link pb_home_heroes.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_home_heroes
         * @static
         * @param {Ipb_home_heroes} message pb_home_heroes message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_home_heroes.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_home_heroes message from the specified reader or buffer.
         * @function decode
         * @memberof pb_home_heroes
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_home_heroes} pb_home_heroes
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_home_heroes.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_home_heroes();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.hid = reader.int32();
                        break;
                    }
                case 2: {
                        message.landId = reader.int32();
                        break;
                    }
                case 3: {
                        if (!(message.roomers && message.roomers.length))
                            message.roomers = [];
                        message.roomers.push($root.pb_home_roomer.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a pb_home_heroes message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_home_heroes
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_home_heroes} pb_home_heroes
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_home_heroes.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_home_heroes message.
         * @function verify
         * @memberof pb_home_heroes
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_home_heroes.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.hid != null && message.hasOwnProperty("hid"))
                if (!$util.isInteger(message.hid))
                    return "hid: integer expected";
            if (message.landId != null && message.hasOwnProperty("landId"))
                if (!$util.isInteger(message.landId))
                    return "landId: integer expected";
            if (message.roomers != null && message.hasOwnProperty("roomers")) {
                if (!Array.isArray(message.roomers))
                    return "roomers: array expected";
                for (var i = 0; i < message.roomers.length; ++i) {
                    var error = $root.pb_home_roomer.verify(message.roomers[i]);
                    if (error)
                        return "roomers." + error;
                }
            }
            return null;
        };
    
        /**
         * Creates a pb_home_heroes message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_home_heroes
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_home_heroes} pb_home_heroes
         */
        pb_home_heroes.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_home_heroes)
                return object;
            var message = new $root.pb_home_heroes();
            if (object.hid != null)
                message.hid = object.hid | 0;
            if (object.landId != null)
                message.landId = object.landId | 0;
            if (object.roomers) {
                if (!Array.isArray(object.roomers))
                    throw TypeError(".pb_home_heroes.roomers: array expected");
                message.roomers = [];
                for (var i = 0; i < object.roomers.length; ++i) {
                    if (typeof object.roomers[i] !== "object")
                        throw TypeError(".pb_home_heroes.roomers: object expected");
                    message.roomers[i] = $root.pb_home_roomer.fromObject(object.roomers[i]);
                }
            }
            return message;
        };
    
        /**
         * Creates a plain object from a pb_home_heroes message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_home_heroes
         * @static
         * @param {pb_home_heroes} message pb_home_heroes
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_home_heroes.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.roomers = [];
            if (options.defaults) {
                object.hid = 0;
                object.landId = 0;
            }
            if (message.hid != null && message.hasOwnProperty("hid"))
                object.hid = message.hid;
            if (message.landId != null && message.hasOwnProperty("landId"))
                object.landId = message.landId;
            if (message.roomers && message.roomers.length) {
                object.roomers = [];
                for (var j = 0; j < message.roomers.length; ++j)
                    object.roomers[j] = $root.pb_home_roomer.toObject(message.roomers[j], options);
            }
            return object;
        };
    
        /**
         * Converts this pb_home_heroes to JSON.
         * @function toJSON
         * @memberof pb_home_heroes
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_home_heroes.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_home_heroes
         * @function getTypeUrl
         * @memberof pb_home_heroes
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_home_heroes.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_home_heroes";
        };
    
        return pb_home_heroes;
    })();
    
    $root.pb_coll = (function() {
    
        /**
         * Properties of a pb_coll.
         * @exports Ipb_coll
         * @interface Ipb_coll
         * @property {number|null} [type] pb_coll type
         * @property {number|null} [score] pb_coll score
         * @property {number|null} [lv] pb_coll lv
         */
    
        /**
         * Constructs a new pb_coll.
         * @exports pb_coll
         * @classdesc Represents a pb_coll.
         * @implements Ipb_coll
         * @constructor
         * @param {Ipb_coll=} [properties] Properties to set
         */
        function pb_coll(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_coll type.
         * @member {number} type
         * @memberof pb_coll
         * @instance
         */
        pb_coll.prototype.type = 0;
    
        /**
         * pb_coll score.
         * @member {number} score
         * @memberof pb_coll
         * @instance
         */
        pb_coll.prototype.score = 0;
    
        /**
         * pb_coll lv.
         * @member {number} lv
         * @memberof pb_coll
         * @instance
         */
        pb_coll.prototype.lv = 0;
    
        /**
         * Creates a new pb_coll instance using the specified properties.
         * @function create
         * @memberof pb_coll
         * @static
         * @param {Ipb_coll=} [properties] Properties to set
         * @returns {pb_coll} pb_coll instance
         */
        pb_coll.create = function create(properties) {
            return new pb_coll(properties);
        };
    
        /**
         * Encodes the specified pb_coll message. Does not implicitly {@link pb_coll.verify|verify} messages.
         * @function encode
         * @memberof pb_coll
         * @static
         * @param {Ipb_coll} message pb_coll message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_coll.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            if (message.score != null && Object.hasOwnProperty.call(message, "score"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.score);
            if (message.lv != null && Object.hasOwnProperty.call(message, "lv"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.lv);
            return writer;
        };
    
        /**
         * Encodes the specified pb_coll message, length delimited. Does not implicitly {@link pb_coll.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_coll
         * @static
         * @param {Ipb_coll} message pb_coll message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_coll.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_coll message from the specified reader or buffer.
         * @function decode
         * @memberof pb_coll
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_coll} pb_coll
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_coll.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_coll();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.type = reader.int32();
                        break;
                    }
                case 2: {
                        message.score = reader.int32();
                        break;
                    }
                case 3: {
                        message.lv = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a pb_coll message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_coll
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_coll} pb_coll
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_coll.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_coll message.
         * @function verify
         * @memberof pb_coll
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_coll.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isInteger(message.type))
                    return "type: integer expected";
            if (message.score != null && message.hasOwnProperty("score"))
                if (!$util.isInteger(message.score))
                    return "score: integer expected";
            if (message.lv != null && message.hasOwnProperty("lv"))
                if (!$util.isInteger(message.lv))
                    return "lv: integer expected";
            return null;
        };
    
        /**
         * Creates a pb_coll message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_coll
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_coll} pb_coll
         */
        pb_coll.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_coll)
                return object;
            var message = new $root.pb_coll();
            if (object.type != null)
                message.type = object.type | 0;
            if (object.score != null)
                message.score = object.score | 0;
            if (object.lv != null)
                message.lv = object.lv | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a pb_coll message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_coll
         * @static
         * @param {pb_coll} message pb_coll
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_coll.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.type = 0;
                object.score = 0;
                object.lv = 0;
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            if (message.score != null && message.hasOwnProperty("score"))
                object.score = message.score;
            if (message.lv != null && message.hasOwnProperty("lv"))
                object.lv = message.lv;
            return object;
        };
    
        /**
         * Converts this pb_coll to JSON.
         * @function toJSON
         * @memberof pb_coll
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_coll.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_coll
         * @function getTypeUrl
         * @memberof pb_coll
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_coll.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_coll";
        };
    
        return pb_coll;
    })();
    
    $root.pb_stove = (function() {
    
        /**
         * Properties of a pb_stove.
         * @exports Ipb_stove
         * @interface Ipb_stove
         * @property {number|null} [id] pb_stove id
         * @property {number|null} [num] pb_stove num
         * @property {number|null} [cd] pb_stove cd
         * @property {number|null} [qid] pb_stove qid
         */
    
        /**
         * Constructs a new pb_stove.
         * @exports pb_stove
         * @classdesc Represents a pb_stove.
         * @implements Ipb_stove
         * @constructor
         * @param {Ipb_stove=} [properties] Properties to set
         */
        function pb_stove(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_stove id.
         * @member {number} id
         * @memberof pb_stove
         * @instance
         */
        pb_stove.prototype.id = 0;
    
        /**
         * pb_stove num.
         * @member {number} num
         * @memberof pb_stove
         * @instance
         */
        pb_stove.prototype.num = 0;
    
        /**
         * pb_stove cd.
         * @member {number} cd
         * @memberof pb_stove
         * @instance
         */
        pb_stove.prototype.cd = 0;
    
        /**
         * pb_stove qid.
         * @member {number} qid
         * @memberof pb_stove
         * @instance
         */
        pb_stove.prototype.qid = 0;
    
        /**
         * Creates a new pb_stove instance using the specified properties.
         * @function create
         * @memberof pb_stove
         * @static
         * @param {Ipb_stove=} [properties] Properties to set
         * @returns {pb_stove} pb_stove instance
         */
        pb_stove.create = function create(properties) {
            return new pb_stove(properties);
        };
    
        /**
         * Encodes the specified pb_stove message. Does not implicitly {@link pb_stove.verify|verify} messages.
         * @function encode
         * @memberof pb_stove
         * @static
         * @param {Ipb_stove} message pb_stove message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_stove.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.id);
            if (message.num != null && Object.hasOwnProperty.call(message, "num"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.num);
            if (message.cd != null && Object.hasOwnProperty.call(message, "cd"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.cd);
            if (message.qid != null && Object.hasOwnProperty.call(message, "qid"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.qid);
            return writer;
        };
    
        /**
         * Encodes the specified pb_stove message, length delimited. Does not implicitly {@link pb_stove.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_stove
         * @static
         * @param {Ipb_stove} message pb_stove message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_stove.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_stove message from the specified reader or buffer.
         * @function decode
         * @memberof pb_stove
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_stove} pb_stove
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_stove.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_stove();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.id = reader.int32();
                        break;
                    }
                case 2: {
                        message.num = reader.int32();
                        break;
                    }
                case 3: {
                        message.cd = reader.int32();
                        break;
                    }
                case 4: {
                        message.qid = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a pb_stove message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_stove
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_stove} pb_stove
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_stove.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_stove message.
         * @function verify
         * @memberof pb_stove
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_stove.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id))
                    return "id: integer expected";
            if (message.num != null && message.hasOwnProperty("num"))
                if (!$util.isInteger(message.num))
                    return "num: integer expected";
            if (message.cd != null && message.hasOwnProperty("cd"))
                if (!$util.isInteger(message.cd))
                    return "cd: integer expected";
            if (message.qid != null && message.hasOwnProperty("qid"))
                if (!$util.isInteger(message.qid))
                    return "qid: integer expected";
            return null;
        };
    
        /**
         * Creates a pb_stove message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_stove
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_stove} pb_stove
         */
        pb_stove.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_stove)
                return object;
            var message = new $root.pb_stove();
            if (object.id != null)
                message.id = object.id | 0;
            if (object.num != null)
                message.num = object.num | 0;
            if (object.cd != null)
                message.cd = object.cd | 0;
            if (object.qid != null)
                message.qid = object.qid | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a pb_stove message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_stove
         * @static
         * @param {pb_stove} message pb_stove
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_stove.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = 0;
                object.num = 0;
                object.cd = 0;
                object.qid = 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.num != null && message.hasOwnProperty("num"))
                object.num = message.num;
            if (message.cd != null && message.hasOwnProperty("cd"))
                object.cd = message.cd;
            if (message.qid != null && message.hasOwnProperty("qid"))
                object.qid = message.qid;
            return object;
        };
    
        /**
         * Converts this pb_stove to JSON.
         * @function toJSON
         * @memberof pb_stove
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_stove.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_stove
         * @function getTypeUrl
         * @memberof pb_stove
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_stove.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_stove";
        };
    
        return pb_stove;
    })();
    
    $root.pb_stove_buy = (function() {
    
        /**
         * Properties of a pb_stove_buy.
         * @exports Ipb_stove_buy
         * @interface Ipb_stove_buy
         * @property {number} id pb_stove_buy id
         * @property {number} num pb_stove_buy num
         */
    
        /**
         * Constructs a new pb_stove_buy.
         * @exports pb_stove_buy
         * @classdesc Represents a pb_stove_buy.
         * @implements Ipb_stove_buy
         * @constructor
         * @param {Ipb_stove_buy=} [properties] Properties to set
         */
        function pb_stove_buy(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_stove_buy id.
         * @member {number} id
         * @memberof pb_stove_buy
         * @instance
         */
        pb_stove_buy.prototype.id = 0;
    
        /**
         * pb_stove_buy num.
         * @member {number} num
         * @memberof pb_stove_buy
         * @instance
         */
        pb_stove_buy.prototype.num = 0;
    
        /**
         * Creates a new pb_stove_buy instance using the specified properties.
         * @function create
         * @memberof pb_stove_buy
         * @static
         * @param {Ipb_stove_buy=} [properties] Properties to set
         * @returns {pb_stove_buy} pb_stove_buy instance
         */
        pb_stove_buy.create = function create(properties) {
            return new pb_stove_buy(properties);
        };
    
        /**
         * Encodes the specified pb_stove_buy message. Does not implicitly {@link pb_stove_buy.verify|verify} messages.
         * @function encode
         * @memberof pb_stove_buy
         * @static
         * @param {Ipb_stove_buy} message pb_stove_buy message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_stove_buy.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.id);
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.num);
            return writer;
        };
    
        /**
         * Encodes the specified pb_stove_buy message, length delimited. Does not implicitly {@link pb_stove_buy.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_stove_buy
         * @static
         * @param {Ipb_stove_buy} message pb_stove_buy message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_stove_buy.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_stove_buy message from the specified reader or buffer.
         * @function decode
         * @memberof pb_stove_buy
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_stove_buy} pb_stove_buy
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_stove_buy.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_stove_buy();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.id = reader.int32();
                        break;
                    }
                case 2: {
                        message.num = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("id"))
                throw $util.ProtocolError("missing required 'id'", { instance: message });
            if (!message.hasOwnProperty("num"))
                throw $util.ProtocolError("missing required 'num'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a pb_stove_buy message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_stove_buy
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_stove_buy} pb_stove_buy
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_stove_buy.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_stove_buy message.
         * @function verify
         * @memberof pb_stove_buy
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_stove_buy.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.id))
                return "id: integer expected";
            if (!$util.isInteger(message.num))
                return "num: integer expected";
            return null;
        };
    
        /**
         * Creates a pb_stove_buy message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_stove_buy
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_stove_buy} pb_stove_buy
         */
        pb_stove_buy.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_stove_buy)
                return object;
            var message = new $root.pb_stove_buy();
            if (object.id != null)
                message.id = object.id | 0;
            if (object.num != null)
                message.num = object.num | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a pb_stove_buy message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_stove_buy
         * @static
         * @param {pb_stove_buy} message pb_stove_buy
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_stove_buy.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = 0;
                object.num = 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.num != null && message.hasOwnProperty("num"))
                object.num = message.num;
            return object;
        };
    
        /**
         * Converts this pb_stove_buy to JSON.
         * @function toJSON
         * @memberof pb_stove_buy
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_stove_buy.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_stove_buy
         * @function getTypeUrl
         * @memberof pb_stove_buy
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_stove_buy.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_stove_buy";
        };
    
        return pb_stove_buy;
    })();
    
    $root.pb_gvm_stone = (function() {
    
        /**
         * Properties of a pb_gvm_stone.
         * @exports Ipb_gvm_stone
         * @interface Ipb_gvm_stone
         * @property {number|null} [bid] pb_gvm_stone bid
         * @property {number} id pb_gvm_stone id
         * @property {Array.<number>|null} [num] pb_gvm_stone num
         * @property {number|null} [pos] pb_gvm_stone pos
         */
    
        /**
         * Constructs a new pb_gvm_stone.
         * @exports pb_gvm_stone
         * @classdesc Represents a pb_gvm_stone.
         * @implements Ipb_gvm_stone
         * @constructor
         * @param {Ipb_gvm_stone=} [properties] Properties to set
         */
        function pb_gvm_stone(properties) {
            this.num = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_gvm_stone bid.
         * @member {number} bid
         * @memberof pb_gvm_stone
         * @instance
         */
        pb_gvm_stone.prototype.bid = 0;
    
        /**
         * pb_gvm_stone id.
         * @member {number} id
         * @memberof pb_gvm_stone
         * @instance
         */
        pb_gvm_stone.prototype.id = 0;
    
        /**
         * pb_gvm_stone num.
         * @member {Array.<number>} num
         * @memberof pb_gvm_stone
         * @instance
         */
        pb_gvm_stone.prototype.num = $util.emptyArray;
    
        /**
         * pb_gvm_stone pos.
         * @member {number} pos
         * @memberof pb_gvm_stone
         * @instance
         */
        pb_gvm_stone.prototype.pos = 0;
    
        /**
         * Creates a new pb_gvm_stone instance using the specified properties.
         * @function create
         * @memberof pb_gvm_stone
         * @static
         * @param {Ipb_gvm_stone=} [properties] Properties to set
         * @returns {pb_gvm_stone} pb_gvm_stone instance
         */
        pb_gvm_stone.create = function create(properties) {
            return new pb_gvm_stone(properties);
        };
    
        /**
         * Encodes the specified pb_gvm_stone message. Does not implicitly {@link pb_gvm_stone.verify|verify} messages.
         * @function encode
         * @memberof pb_gvm_stone
         * @static
         * @param {Ipb_gvm_stone} message pb_gvm_stone message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_gvm_stone.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.bid != null && Object.hasOwnProperty.call(message, "bid"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.bid);
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.id);
            if (message.num != null && message.num.length)
                for (var i = 0; i < message.num.length; ++i)
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.num[i]);
            if (message.pos != null && Object.hasOwnProperty.call(message, "pos"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.pos);
            return writer;
        };
    
        /**
         * Encodes the specified pb_gvm_stone message, length delimited. Does not implicitly {@link pb_gvm_stone.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_gvm_stone
         * @static
         * @param {Ipb_gvm_stone} message pb_gvm_stone message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_gvm_stone.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_gvm_stone message from the specified reader or buffer.
         * @function decode
         * @memberof pb_gvm_stone
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_gvm_stone} pb_gvm_stone
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_gvm_stone.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_gvm_stone();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.bid = reader.int32();
                        break;
                    }
                case 2: {
                        message.id = reader.int32();
                        break;
                    }
                case 3: {
                        if (!(message.num && message.num.length))
                            message.num = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.num.push(reader.int32());
                        } else
                            message.num.push(reader.int32());
                        break;
                    }
                case 4: {
                        message.pos = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("id"))
                throw $util.ProtocolError("missing required 'id'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a pb_gvm_stone message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_gvm_stone
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_gvm_stone} pb_gvm_stone
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_gvm_stone.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_gvm_stone message.
         * @function verify
         * @memberof pb_gvm_stone
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_gvm_stone.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.bid != null && message.hasOwnProperty("bid"))
                if (!$util.isInteger(message.bid))
                    return "bid: integer expected";
            if (!$util.isInteger(message.id))
                return "id: integer expected";
            if (message.num != null && message.hasOwnProperty("num")) {
                if (!Array.isArray(message.num))
                    return "num: array expected";
                for (var i = 0; i < message.num.length; ++i)
                    if (!$util.isInteger(message.num[i]))
                        return "num: integer[] expected";
            }
            if (message.pos != null && message.hasOwnProperty("pos"))
                if (!$util.isInteger(message.pos))
                    return "pos: integer expected";
            return null;
        };
    
        /**
         * Creates a pb_gvm_stone message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_gvm_stone
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_gvm_stone} pb_gvm_stone
         */
        pb_gvm_stone.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_gvm_stone)
                return object;
            var message = new $root.pb_gvm_stone();
            if (object.bid != null)
                message.bid = object.bid | 0;
            if (object.id != null)
                message.id = object.id | 0;
            if (object.num) {
                if (!Array.isArray(object.num))
                    throw TypeError(".pb_gvm_stone.num: array expected");
                message.num = [];
                for (var i = 0; i < object.num.length; ++i)
                    message.num[i] = object.num[i] | 0;
            }
            if (object.pos != null)
                message.pos = object.pos | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a pb_gvm_stone message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_gvm_stone
         * @static
         * @param {pb_gvm_stone} message pb_gvm_stone
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_gvm_stone.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.num = [];
            if (options.defaults) {
                object.bid = 0;
                object.id = 0;
                object.pos = 0;
            }
            if (message.bid != null && message.hasOwnProperty("bid"))
                object.bid = message.bid;
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.num && message.num.length) {
                object.num = [];
                for (var j = 0; j < message.num.length; ++j)
                    object.num[j] = message.num[j];
            }
            if (message.pos != null && message.hasOwnProperty("pos"))
                object.pos = message.pos;
            return object;
        };
    
        /**
         * Converts this pb_gvm_stone to JSON.
         * @function toJSON
         * @memberof pb_gvm_stone
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_gvm_stone.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_gvm_stone
         * @function getTypeUrl
         * @memberof pb_gvm_stone
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_gvm_stone.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_gvm_stone";
        };
    
        return pb_gvm_stone;
    })();
    
    $root.pb_gvm_map = (function() {
    
        /**
         * Properties of a pb_gvm_map.
         * @exports Ipb_gvm_map
         * @interface Ipb_gvm_map
         * @property {number} id pb_gvm_map id
         * @property {number|null} [buffNum] pb_gvm_map buffNum
         */
    
        /**
         * Constructs a new pb_gvm_map.
         * @exports pb_gvm_map
         * @classdesc Represents a pb_gvm_map.
         * @implements Ipb_gvm_map
         * @constructor
         * @param {Ipb_gvm_map=} [properties] Properties to set
         */
        function pb_gvm_map(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_gvm_map id.
         * @member {number} id
         * @memberof pb_gvm_map
         * @instance
         */
        pb_gvm_map.prototype.id = 0;
    
        /**
         * pb_gvm_map buffNum.
         * @member {number} buffNum
         * @memberof pb_gvm_map
         * @instance
         */
        pb_gvm_map.prototype.buffNum = 0;
    
        /**
         * Creates a new pb_gvm_map instance using the specified properties.
         * @function create
         * @memberof pb_gvm_map
         * @static
         * @param {Ipb_gvm_map=} [properties] Properties to set
         * @returns {pb_gvm_map} pb_gvm_map instance
         */
        pb_gvm_map.create = function create(properties) {
            return new pb_gvm_map(properties);
        };
    
        /**
         * Encodes the specified pb_gvm_map message. Does not implicitly {@link pb_gvm_map.verify|verify} messages.
         * @function encode
         * @memberof pb_gvm_map
         * @static
         * @param {Ipb_gvm_map} message pb_gvm_map message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_gvm_map.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.id);
            if (message.buffNum != null && Object.hasOwnProperty.call(message, "buffNum"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.buffNum);
            return writer;
        };
    
        /**
         * Encodes the specified pb_gvm_map message, length delimited. Does not implicitly {@link pb_gvm_map.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_gvm_map
         * @static
         * @param {Ipb_gvm_map} message pb_gvm_map message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_gvm_map.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_gvm_map message from the specified reader or buffer.
         * @function decode
         * @memberof pb_gvm_map
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_gvm_map} pb_gvm_map
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_gvm_map.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_gvm_map();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.id = reader.int32();
                        break;
                    }
                case 3: {
                        message.buffNum = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("id"))
                throw $util.ProtocolError("missing required 'id'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a pb_gvm_map message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_gvm_map
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_gvm_map} pb_gvm_map
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_gvm_map.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_gvm_map message.
         * @function verify
         * @memberof pb_gvm_map
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_gvm_map.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.id))
                return "id: integer expected";
            if (message.buffNum != null && message.hasOwnProperty("buffNum"))
                if (!$util.isInteger(message.buffNum))
                    return "buffNum: integer expected";
            return null;
        };
    
        /**
         * Creates a pb_gvm_map message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_gvm_map
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_gvm_map} pb_gvm_map
         */
        pb_gvm_map.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_gvm_map)
                return object;
            var message = new $root.pb_gvm_map();
            if (object.id != null)
                message.id = object.id | 0;
            if (object.buffNum != null)
                message.buffNum = object.buffNum | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a pb_gvm_map message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_gvm_map
         * @static
         * @param {pb_gvm_map} message pb_gvm_map
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_gvm_map.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = 0;
                object.buffNum = 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.buffNum != null && message.hasOwnProperty("buffNum"))
                object.buffNum = message.buffNum;
            return object;
        };
    
        /**
         * Converts this pb_gvm_map to JSON.
         * @function toJSON
         * @memberof pb_gvm_map
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_gvm_map.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_gvm_map
         * @function getTypeUrl
         * @memberof pb_gvm_map
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_gvm_map.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_gvm_map";
        };
    
        return pb_gvm_map;
    })();
    
    $root.pb_gvm_map_node = (function() {
    
        /**
         * Properties of a pb_gvm_map_node.
         * @exports Ipb_gvm_map_node
         * @interface Ipb_gvm_map_node
         * @property {number} id pb_gvm_map_node id
         * @property {number} state pb_gvm_map_node state
         * @property {number|null} [cfgId] pb_gvm_map_node cfgId
         * @property {Array.<number>|null} [hps] pb_gvm_map_node hps
         */
    
        /**
         * Constructs a new pb_gvm_map_node.
         * @exports pb_gvm_map_node
         * @classdesc Represents a pb_gvm_map_node.
         * @implements Ipb_gvm_map_node
         * @constructor
         * @param {Ipb_gvm_map_node=} [properties] Properties to set
         */
        function pb_gvm_map_node(properties) {
            this.hps = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_gvm_map_node id.
         * @member {number} id
         * @memberof pb_gvm_map_node
         * @instance
         */
        pb_gvm_map_node.prototype.id = 0;
    
        /**
         * pb_gvm_map_node state.
         * @member {number} state
         * @memberof pb_gvm_map_node
         * @instance
         */
        pb_gvm_map_node.prototype.state = 0;
    
        /**
         * pb_gvm_map_node cfgId.
         * @member {number} cfgId
         * @memberof pb_gvm_map_node
         * @instance
         */
        pb_gvm_map_node.prototype.cfgId = 0;
    
        /**
         * pb_gvm_map_node hps.
         * @member {Array.<number>} hps
         * @memberof pb_gvm_map_node
         * @instance
         */
        pb_gvm_map_node.prototype.hps = $util.emptyArray;
    
        /**
         * Creates a new pb_gvm_map_node instance using the specified properties.
         * @function create
         * @memberof pb_gvm_map_node
         * @static
         * @param {Ipb_gvm_map_node=} [properties] Properties to set
         * @returns {pb_gvm_map_node} pb_gvm_map_node instance
         */
        pb_gvm_map_node.create = function create(properties) {
            return new pb_gvm_map_node(properties);
        };
    
        /**
         * Encodes the specified pb_gvm_map_node message. Does not implicitly {@link pb_gvm_map_node.verify|verify} messages.
         * @function encode
         * @memberof pb_gvm_map_node
         * @static
         * @param {Ipb_gvm_map_node} message pb_gvm_map_node message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_gvm_map_node.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.id);
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.state);
            if (message.cfgId != null && Object.hasOwnProperty.call(message, "cfgId"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.cfgId);
            if (message.hps != null && message.hps.length)
                for (var i = 0; i < message.hps.length; ++i)
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.hps[i]);
            return writer;
        };
    
        /**
         * Encodes the specified pb_gvm_map_node message, length delimited. Does not implicitly {@link pb_gvm_map_node.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_gvm_map_node
         * @static
         * @param {Ipb_gvm_map_node} message pb_gvm_map_node message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_gvm_map_node.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_gvm_map_node message from the specified reader or buffer.
         * @function decode
         * @memberof pb_gvm_map_node
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_gvm_map_node} pb_gvm_map_node
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_gvm_map_node.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_gvm_map_node();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.id = reader.int32();
                        break;
                    }
                case 2: {
                        message.state = reader.int32();
                        break;
                    }
                case 3: {
                        message.cfgId = reader.int32();
                        break;
                    }
                case 4: {
                        if (!(message.hps && message.hps.length))
                            message.hps = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.hps.push(reader.int32());
                        } else
                            message.hps.push(reader.int32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("id"))
                throw $util.ProtocolError("missing required 'id'", { instance: message });
            if (!message.hasOwnProperty("state"))
                throw $util.ProtocolError("missing required 'state'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a pb_gvm_map_node message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_gvm_map_node
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_gvm_map_node} pb_gvm_map_node
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_gvm_map_node.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_gvm_map_node message.
         * @function verify
         * @memberof pb_gvm_map_node
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_gvm_map_node.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.id))
                return "id: integer expected";
            if (!$util.isInteger(message.state))
                return "state: integer expected";
            if (message.cfgId != null && message.hasOwnProperty("cfgId"))
                if (!$util.isInteger(message.cfgId))
                    return "cfgId: integer expected";
            if (message.hps != null && message.hasOwnProperty("hps")) {
                if (!Array.isArray(message.hps))
                    return "hps: array expected";
                for (var i = 0; i < message.hps.length; ++i)
                    if (!$util.isInteger(message.hps[i]))
                        return "hps: integer[] expected";
            }
            return null;
        };
    
        /**
         * Creates a pb_gvm_map_node message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_gvm_map_node
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_gvm_map_node} pb_gvm_map_node
         */
        pb_gvm_map_node.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_gvm_map_node)
                return object;
            var message = new $root.pb_gvm_map_node();
            if (object.id != null)
                message.id = object.id | 0;
            if (object.state != null)
                message.state = object.state | 0;
            if (object.cfgId != null)
                message.cfgId = object.cfgId | 0;
            if (object.hps) {
                if (!Array.isArray(object.hps))
                    throw TypeError(".pb_gvm_map_node.hps: array expected");
                message.hps = [];
                for (var i = 0; i < object.hps.length; ++i)
                    message.hps[i] = object.hps[i] | 0;
            }
            return message;
        };
    
        /**
         * Creates a plain object from a pb_gvm_map_node message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_gvm_map_node
         * @static
         * @param {pb_gvm_map_node} message pb_gvm_map_node
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_gvm_map_node.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.hps = [];
            if (options.defaults) {
                object.id = 0;
                object.state = 0;
                object.cfgId = 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.state != null && message.hasOwnProperty("state"))
                object.state = message.state;
            if (message.cfgId != null && message.hasOwnProperty("cfgId"))
                object.cfgId = message.cfgId;
            if (message.hps && message.hps.length) {
                object.hps = [];
                for (var j = 0; j < message.hps.length; ++j)
                    object.hps[j] = message.hps[j];
            }
            return object;
        };
    
        /**
         * Converts this pb_gvm_map_node to JSON.
         * @function toJSON
         * @memberof pb_gvm_map_node
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_gvm_map_node.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_gvm_map_node
         * @function getTypeUrl
         * @memberof pb_gvm_map_node
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_gvm_map_node.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_gvm_map_node";
        };
    
        return pb_gvm_map_node;
    })();
    
    $root.pb_gvm_rank = (function() {
    
        /**
         * Properties of a pb_gvm_rank.
         * @exports Ipb_gvm_rank
         * @interface Ipb_gvm_rank
         * @property {number|null} [gid] pb_gvm_rank gid
         * @property {number|Long|null} [score] pb_gvm_rank score
         * @property {number|null} [time] pb_gvm_rank time
         * @property {number|null} [logo] pb_gvm_rank logo
         * @property {string|null} [name] pb_gvm_rank name
         * @property {number|null} [member] pb_gvm_rank member
         * @property {number|Long|null} [exp] pb_gvm_rank exp
         */
    
        /**
         * Constructs a new pb_gvm_rank.
         * @exports pb_gvm_rank
         * @classdesc Represents a pb_gvm_rank.
         * @implements Ipb_gvm_rank
         * @constructor
         * @param {Ipb_gvm_rank=} [properties] Properties to set
         */
        function pb_gvm_rank(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_gvm_rank gid.
         * @member {number} gid
         * @memberof pb_gvm_rank
         * @instance
         */
        pb_gvm_rank.prototype.gid = 0;
    
        /**
         * pb_gvm_rank score.
         * @member {number|Long} score
         * @memberof pb_gvm_rank
         * @instance
         */
        pb_gvm_rank.prototype.score = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * pb_gvm_rank time.
         * @member {number} time
         * @memberof pb_gvm_rank
         * @instance
         */
        pb_gvm_rank.prototype.time = 0;
    
        /**
         * pb_gvm_rank logo.
         * @member {number} logo
         * @memberof pb_gvm_rank
         * @instance
         */
        pb_gvm_rank.prototype.logo = 0;
    
        /**
         * pb_gvm_rank name.
         * @member {string} name
         * @memberof pb_gvm_rank
         * @instance
         */
        pb_gvm_rank.prototype.name = "";
    
        /**
         * pb_gvm_rank member.
         * @member {number} member
         * @memberof pb_gvm_rank
         * @instance
         */
        pb_gvm_rank.prototype.member = 0;
    
        /**
         * pb_gvm_rank exp.
         * @member {number|Long} exp
         * @memberof pb_gvm_rank
         * @instance
         */
        pb_gvm_rank.prototype.exp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * Creates a new pb_gvm_rank instance using the specified properties.
         * @function create
         * @memberof pb_gvm_rank
         * @static
         * @param {Ipb_gvm_rank=} [properties] Properties to set
         * @returns {pb_gvm_rank} pb_gvm_rank instance
         */
        pb_gvm_rank.create = function create(properties) {
            return new pb_gvm_rank(properties);
        };
    
        /**
         * Encodes the specified pb_gvm_rank message. Does not implicitly {@link pb_gvm_rank.verify|verify} messages.
         * @function encode
         * @memberof pb_gvm_rank
         * @static
         * @param {Ipb_gvm_rank} message pb_gvm_rank message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_gvm_rank.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.gid != null && Object.hasOwnProperty.call(message, "gid"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.gid);
            if (message.score != null && Object.hasOwnProperty.call(message, "score"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.score);
            if (message.time != null && Object.hasOwnProperty.call(message, "time"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.time);
            if (message.logo != null && Object.hasOwnProperty.call(message, "logo"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.logo);
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.name);
            if (message.member != null && Object.hasOwnProperty.call(message, "member"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.member);
            if (message.exp != null && Object.hasOwnProperty.call(message, "exp"))
                writer.uint32(/* id 9, wireType 0 =*/72).int64(message.exp);
            return writer;
        };
    
        /**
         * Encodes the specified pb_gvm_rank message, length delimited. Does not implicitly {@link pb_gvm_rank.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_gvm_rank
         * @static
         * @param {Ipb_gvm_rank} message pb_gvm_rank message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_gvm_rank.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_gvm_rank message from the specified reader or buffer.
         * @function decode
         * @memberof pb_gvm_rank
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_gvm_rank} pb_gvm_rank
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_gvm_rank.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_gvm_rank();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.gid = reader.int32();
                        break;
                    }
                case 2: {
                        message.score = reader.int64();
                        break;
                    }
                case 4: {
                        message.time = reader.int32();
                        break;
                    }
                case 5: {
                        message.logo = reader.int32();
                        break;
                    }
                case 6: {
                        message.name = reader.string();
                        break;
                    }
                case 8: {
                        message.member = reader.int32();
                        break;
                    }
                case 9: {
                        message.exp = reader.int64();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a pb_gvm_rank message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_gvm_rank
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_gvm_rank} pb_gvm_rank
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_gvm_rank.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_gvm_rank message.
         * @function verify
         * @memberof pb_gvm_rank
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_gvm_rank.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.gid != null && message.hasOwnProperty("gid"))
                if (!$util.isInteger(message.gid))
                    return "gid: integer expected";
            if (message.score != null && message.hasOwnProperty("score"))
                if (!$util.isInteger(message.score) && !(message.score && $util.isInteger(message.score.low) && $util.isInteger(message.score.high)))
                    return "score: integer|Long expected";
            if (message.time != null && message.hasOwnProperty("time"))
                if (!$util.isInteger(message.time))
                    return "time: integer expected";
            if (message.logo != null && message.hasOwnProperty("logo"))
                if (!$util.isInteger(message.logo))
                    return "logo: integer expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.member != null && message.hasOwnProperty("member"))
                if (!$util.isInteger(message.member))
                    return "member: integer expected";
            if (message.exp != null && message.hasOwnProperty("exp"))
                if (!$util.isInteger(message.exp) && !(message.exp && $util.isInteger(message.exp.low) && $util.isInteger(message.exp.high)))
                    return "exp: integer|Long expected";
            return null;
        };
    
        /**
         * Creates a pb_gvm_rank message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_gvm_rank
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_gvm_rank} pb_gvm_rank
         */
        pb_gvm_rank.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_gvm_rank)
                return object;
            var message = new $root.pb_gvm_rank();
            if (object.gid != null)
                message.gid = object.gid | 0;
            if (object.score != null)
                if ($util.Long)
                    (message.score = $util.Long.fromValue(object.score)).unsigned = false;
                else if (typeof object.score === "string")
                    message.score = parseInt(object.score, 10);
                else if (typeof object.score === "number")
                    message.score = object.score;
                else if (typeof object.score === "object")
                    message.score = new $util.LongBits(object.score.low >>> 0, object.score.high >>> 0).toNumber();
            if (object.time != null)
                message.time = object.time | 0;
            if (object.logo != null)
                message.logo = object.logo | 0;
            if (object.name != null)
                message.name = String(object.name);
            if (object.member != null)
                message.member = object.member | 0;
            if (object.exp != null)
                if ($util.Long)
                    (message.exp = $util.Long.fromValue(object.exp)).unsigned = false;
                else if (typeof object.exp === "string")
                    message.exp = parseInt(object.exp, 10);
                else if (typeof object.exp === "number")
                    message.exp = object.exp;
                else if (typeof object.exp === "object")
                    message.exp = new $util.LongBits(object.exp.low >>> 0, object.exp.high >>> 0).toNumber();
            return message;
        };
    
        /**
         * Creates a plain object from a pb_gvm_rank message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_gvm_rank
         * @static
         * @param {pb_gvm_rank} message pb_gvm_rank
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_gvm_rank.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.gid = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.score = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.score = options.longs === String ? "0" : 0;
                object.time = 0;
                object.logo = 0;
                object.name = "";
                object.member = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.exp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.exp = options.longs === String ? "0" : 0;
            }
            if (message.gid != null && message.hasOwnProperty("gid"))
                object.gid = message.gid;
            if (message.score != null && message.hasOwnProperty("score"))
                if (typeof message.score === "number")
                    object.score = options.longs === String ? String(message.score) : message.score;
                else
                    object.score = options.longs === String ? $util.Long.prototype.toString.call(message.score) : options.longs === Number ? new $util.LongBits(message.score.low >>> 0, message.score.high >>> 0).toNumber() : message.score;
            if (message.time != null && message.hasOwnProperty("time"))
                object.time = message.time;
            if (message.logo != null && message.hasOwnProperty("logo"))
                object.logo = message.logo;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.member != null && message.hasOwnProperty("member"))
                object.member = message.member;
            if (message.exp != null && message.hasOwnProperty("exp"))
                if (typeof message.exp === "number")
                    object.exp = options.longs === String ? String(message.exp) : message.exp;
                else
                    object.exp = options.longs === String ? $util.Long.prototype.toString.call(message.exp) : options.longs === Number ? new $util.LongBits(message.exp.low >>> 0, message.exp.high >>> 0).toNumber() : message.exp;
            return object;
        };
    
        /**
         * Converts this pb_gvm_rank to JSON.
         * @function toJSON
         * @memberof pb_gvm_rank
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_gvm_rank.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_gvm_rank
         * @function getTypeUrl
         * @memberof pb_gvm_rank
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_gvm_rank.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_gvm_rank";
        };
    
        return pb_gvm_rank;
    })();
    
    $root.pb_match = (function() {
    
        /**
         * Properties of a pb_match.
         * @exports Ipb_match
         * @interface Ipb_match
         * @property {number} idx pb_match idx
         * @property {string|null} [name] pb_match name
         * @property {number|Long|null} [uid] pb_match uid
         * @property {number|null} [lv] pb_match lv
         * @property {number|null} [logo] pb_match logo
         * @property {number|null} [lbox] pb_match lbox
         * @property {number|null} [win] pb_match win
         * @property {Array.<Ipb_match_hero>|null} [heroes] pb_match heroes
         * @property {number|Long|null} [power] pb_match power
         */
    
        /**
         * Constructs a new pb_match.
         * @exports pb_match
         * @classdesc Represents a pb_match.
         * @implements Ipb_match
         * @constructor
         * @param {Ipb_match=} [properties] Properties to set
         */
        function pb_match(properties) {
            this.heroes = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_match idx.
         * @member {number} idx
         * @memberof pb_match
         * @instance
         */
        pb_match.prototype.idx = 0;
    
        /**
         * pb_match name.
         * @member {string} name
         * @memberof pb_match
         * @instance
         */
        pb_match.prototype.name = "";
    
        /**
         * pb_match uid.
         * @member {number|Long} uid
         * @memberof pb_match
         * @instance
         */
        pb_match.prototype.uid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * pb_match lv.
         * @member {number} lv
         * @memberof pb_match
         * @instance
         */
        pb_match.prototype.lv = 0;
    
        /**
         * pb_match logo.
         * @member {number} logo
         * @memberof pb_match
         * @instance
         */
        pb_match.prototype.logo = 0;
    
        /**
         * pb_match lbox.
         * @member {number} lbox
         * @memberof pb_match
         * @instance
         */
        pb_match.prototype.lbox = 0;
    
        /**
         * pb_match win.
         * @member {number} win
         * @memberof pb_match
         * @instance
         */
        pb_match.prototype.win = 0;
    
        /**
         * pb_match heroes.
         * @member {Array.<Ipb_match_hero>} heroes
         * @memberof pb_match
         * @instance
         */
        pb_match.prototype.heroes = $util.emptyArray;
    
        /**
         * pb_match power.
         * @member {number|Long} power
         * @memberof pb_match
         * @instance
         */
        pb_match.prototype.power = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * Creates a new pb_match instance using the specified properties.
         * @function create
         * @memberof pb_match
         * @static
         * @param {Ipb_match=} [properties] Properties to set
         * @returns {pb_match} pb_match instance
         */
        pb_match.create = function create(properties) {
            return new pb_match(properties);
        };
    
        /**
         * Encodes the specified pb_match message. Does not implicitly {@link pb_match.verify|verify} messages.
         * @function encode
         * @memberof pb_match
         * @static
         * @param {Ipb_match} message pb_match message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_match.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).sint32(message.idx);
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
            if (message.uid != null && Object.hasOwnProperty.call(message, "uid"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.uid);
            if (message.logo != null && Object.hasOwnProperty.call(message, "logo"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.logo);
            if (message.lbox != null && Object.hasOwnProperty.call(message, "lbox"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.lbox);
            if (message.lv != null && Object.hasOwnProperty.call(message, "lv"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.lv);
            if (message.win != null && Object.hasOwnProperty.call(message, "win"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.win);
            if (message.heroes != null && message.heroes.length)
                for (var i = 0; i < message.heroes.length; ++i)
                    $root.pb_match_hero.encode(message.heroes[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message.power != null && Object.hasOwnProperty.call(message, "power"))
                writer.uint32(/* id 9, wireType 0 =*/72).int64(message.power);
            return writer;
        };
    
        /**
         * Encodes the specified pb_match message, length delimited. Does not implicitly {@link pb_match.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_match
         * @static
         * @param {Ipb_match} message pb_match message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_match.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_match message from the specified reader or buffer.
         * @function decode
         * @memberof pb_match
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_match} pb_match
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_match.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_match();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.idx = reader.sint32();
                        break;
                    }
                case 2: {
                        message.name = reader.string();
                        break;
                    }
                case 3: {
                        message.uid = reader.int64();
                        break;
                    }
                case 6: {
                        message.lv = reader.int32();
                        break;
                    }
                case 4: {
                        message.logo = reader.int32();
                        break;
                    }
                case 5: {
                        message.lbox = reader.int32();
                        break;
                    }
                case 7: {
                        message.win = reader.int32();
                        break;
                    }
                case 8: {
                        if (!(message.heroes && message.heroes.length))
                            message.heroes = [];
                        message.heroes.push($root.pb_match_hero.decode(reader, reader.uint32()));
                        break;
                    }
                case 9: {
                        message.power = reader.int64();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("idx"))
                throw $util.ProtocolError("missing required 'idx'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a pb_match message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_match
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_match} pb_match
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_match.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_match message.
         * @function verify
         * @memberof pb_match
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_match.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.idx))
                return "idx: integer expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (!$util.isInteger(message.uid) && !(message.uid && $util.isInteger(message.uid.low) && $util.isInteger(message.uid.high)))
                    return "uid: integer|Long expected";
            if (message.lv != null && message.hasOwnProperty("lv"))
                if (!$util.isInteger(message.lv))
                    return "lv: integer expected";
            if (message.logo != null && message.hasOwnProperty("logo"))
                if (!$util.isInteger(message.logo))
                    return "logo: integer expected";
            if (message.lbox != null && message.hasOwnProperty("lbox"))
                if (!$util.isInteger(message.lbox))
                    return "lbox: integer expected";
            if (message.win != null && message.hasOwnProperty("win"))
                if (!$util.isInteger(message.win))
                    return "win: integer expected";
            if (message.heroes != null && message.hasOwnProperty("heroes")) {
                if (!Array.isArray(message.heroes))
                    return "heroes: array expected";
                for (var i = 0; i < message.heroes.length; ++i) {
                    var error = $root.pb_match_hero.verify(message.heroes[i]);
                    if (error)
                        return "heroes." + error;
                }
            }
            if (message.power != null && message.hasOwnProperty("power"))
                if (!$util.isInteger(message.power) && !(message.power && $util.isInteger(message.power.low) && $util.isInteger(message.power.high)))
                    return "power: integer|Long expected";
            return null;
        };
    
        /**
         * Creates a pb_match message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_match
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_match} pb_match
         */
        pb_match.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_match)
                return object;
            var message = new $root.pb_match();
            if (object.idx != null)
                message.idx = object.idx | 0;
            if (object.name != null)
                message.name = String(object.name);
            if (object.uid != null)
                if ($util.Long)
                    (message.uid = $util.Long.fromValue(object.uid)).unsigned = false;
                else if (typeof object.uid === "string")
                    message.uid = parseInt(object.uid, 10);
                else if (typeof object.uid === "number")
                    message.uid = object.uid;
                else if (typeof object.uid === "object")
                    message.uid = new $util.LongBits(object.uid.low >>> 0, object.uid.high >>> 0).toNumber();
            if (object.lv != null)
                message.lv = object.lv | 0;
            if (object.logo != null)
                message.logo = object.logo | 0;
            if (object.lbox != null)
                message.lbox = object.lbox | 0;
            if (object.win != null)
                message.win = object.win | 0;
            if (object.heroes) {
                if (!Array.isArray(object.heroes))
                    throw TypeError(".pb_match.heroes: array expected");
                message.heroes = [];
                for (var i = 0; i < object.heroes.length; ++i) {
                    if (typeof object.heroes[i] !== "object")
                        throw TypeError(".pb_match.heroes: object expected");
                    message.heroes[i] = $root.pb_match_hero.fromObject(object.heroes[i]);
                }
            }
            if (object.power != null)
                if ($util.Long)
                    (message.power = $util.Long.fromValue(object.power)).unsigned = false;
                else if (typeof object.power === "string")
                    message.power = parseInt(object.power, 10);
                else if (typeof object.power === "number")
                    message.power = object.power;
                else if (typeof object.power === "object")
                    message.power = new $util.LongBits(object.power.low >>> 0, object.power.high >>> 0).toNumber();
            return message;
        };
    
        /**
         * Creates a plain object from a pb_match message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_match
         * @static
         * @param {pb_match} message pb_match
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_match.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.heroes = [];
            if (options.defaults) {
                object.idx = 0;
                object.name = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.uid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.uid = options.longs === String ? "0" : 0;
                object.logo = 0;
                object.lbox = 0;
                object.lv = 0;
                object.win = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.power = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.power = options.longs === String ? "0" : 0;
            }
            if (message.idx != null && message.hasOwnProperty("idx"))
                object.idx = message.idx;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (typeof message.uid === "number")
                    object.uid = options.longs === String ? String(message.uid) : message.uid;
                else
                    object.uid = options.longs === String ? $util.Long.prototype.toString.call(message.uid) : options.longs === Number ? new $util.LongBits(message.uid.low >>> 0, message.uid.high >>> 0).toNumber() : message.uid;
            if (message.logo != null && message.hasOwnProperty("logo"))
                object.logo = message.logo;
            if (message.lbox != null && message.hasOwnProperty("lbox"))
                object.lbox = message.lbox;
            if (message.lv != null && message.hasOwnProperty("lv"))
                object.lv = message.lv;
            if (message.win != null && message.hasOwnProperty("win"))
                object.win = message.win;
            if (message.heroes && message.heroes.length) {
                object.heroes = [];
                for (var j = 0; j < message.heroes.length; ++j)
                    object.heroes[j] = $root.pb_match_hero.toObject(message.heroes[j], options);
            }
            if (message.power != null && message.hasOwnProperty("power"))
                if (typeof message.power === "number")
                    object.power = options.longs === String ? String(message.power) : message.power;
                else
                    object.power = options.longs === String ? $util.Long.prototype.toString.call(message.power) : options.longs === Number ? new $util.LongBits(message.power.low >>> 0, message.power.high >>> 0).toNumber() : message.power;
            return object;
        };
    
        /**
         * Converts this pb_match to JSON.
         * @function toJSON
         * @memberof pb_match
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_match.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_match
         * @function getTypeUrl
         * @memberof pb_match
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_match.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_match";
        };
    
        return pb_match;
    })();
    
    $root.pb_match_hero = (function() {
    
        /**
         * Properties of a pb_match_hero.
         * @exports Ipb_match_hero
         * @interface Ipb_match_hero
         * @property {number} pos pb_match_hero pos
         * @property {number} id pb_match_hero id
         * @property {number|null} [lv] pb_match_hero lv
         * @property {number|null} [stl] pb_match_hero stl
         * @property {number|null} [flag] pb_match_hero flag
         * @property {Array.<Ipb_equip>|null} [equips] pb_match_hero equips
         * @property {number|null} [wake] pb_match_hero wake
         * @property {Array.<number>|null} [skillId] pb_match_hero skillId
         * @property {Ipb_attr|null} [attr] pb_match_hero attr
         * @property {number|null} [skin] pb_match_hero skin
         * @property {number|null} [qlv] pb_match_hero qlv
         * @property {number|null} [treeFlag] pb_match_hero treeFlag
         * @property {number|null} [core] pb_match_hero core
         * @property {number|null} [times] pb_match_hero times
         * @property {number|null} [use] pb_match_hero use
         */
    
        /**
         * Constructs a new pb_match_hero.
         * @exports pb_match_hero
         * @classdesc Represents a pb_match_hero.
         * @implements Ipb_match_hero
         * @constructor
         * @param {Ipb_match_hero=} [properties] Properties to set
         */
        function pb_match_hero(properties) {
            this.equips = [];
            this.skillId = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_match_hero pos.
         * @member {number} pos
         * @memberof pb_match_hero
         * @instance
         */
        pb_match_hero.prototype.pos = 0;
    
        /**
         * pb_match_hero id.
         * @member {number} id
         * @memberof pb_match_hero
         * @instance
         */
        pb_match_hero.prototype.id = 0;
    
        /**
         * pb_match_hero lv.
         * @member {number} lv
         * @memberof pb_match_hero
         * @instance
         */
        pb_match_hero.prototype.lv = 0;
    
        /**
         * pb_match_hero stl.
         * @member {number} stl
         * @memberof pb_match_hero
         * @instance
         */
        pb_match_hero.prototype.stl = 0;
    
        /**
         * pb_match_hero flag.
         * @member {number} flag
         * @memberof pb_match_hero
         * @instance
         */
        pb_match_hero.prototype.flag = 0;
    
        /**
         * pb_match_hero equips.
         * @member {Array.<Ipb_equip>} equips
         * @memberof pb_match_hero
         * @instance
         */
        pb_match_hero.prototype.equips = $util.emptyArray;
    
        /**
         * pb_match_hero wake.
         * @member {number} wake
         * @memberof pb_match_hero
         * @instance
         */
        pb_match_hero.prototype.wake = 0;
    
        /**
         * pb_match_hero skillId.
         * @member {Array.<number>} skillId
         * @memberof pb_match_hero
         * @instance
         */
        pb_match_hero.prototype.skillId = $util.emptyArray;
    
        /**
         * pb_match_hero attr.
         * @member {Ipb_attr|null|undefined} attr
         * @memberof pb_match_hero
         * @instance
         */
        pb_match_hero.prototype.attr = null;
    
        /**
         * pb_match_hero skin.
         * @member {number} skin
         * @memberof pb_match_hero
         * @instance
         */
        pb_match_hero.prototype.skin = 0;
    
        /**
         * pb_match_hero qlv.
         * @member {number} qlv
         * @memberof pb_match_hero
         * @instance
         */
        pb_match_hero.prototype.qlv = 0;
    
        /**
         * pb_match_hero treeFlag.
         * @member {number} treeFlag
         * @memberof pb_match_hero
         * @instance
         */
        pb_match_hero.prototype.treeFlag = 0;
    
        /**
         * pb_match_hero core.
         * @member {number} core
         * @memberof pb_match_hero
         * @instance
         */
        pb_match_hero.prototype.core = 0;
    
        /**
         * pb_match_hero times.
         * @member {number} times
         * @memberof pb_match_hero
         * @instance
         */
        pb_match_hero.prototype.times = 0;
    
        /**
         * pb_match_hero use.
         * @member {number} use
         * @memberof pb_match_hero
         * @instance
         */
        pb_match_hero.prototype.use = 0;
    
        /**
         * Creates a new pb_match_hero instance using the specified properties.
         * @function create
         * @memberof pb_match_hero
         * @static
         * @param {Ipb_match_hero=} [properties] Properties to set
         * @returns {pb_match_hero} pb_match_hero instance
         */
        pb_match_hero.create = function create(properties) {
            return new pb_match_hero(properties);
        };
    
        /**
         * Encodes the specified pb_match_hero message. Does not implicitly {@link pb_match_hero.verify|verify} messages.
         * @function encode
         * @memberof pb_match_hero
         * @static
         * @param {Ipb_match_hero} message pb_match_hero message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_match_hero.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.pos);
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.id);
            if (message.lv != null && Object.hasOwnProperty.call(message, "lv"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.lv);
            if (message.stl != null && Object.hasOwnProperty.call(message, "stl"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.stl);
            if (message.flag != null && Object.hasOwnProperty.call(message, "flag"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.flag);
            if (message.equips != null && message.equips.length)
                for (var i = 0; i < message.equips.length; ++i)
                    $root.pb_equip.encode(message.equips[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.wake != null && Object.hasOwnProperty.call(message, "wake"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.wake);
            if (message.skillId != null && message.skillId.length)
                for (var i = 0; i < message.skillId.length; ++i)
                    writer.uint32(/* id 8, wireType 0 =*/64).int32(message.skillId[i]);
            if (message.attr != null && Object.hasOwnProperty.call(message, "attr"))
                $root.pb_attr.encode(message.attr, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
            if (message.skin != null && Object.hasOwnProperty.call(message, "skin"))
                writer.uint32(/* id 10, wireType 0 =*/80).int32(message.skin);
            if (message.qlv != null && Object.hasOwnProperty.call(message, "qlv"))
                writer.uint32(/* id 11, wireType 0 =*/88).int32(message.qlv);
            if (message.treeFlag != null && Object.hasOwnProperty.call(message, "treeFlag"))
                writer.uint32(/* id 12, wireType 0 =*/96).int32(message.treeFlag);
            if (message.core != null && Object.hasOwnProperty.call(message, "core"))
                writer.uint32(/* id 13, wireType 0 =*/104).int32(message.core);
            if (message.times != null && Object.hasOwnProperty.call(message, "times"))
                writer.uint32(/* id 14, wireType 0 =*/112).int32(message.times);
            if (message.use != null && Object.hasOwnProperty.call(message, "use"))
                writer.uint32(/* id 15, wireType 0 =*/120).int32(message.use);
            return writer;
        };
    
        /**
         * Encodes the specified pb_match_hero message, length delimited. Does not implicitly {@link pb_match_hero.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_match_hero
         * @static
         * @param {Ipb_match_hero} message pb_match_hero message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_match_hero.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_match_hero message from the specified reader or buffer.
         * @function decode
         * @memberof pb_match_hero
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_match_hero} pb_match_hero
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_match_hero.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_match_hero();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.pos = reader.int32();
                        break;
                    }
                case 2: {
                        message.id = reader.int32();
                        break;
                    }
                case 3: {
                        message.lv = reader.int32();
                        break;
                    }
                case 4: {
                        message.stl = reader.int32();
                        break;
                    }
                case 5: {
                        message.flag = reader.int32();
                        break;
                    }
                case 6: {
                        if (!(message.equips && message.equips.length))
                            message.equips = [];
                        message.equips.push($root.pb_equip.decode(reader, reader.uint32()));
                        break;
                    }
                case 7: {
                        message.wake = reader.int32();
                        break;
                    }
                case 8: {
                        if (!(message.skillId && message.skillId.length))
                            message.skillId = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.skillId.push(reader.int32());
                        } else
                            message.skillId.push(reader.int32());
                        break;
                    }
                case 9: {
                        message.attr = $root.pb_attr.decode(reader, reader.uint32());
                        break;
                    }
                case 10: {
                        message.skin = reader.int32();
                        break;
                    }
                case 11: {
                        message.qlv = reader.int32();
                        break;
                    }
                case 12: {
                        message.treeFlag = reader.int32();
                        break;
                    }
                case 13: {
                        message.core = reader.int32();
                        break;
                    }
                case 14: {
                        message.times = reader.int32();
                        break;
                    }
                case 15: {
                        message.use = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("pos"))
                throw $util.ProtocolError("missing required 'pos'", { instance: message });
            if (!message.hasOwnProperty("id"))
                throw $util.ProtocolError("missing required 'id'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a pb_match_hero message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_match_hero
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_match_hero} pb_match_hero
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_match_hero.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_match_hero message.
         * @function verify
         * @memberof pb_match_hero
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_match_hero.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.pos))
                return "pos: integer expected";
            if (!$util.isInteger(message.id))
                return "id: integer expected";
            if (message.lv != null && message.hasOwnProperty("lv"))
                if (!$util.isInteger(message.lv))
                    return "lv: integer expected";
            if (message.stl != null && message.hasOwnProperty("stl"))
                if (!$util.isInteger(message.stl))
                    return "stl: integer expected";
            if (message.flag != null && message.hasOwnProperty("flag"))
                if (!$util.isInteger(message.flag))
                    return "flag: integer expected";
            if (message.equips != null && message.hasOwnProperty("equips")) {
                if (!Array.isArray(message.equips))
                    return "equips: array expected";
                for (var i = 0; i < message.equips.length; ++i) {
                    var error = $root.pb_equip.verify(message.equips[i]);
                    if (error)
                        return "equips." + error;
                }
            }
            if (message.wake != null && message.hasOwnProperty("wake"))
                if (!$util.isInteger(message.wake))
                    return "wake: integer expected";
            if (message.skillId != null && message.hasOwnProperty("skillId")) {
                if (!Array.isArray(message.skillId))
                    return "skillId: array expected";
                for (var i = 0; i < message.skillId.length; ++i)
                    if (!$util.isInteger(message.skillId[i]))
                        return "skillId: integer[] expected";
            }
            if (message.attr != null && message.hasOwnProperty("attr")) {
                var error = $root.pb_attr.verify(message.attr);
                if (error)
                    return "attr." + error;
            }
            if (message.skin != null && message.hasOwnProperty("skin"))
                if (!$util.isInteger(message.skin))
                    return "skin: integer expected";
            if (message.qlv != null && message.hasOwnProperty("qlv"))
                if (!$util.isInteger(message.qlv))
                    return "qlv: integer expected";
            if (message.treeFlag != null && message.hasOwnProperty("treeFlag"))
                if (!$util.isInteger(message.treeFlag))
                    return "treeFlag: integer expected";
            if (message.core != null && message.hasOwnProperty("core"))
                if (!$util.isInteger(message.core))
                    return "core: integer expected";
            if (message.times != null && message.hasOwnProperty("times"))
                if (!$util.isInteger(message.times))
                    return "times: integer expected";
            if (message.use != null && message.hasOwnProperty("use"))
                if (!$util.isInteger(message.use))
                    return "use: integer expected";
            return null;
        };
    
        /**
         * Creates a pb_match_hero message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_match_hero
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_match_hero} pb_match_hero
         */
        pb_match_hero.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_match_hero)
                return object;
            var message = new $root.pb_match_hero();
            if (object.pos != null)
                message.pos = object.pos | 0;
            if (object.id != null)
                message.id = object.id | 0;
            if (object.lv != null)
                message.lv = object.lv | 0;
            if (object.stl != null)
                message.stl = object.stl | 0;
            if (object.flag != null)
                message.flag = object.flag | 0;
            if (object.equips) {
                if (!Array.isArray(object.equips))
                    throw TypeError(".pb_match_hero.equips: array expected");
                message.equips = [];
                for (var i = 0; i < object.equips.length; ++i) {
                    if (typeof object.equips[i] !== "object")
                        throw TypeError(".pb_match_hero.equips: object expected");
                    message.equips[i] = $root.pb_equip.fromObject(object.equips[i]);
                }
            }
            if (object.wake != null)
                message.wake = object.wake | 0;
            if (object.skillId) {
                if (!Array.isArray(object.skillId))
                    throw TypeError(".pb_match_hero.skillId: array expected");
                message.skillId = [];
                for (var i = 0; i < object.skillId.length; ++i)
                    message.skillId[i] = object.skillId[i] | 0;
            }
            if (object.attr != null) {
                if (typeof object.attr !== "object")
                    throw TypeError(".pb_match_hero.attr: object expected");
                message.attr = $root.pb_attr.fromObject(object.attr);
            }
            if (object.skin != null)
                message.skin = object.skin | 0;
            if (object.qlv != null)
                message.qlv = object.qlv | 0;
            if (object.treeFlag != null)
                message.treeFlag = object.treeFlag | 0;
            if (object.core != null)
                message.core = object.core | 0;
            if (object.times != null)
                message.times = object.times | 0;
            if (object.use != null)
                message.use = object.use | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a pb_match_hero message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_match_hero
         * @static
         * @param {pb_match_hero} message pb_match_hero
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_match_hero.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.equips = [];
                object.skillId = [];
            }
            if (options.defaults) {
                object.pos = 0;
                object.id = 0;
                object.lv = 0;
                object.stl = 0;
                object.flag = 0;
                object.wake = 0;
                object.attr = null;
                object.skin = 0;
                object.qlv = 0;
                object.treeFlag = 0;
                object.core = 0;
                object.times = 0;
                object.use = 0;
            }
            if (message.pos != null && message.hasOwnProperty("pos"))
                object.pos = message.pos;
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.lv != null && message.hasOwnProperty("lv"))
                object.lv = message.lv;
            if (message.stl != null && message.hasOwnProperty("stl"))
                object.stl = message.stl;
            if (message.flag != null && message.hasOwnProperty("flag"))
                object.flag = message.flag;
            if (message.equips && message.equips.length) {
                object.equips = [];
                for (var j = 0; j < message.equips.length; ++j)
                    object.equips[j] = $root.pb_equip.toObject(message.equips[j], options);
            }
            if (message.wake != null && message.hasOwnProperty("wake"))
                object.wake = message.wake;
            if (message.skillId && message.skillId.length) {
                object.skillId = [];
                for (var j = 0; j < message.skillId.length; ++j)
                    object.skillId[j] = message.skillId[j];
            }
            if (message.attr != null && message.hasOwnProperty("attr"))
                object.attr = $root.pb_attr.toObject(message.attr, options);
            if (message.skin != null && message.hasOwnProperty("skin"))
                object.skin = message.skin;
            if (message.qlv != null && message.hasOwnProperty("qlv"))
                object.qlv = message.qlv;
            if (message.treeFlag != null && message.hasOwnProperty("treeFlag"))
                object.treeFlag = message.treeFlag;
            if (message.core != null && message.hasOwnProperty("core"))
                object.core = message.core;
            if (message.times != null && message.hasOwnProperty("times"))
                object.times = message.times;
            if (message.use != null && message.hasOwnProperty("use"))
                object.use = message.use;
            return object;
        };
    
        /**
         * Converts this pb_match_hero to JSON.
         * @function toJSON
         * @memberof pb_match_hero
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_match_hero.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_match_hero
         * @function getTypeUrl
         * @memberof pb_match_hero
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_match_hero.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_match_hero";
        };
    
        return pb_match_hero;
    })();
    
    $root.pb_pvp_accounts = (function() {
    
        /**
         * Properties of a pb_pvp_accounts.
         * @exports Ipb_pvp_accounts
         * @interface Ipb_pvp_accounts
         * @property {number} score pb_pvp_accounts score
         * @property {number} win pb_pvp_accounts win
         */
    
        /**
         * Constructs a new pb_pvp_accounts.
         * @exports pb_pvp_accounts
         * @classdesc Represents a pb_pvp_accounts.
         * @implements Ipb_pvp_accounts
         * @constructor
         * @param {Ipb_pvp_accounts=} [properties] Properties to set
         */
        function pb_pvp_accounts(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_pvp_accounts score.
         * @member {number} score
         * @memberof pb_pvp_accounts
         * @instance
         */
        pb_pvp_accounts.prototype.score = 0;
    
        /**
         * pb_pvp_accounts win.
         * @member {number} win
         * @memberof pb_pvp_accounts
         * @instance
         */
        pb_pvp_accounts.prototype.win = 0;
    
        /**
         * Creates a new pb_pvp_accounts instance using the specified properties.
         * @function create
         * @memberof pb_pvp_accounts
         * @static
         * @param {Ipb_pvp_accounts=} [properties] Properties to set
         * @returns {pb_pvp_accounts} pb_pvp_accounts instance
         */
        pb_pvp_accounts.create = function create(properties) {
            return new pb_pvp_accounts(properties);
        };
    
        /**
         * Encodes the specified pb_pvp_accounts message. Does not implicitly {@link pb_pvp_accounts.verify|verify} messages.
         * @function encode
         * @memberof pb_pvp_accounts
         * @static
         * @param {Ipb_pvp_accounts} message pb_pvp_accounts message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_pvp_accounts.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.score);
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.win);
            return writer;
        };
    
        /**
         * Encodes the specified pb_pvp_accounts message, length delimited. Does not implicitly {@link pb_pvp_accounts.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_pvp_accounts
         * @static
         * @param {Ipb_pvp_accounts} message pb_pvp_accounts message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_pvp_accounts.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_pvp_accounts message from the specified reader or buffer.
         * @function decode
         * @memberof pb_pvp_accounts
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_pvp_accounts} pb_pvp_accounts
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_pvp_accounts.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_pvp_accounts();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.score = reader.int32();
                        break;
                    }
                case 2: {
                        message.win = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("score"))
                throw $util.ProtocolError("missing required 'score'", { instance: message });
            if (!message.hasOwnProperty("win"))
                throw $util.ProtocolError("missing required 'win'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a pb_pvp_accounts message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_pvp_accounts
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_pvp_accounts} pb_pvp_accounts
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_pvp_accounts.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_pvp_accounts message.
         * @function verify
         * @memberof pb_pvp_accounts
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_pvp_accounts.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.score))
                return "score: integer expected";
            if (!$util.isInteger(message.win))
                return "win: integer expected";
            return null;
        };
    
        /**
         * Creates a pb_pvp_accounts message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_pvp_accounts
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_pvp_accounts} pb_pvp_accounts
         */
        pb_pvp_accounts.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_pvp_accounts)
                return object;
            var message = new $root.pb_pvp_accounts();
            if (object.score != null)
                message.score = object.score | 0;
            if (object.win != null)
                message.win = object.win | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a pb_pvp_accounts message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_pvp_accounts
         * @static
         * @param {pb_pvp_accounts} message pb_pvp_accounts
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_pvp_accounts.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.score = 0;
                object.win = 0;
            }
            if (message.score != null && message.hasOwnProperty("score"))
                object.score = message.score;
            if (message.win != null && message.hasOwnProperty("win"))
                object.win = message.win;
            return object;
        };
    
        /**
         * Converts this pb_pvp_accounts to JSON.
         * @function toJSON
         * @memberof pb_pvp_accounts
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_pvp_accounts.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_pvp_accounts
         * @function getTypeUrl
         * @memberof pb_pvp_accounts
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_pvp_accounts.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_pvp_accounts";
        };
    
        return pb_pvp_accounts;
    })();
    
    $root.pb_attr = (function() {
    
        /**
         * Properties of a pb_attr.
         * @exports Ipb_attr
         * @interface Ipb_attr
         * @property {number|null} [atk] pb_attr atk
         * @property {number|Long|null} [hp] pb_attr hp
         * @property {number|null} [arm] pb_attr arm
         * @property {number|null} [spd] pb_attr spd
         * @property {number|null} [sklP] pb_attr sklP
         * @property {number|null} [hit] pb_attr hit
         * @property {number|null} [miss] pb_attr miss
         * @property {number|null} [crit] pb_attr crit
         * @property {number|null} [critTime] pb_attr critTime
         * @property {number|null} [brk] pb_attr brk
         * @property {number|null} [free] pb_attr free
         * @property {number|null} [decDmg] pb_attr decDmg
         * @property {number|null} [trueAtk] pb_attr trueAtk
         */
    
        /**
         * Constructs a new pb_attr.
         * @exports pb_attr
         * @classdesc Represents a pb_attr.
         * @implements Ipb_attr
         * @constructor
         * @param {Ipb_attr=} [properties] Properties to set
         */
        function pb_attr(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_attr atk.
         * @member {number} atk
         * @memberof pb_attr
         * @instance
         */
        pb_attr.prototype.atk = 0;
    
        /**
         * pb_attr hp.
         * @member {number|Long} hp
         * @memberof pb_attr
         * @instance
         */
        pb_attr.prototype.hp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * pb_attr arm.
         * @member {number} arm
         * @memberof pb_attr
         * @instance
         */
        pb_attr.prototype.arm = 0;
    
        /**
         * pb_attr spd.
         * @member {number} spd
         * @memberof pb_attr
         * @instance
         */
        pb_attr.prototype.spd = 0;
    
        /**
         * pb_attr sklP.
         * @member {number} sklP
         * @memberof pb_attr
         * @instance
         */
        pb_attr.prototype.sklP = 0;
    
        /**
         * pb_attr hit.
         * @member {number} hit
         * @memberof pb_attr
         * @instance
         */
        pb_attr.prototype.hit = 0;
    
        /**
         * pb_attr miss.
         * @member {number} miss
         * @memberof pb_attr
         * @instance
         */
        pb_attr.prototype.miss = 0;
    
        /**
         * pb_attr crit.
         * @member {number} crit
         * @memberof pb_attr
         * @instance
         */
        pb_attr.prototype.crit = 0;
    
        /**
         * pb_attr critTime.
         * @member {number} critTime
         * @memberof pb_attr
         * @instance
         */
        pb_attr.prototype.critTime = 0;
    
        /**
         * pb_attr brk.
         * @member {number} brk
         * @memberof pb_attr
         * @instance
         */
        pb_attr.prototype.brk = 0;
    
        /**
         * pb_attr free.
         * @member {number} free
         * @memberof pb_attr
         * @instance
         */
        pb_attr.prototype.free = 0;
    
        /**
         * pb_attr decDmg.
         * @member {number} decDmg
         * @memberof pb_attr
         * @instance
         */
        pb_attr.prototype.decDmg = 0;
    
        /**
         * pb_attr trueAtk.
         * @member {number} trueAtk
         * @memberof pb_attr
         * @instance
         */
        pb_attr.prototype.trueAtk = 0;
    
        /**
         * Creates a new pb_attr instance using the specified properties.
         * @function create
         * @memberof pb_attr
         * @static
         * @param {Ipb_attr=} [properties] Properties to set
         * @returns {pb_attr} pb_attr instance
         */
        pb_attr.create = function create(properties) {
            return new pb_attr(properties);
        };
    
        /**
         * Encodes the specified pb_attr message. Does not implicitly {@link pb_attr.verify|verify} messages.
         * @function encode
         * @memberof pb_attr
         * @static
         * @param {Ipb_attr} message pb_attr message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_attr.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.atk != null && Object.hasOwnProperty.call(message, "atk"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.atk);
            if (message.hp != null && Object.hasOwnProperty.call(message, "hp"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.hp);
            if (message.arm != null && Object.hasOwnProperty.call(message, "arm"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.arm);
            if (message.spd != null && Object.hasOwnProperty.call(message, "spd"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.spd);
            if (message.sklP != null && Object.hasOwnProperty.call(message, "sklP"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.sklP);
            if (message.hit != null && Object.hasOwnProperty.call(message, "hit"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.hit);
            if (message.miss != null && Object.hasOwnProperty.call(message, "miss"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.miss);
            if (message.crit != null && Object.hasOwnProperty.call(message, "crit"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.crit);
            if (message.critTime != null && Object.hasOwnProperty.call(message, "critTime"))
                writer.uint32(/* id 9, wireType 0 =*/72).int32(message.critTime);
            if (message.brk != null && Object.hasOwnProperty.call(message, "brk"))
                writer.uint32(/* id 10, wireType 0 =*/80).int32(message.brk);
            if (message.free != null && Object.hasOwnProperty.call(message, "free"))
                writer.uint32(/* id 11, wireType 0 =*/88).int32(message.free);
            if (message.decDmg != null && Object.hasOwnProperty.call(message, "decDmg"))
                writer.uint32(/* id 12, wireType 0 =*/96).int32(message.decDmg);
            if (message.trueAtk != null && Object.hasOwnProperty.call(message, "trueAtk"))
                writer.uint32(/* id 13, wireType 0 =*/104).int32(message.trueAtk);
            return writer;
        };
    
        /**
         * Encodes the specified pb_attr message, length delimited. Does not implicitly {@link pb_attr.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_attr
         * @static
         * @param {Ipb_attr} message pb_attr message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_attr.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_attr message from the specified reader or buffer.
         * @function decode
         * @memberof pb_attr
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_attr} pb_attr
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_attr.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_attr();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.atk = reader.int32();
                        break;
                    }
                case 2: {
                        message.hp = reader.int64();
                        break;
                    }
                case 3: {
                        message.arm = reader.int32();
                        break;
                    }
                case 4: {
                        message.spd = reader.int32();
                        break;
                    }
                case 5: {
                        message.sklP = reader.int32();
                        break;
                    }
                case 6: {
                        message.hit = reader.int32();
                        break;
                    }
                case 7: {
                        message.miss = reader.int32();
                        break;
                    }
                case 8: {
                        message.crit = reader.int32();
                        break;
                    }
                case 9: {
                        message.critTime = reader.int32();
                        break;
                    }
                case 10: {
                        message.brk = reader.int32();
                        break;
                    }
                case 11: {
                        message.free = reader.int32();
                        break;
                    }
                case 12: {
                        message.decDmg = reader.int32();
                        break;
                    }
                case 13: {
                        message.trueAtk = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a pb_attr message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_attr
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_attr} pb_attr
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_attr.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_attr message.
         * @function verify
         * @memberof pb_attr
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_attr.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.atk != null && message.hasOwnProperty("atk"))
                if (!$util.isInteger(message.atk))
                    return "atk: integer expected";
            if (message.hp != null && message.hasOwnProperty("hp"))
                if (!$util.isInteger(message.hp) && !(message.hp && $util.isInteger(message.hp.low) && $util.isInteger(message.hp.high)))
                    return "hp: integer|Long expected";
            if (message.arm != null && message.hasOwnProperty("arm"))
                if (!$util.isInteger(message.arm))
                    return "arm: integer expected";
            if (message.spd != null && message.hasOwnProperty("spd"))
                if (!$util.isInteger(message.spd))
                    return "spd: integer expected";
            if (message.sklP != null && message.hasOwnProperty("sklP"))
                if (!$util.isInteger(message.sklP))
                    return "sklP: integer expected";
            if (message.hit != null && message.hasOwnProperty("hit"))
                if (!$util.isInteger(message.hit))
                    return "hit: integer expected";
            if (message.miss != null && message.hasOwnProperty("miss"))
                if (!$util.isInteger(message.miss))
                    return "miss: integer expected";
            if (message.crit != null && message.hasOwnProperty("crit"))
                if (!$util.isInteger(message.crit))
                    return "crit: integer expected";
            if (message.critTime != null && message.hasOwnProperty("critTime"))
                if (!$util.isInteger(message.critTime))
                    return "critTime: integer expected";
            if (message.brk != null && message.hasOwnProperty("brk"))
                if (!$util.isInteger(message.brk))
                    return "brk: integer expected";
            if (message.free != null && message.hasOwnProperty("free"))
                if (!$util.isInteger(message.free))
                    return "free: integer expected";
            if (message.decDmg != null && message.hasOwnProperty("decDmg"))
                if (!$util.isInteger(message.decDmg))
                    return "decDmg: integer expected";
            if (message.trueAtk != null && message.hasOwnProperty("trueAtk"))
                if (!$util.isInteger(message.trueAtk))
                    return "trueAtk: integer expected";
            return null;
        };
    
        /**
         * Creates a pb_attr message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_attr
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_attr} pb_attr
         */
        pb_attr.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_attr)
                return object;
            var message = new $root.pb_attr();
            if (object.atk != null)
                message.atk = object.atk | 0;
            if (object.hp != null)
                if ($util.Long)
                    (message.hp = $util.Long.fromValue(object.hp)).unsigned = false;
                else if (typeof object.hp === "string")
                    message.hp = parseInt(object.hp, 10);
                else if (typeof object.hp === "number")
                    message.hp = object.hp;
                else if (typeof object.hp === "object")
                    message.hp = new $util.LongBits(object.hp.low >>> 0, object.hp.high >>> 0).toNumber();
            if (object.arm != null)
                message.arm = object.arm | 0;
            if (object.spd != null)
                message.spd = object.spd | 0;
            if (object.sklP != null)
                message.sklP = object.sklP | 0;
            if (object.hit != null)
                message.hit = object.hit | 0;
            if (object.miss != null)
                message.miss = object.miss | 0;
            if (object.crit != null)
                message.crit = object.crit | 0;
            if (object.critTime != null)
                message.critTime = object.critTime | 0;
            if (object.brk != null)
                message.brk = object.brk | 0;
            if (object.free != null)
                message.free = object.free | 0;
            if (object.decDmg != null)
                message.decDmg = object.decDmg | 0;
            if (object.trueAtk != null)
                message.trueAtk = object.trueAtk | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a pb_attr message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_attr
         * @static
         * @param {pb_attr} message pb_attr
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_attr.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.atk = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.hp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.hp = options.longs === String ? "0" : 0;
                object.arm = 0;
                object.spd = 0;
                object.sklP = 0;
                object.hit = 0;
                object.miss = 0;
                object.crit = 0;
                object.critTime = 0;
                object.brk = 0;
                object.free = 0;
                object.decDmg = 0;
                object.trueAtk = 0;
            }
            if (message.atk != null && message.hasOwnProperty("atk"))
                object.atk = message.atk;
            if (message.hp != null && message.hasOwnProperty("hp"))
                if (typeof message.hp === "number")
                    object.hp = options.longs === String ? String(message.hp) : message.hp;
                else
                    object.hp = options.longs === String ? $util.Long.prototype.toString.call(message.hp) : options.longs === Number ? new $util.LongBits(message.hp.low >>> 0, message.hp.high >>> 0).toNumber() : message.hp;
            if (message.arm != null && message.hasOwnProperty("arm"))
                object.arm = message.arm;
            if (message.spd != null && message.hasOwnProperty("spd"))
                object.spd = message.spd;
            if (message.sklP != null && message.hasOwnProperty("sklP"))
                object.sklP = message.sklP;
            if (message.hit != null && message.hasOwnProperty("hit"))
                object.hit = message.hit;
            if (message.miss != null && message.hasOwnProperty("miss"))
                object.miss = message.miss;
            if (message.crit != null && message.hasOwnProperty("crit"))
                object.crit = message.crit;
            if (message.critTime != null && message.hasOwnProperty("critTime"))
                object.critTime = message.critTime;
            if (message.brk != null && message.hasOwnProperty("brk"))
                object.brk = message.brk;
            if (message.free != null && message.hasOwnProperty("free"))
                object.free = message.free;
            if (message.decDmg != null && message.hasOwnProperty("decDmg"))
                object.decDmg = message.decDmg;
            if (message.trueAtk != null && message.hasOwnProperty("trueAtk"))
                object.trueAtk = message.trueAtk;
            return object;
        };
    
        /**
         * Converts this pb_attr to JSON.
         * @function toJSON
         * @memberof pb_attr
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_attr.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_attr
         * @function getTypeUrl
         * @memberof pb_attr
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_attr.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_attr";
        };
    
        return pb_attr;
    })();
    
    $root.pb_gvm_mbr = (function() {
    
        /**
         * Properties of a pb_gvm_mbr.
         * @exports Ipb_gvm_mbr
         * @interface Ipb_gvm_mbr
         * @property {string|null} [name] pb_gvm_mbr name
         * @property {number|Long|null} [uid] pb_gvm_mbr uid
         * @property {number|null} [lv] pb_gvm_mbr lv
         * @property {number|null} [logo] pb_gvm_mbr logo
         * @property {number|null} [lbox] pb_gvm_mbr lbox
         * @property {Array.<number|Long>|null} [scores] pb_gvm_mbr scores
         * @property {number|Long|null} [score] pb_gvm_mbr score
         */
    
        /**
         * Constructs a new pb_gvm_mbr.
         * @exports pb_gvm_mbr
         * @classdesc Represents a pb_gvm_mbr.
         * @implements Ipb_gvm_mbr
         * @constructor
         * @param {Ipb_gvm_mbr=} [properties] Properties to set
         */
        function pb_gvm_mbr(properties) {
            this.scores = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_gvm_mbr name.
         * @member {string} name
         * @memberof pb_gvm_mbr
         * @instance
         */
        pb_gvm_mbr.prototype.name = "";
    
        /**
         * pb_gvm_mbr uid.
         * @member {number|Long} uid
         * @memberof pb_gvm_mbr
         * @instance
         */
        pb_gvm_mbr.prototype.uid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * pb_gvm_mbr lv.
         * @member {number} lv
         * @memberof pb_gvm_mbr
         * @instance
         */
        pb_gvm_mbr.prototype.lv = 0;
    
        /**
         * pb_gvm_mbr logo.
         * @member {number} logo
         * @memberof pb_gvm_mbr
         * @instance
         */
        pb_gvm_mbr.prototype.logo = 0;
    
        /**
         * pb_gvm_mbr lbox.
         * @member {number} lbox
         * @memberof pb_gvm_mbr
         * @instance
         */
        pb_gvm_mbr.prototype.lbox = 0;
    
        /**
         * pb_gvm_mbr scores.
         * @member {Array.<number|Long>} scores
         * @memberof pb_gvm_mbr
         * @instance
         */
        pb_gvm_mbr.prototype.scores = $util.emptyArray;
    
        /**
         * pb_gvm_mbr score.
         * @member {number|Long} score
         * @memberof pb_gvm_mbr
         * @instance
         */
        pb_gvm_mbr.prototype.score = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * Creates a new pb_gvm_mbr instance using the specified properties.
         * @function create
         * @memberof pb_gvm_mbr
         * @static
         * @param {Ipb_gvm_mbr=} [properties] Properties to set
         * @returns {pb_gvm_mbr} pb_gvm_mbr instance
         */
        pb_gvm_mbr.create = function create(properties) {
            return new pb_gvm_mbr(properties);
        };
    
        /**
         * Encodes the specified pb_gvm_mbr message. Does not implicitly {@link pb_gvm_mbr.verify|verify} messages.
         * @function encode
         * @memberof pb_gvm_mbr
         * @static
         * @param {Ipb_gvm_mbr} message pb_gvm_mbr message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_gvm_mbr.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
            if (message.uid != null && Object.hasOwnProperty.call(message, "uid"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.uid);
            if (message.lv != null && Object.hasOwnProperty.call(message, "lv"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.lv);
            if (message.logo != null && Object.hasOwnProperty.call(message, "logo"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.logo);
            if (message.lbox != null && Object.hasOwnProperty.call(message, "lbox"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.lbox);
            if (message.scores != null && message.scores.length)
                for (var i = 0; i < message.scores.length; ++i)
                    writer.uint32(/* id 6, wireType 0 =*/48).int64(message.scores[i]);
            if (message.score != null && Object.hasOwnProperty.call(message, "score"))
                writer.uint32(/* id 7, wireType 0 =*/56).int64(message.score);
            return writer;
        };
    
        /**
         * Encodes the specified pb_gvm_mbr message, length delimited. Does not implicitly {@link pb_gvm_mbr.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_gvm_mbr
         * @static
         * @param {Ipb_gvm_mbr} message pb_gvm_mbr message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_gvm_mbr.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_gvm_mbr message from the specified reader or buffer.
         * @function decode
         * @memberof pb_gvm_mbr
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_gvm_mbr} pb_gvm_mbr
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_gvm_mbr.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_gvm_mbr();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.name = reader.string();
                        break;
                    }
                case 2: {
                        message.uid = reader.int64();
                        break;
                    }
                case 3: {
                        message.lv = reader.int32();
                        break;
                    }
                case 4: {
                        message.logo = reader.int32();
                        break;
                    }
                case 5: {
                        message.lbox = reader.int32();
                        break;
                    }
                case 6: {
                        if (!(message.scores && message.scores.length))
                            message.scores = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.scores.push(reader.int64());
                        } else
                            message.scores.push(reader.int64());
                        break;
                    }
                case 7: {
                        message.score = reader.int64();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a pb_gvm_mbr message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_gvm_mbr
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_gvm_mbr} pb_gvm_mbr
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_gvm_mbr.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_gvm_mbr message.
         * @function verify
         * @memberof pb_gvm_mbr
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_gvm_mbr.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (!$util.isInteger(message.uid) && !(message.uid && $util.isInteger(message.uid.low) && $util.isInteger(message.uid.high)))
                    return "uid: integer|Long expected";
            if (message.lv != null && message.hasOwnProperty("lv"))
                if (!$util.isInteger(message.lv))
                    return "lv: integer expected";
            if (message.logo != null && message.hasOwnProperty("logo"))
                if (!$util.isInteger(message.logo))
                    return "logo: integer expected";
            if (message.lbox != null && message.hasOwnProperty("lbox"))
                if (!$util.isInteger(message.lbox))
                    return "lbox: integer expected";
            if (message.scores != null && message.hasOwnProperty("scores")) {
                if (!Array.isArray(message.scores))
                    return "scores: array expected";
                for (var i = 0; i < message.scores.length; ++i)
                    if (!$util.isInteger(message.scores[i]) && !(message.scores[i] && $util.isInteger(message.scores[i].low) && $util.isInteger(message.scores[i].high)))
                        return "scores: integer|Long[] expected";
            }
            if (message.score != null && message.hasOwnProperty("score"))
                if (!$util.isInteger(message.score) && !(message.score && $util.isInteger(message.score.low) && $util.isInteger(message.score.high)))
                    return "score: integer|Long expected";
            return null;
        };
    
        /**
         * Creates a pb_gvm_mbr message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_gvm_mbr
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_gvm_mbr} pb_gvm_mbr
         */
        pb_gvm_mbr.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_gvm_mbr)
                return object;
            var message = new $root.pb_gvm_mbr();
            if (object.name != null)
                message.name = String(object.name);
            if (object.uid != null)
                if ($util.Long)
                    (message.uid = $util.Long.fromValue(object.uid)).unsigned = false;
                else if (typeof object.uid === "string")
                    message.uid = parseInt(object.uid, 10);
                else if (typeof object.uid === "number")
                    message.uid = object.uid;
                else if (typeof object.uid === "object")
                    message.uid = new $util.LongBits(object.uid.low >>> 0, object.uid.high >>> 0).toNumber();
            if (object.lv != null)
                message.lv = object.lv | 0;
            if (object.logo != null)
                message.logo = object.logo | 0;
            if (object.lbox != null)
                message.lbox = object.lbox | 0;
            if (object.scores) {
                if (!Array.isArray(object.scores))
                    throw TypeError(".pb_gvm_mbr.scores: array expected");
                message.scores = [];
                for (var i = 0; i < object.scores.length; ++i)
                    if ($util.Long)
                        (message.scores[i] = $util.Long.fromValue(object.scores[i])).unsigned = false;
                    else if (typeof object.scores[i] === "string")
                        message.scores[i] = parseInt(object.scores[i], 10);
                    else if (typeof object.scores[i] === "number")
                        message.scores[i] = object.scores[i];
                    else if (typeof object.scores[i] === "object")
                        message.scores[i] = new $util.LongBits(object.scores[i].low >>> 0, object.scores[i].high >>> 0).toNumber();
            }
            if (object.score != null)
                if ($util.Long)
                    (message.score = $util.Long.fromValue(object.score)).unsigned = false;
                else if (typeof object.score === "string")
                    message.score = parseInt(object.score, 10);
                else if (typeof object.score === "number")
                    message.score = object.score;
                else if (typeof object.score === "object")
                    message.score = new $util.LongBits(object.score.low >>> 0, object.score.high >>> 0).toNumber();
            return message;
        };
    
        /**
         * Creates a plain object from a pb_gvm_mbr message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_gvm_mbr
         * @static
         * @param {pb_gvm_mbr} message pb_gvm_mbr
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_gvm_mbr.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.scores = [];
            if (options.defaults) {
                object.name = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.uid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.uid = options.longs === String ? "0" : 0;
                object.lv = 0;
                object.logo = 0;
                object.lbox = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.score = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.score = options.longs === String ? "0" : 0;
            }
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (typeof message.uid === "number")
                    object.uid = options.longs === String ? String(message.uid) : message.uid;
                else
                    object.uid = options.longs === String ? $util.Long.prototype.toString.call(message.uid) : options.longs === Number ? new $util.LongBits(message.uid.low >>> 0, message.uid.high >>> 0).toNumber() : message.uid;
            if (message.lv != null && message.hasOwnProperty("lv"))
                object.lv = message.lv;
            if (message.logo != null && message.hasOwnProperty("logo"))
                object.logo = message.logo;
            if (message.lbox != null && message.hasOwnProperty("lbox"))
                object.lbox = message.lbox;
            if (message.scores && message.scores.length) {
                object.scores = [];
                for (var j = 0; j < message.scores.length; ++j)
                    if (typeof message.scores[j] === "number")
                        object.scores[j] = options.longs === String ? String(message.scores[j]) : message.scores[j];
                    else
                        object.scores[j] = options.longs === String ? $util.Long.prototype.toString.call(message.scores[j]) : options.longs === Number ? new $util.LongBits(message.scores[j].low >>> 0, message.scores[j].high >>> 0).toNumber() : message.scores[j];
            }
            if (message.score != null && message.hasOwnProperty("score"))
                if (typeof message.score === "number")
                    object.score = options.longs === String ? String(message.score) : message.score;
                else
                    object.score = options.longs === String ? $util.Long.prototype.toString.call(message.score) : options.longs === Number ? new $util.LongBits(message.score.low >>> 0, message.score.high >>> 0).toNumber() : message.score;
            return object;
        };
    
        /**
         * Converts this pb_gvm_mbr to JSON.
         * @function toJSON
         * @memberof pb_gvm_mbr
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_gvm_mbr.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_gvm_mbr
         * @function getTypeUrl
         * @memberof pb_gvm_mbr
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_gvm_mbr.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_gvm_mbr";
        };
    
        return pb_gvm_mbr;
    })();
    
    $root.pb_up_star = (function() {
    
        /**
         * Properties of a pb_up_star.
         * @exports Ipb_up_star
         * @interface Ipb_up_star
         * @property {number} id pb_up_star id
         * @property {Array.<number>|null} [hid] pb_up_star hid
         */
    
        /**
         * Constructs a new pb_up_star.
         * @exports pb_up_star
         * @classdesc Represents a pb_up_star.
         * @implements Ipb_up_star
         * @constructor
         * @param {Ipb_up_star=} [properties] Properties to set
         */
        function pb_up_star(properties) {
            this.hid = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_up_star id.
         * @member {number} id
         * @memberof pb_up_star
         * @instance
         */
        pb_up_star.prototype.id = 0;
    
        /**
         * pb_up_star hid.
         * @member {Array.<number>} hid
         * @memberof pb_up_star
         * @instance
         */
        pb_up_star.prototype.hid = $util.emptyArray;
    
        /**
         * Creates a new pb_up_star instance using the specified properties.
         * @function create
         * @memberof pb_up_star
         * @static
         * @param {Ipb_up_star=} [properties] Properties to set
         * @returns {pb_up_star} pb_up_star instance
         */
        pb_up_star.create = function create(properties) {
            return new pb_up_star(properties);
        };
    
        /**
         * Encodes the specified pb_up_star message. Does not implicitly {@link pb_up_star.verify|verify} messages.
         * @function encode
         * @memberof pb_up_star
         * @static
         * @param {Ipb_up_star} message pb_up_star message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_up_star.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.id);
            if (message.hid != null && message.hid.length)
                for (var i = 0; i < message.hid.length; ++i)
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.hid[i]);
            return writer;
        };
    
        /**
         * Encodes the specified pb_up_star message, length delimited. Does not implicitly {@link pb_up_star.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_up_star
         * @static
         * @param {Ipb_up_star} message pb_up_star message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_up_star.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_up_star message from the specified reader or buffer.
         * @function decode
         * @memberof pb_up_star
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_up_star} pb_up_star
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_up_star.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_up_star();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.id = reader.int32();
                        break;
                    }
                case 2: {
                        if (!(message.hid && message.hid.length))
                            message.hid = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.hid.push(reader.int32());
                        } else
                            message.hid.push(reader.int32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("id"))
                throw $util.ProtocolError("missing required 'id'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a pb_up_star message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_up_star
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_up_star} pb_up_star
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_up_star.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_up_star message.
         * @function verify
         * @memberof pb_up_star
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_up_star.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.id))
                return "id: integer expected";
            if (message.hid != null && message.hasOwnProperty("hid")) {
                if (!Array.isArray(message.hid))
                    return "hid: array expected";
                for (var i = 0; i < message.hid.length; ++i)
                    if (!$util.isInteger(message.hid[i]))
                        return "hid: integer[] expected";
            }
            return null;
        };
    
        /**
         * Creates a pb_up_star message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_up_star
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_up_star} pb_up_star
         */
        pb_up_star.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_up_star)
                return object;
            var message = new $root.pb_up_star();
            if (object.id != null)
                message.id = object.id | 0;
            if (object.hid) {
                if (!Array.isArray(object.hid))
                    throw TypeError(".pb_up_star.hid: array expected");
                message.hid = [];
                for (var i = 0; i < object.hid.length; ++i)
                    message.hid[i] = object.hid[i] | 0;
            }
            return message;
        };
    
        /**
         * Creates a plain object from a pb_up_star message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_up_star
         * @static
         * @param {pb_up_star} message pb_up_star
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_up_star.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.hid = [];
            if (options.defaults)
                object.id = 0;
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.hid && message.hid.length) {
                object.hid = [];
                for (var j = 0; j < message.hid.length; ++j)
                    object.hid[j] = message.hid[j];
            }
            return object;
        };
    
        /**
         * Converts this pb_up_star to JSON.
         * @function toJSON
         * @memberof pb_up_star
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_up_star.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_up_star
         * @function getTypeUrl
         * @memberof pb_up_star
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_up_star.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_up_star";
        };
    
        return pb_up_star;
    })();
    
    $root.pb_fun = (function() {
    
        /**
         * Properties of a pb_fun.
         * @exports Ipb_fun
         * @interface Ipb_fun
         * @property {number} open pb_fun open
         * @property {number} cd pb_fun cd
         * @property {number|null} [id] pb_fun id
         */
    
        /**
         * Constructs a new pb_fun.
         * @exports pb_fun
         * @classdesc Represents a pb_fun.
         * @implements Ipb_fun
         * @constructor
         * @param {Ipb_fun=} [properties] Properties to set
         */
        function pb_fun(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_fun open.
         * @member {number} open
         * @memberof pb_fun
         * @instance
         */
        pb_fun.prototype.open = 0;
    
        /**
         * pb_fun cd.
         * @member {number} cd
         * @memberof pb_fun
         * @instance
         */
        pb_fun.prototype.cd = 0;
    
        /**
         * pb_fun id.
         * @member {number} id
         * @memberof pb_fun
         * @instance
         */
        pb_fun.prototype.id = 0;
    
        /**
         * Creates a new pb_fun instance using the specified properties.
         * @function create
         * @memberof pb_fun
         * @static
         * @param {Ipb_fun=} [properties] Properties to set
         * @returns {pb_fun} pb_fun instance
         */
        pb_fun.create = function create(properties) {
            return new pb_fun(properties);
        };
    
        /**
         * Encodes the specified pb_fun message. Does not implicitly {@link pb_fun.verify|verify} messages.
         * @function encode
         * @memberof pb_fun
         * @static
         * @param {Ipb_fun} message pb_fun message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_fun.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.open);
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.cd);
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.id);
            return writer;
        };
    
        /**
         * Encodes the specified pb_fun message, length delimited. Does not implicitly {@link pb_fun.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_fun
         * @static
         * @param {Ipb_fun} message pb_fun message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_fun.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_fun message from the specified reader or buffer.
         * @function decode
         * @memberof pb_fun
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_fun} pb_fun
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_fun.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_fun();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.open = reader.int32();
                        break;
                    }
                case 2: {
                        message.cd = reader.int32();
                        break;
                    }
                case 3: {
                        message.id = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("open"))
                throw $util.ProtocolError("missing required 'open'", { instance: message });
            if (!message.hasOwnProperty("cd"))
                throw $util.ProtocolError("missing required 'cd'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a pb_fun message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_fun
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_fun} pb_fun
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_fun.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_fun message.
         * @function verify
         * @memberof pb_fun
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_fun.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.open))
                return "open: integer expected";
            if (!$util.isInteger(message.cd))
                return "cd: integer expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id))
                    return "id: integer expected";
            return null;
        };
    
        /**
         * Creates a pb_fun message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_fun
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_fun} pb_fun
         */
        pb_fun.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_fun)
                return object;
            var message = new $root.pb_fun();
            if (object.open != null)
                message.open = object.open | 0;
            if (object.cd != null)
                message.cd = object.cd | 0;
            if (object.id != null)
                message.id = object.id | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a pb_fun message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_fun
         * @static
         * @param {pb_fun} message pb_fun
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_fun.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.open = 0;
                object.cd = 0;
                object.id = 0;
            }
            if (message.open != null && message.hasOwnProperty("open"))
                object.open = message.open;
            if (message.cd != null && message.hasOwnProperty("cd"))
                object.cd = message.cd;
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            return object;
        };
    
        /**
         * Converts this pb_fun to JSON.
         * @function toJSON
         * @memberof pb_fun
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_fun.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_fun
         * @function getTypeUrl
         * @memberof pb_fun
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_fun.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_fun";
        };
    
        return pb_fun;
    })();
    
    $root.hland_change_skin = (function() {
    
        /**
         * Properties of a hland_change_skin.
         * @exports Ihland_change_skin
         * @interface Ihland_change_skin
         * @property {number} skin hland_change_skin skin
         * @property {number} pos hland_change_skin pos
         */
    
        /**
         * Constructs a new hland_change_skin.
         * @exports hland_change_skin
         * @classdesc Represents a hland_change_skin.
         * @implements Ihland_change_skin
         * @constructor
         * @param {Ihland_change_skin=} [properties] Properties to set
         */
        function hland_change_skin(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * hland_change_skin skin.
         * @member {number} skin
         * @memberof hland_change_skin
         * @instance
         */
        hland_change_skin.prototype.skin = 0;
    
        /**
         * hland_change_skin pos.
         * @member {number} pos
         * @memberof hland_change_skin
         * @instance
         */
        hland_change_skin.prototype.pos = 0;
    
        /**
         * Creates a new hland_change_skin instance using the specified properties.
         * @function create
         * @memberof hland_change_skin
         * @static
         * @param {Ihland_change_skin=} [properties] Properties to set
         * @returns {hland_change_skin} hland_change_skin instance
         */
        hland_change_skin.create = function create(properties) {
            return new hland_change_skin(properties);
        };
    
        /**
         * Encodes the specified hland_change_skin message. Does not implicitly {@link hland_change_skin.verify|verify} messages.
         * @function encode
         * @memberof hland_change_skin
         * @static
         * @param {Ihland_change_skin} message hland_change_skin message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        hland_change_skin.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.skin);
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.pos);
            return writer;
        };
    
        /**
         * Encodes the specified hland_change_skin message, length delimited. Does not implicitly {@link hland_change_skin.verify|verify} messages.
         * @function encodeDelimited
         * @memberof hland_change_skin
         * @static
         * @param {Ihland_change_skin} message hland_change_skin message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        hland_change_skin.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a hland_change_skin message from the specified reader or buffer.
         * @function decode
         * @memberof hland_change_skin
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {hland_change_skin} hland_change_skin
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        hland_change_skin.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.hland_change_skin();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.skin = reader.int32();
                        break;
                    }
                case 2: {
                        message.pos = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("skin"))
                throw $util.ProtocolError("missing required 'skin'", { instance: message });
            if (!message.hasOwnProperty("pos"))
                throw $util.ProtocolError("missing required 'pos'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a hland_change_skin message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof hland_change_skin
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {hland_change_skin} hland_change_skin
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        hland_change_skin.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a hland_change_skin message.
         * @function verify
         * @memberof hland_change_skin
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        hland_change_skin.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.skin))
                return "skin: integer expected";
            if (!$util.isInteger(message.pos))
                return "pos: integer expected";
            return null;
        };
    
        /**
         * Creates a hland_change_skin message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof hland_change_skin
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {hland_change_skin} hland_change_skin
         */
        hland_change_skin.fromObject = function fromObject(object) {
            if (object instanceof $root.hland_change_skin)
                return object;
            var message = new $root.hland_change_skin();
            if (object.skin != null)
                message.skin = object.skin | 0;
            if (object.pos != null)
                message.pos = object.pos | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a hland_change_skin message. Also converts values to other types if specified.
         * @function toObject
         * @memberof hland_change_skin
         * @static
         * @param {hland_change_skin} message hland_change_skin
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        hland_change_skin.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.skin = 0;
                object.pos = 0;
            }
            if (message.skin != null && message.hasOwnProperty("skin"))
                object.skin = message.skin;
            if (message.pos != null && message.hasOwnProperty("pos"))
                object.pos = message.pos;
            return object;
        };
    
        /**
         * Converts this hland_change_skin to JSON.
         * @function toJSON
         * @memberof hland_change_skin
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        hland_change_skin.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for hland_change_skin
         * @function getTypeUrl
         * @memberof hland_change_skin
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        hland_change_skin.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/hland_change_skin";
        };
    
        return hland_change_skin;
    })();
    
    $root.pb_hland_log = (function() {
    
        /**
         * Properties of a pb_hland_log.
         * @exports Ipb_hland_log
         * @interface Ipb_hland_log
         * @property {string|null} [name] pb_hland_log name
         * @property {number|Long|null} [uid] pb_hland_log uid
         * @property {number|null} [lv] pb_hland_log lv
         * @property {number|null} [logo] pb_hland_log logo
         * @property {number|null} [lbox] pb_hland_log lbox
         * @property {number|null} [type] pb_hland_log type
         * @property {number|Long|null} [time] pb_hland_log time
         */
    
        /**
         * Constructs a new pb_hland_log.
         * @exports pb_hland_log
         * @classdesc Represents a pb_hland_log.
         * @implements Ipb_hland_log
         * @constructor
         * @param {Ipb_hland_log=} [properties] Properties to set
         */
        function pb_hland_log(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_hland_log name.
         * @member {string} name
         * @memberof pb_hland_log
         * @instance
         */
        pb_hland_log.prototype.name = "";
    
        /**
         * pb_hland_log uid.
         * @member {number|Long} uid
         * @memberof pb_hland_log
         * @instance
         */
        pb_hland_log.prototype.uid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * pb_hland_log lv.
         * @member {number} lv
         * @memberof pb_hland_log
         * @instance
         */
        pb_hland_log.prototype.lv = 0;
    
        /**
         * pb_hland_log logo.
         * @member {number} logo
         * @memberof pb_hland_log
         * @instance
         */
        pb_hland_log.prototype.logo = 0;
    
        /**
         * pb_hland_log lbox.
         * @member {number} lbox
         * @memberof pb_hland_log
         * @instance
         */
        pb_hland_log.prototype.lbox = 0;
    
        /**
         * pb_hland_log type.
         * @member {number} type
         * @memberof pb_hland_log
         * @instance
         */
        pb_hland_log.prototype.type = 0;
    
        /**
         * pb_hland_log time.
         * @member {number|Long} time
         * @memberof pb_hland_log
         * @instance
         */
        pb_hland_log.prototype.time = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * Creates a new pb_hland_log instance using the specified properties.
         * @function create
         * @memberof pb_hland_log
         * @static
         * @param {Ipb_hland_log=} [properties] Properties to set
         * @returns {pb_hland_log} pb_hland_log instance
         */
        pb_hland_log.create = function create(properties) {
            return new pb_hland_log(properties);
        };
    
        /**
         * Encodes the specified pb_hland_log message. Does not implicitly {@link pb_hland_log.verify|verify} messages.
         * @function encode
         * @memberof pb_hland_log
         * @static
         * @param {Ipb_hland_log} message pb_hland_log message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_hland_log.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
            if (message.uid != null && Object.hasOwnProperty.call(message, "uid"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.uid);
            if (message.lv != null && Object.hasOwnProperty.call(message, "lv"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.lv);
            if (message.logo != null && Object.hasOwnProperty.call(message, "logo"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.logo);
            if (message.lbox != null && Object.hasOwnProperty.call(message, "lbox"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.lbox);
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.type);
            if (message.time != null && Object.hasOwnProperty.call(message, "time"))
                writer.uint32(/* id 7, wireType 0 =*/56).int64(message.time);
            return writer;
        };
    
        /**
         * Encodes the specified pb_hland_log message, length delimited. Does not implicitly {@link pb_hland_log.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_hland_log
         * @static
         * @param {Ipb_hland_log} message pb_hland_log message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_hland_log.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_hland_log message from the specified reader or buffer.
         * @function decode
         * @memberof pb_hland_log
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_hland_log} pb_hland_log
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_hland_log.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_hland_log();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.name = reader.string();
                        break;
                    }
                case 2: {
                        message.uid = reader.int64();
                        break;
                    }
                case 3: {
                        message.lv = reader.int32();
                        break;
                    }
                case 4: {
                        message.logo = reader.int32();
                        break;
                    }
                case 5: {
                        message.lbox = reader.int32();
                        break;
                    }
                case 6: {
                        message.type = reader.int32();
                        break;
                    }
                case 7: {
                        message.time = reader.int64();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a pb_hland_log message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_hland_log
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_hland_log} pb_hland_log
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_hland_log.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_hland_log message.
         * @function verify
         * @memberof pb_hland_log
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_hland_log.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (!$util.isInteger(message.uid) && !(message.uid && $util.isInteger(message.uid.low) && $util.isInteger(message.uid.high)))
                    return "uid: integer|Long expected";
            if (message.lv != null && message.hasOwnProperty("lv"))
                if (!$util.isInteger(message.lv))
                    return "lv: integer expected";
            if (message.logo != null && message.hasOwnProperty("logo"))
                if (!$util.isInteger(message.logo))
                    return "logo: integer expected";
            if (message.lbox != null && message.hasOwnProperty("lbox"))
                if (!$util.isInteger(message.lbox))
                    return "lbox: integer expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isInteger(message.type))
                    return "type: integer expected";
            if (message.time != null && message.hasOwnProperty("time"))
                if (!$util.isInteger(message.time) && !(message.time && $util.isInteger(message.time.low) && $util.isInteger(message.time.high)))
                    return "time: integer|Long expected";
            return null;
        };
    
        /**
         * Creates a pb_hland_log message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_hland_log
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_hland_log} pb_hland_log
         */
        pb_hland_log.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_hland_log)
                return object;
            var message = new $root.pb_hland_log();
            if (object.name != null)
                message.name = String(object.name);
            if (object.uid != null)
                if ($util.Long)
                    (message.uid = $util.Long.fromValue(object.uid)).unsigned = false;
                else if (typeof object.uid === "string")
                    message.uid = parseInt(object.uid, 10);
                else if (typeof object.uid === "number")
                    message.uid = object.uid;
                else if (typeof object.uid === "object")
                    message.uid = new $util.LongBits(object.uid.low >>> 0, object.uid.high >>> 0).toNumber();
            if (object.lv != null)
                message.lv = object.lv | 0;
            if (object.logo != null)
                message.logo = object.logo | 0;
            if (object.lbox != null)
                message.lbox = object.lbox | 0;
            if (object.type != null)
                message.type = object.type | 0;
            if (object.time != null)
                if ($util.Long)
                    (message.time = $util.Long.fromValue(object.time)).unsigned = false;
                else if (typeof object.time === "string")
                    message.time = parseInt(object.time, 10);
                else if (typeof object.time === "number")
                    message.time = object.time;
                else if (typeof object.time === "object")
                    message.time = new $util.LongBits(object.time.low >>> 0, object.time.high >>> 0).toNumber();
            return message;
        };
    
        /**
         * Creates a plain object from a pb_hland_log message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_hland_log
         * @static
         * @param {pb_hland_log} message pb_hland_log
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_hland_log.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.name = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.uid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.uid = options.longs === String ? "0" : 0;
                object.lv = 0;
                object.logo = 0;
                object.lbox = 0;
                object.type = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.time = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.time = options.longs === String ? "0" : 0;
            }
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (typeof message.uid === "number")
                    object.uid = options.longs === String ? String(message.uid) : message.uid;
                else
                    object.uid = options.longs === String ? $util.Long.prototype.toString.call(message.uid) : options.longs === Number ? new $util.LongBits(message.uid.low >>> 0, message.uid.high >>> 0).toNumber() : message.uid;
            if (message.lv != null && message.hasOwnProperty("lv"))
                object.lv = message.lv;
            if (message.logo != null && message.hasOwnProperty("logo"))
                object.logo = message.logo;
            if (message.lbox != null && message.hasOwnProperty("lbox"))
                object.lbox = message.lbox;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            if (message.time != null && message.hasOwnProperty("time"))
                if (typeof message.time === "number")
                    object.time = options.longs === String ? String(message.time) : message.time;
                else
                    object.time = options.longs === String ? $util.Long.prototype.toString.call(message.time) : options.longs === Number ? new $util.LongBits(message.time.low >>> 0, message.time.high >>> 0).toNumber() : message.time;
            return object;
        };
    
        /**
         * Converts this pb_hland_log to JSON.
         * @function toJSON
         * @memberof pb_hland_log
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_hland_log.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_hland_log
         * @function getTypeUrl
         * @memberof pb_hland_log
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_hland_log.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_hland_log";
        };
    
        return pb_hland_log;
    })();
    
    $root.pb_hmbr = (function() {
    
        /**
         * Properties of a pb_hmbr.
         * @exports Ipb_hmbr
         * @interface Ipb_hmbr
         * @property {string|null} [name] pb_hmbr name
         * @property {number|Long|null} [uid] pb_hmbr uid
         * @property {number|null} [lv] pb_hmbr lv
         * @property {number|null} [logo] pb_hmbr logo
         * @property {number|null} [lbox] pb_hmbr lbox
         * @property {Array.<number>|null} [itemIds] pb_hmbr itemIds
         */
    
        /**
         * Constructs a new pb_hmbr.
         * @exports pb_hmbr
         * @classdesc Represents a pb_hmbr.
         * @implements Ipb_hmbr
         * @constructor
         * @param {Ipb_hmbr=} [properties] Properties to set
         */
        function pb_hmbr(properties) {
            this.itemIds = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_hmbr name.
         * @member {string} name
         * @memberof pb_hmbr
         * @instance
         */
        pb_hmbr.prototype.name = "";
    
        /**
         * pb_hmbr uid.
         * @member {number|Long} uid
         * @memberof pb_hmbr
         * @instance
         */
        pb_hmbr.prototype.uid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * pb_hmbr lv.
         * @member {number} lv
         * @memberof pb_hmbr
         * @instance
         */
        pb_hmbr.prototype.lv = 0;
    
        /**
         * pb_hmbr logo.
         * @member {number} logo
         * @memberof pb_hmbr
         * @instance
         */
        pb_hmbr.prototype.logo = 0;
    
        /**
         * pb_hmbr lbox.
         * @member {number} lbox
         * @memberof pb_hmbr
         * @instance
         */
        pb_hmbr.prototype.lbox = 0;
    
        /**
         * pb_hmbr itemIds.
         * @member {Array.<number>} itemIds
         * @memberof pb_hmbr
         * @instance
         */
        pb_hmbr.prototype.itemIds = $util.emptyArray;
    
        /**
         * Creates a new pb_hmbr instance using the specified properties.
         * @function create
         * @memberof pb_hmbr
         * @static
         * @param {Ipb_hmbr=} [properties] Properties to set
         * @returns {pb_hmbr} pb_hmbr instance
         */
        pb_hmbr.create = function create(properties) {
            return new pb_hmbr(properties);
        };
    
        /**
         * Encodes the specified pb_hmbr message. Does not implicitly {@link pb_hmbr.verify|verify} messages.
         * @function encode
         * @memberof pb_hmbr
         * @static
         * @param {Ipb_hmbr} message pb_hmbr message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_hmbr.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
            if (message.uid != null && Object.hasOwnProperty.call(message, "uid"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.uid);
            if (message.lv != null && Object.hasOwnProperty.call(message, "lv"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.lv);
            if (message.logo != null && Object.hasOwnProperty.call(message, "logo"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.logo);
            if (message.lbox != null && Object.hasOwnProperty.call(message, "lbox"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.lbox);
            if (message.itemIds != null && message.itemIds.length)
                for (var i = 0; i < message.itemIds.length; ++i)
                    writer.uint32(/* id 6, wireType 0 =*/48).int32(message.itemIds[i]);
            return writer;
        };
    
        /**
         * Encodes the specified pb_hmbr message, length delimited. Does not implicitly {@link pb_hmbr.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_hmbr
         * @static
         * @param {Ipb_hmbr} message pb_hmbr message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_hmbr.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_hmbr message from the specified reader or buffer.
         * @function decode
         * @memberof pb_hmbr
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_hmbr} pb_hmbr
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_hmbr.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_hmbr();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.name = reader.string();
                        break;
                    }
                case 2: {
                        message.uid = reader.int64();
                        break;
                    }
                case 3: {
                        message.lv = reader.int32();
                        break;
                    }
                case 4: {
                        message.logo = reader.int32();
                        break;
                    }
                case 5: {
                        message.lbox = reader.int32();
                        break;
                    }
                case 6: {
                        if (!(message.itemIds && message.itemIds.length))
                            message.itemIds = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.itemIds.push(reader.int32());
                        } else
                            message.itemIds.push(reader.int32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a pb_hmbr message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_hmbr
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_hmbr} pb_hmbr
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_hmbr.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_hmbr message.
         * @function verify
         * @memberof pb_hmbr
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_hmbr.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (!$util.isInteger(message.uid) && !(message.uid && $util.isInteger(message.uid.low) && $util.isInteger(message.uid.high)))
                    return "uid: integer|Long expected";
            if (message.lv != null && message.hasOwnProperty("lv"))
                if (!$util.isInteger(message.lv))
                    return "lv: integer expected";
            if (message.logo != null && message.hasOwnProperty("logo"))
                if (!$util.isInteger(message.logo))
                    return "logo: integer expected";
            if (message.lbox != null && message.hasOwnProperty("lbox"))
                if (!$util.isInteger(message.lbox))
                    return "lbox: integer expected";
            if (message.itemIds != null && message.hasOwnProperty("itemIds")) {
                if (!Array.isArray(message.itemIds))
                    return "itemIds: array expected";
                for (var i = 0; i < message.itemIds.length; ++i)
                    if (!$util.isInteger(message.itemIds[i]))
                        return "itemIds: integer[] expected";
            }
            return null;
        };
    
        /**
         * Creates a pb_hmbr message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_hmbr
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_hmbr} pb_hmbr
         */
        pb_hmbr.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_hmbr)
                return object;
            var message = new $root.pb_hmbr();
            if (object.name != null)
                message.name = String(object.name);
            if (object.uid != null)
                if ($util.Long)
                    (message.uid = $util.Long.fromValue(object.uid)).unsigned = false;
                else if (typeof object.uid === "string")
                    message.uid = parseInt(object.uid, 10);
                else if (typeof object.uid === "number")
                    message.uid = object.uid;
                else if (typeof object.uid === "object")
                    message.uid = new $util.LongBits(object.uid.low >>> 0, object.uid.high >>> 0).toNumber();
            if (object.lv != null)
                message.lv = object.lv | 0;
            if (object.logo != null)
                message.logo = object.logo | 0;
            if (object.lbox != null)
                message.lbox = object.lbox | 0;
            if (object.itemIds) {
                if (!Array.isArray(object.itemIds))
                    throw TypeError(".pb_hmbr.itemIds: array expected");
                message.itemIds = [];
                for (var i = 0; i < object.itemIds.length; ++i)
                    message.itemIds[i] = object.itemIds[i] | 0;
            }
            return message;
        };
    
        /**
         * Creates a plain object from a pb_hmbr message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_hmbr
         * @static
         * @param {pb_hmbr} message pb_hmbr
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_hmbr.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.itemIds = [];
            if (options.defaults) {
                object.name = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.uid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.uid = options.longs === String ? "0" : 0;
                object.lv = 0;
                object.logo = 0;
                object.lbox = 0;
            }
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (typeof message.uid === "number")
                    object.uid = options.longs === String ? String(message.uid) : message.uid;
                else
                    object.uid = options.longs === String ? $util.Long.prototype.toString.call(message.uid) : options.longs === Number ? new $util.LongBits(message.uid.low >>> 0, message.uid.high >>> 0).toNumber() : message.uid;
            if (message.lv != null && message.hasOwnProperty("lv"))
                object.lv = message.lv;
            if (message.logo != null && message.hasOwnProperty("logo"))
                object.logo = message.logo;
            if (message.lbox != null && message.hasOwnProperty("lbox"))
                object.lbox = message.lbox;
            if (message.itemIds && message.itemIds.length) {
                object.itemIds = [];
                for (var j = 0; j < message.itemIds.length; ++j)
                    object.itemIds[j] = message.itemIds[j];
            }
            return object;
        };
    
        /**
         * Converts this pb_hmbr to JSON.
         * @function toJSON
         * @memberof pb_hmbr
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_hmbr.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_hmbr
         * @function getTypeUrl
         * @memberof pb_hmbr
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_hmbr.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_hmbr";
        };
    
        return pb_hmbr;
    })();
    
    $root.pb_hteam = (function() {
    
        /**
         * Properties of a pb_hteam.
         * @exports Ipb_hteam
         * @interface Ipb_hteam
         * @property {string|null} [id] pb_hteam id
         * @property {number|Long|null} [leader] pb_hteam leader
         * @property {number|null} [type] pb_hteam type
         * @property {Array.<Ipb_hmbr>|null} [mbr] pb_hteam mbr
         * @property {number|null} [cd] pb_hteam cd
         * @property {boolean|null} [shape] pb_hteam shape
         * @property {Array.<number|Long>|null} [invites] pb_hteam invites
         */
    
        /**
         * Constructs a new pb_hteam.
         * @exports pb_hteam
         * @classdesc Represents a pb_hteam.
         * @implements Ipb_hteam
         * @constructor
         * @param {Ipb_hteam=} [properties] Properties to set
         */
        function pb_hteam(properties) {
            this.mbr = [];
            this.invites = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_hteam id.
         * @member {string} id
         * @memberof pb_hteam
         * @instance
         */
        pb_hteam.prototype.id = "";
    
        /**
         * pb_hteam leader.
         * @member {number|Long} leader
         * @memberof pb_hteam
         * @instance
         */
        pb_hteam.prototype.leader = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * pb_hteam type.
         * @member {number} type
         * @memberof pb_hteam
         * @instance
         */
        pb_hteam.prototype.type = 0;
    
        /**
         * pb_hteam mbr.
         * @member {Array.<Ipb_hmbr>} mbr
         * @memberof pb_hteam
         * @instance
         */
        pb_hteam.prototype.mbr = $util.emptyArray;
    
        /**
         * pb_hteam cd.
         * @member {number} cd
         * @memberof pb_hteam
         * @instance
         */
        pb_hteam.prototype.cd = 0;
    
        /**
         * pb_hteam shape.
         * @member {boolean} shape
         * @memberof pb_hteam
         * @instance
         */
        pb_hteam.prototype.shape = false;
    
        /**
         * pb_hteam invites.
         * @member {Array.<number|Long>} invites
         * @memberof pb_hteam
         * @instance
         */
        pb_hteam.prototype.invites = $util.emptyArray;
    
        /**
         * Creates a new pb_hteam instance using the specified properties.
         * @function create
         * @memberof pb_hteam
         * @static
         * @param {Ipb_hteam=} [properties] Properties to set
         * @returns {pb_hteam} pb_hteam instance
         */
        pb_hteam.create = function create(properties) {
            return new pb_hteam(properties);
        };
    
        /**
         * Encodes the specified pb_hteam message. Does not implicitly {@link pb_hteam.verify|verify} messages.
         * @function encode
         * @memberof pb_hteam
         * @static
         * @param {Ipb_hteam} message pb_hteam message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_hteam.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
            if (message.leader != null && Object.hasOwnProperty.call(message, "leader"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.leader);
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.type);
            if (message.mbr != null && message.mbr.length)
                for (var i = 0; i < message.mbr.length; ++i)
                    $root.pb_hmbr.encode(message.mbr[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.cd != null && Object.hasOwnProperty.call(message, "cd"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.cd);
            if (message.shape != null && Object.hasOwnProperty.call(message, "shape"))
                writer.uint32(/* id 6, wireType 0 =*/48).bool(message.shape);
            if (message.invites != null && message.invites.length)
                for (var i = 0; i < message.invites.length; ++i)
                    writer.uint32(/* id 7, wireType 0 =*/56).int64(message.invites[i]);
            return writer;
        };
    
        /**
         * Encodes the specified pb_hteam message, length delimited. Does not implicitly {@link pb_hteam.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_hteam
         * @static
         * @param {Ipb_hteam} message pb_hteam message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_hteam.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_hteam message from the specified reader or buffer.
         * @function decode
         * @memberof pb_hteam
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_hteam} pb_hteam
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_hteam.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_hteam();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.id = reader.string();
                        break;
                    }
                case 2: {
                        message.leader = reader.int64();
                        break;
                    }
                case 3: {
                        message.type = reader.int32();
                        break;
                    }
                case 4: {
                        if (!(message.mbr && message.mbr.length))
                            message.mbr = [];
                        message.mbr.push($root.pb_hmbr.decode(reader, reader.uint32()));
                        break;
                    }
                case 5: {
                        message.cd = reader.int32();
                        break;
                    }
                case 6: {
                        message.shape = reader.bool();
                        break;
                    }
                case 7: {
                        if (!(message.invites && message.invites.length))
                            message.invites = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.invites.push(reader.int64());
                        } else
                            message.invites.push(reader.int64());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a pb_hteam message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_hteam
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_hteam} pb_hteam
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_hteam.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_hteam message.
         * @function verify
         * @memberof pb_hteam
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_hteam.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            if (message.leader != null && message.hasOwnProperty("leader"))
                if (!$util.isInteger(message.leader) && !(message.leader && $util.isInteger(message.leader.low) && $util.isInteger(message.leader.high)))
                    return "leader: integer|Long expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isInteger(message.type))
                    return "type: integer expected";
            if (message.mbr != null && message.hasOwnProperty("mbr")) {
                if (!Array.isArray(message.mbr))
                    return "mbr: array expected";
                for (var i = 0; i < message.mbr.length; ++i) {
                    var error = $root.pb_hmbr.verify(message.mbr[i]);
                    if (error)
                        return "mbr." + error;
                }
            }
            if (message.cd != null && message.hasOwnProperty("cd"))
                if (!$util.isInteger(message.cd))
                    return "cd: integer expected";
            if (message.shape != null && message.hasOwnProperty("shape"))
                if (typeof message.shape !== "boolean")
                    return "shape: boolean expected";
            if (message.invites != null && message.hasOwnProperty("invites")) {
                if (!Array.isArray(message.invites))
                    return "invites: array expected";
                for (var i = 0; i < message.invites.length; ++i)
                    if (!$util.isInteger(message.invites[i]) && !(message.invites[i] && $util.isInteger(message.invites[i].low) && $util.isInteger(message.invites[i].high)))
                        return "invites: integer|Long[] expected";
            }
            return null;
        };
    
        /**
         * Creates a pb_hteam message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_hteam
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_hteam} pb_hteam
         */
        pb_hteam.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_hteam)
                return object;
            var message = new $root.pb_hteam();
            if (object.id != null)
                message.id = String(object.id);
            if (object.leader != null)
                if ($util.Long)
                    (message.leader = $util.Long.fromValue(object.leader)).unsigned = false;
                else if (typeof object.leader === "string")
                    message.leader = parseInt(object.leader, 10);
                else if (typeof object.leader === "number")
                    message.leader = object.leader;
                else if (typeof object.leader === "object")
                    message.leader = new $util.LongBits(object.leader.low >>> 0, object.leader.high >>> 0).toNumber();
            if (object.type != null)
                message.type = object.type | 0;
            if (object.mbr) {
                if (!Array.isArray(object.mbr))
                    throw TypeError(".pb_hteam.mbr: array expected");
                message.mbr = [];
                for (var i = 0; i < object.mbr.length; ++i) {
                    if (typeof object.mbr[i] !== "object")
                        throw TypeError(".pb_hteam.mbr: object expected");
                    message.mbr[i] = $root.pb_hmbr.fromObject(object.mbr[i]);
                }
            }
            if (object.cd != null)
                message.cd = object.cd | 0;
            if (object.shape != null)
                message.shape = Boolean(object.shape);
            if (object.invites) {
                if (!Array.isArray(object.invites))
                    throw TypeError(".pb_hteam.invites: array expected");
                message.invites = [];
                for (var i = 0; i < object.invites.length; ++i)
                    if ($util.Long)
                        (message.invites[i] = $util.Long.fromValue(object.invites[i])).unsigned = false;
                    else if (typeof object.invites[i] === "string")
                        message.invites[i] = parseInt(object.invites[i], 10);
                    else if (typeof object.invites[i] === "number")
                        message.invites[i] = object.invites[i];
                    else if (typeof object.invites[i] === "object")
                        message.invites[i] = new $util.LongBits(object.invites[i].low >>> 0, object.invites[i].high >>> 0).toNumber();
            }
            return message;
        };
    
        /**
         * Creates a plain object from a pb_hteam message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_hteam
         * @static
         * @param {pb_hteam} message pb_hteam
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_hteam.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.mbr = [];
                object.invites = [];
            }
            if (options.defaults) {
                object.id = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.leader = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.leader = options.longs === String ? "0" : 0;
                object.type = 0;
                object.cd = 0;
                object.shape = false;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.leader != null && message.hasOwnProperty("leader"))
                if (typeof message.leader === "number")
                    object.leader = options.longs === String ? String(message.leader) : message.leader;
                else
                    object.leader = options.longs === String ? $util.Long.prototype.toString.call(message.leader) : options.longs === Number ? new $util.LongBits(message.leader.low >>> 0, message.leader.high >>> 0).toNumber() : message.leader;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            if (message.mbr && message.mbr.length) {
                object.mbr = [];
                for (var j = 0; j < message.mbr.length; ++j)
                    object.mbr[j] = $root.pb_hmbr.toObject(message.mbr[j], options);
            }
            if (message.cd != null && message.hasOwnProperty("cd"))
                object.cd = message.cd;
            if (message.shape != null && message.hasOwnProperty("shape"))
                object.shape = message.shape;
            if (message.invites && message.invites.length) {
                object.invites = [];
                for (var j = 0; j < message.invites.length; ++j)
                    if (typeof message.invites[j] === "number")
                        object.invites[j] = options.longs === String ? String(message.invites[j]) : message.invites[j];
                    else
                        object.invites[j] = options.longs === String ? $util.Long.prototype.toString.call(message.invites[j]) : options.longs === Number ? new $util.LongBits(message.invites[j].low >>> 0, message.invites[j].high >>> 0).toNumber() : message.invites[j];
            }
            return object;
        };
    
        /**
         * Converts this pb_hteam to JSON.
         * @function toJSON
         * @memberof pb_hteam
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_hteam.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_hteam
         * @function getTypeUrl
         * @memberof pb_hteam
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_hteam.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_hteam";
        };
    
        return pb_hteam;
    })();
    
    $root.pb_team_info = (function() {
    
        /**
         * Properties of a pb_team_info.
         * @exports Ipb_team_info
         * @interface Ipb_team_info
         * @property {number} id pb_team_info id
         * @property {string|null} [name] pb_team_info name
         * @property {Array.<Ipb_team_hero>|null} [heroes] pb_team_info heroes
         * @property {number|null} [petid] pb_team_info petid
         * @property {number|null} [flag] pb_team_info flag
         */
    
        /**
         * Constructs a new pb_team_info.
         * @exports pb_team_info
         * @classdesc Represents a pb_team_info.
         * @implements Ipb_team_info
         * @constructor
         * @param {Ipb_team_info=} [properties] Properties to set
         */
        function pb_team_info(properties) {
            this.heroes = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_team_info id.
         * @member {number} id
         * @memberof pb_team_info
         * @instance
         */
        pb_team_info.prototype.id = 0;
    
        /**
         * pb_team_info name.
         * @member {string} name
         * @memberof pb_team_info
         * @instance
         */
        pb_team_info.prototype.name = "";
    
        /**
         * pb_team_info heroes.
         * @member {Array.<Ipb_team_hero>} heroes
         * @memberof pb_team_info
         * @instance
         */
        pb_team_info.prototype.heroes = $util.emptyArray;
    
        /**
         * pb_team_info petid.
         * @member {number} petid
         * @memberof pb_team_info
         * @instance
         */
        pb_team_info.prototype.petid = 0;
    
        /**
         * pb_team_info flag.
         * @member {number} flag
         * @memberof pb_team_info
         * @instance
         */
        pb_team_info.prototype.flag = 0;
    
        /**
         * Creates a new pb_team_info instance using the specified properties.
         * @function create
         * @memberof pb_team_info
         * @static
         * @param {Ipb_team_info=} [properties] Properties to set
         * @returns {pb_team_info} pb_team_info instance
         */
        pb_team_info.create = function create(properties) {
            return new pb_team_info(properties);
        };
    
        /**
         * Encodes the specified pb_team_info message. Does not implicitly {@link pb_team_info.verify|verify} messages.
         * @function encode
         * @memberof pb_team_info
         * @static
         * @param {Ipb_team_info} message pb_team_info message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_team_info.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.id);
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
            if (message.heroes != null && message.heroes.length)
                for (var i = 0; i < message.heroes.length; ++i)
                    $root.pb_team_hero.encode(message.heroes[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.petid != null && Object.hasOwnProperty.call(message, "petid"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.petid);
            if (message.flag != null && Object.hasOwnProperty.call(message, "flag"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.flag);
            return writer;
        };
    
        /**
         * Encodes the specified pb_team_info message, length delimited. Does not implicitly {@link pb_team_info.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_team_info
         * @static
         * @param {Ipb_team_info} message pb_team_info message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_team_info.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_team_info message from the specified reader or buffer.
         * @function decode
         * @memberof pb_team_info
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_team_info} pb_team_info
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_team_info.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_team_info();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.id = reader.int32();
                        break;
                    }
                case 2: {
                        message.name = reader.string();
                        break;
                    }
                case 3: {
                        if (!(message.heroes && message.heroes.length))
                            message.heroes = [];
                        message.heroes.push($root.pb_team_hero.decode(reader, reader.uint32()));
                        break;
                    }
                case 4: {
                        message.petid = reader.int32();
                        break;
                    }
                case 5: {
                        message.flag = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("id"))
                throw $util.ProtocolError("missing required 'id'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a pb_team_info message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_team_info
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_team_info} pb_team_info
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_team_info.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_team_info message.
         * @function verify
         * @memberof pb_team_info
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_team_info.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.id))
                return "id: integer expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.heroes != null && message.hasOwnProperty("heroes")) {
                if (!Array.isArray(message.heroes))
                    return "heroes: array expected";
                for (var i = 0; i < message.heroes.length; ++i) {
                    var error = $root.pb_team_hero.verify(message.heroes[i]);
                    if (error)
                        return "heroes." + error;
                }
            }
            if (message.petid != null && message.hasOwnProperty("petid"))
                if (!$util.isInteger(message.petid))
                    return "petid: integer expected";
            if (message.flag != null && message.hasOwnProperty("flag"))
                if (!$util.isInteger(message.flag))
                    return "flag: integer expected";
            return null;
        };
    
        /**
         * Creates a pb_team_info message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_team_info
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_team_info} pb_team_info
         */
        pb_team_info.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_team_info)
                return object;
            var message = new $root.pb_team_info();
            if (object.id != null)
                message.id = object.id | 0;
            if (object.name != null)
                message.name = String(object.name);
            if (object.heroes) {
                if (!Array.isArray(object.heroes))
                    throw TypeError(".pb_team_info.heroes: array expected");
                message.heroes = [];
                for (var i = 0; i < object.heroes.length; ++i) {
                    if (typeof object.heroes[i] !== "object")
                        throw TypeError(".pb_team_info.heroes: object expected");
                    message.heroes[i] = $root.pb_team_hero.fromObject(object.heroes[i]);
                }
            }
            if (object.petid != null)
                message.petid = object.petid | 0;
            if (object.flag != null)
                message.flag = object.flag | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a pb_team_info message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_team_info
         * @static
         * @param {pb_team_info} message pb_team_info
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_team_info.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.heroes = [];
            if (options.defaults) {
                object.id = 0;
                object.name = "";
                object.petid = 0;
                object.flag = 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.heroes && message.heroes.length) {
                object.heroes = [];
                for (var j = 0; j < message.heroes.length; ++j)
                    object.heroes[j] = $root.pb_team_hero.toObject(message.heroes[j], options);
            }
            if (message.petid != null && message.hasOwnProperty("petid"))
                object.petid = message.petid;
            if (message.flag != null && message.hasOwnProperty("flag"))
                object.flag = message.flag;
            return object;
        };
    
        /**
         * Converts this pb_team_info to JSON.
         * @function toJSON
         * @memberof pb_team_info
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_team_info.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_team_info
         * @function getTypeUrl
         * @memberof pb_team_info
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_team_info.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_team_info";
        };
    
        return pb_team_info;
    })();
    
    $root.pb_team_hero = (function() {
    
        /**
         * Properties of a pb_team_hero.
         * @exports Ipb_team_hero
         * @interface Ipb_team_hero
         * @property {number} pos pb_team_hero pos
         * @property {number} hid pb_team_hero hid
         * @property {Array.<Ipb_equip>|null} [equips] pb_team_hero equips
         * @property {Array.<number>|null} [skillId] pb_team_hero skillId
         * @property {Array.<Ipb_sattr>|null} [sattrs] pb_team_hero sattrs
         * @property {number|null} [flag] pb_team_hero flag
         */
    
        /**
         * Constructs a new pb_team_hero.
         * @exports pb_team_hero
         * @classdesc Represents a pb_team_hero.
         * @implements Ipb_team_hero
         * @constructor
         * @param {Ipb_team_hero=} [properties] Properties to set
         */
        function pb_team_hero(properties) {
            this.equips = [];
            this.skillId = [];
            this.sattrs = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_team_hero pos.
         * @member {number} pos
         * @memberof pb_team_hero
         * @instance
         */
        pb_team_hero.prototype.pos = 0;
    
        /**
         * pb_team_hero hid.
         * @member {number} hid
         * @memberof pb_team_hero
         * @instance
         */
        pb_team_hero.prototype.hid = 0;
    
        /**
         * pb_team_hero equips.
         * @member {Array.<Ipb_equip>} equips
         * @memberof pb_team_hero
         * @instance
         */
        pb_team_hero.prototype.equips = $util.emptyArray;
    
        /**
         * pb_team_hero skillId.
         * @member {Array.<number>} skillId
         * @memberof pb_team_hero
         * @instance
         */
        pb_team_hero.prototype.skillId = $util.emptyArray;
    
        /**
         * pb_team_hero sattrs.
         * @member {Array.<Ipb_sattr>} sattrs
         * @memberof pb_team_hero
         * @instance
         */
        pb_team_hero.prototype.sattrs = $util.emptyArray;
    
        /**
         * pb_team_hero flag.
         * @member {number} flag
         * @memberof pb_team_hero
         * @instance
         */
        pb_team_hero.prototype.flag = 0;
    
        /**
         * Creates a new pb_team_hero instance using the specified properties.
         * @function create
         * @memberof pb_team_hero
         * @static
         * @param {Ipb_team_hero=} [properties] Properties to set
         * @returns {pb_team_hero} pb_team_hero instance
         */
        pb_team_hero.create = function create(properties) {
            return new pb_team_hero(properties);
        };
    
        /**
         * Encodes the specified pb_team_hero message. Does not implicitly {@link pb_team_hero.verify|verify} messages.
         * @function encode
         * @memberof pb_team_hero
         * @static
         * @param {Ipb_team_hero} message pb_team_hero message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_team_hero.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.pos);
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.hid);
            if (message.equips != null && message.equips.length)
                for (var i = 0; i < message.equips.length; ++i)
                    $root.pb_equip.encode(message.equips[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.skillId != null && message.skillId.length)
                for (var i = 0; i < message.skillId.length; ++i)
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.skillId[i]);
            if (message.sattrs != null && message.sattrs.length)
                for (var i = 0; i < message.sattrs.length; ++i)
                    $root.pb_sattr.encode(message.sattrs[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.flag != null && Object.hasOwnProperty.call(message, "flag"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.flag);
            return writer;
        };
    
        /**
         * Encodes the specified pb_team_hero message, length delimited. Does not implicitly {@link pb_team_hero.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_team_hero
         * @static
         * @param {Ipb_team_hero} message pb_team_hero message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_team_hero.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_team_hero message from the specified reader or buffer.
         * @function decode
         * @memberof pb_team_hero
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_team_hero} pb_team_hero
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_team_hero.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_team_hero();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.pos = reader.int32();
                        break;
                    }
                case 2: {
                        message.hid = reader.int32();
                        break;
                    }
                case 3: {
                        if (!(message.equips && message.equips.length))
                            message.equips = [];
                        message.equips.push($root.pb_equip.decode(reader, reader.uint32()));
                        break;
                    }
                case 4: {
                        if (!(message.skillId && message.skillId.length))
                            message.skillId = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.skillId.push(reader.int32());
                        } else
                            message.skillId.push(reader.int32());
                        break;
                    }
                case 5: {
                        if (!(message.sattrs && message.sattrs.length))
                            message.sattrs = [];
                        message.sattrs.push($root.pb_sattr.decode(reader, reader.uint32()));
                        break;
                    }
                case 6: {
                        message.flag = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("pos"))
                throw $util.ProtocolError("missing required 'pos'", { instance: message });
            if (!message.hasOwnProperty("hid"))
                throw $util.ProtocolError("missing required 'hid'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a pb_team_hero message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_team_hero
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_team_hero} pb_team_hero
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_team_hero.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_team_hero message.
         * @function verify
         * @memberof pb_team_hero
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_team_hero.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.pos))
                return "pos: integer expected";
            if (!$util.isInteger(message.hid))
                return "hid: integer expected";
            if (message.equips != null && message.hasOwnProperty("equips")) {
                if (!Array.isArray(message.equips))
                    return "equips: array expected";
                for (var i = 0; i < message.equips.length; ++i) {
                    var error = $root.pb_equip.verify(message.equips[i]);
                    if (error)
                        return "equips." + error;
                }
            }
            if (message.skillId != null && message.hasOwnProperty("skillId")) {
                if (!Array.isArray(message.skillId))
                    return "skillId: array expected";
                for (var i = 0; i < message.skillId.length; ++i)
                    if (!$util.isInteger(message.skillId[i]))
                        return "skillId: integer[] expected";
            }
            if (message.sattrs != null && message.hasOwnProperty("sattrs")) {
                if (!Array.isArray(message.sattrs))
                    return "sattrs: array expected";
                for (var i = 0; i < message.sattrs.length; ++i) {
                    var error = $root.pb_sattr.verify(message.sattrs[i]);
                    if (error)
                        return "sattrs." + error;
                }
            }
            if (message.flag != null && message.hasOwnProperty("flag"))
                if (!$util.isInteger(message.flag))
                    return "flag: integer expected";
            return null;
        };
    
        /**
         * Creates a pb_team_hero message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_team_hero
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_team_hero} pb_team_hero
         */
        pb_team_hero.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_team_hero)
                return object;
            var message = new $root.pb_team_hero();
            if (object.pos != null)
                message.pos = object.pos | 0;
            if (object.hid != null)
                message.hid = object.hid | 0;
            if (object.equips) {
                if (!Array.isArray(object.equips))
                    throw TypeError(".pb_team_hero.equips: array expected");
                message.equips = [];
                for (var i = 0; i < object.equips.length; ++i) {
                    if (typeof object.equips[i] !== "object")
                        throw TypeError(".pb_team_hero.equips: object expected");
                    message.equips[i] = $root.pb_equip.fromObject(object.equips[i]);
                }
            }
            if (object.skillId) {
                if (!Array.isArray(object.skillId))
                    throw TypeError(".pb_team_hero.skillId: array expected");
                message.skillId = [];
                for (var i = 0; i < object.skillId.length; ++i)
                    message.skillId[i] = object.skillId[i] | 0;
            }
            if (object.sattrs) {
                if (!Array.isArray(object.sattrs))
                    throw TypeError(".pb_team_hero.sattrs: array expected");
                message.sattrs = [];
                for (var i = 0; i < object.sattrs.length; ++i) {
                    if (typeof object.sattrs[i] !== "object")
                        throw TypeError(".pb_team_hero.sattrs: object expected");
                    message.sattrs[i] = $root.pb_sattr.fromObject(object.sattrs[i]);
                }
            }
            if (object.flag != null)
                message.flag = object.flag | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a pb_team_hero message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_team_hero
         * @static
         * @param {pb_team_hero} message pb_team_hero
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_team_hero.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.equips = [];
                object.skillId = [];
                object.sattrs = [];
            }
            if (options.defaults) {
                object.pos = 0;
                object.hid = 0;
                object.flag = 0;
            }
            if (message.pos != null && message.hasOwnProperty("pos"))
                object.pos = message.pos;
            if (message.hid != null && message.hasOwnProperty("hid"))
                object.hid = message.hid;
            if (message.equips && message.equips.length) {
                object.equips = [];
                for (var j = 0; j < message.equips.length; ++j)
                    object.equips[j] = $root.pb_equip.toObject(message.equips[j], options);
            }
            if (message.skillId && message.skillId.length) {
                object.skillId = [];
                for (var j = 0; j < message.skillId.length; ++j)
                    object.skillId[j] = message.skillId[j];
            }
            if (message.sattrs && message.sattrs.length) {
                object.sattrs = [];
                for (var j = 0; j < message.sattrs.length; ++j)
                    object.sattrs[j] = $root.pb_sattr.toObject(message.sattrs[j], options);
            }
            if (message.flag != null && message.hasOwnProperty("flag"))
                object.flag = message.flag;
            return object;
        };
    
        /**
         * Converts this pb_team_hero to JSON.
         * @function toJSON
         * @memberof pb_team_hero
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_team_hero.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_team_hero
         * @function getTypeUrl
         * @memberof pb_team_hero
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_team_hero.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_team_hero";
        };
    
        return pb_team_hero;
    })();
    
    $root.good = (function() {
    
        /**
         * Properties of a good.
         * @exports Igood
         * @interface Igood
         * @property {number|null} [goodId] good goodId
         * @property {number|null} [heroId] good heroId
         * @property {Ipb_hero_qlc|null} [qlt] good qlt
         * @property {number|Long|null} [price] good price
         * @property {number|Long|null} [delPrice] good delPrice
         * @property {number|null} [state] good state
         * @property {number|null} [cd] good cd
         * @property {number|null} [rprice] good rprice
         * @property {Ipb_give_role|null} [seller] good seller
         * @property {Ipb_give_role|null} [buyer] good buyer
         */
    
        /**
         * Constructs a new good.
         * @exports good
         * @classdesc Represents a good.
         * @implements Igood
         * @constructor
         * @param {Igood=} [properties] Properties to set
         */
        function good(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * good goodId.
         * @member {number} goodId
         * @memberof good
         * @instance
         */
        good.prototype.goodId = 0;
    
        /**
         * good heroId.
         * @member {number} heroId
         * @memberof good
         * @instance
         */
        good.prototype.heroId = 0;
    
        /**
         * good qlt.
         * @member {Ipb_hero_qlc|null|undefined} qlt
         * @memberof good
         * @instance
         */
        good.prototype.qlt = null;
    
        /**
         * good price.
         * @member {number|Long} price
         * @memberof good
         * @instance
         */
        good.prototype.price = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * good delPrice.
         * @member {number|Long} delPrice
         * @memberof good
         * @instance
         */
        good.prototype.delPrice = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * good state.
         * @member {number} state
         * @memberof good
         * @instance
         */
        good.prototype.state = 0;
    
        /**
         * good cd.
         * @member {number} cd
         * @memberof good
         * @instance
         */
        good.prototype.cd = 0;
    
        /**
         * good rprice.
         * @member {number} rprice
         * @memberof good
         * @instance
         */
        good.prototype.rprice = 0;
    
        /**
         * good seller.
         * @member {Ipb_give_role|null|undefined} seller
         * @memberof good
         * @instance
         */
        good.prototype.seller = null;
    
        /**
         * good buyer.
         * @member {Ipb_give_role|null|undefined} buyer
         * @memberof good
         * @instance
         */
        good.prototype.buyer = null;
    
        /**
         * Creates a new good instance using the specified properties.
         * @function create
         * @memberof good
         * @static
         * @param {Igood=} [properties] Properties to set
         * @returns {good} good instance
         */
        good.create = function create(properties) {
            return new good(properties);
        };
    
        /**
         * Encodes the specified good message. Does not implicitly {@link good.verify|verify} messages.
         * @function encode
         * @memberof good
         * @static
         * @param {Igood} message good message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        good.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.goodId != null && Object.hasOwnProperty.call(message, "goodId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.goodId);
            if (message.heroId != null && Object.hasOwnProperty.call(message, "heroId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.heroId);
            if (message.qlt != null && Object.hasOwnProperty.call(message, "qlt"))
                $root.pb_hero_qlc.encode(message.qlt, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.price != null && Object.hasOwnProperty.call(message, "price"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.price);
            if (message.delPrice != null && Object.hasOwnProperty.call(message, "delPrice"))
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.delPrice);
            if (message.state != null && Object.hasOwnProperty.call(message, "state"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.state);
            if (message.cd != null && Object.hasOwnProperty.call(message, "cd"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.cd);
            if (message.rprice != null && Object.hasOwnProperty.call(message, "rprice"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.rprice);
            if (message.seller != null && Object.hasOwnProperty.call(message, "seller"))
                $root.pb_give_role.encode(message.seller, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
            if (message.buyer != null && Object.hasOwnProperty.call(message, "buyer"))
                $root.pb_give_role.encode(message.buyer, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified good message, length delimited. Does not implicitly {@link good.verify|verify} messages.
         * @function encodeDelimited
         * @memberof good
         * @static
         * @param {Igood} message good message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        good.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a good message from the specified reader or buffer.
         * @function decode
         * @memberof good
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {good} good
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        good.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.good();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.goodId = reader.int32();
                        break;
                    }
                case 2: {
                        message.heroId = reader.int32();
                        break;
                    }
                case 3: {
                        message.qlt = $root.pb_hero_qlc.decode(reader, reader.uint32());
                        break;
                    }
                case 4: {
                        message.price = reader.int64();
                        break;
                    }
                case 5: {
                        message.delPrice = reader.int64();
                        break;
                    }
                case 6: {
                        message.state = reader.int32();
                        break;
                    }
                case 7: {
                        message.cd = reader.int32();
                        break;
                    }
                case 8: {
                        message.rprice = reader.int32();
                        break;
                    }
                case 9: {
                        message.seller = $root.pb_give_role.decode(reader, reader.uint32());
                        break;
                    }
                case 10: {
                        message.buyer = $root.pb_give_role.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a good message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof good
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {good} good
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        good.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a good message.
         * @function verify
         * @memberof good
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        good.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.goodId != null && message.hasOwnProperty("goodId"))
                if (!$util.isInteger(message.goodId))
                    return "goodId: integer expected";
            if (message.heroId != null && message.hasOwnProperty("heroId"))
                if (!$util.isInteger(message.heroId))
                    return "heroId: integer expected";
            if (message.qlt != null && message.hasOwnProperty("qlt")) {
                var error = $root.pb_hero_qlc.verify(message.qlt);
                if (error)
                    return "qlt." + error;
            }
            if (message.price != null && message.hasOwnProperty("price"))
                if (!$util.isInteger(message.price) && !(message.price && $util.isInteger(message.price.low) && $util.isInteger(message.price.high)))
                    return "price: integer|Long expected";
            if (message.delPrice != null && message.hasOwnProperty("delPrice"))
                if (!$util.isInteger(message.delPrice) && !(message.delPrice && $util.isInteger(message.delPrice.low) && $util.isInteger(message.delPrice.high)))
                    return "delPrice: integer|Long expected";
            if (message.state != null && message.hasOwnProperty("state"))
                if (!$util.isInteger(message.state))
                    return "state: integer expected";
            if (message.cd != null && message.hasOwnProperty("cd"))
                if (!$util.isInteger(message.cd))
                    return "cd: integer expected";
            if (message.rprice != null && message.hasOwnProperty("rprice"))
                if (!$util.isInteger(message.rprice))
                    return "rprice: integer expected";
            if (message.seller != null && message.hasOwnProperty("seller")) {
                var error = $root.pb_give_role.verify(message.seller);
                if (error)
                    return "seller." + error;
            }
            if (message.buyer != null && message.hasOwnProperty("buyer")) {
                var error = $root.pb_give_role.verify(message.buyer);
                if (error)
                    return "buyer." + error;
            }
            return null;
        };
    
        /**
         * Creates a good message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof good
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {good} good
         */
        good.fromObject = function fromObject(object) {
            if (object instanceof $root.good)
                return object;
            var message = new $root.good();
            if (object.goodId != null)
                message.goodId = object.goodId | 0;
            if (object.heroId != null)
                message.heroId = object.heroId | 0;
            if (object.qlt != null) {
                if (typeof object.qlt !== "object")
                    throw TypeError(".good.qlt: object expected");
                message.qlt = $root.pb_hero_qlc.fromObject(object.qlt);
            }
            if (object.price != null)
                if ($util.Long)
                    (message.price = $util.Long.fromValue(object.price)).unsigned = false;
                else if (typeof object.price === "string")
                    message.price = parseInt(object.price, 10);
                else if (typeof object.price === "number")
                    message.price = object.price;
                else if (typeof object.price === "object")
                    message.price = new $util.LongBits(object.price.low >>> 0, object.price.high >>> 0).toNumber();
            if (object.delPrice != null)
                if ($util.Long)
                    (message.delPrice = $util.Long.fromValue(object.delPrice)).unsigned = false;
                else if (typeof object.delPrice === "string")
                    message.delPrice = parseInt(object.delPrice, 10);
                else if (typeof object.delPrice === "number")
                    message.delPrice = object.delPrice;
                else if (typeof object.delPrice === "object")
                    message.delPrice = new $util.LongBits(object.delPrice.low >>> 0, object.delPrice.high >>> 0).toNumber();
            if (object.state != null)
                message.state = object.state | 0;
            if (object.cd != null)
                message.cd = object.cd | 0;
            if (object.rprice != null)
                message.rprice = object.rprice | 0;
            if (object.seller != null) {
                if (typeof object.seller !== "object")
                    throw TypeError(".good.seller: object expected");
                message.seller = $root.pb_give_role.fromObject(object.seller);
            }
            if (object.buyer != null) {
                if (typeof object.buyer !== "object")
                    throw TypeError(".good.buyer: object expected");
                message.buyer = $root.pb_give_role.fromObject(object.buyer);
            }
            return message;
        };
    
        /**
         * Creates a plain object from a good message. Also converts values to other types if specified.
         * @function toObject
         * @memberof good
         * @static
         * @param {good} message good
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        good.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.goodId = 0;
                object.heroId = 0;
                object.qlt = null;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.price = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.price = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.delPrice = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.delPrice = options.longs === String ? "0" : 0;
                object.state = 0;
                object.cd = 0;
                object.rprice = 0;
                object.seller = null;
                object.buyer = null;
            }
            if (message.goodId != null && message.hasOwnProperty("goodId"))
                object.goodId = message.goodId;
            if (message.heroId != null && message.hasOwnProperty("heroId"))
                object.heroId = message.heroId;
            if (message.qlt != null && message.hasOwnProperty("qlt"))
                object.qlt = $root.pb_hero_qlc.toObject(message.qlt, options);
            if (message.price != null && message.hasOwnProperty("price"))
                if (typeof message.price === "number")
                    object.price = options.longs === String ? String(message.price) : message.price;
                else
                    object.price = options.longs === String ? $util.Long.prototype.toString.call(message.price) : options.longs === Number ? new $util.LongBits(message.price.low >>> 0, message.price.high >>> 0).toNumber() : message.price;
            if (message.delPrice != null && message.hasOwnProperty("delPrice"))
                if (typeof message.delPrice === "number")
                    object.delPrice = options.longs === String ? String(message.delPrice) : message.delPrice;
                else
                    object.delPrice = options.longs === String ? $util.Long.prototype.toString.call(message.delPrice) : options.longs === Number ? new $util.LongBits(message.delPrice.low >>> 0, message.delPrice.high >>> 0).toNumber() : message.delPrice;
            if (message.state != null && message.hasOwnProperty("state"))
                object.state = message.state;
            if (message.cd != null && message.hasOwnProperty("cd"))
                object.cd = message.cd;
            if (message.rprice != null && message.hasOwnProperty("rprice"))
                object.rprice = message.rprice;
            if (message.seller != null && message.hasOwnProperty("seller"))
                object.seller = $root.pb_give_role.toObject(message.seller, options);
            if (message.buyer != null && message.hasOwnProperty("buyer"))
                object.buyer = $root.pb_give_role.toObject(message.buyer, options);
            return object;
        };
    
        /**
         * Converts this good to JSON.
         * @function toJSON
         * @memberof good
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        good.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for good
         * @function getTypeUrl
         * @memberof good
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        good.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/good";
        };
    
        return good;
    })();
    
    $root.mall_log = (function() {
    
        /**
         * Properties of a mall_log.
         * @exports Imall_log
         * @interface Imall_log
         * @property {number|null} [time] mall_log time
         * @property {number|null} [heroid] mall_log heroid
         * @property {Ipb_hero_qlc|null} [qlt] mall_log qlt
         * @property {number|null} [price] mall_log price
         * @property {number|null} [type] mall_log type
         * @property {number|null} [status] mall_log status
         * @property {number|null} [goodid] mall_log goodid
         * @property {Ipb_give_role|null} [user] mall_log user
         */
    
        /**
         * Constructs a new mall_log.
         * @exports mall_log
         * @classdesc Represents a mall_log.
         * @implements Imall_log
         * @constructor
         * @param {Imall_log=} [properties] Properties to set
         */
        function mall_log(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * mall_log time.
         * @member {number} time
         * @memberof mall_log
         * @instance
         */
        mall_log.prototype.time = 0;
    
        /**
         * mall_log heroid.
         * @member {number} heroid
         * @memberof mall_log
         * @instance
         */
        mall_log.prototype.heroid = 0;
    
        /**
         * mall_log qlt.
         * @member {Ipb_hero_qlc|null|undefined} qlt
         * @memberof mall_log
         * @instance
         */
        mall_log.prototype.qlt = null;
    
        /**
         * mall_log price.
         * @member {number} price
         * @memberof mall_log
         * @instance
         */
        mall_log.prototype.price = 0;
    
        /**
         * mall_log type.
         * @member {number} type
         * @memberof mall_log
         * @instance
         */
        mall_log.prototype.type = 0;
    
        /**
         * mall_log status.
         * @member {number} status
         * @memberof mall_log
         * @instance
         */
        mall_log.prototype.status = 0;
    
        /**
         * mall_log goodid.
         * @member {number} goodid
         * @memberof mall_log
         * @instance
         */
        mall_log.prototype.goodid = 0;
    
        /**
         * mall_log user.
         * @member {Ipb_give_role|null|undefined} user
         * @memberof mall_log
         * @instance
         */
        mall_log.prototype.user = null;
    
        /**
         * Creates a new mall_log instance using the specified properties.
         * @function create
         * @memberof mall_log
         * @static
         * @param {Imall_log=} [properties] Properties to set
         * @returns {mall_log} mall_log instance
         */
        mall_log.create = function create(properties) {
            return new mall_log(properties);
        };
    
        /**
         * Encodes the specified mall_log message. Does not implicitly {@link mall_log.verify|verify} messages.
         * @function encode
         * @memberof mall_log
         * @static
         * @param {Imall_log} message mall_log message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        mall_log.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.time != null && Object.hasOwnProperty.call(message, "time"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.time);
            if (message.heroid != null && Object.hasOwnProperty.call(message, "heroid"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.heroid);
            if (message.qlt != null && Object.hasOwnProperty.call(message, "qlt"))
                $root.pb_hero_qlc.encode(message.qlt, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.price != null && Object.hasOwnProperty.call(message, "price"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.price);
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.type);
            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.status);
            if (message.goodid != null && Object.hasOwnProperty.call(message, "goodid"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.goodid);
            if (message.user != null && Object.hasOwnProperty.call(message, "user"))
                $root.pb_give_role.encode(message.user, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified mall_log message, length delimited. Does not implicitly {@link mall_log.verify|verify} messages.
         * @function encodeDelimited
         * @memberof mall_log
         * @static
         * @param {Imall_log} message mall_log message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        mall_log.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a mall_log message from the specified reader or buffer.
         * @function decode
         * @memberof mall_log
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {mall_log} mall_log
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        mall_log.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.mall_log();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.time = reader.int32();
                        break;
                    }
                case 2: {
                        message.heroid = reader.int32();
                        break;
                    }
                case 3: {
                        message.qlt = $root.pb_hero_qlc.decode(reader, reader.uint32());
                        break;
                    }
                case 4: {
                        message.price = reader.int32();
                        break;
                    }
                case 5: {
                        message.type = reader.int32();
                        break;
                    }
                case 6: {
                        message.status = reader.int32();
                        break;
                    }
                case 7: {
                        message.goodid = reader.int32();
                        break;
                    }
                case 8: {
                        message.user = $root.pb_give_role.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a mall_log message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof mall_log
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {mall_log} mall_log
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        mall_log.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a mall_log message.
         * @function verify
         * @memberof mall_log
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        mall_log.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.time != null && message.hasOwnProperty("time"))
                if (!$util.isInteger(message.time))
                    return "time: integer expected";
            if (message.heroid != null && message.hasOwnProperty("heroid"))
                if (!$util.isInteger(message.heroid))
                    return "heroid: integer expected";
            if (message.qlt != null && message.hasOwnProperty("qlt")) {
                var error = $root.pb_hero_qlc.verify(message.qlt);
                if (error)
                    return "qlt." + error;
            }
            if (message.price != null && message.hasOwnProperty("price"))
                if (!$util.isInteger(message.price))
                    return "price: integer expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isInteger(message.type))
                    return "type: integer expected";
            if (message.status != null && message.hasOwnProperty("status"))
                if (!$util.isInteger(message.status))
                    return "status: integer expected";
            if (message.goodid != null && message.hasOwnProperty("goodid"))
                if (!$util.isInteger(message.goodid))
                    return "goodid: integer expected";
            if (message.user != null && message.hasOwnProperty("user")) {
                var error = $root.pb_give_role.verify(message.user);
                if (error)
                    return "user." + error;
            }
            return null;
        };
    
        /**
         * Creates a mall_log message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof mall_log
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {mall_log} mall_log
         */
        mall_log.fromObject = function fromObject(object) {
            if (object instanceof $root.mall_log)
                return object;
            var message = new $root.mall_log();
            if (object.time != null)
                message.time = object.time | 0;
            if (object.heroid != null)
                message.heroid = object.heroid | 0;
            if (object.qlt != null) {
                if (typeof object.qlt !== "object")
                    throw TypeError(".mall_log.qlt: object expected");
                message.qlt = $root.pb_hero_qlc.fromObject(object.qlt);
            }
            if (object.price != null)
                message.price = object.price | 0;
            if (object.type != null)
                message.type = object.type | 0;
            if (object.status != null)
                message.status = object.status | 0;
            if (object.goodid != null)
                message.goodid = object.goodid | 0;
            if (object.user != null) {
                if (typeof object.user !== "object")
                    throw TypeError(".mall_log.user: object expected");
                message.user = $root.pb_give_role.fromObject(object.user);
            }
            return message;
        };
    
        /**
         * Creates a plain object from a mall_log message. Also converts values to other types if specified.
         * @function toObject
         * @memberof mall_log
         * @static
         * @param {mall_log} message mall_log
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        mall_log.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.time = 0;
                object.heroid = 0;
                object.qlt = null;
                object.price = 0;
                object.type = 0;
                object.status = 0;
                object.goodid = 0;
                object.user = null;
            }
            if (message.time != null && message.hasOwnProperty("time"))
                object.time = message.time;
            if (message.heroid != null && message.hasOwnProperty("heroid"))
                object.heroid = message.heroid;
            if (message.qlt != null && message.hasOwnProperty("qlt"))
                object.qlt = $root.pb_hero_qlc.toObject(message.qlt, options);
            if (message.price != null && message.hasOwnProperty("price"))
                object.price = message.price;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = message.status;
            if (message.goodid != null && message.hasOwnProperty("goodid"))
                object.goodid = message.goodid;
            if (message.user != null && message.hasOwnProperty("user"))
                object.user = $root.pb_give_role.toObject(message.user, options);
            return object;
        };
    
        /**
         * Converts this mall_log to JSON.
         * @function toJSON
         * @memberof mall_log
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        mall_log.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for mall_log
         * @function getTypeUrl
         * @memberof mall_log
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        mall_log.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/mall_log";
        };
    
        return mall_log;
    })();
    
    $root.pb_kv = (function() {
    
        /**
         * Properties of a pb_kv.
         * @exports Ipb_kv
         * @interface Ipb_kv
         * @property {number|null} [k] pb_kv k
         * @property {number|null} [v] pb_kv v
         */
    
        /**
         * Constructs a new pb_kv.
         * @exports pb_kv
         * @classdesc Represents a pb_kv.
         * @implements Ipb_kv
         * @constructor
         * @param {Ipb_kv=} [properties] Properties to set
         */
        function pb_kv(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_kv k.
         * @member {number} k
         * @memberof pb_kv
         * @instance
         */
        pb_kv.prototype.k = 0;
    
        /**
         * pb_kv v.
         * @member {number} v
         * @memberof pb_kv
         * @instance
         */
        pb_kv.prototype.v = 0;
    
        /**
         * Creates a new pb_kv instance using the specified properties.
         * @function create
         * @memberof pb_kv
         * @static
         * @param {Ipb_kv=} [properties] Properties to set
         * @returns {pb_kv} pb_kv instance
         */
        pb_kv.create = function create(properties) {
            return new pb_kv(properties);
        };
    
        /**
         * Encodes the specified pb_kv message. Does not implicitly {@link pb_kv.verify|verify} messages.
         * @function encode
         * @memberof pb_kv
         * @static
         * @param {Ipb_kv} message pb_kv message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_kv.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.k != null && Object.hasOwnProperty.call(message, "k"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.k);
            if (message.v != null && Object.hasOwnProperty.call(message, "v"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.v);
            return writer;
        };
    
        /**
         * Encodes the specified pb_kv message, length delimited. Does not implicitly {@link pb_kv.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_kv
         * @static
         * @param {Ipb_kv} message pb_kv message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_kv.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_kv message from the specified reader or buffer.
         * @function decode
         * @memberof pb_kv
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_kv} pb_kv
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_kv.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_kv();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.k = reader.int32();
                        break;
                    }
                case 2: {
                        message.v = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a pb_kv message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_kv
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_kv} pb_kv
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_kv.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_kv message.
         * @function verify
         * @memberof pb_kv
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_kv.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.k != null && message.hasOwnProperty("k"))
                if (!$util.isInteger(message.k))
                    return "k: integer expected";
            if (message.v != null && message.hasOwnProperty("v"))
                if (!$util.isInteger(message.v))
                    return "v: integer expected";
            return null;
        };
    
        /**
         * Creates a pb_kv message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_kv
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_kv} pb_kv
         */
        pb_kv.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_kv)
                return object;
            var message = new $root.pb_kv();
            if (object.k != null)
                message.k = object.k | 0;
            if (object.v != null)
                message.v = object.v | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a pb_kv message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_kv
         * @static
         * @param {pb_kv} message pb_kv
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_kv.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.k = 0;
                object.v = 0;
            }
            if (message.k != null && message.hasOwnProperty("k"))
                object.k = message.k;
            if (message.v != null && message.hasOwnProperty("v"))
                object.v = message.v;
            return object;
        };
    
        /**
         * Converts this pb_kv to JSON.
         * @function toJSON
         * @memberof pb_kv
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_kv.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_kv
         * @function getTypeUrl
         * @memberof pb_kv
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_kv.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_kv";
        };
    
        return pb_kv;
    })();
    
    $root.pb_kvs = (function() {
    
        /**
         * Properties of a pb_kvs.
         * @exports Ipb_kvs
         * @interface Ipb_kvs
         * @property {Array.<number>|null} [k] pb_kvs k
         * @property {Array.<number>|null} [v] pb_kvs v
         * @property {Array.<number>|null} [v2] pb_kvs v2
         */
    
        /**
         * Constructs a new pb_kvs.
         * @exports pb_kvs
         * @classdesc Represents a pb_kvs.
         * @implements Ipb_kvs
         * @constructor
         * @param {Ipb_kvs=} [properties] Properties to set
         */
        function pb_kvs(properties) {
            this.k = [];
            this.v = [];
            this.v2 = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_kvs k.
         * @member {Array.<number>} k
         * @memberof pb_kvs
         * @instance
         */
        pb_kvs.prototype.k = $util.emptyArray;
    
        /**
         * pb_kvs v.
         * @member {Array.<number>} v
         * @memberof pb_kvs
         * @instance
         */
        pb_kvs.prototype.v = $util.emptyArray;
    
        /**
         * pb_kvs v2.
         * @member {Array.<number>} v2
         * @memberof pb_kvs
         * @instance
         */
        pb_kvs.prototype.v2 = $util.emptyArray;
    
        /**
         * Creates a new pb_kvs instance using the specified properties.
         * @function create
         * @memberof pb_kvs
         * @static
         * @param {Ipb_kvs=} [properties] Properties to set
         * @returns {pb_kvs} pb_kvs instance
         */
        pb_kvs.create = function create(properties) {
            return new pb_kvs(properties);
        };
    
        /**
         * Encodes the specified pb_kvs message. Does not implicitly {@link pb_kvs.verify|verify} messages.
         * @function encode
         * @memberof pb_kvs
         * @static
         * @param {Ipb_kvs} message pb_kvs message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_kvs.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.k != null && message.k.length)
                for (var i = 0; i < message.k.length; ++i)
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.k[i]);
            if (message.v != null && message.v.length)
                for (var i = 0; i < message.v.length; ++i)
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.v[i]);
            if (message.v2 != null && message.v2.length)
                for (var i = 0; i < message.v2.length; ++i)
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.v2[i]);
            return writer;
        };
    
        /**
         * Encodes the specified pb_kvs message, length delimited. Does not implicitly {@link pb_kvs.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_kvs
         * @static
         * @param {Ipb_kvs} message pb_kvs message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_kvs.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_kvs message from the specified reader or buffer.
         * @function decode
         * @memberof pb_kvs
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_kvs} pb_kvs
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_kvs.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_kvs();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.k && message.k.length))
                            message.k = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.k.push(reader.int32());
                        } else
                            message.k.push(reader.int32());
                        break;
                    }
                case 2: {
                        if (!(message.v && message.v.length))
                            message.v = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.v.push(reader.int32());
                        } else
                            message.v.push(reader.int32());
                        break;
                    }
                case 3: {
                        if (!(message.v2 && message.v2.length))
                            message.v2 = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.v2.push(reader.int32());
                        } else
                            message.v2.push(reader.int32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a pb_kvs message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_kvs
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_kvs} pb_kvs
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_kvs.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_kvs message.
         * @function verify
         * @memberof pb_kvs
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_kvs.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.k != null && message.hasOwnProperty("k")) {
                if (!Array.isArray(message.k))
                    return "k: array expected";
                for (var i = 0; i < message.k.length; ++i)
                    if (!$util.isInteger(message.k[i]))
                        return "k: integer[] expected";
            }
            if (message.v != null && message.hasOwnProperty("v")) {
                if (!Array.isArray(message.v))
                    return "v: array expected";
                for (var i = 0; i < message.v.length; ++i)
                    if (!$util.isInteger(message.v[i]))
                        return "v: integer[] expected";
            }
            if (message.v2 != null && message.hasOwnProperty("v2")) {
                if (!Array.isArray(message.v2))
                    return "v2: array expected";
                for (var i = 0; i < message.v2.length; ++i)
                    if (!$util.isInteger(message.v2[i]))
                        return "v2: integer[] expected";
            }
            return null;
        };
    
        /**
         * Creates a pb_kvs message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_kvs
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_kvs} pb_kvs
         */
        pb_kvs.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_kvs)
                return object;
            var message = new $root.pb_kvs();
            if (object.k) {
                if (!Array.isArray(object.k))
                    throw TypeError(".pb_kvs.k: array expected");
                message.k = [];
                for (var i = 0; i < object.k.length; ++i)
                    message.k[i] = object.k[i] | 0;
            }
            if (object.v) {
                if (!Array.isArray(object.v))
                    throw TypeError(".pb_kvs.v: array expected");
                message.v = [];
                for (var i = 0; i < object.v.length; ++i)
                    message.v[i] = object.v[i] | 0;
            }
            if (object.v2) {
                if (!Array.isArray(object.v2))
                    throw TypeError(".pb_kvs.v2: array expected");
                message.v2 = [];
                for (var i = 0; i < object.v2.length; ++i)
                    message.v2[i] = object.v2[i] | 0;
            }
            return message;
        };
    
        /**
         * Creates a plain object from a pb_kvs message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_kvs
         * @static
         * @param {pb_kvs} message pb_kvs
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_kvs.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.k = [];
                object.v = [];
                object.v2 = [];
            }
            if (message.k && message.k.length) {
                object.k = [];
                for (var j = 0; j < message.k.length; ++j)
                    object.k[j] = message.k[j];
            }
            if (message.v && message.v.length) {
                object.v = [];
                for (var j = 0; j < message.v.length; ++j)
                    object.v[j] = message.v[j];
            }
            if (message.v2 && message.v2.length) {
                object.v2 = [];
                for (var j = 0; j < message.v2.length; ++j)
                    object.v2[j] = message.v2[j];
            }
            return object;
        };
    
        /**
         * Converts this pb_kvs to JSON.
         * @function toJSON
         * @memberof pb_kvs
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_kvs.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_kvs
         * @function getTypeUrl
         * @memberof pb_kvs
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_kvs.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_kvs";
        };
    
        return pb_kvs;
    })();
    
    $root.pb_kv2 = (function() {
    
        /**
         * Properties of a pb_kv2.
         * @exports Ipb_kv2
         * @interface Ipb_kv2
         * @property {number|null} [k] pb_kv2 k
         * @property {number|null} [v] pb_kv2 v
         * @property {number|null} [v2] pb_kv2 v2
         */
    
        /**
         * Constructs a new pb_kv2.
         * @exports pb_kv2
         * @classdesc Represents a pb_kv2.
         * @implements Ipb_kv2
         * @constructor
         * @param {Ipb_kv2=} [properties] Properties to set
         */
        function pb_kv2(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_kv2 k.
         * @member {number} k
         * @memberof pb_kv2
         * @instance
         */
        pb_kv2.prototype.k = 0;
    
        /**
         * pb_kv2 v.
         * @member {number} v
         * @memberof pb_kv2
         * @instance
         */
        pb_kv2.prototype.v = 0;
    
        /**
         * pb_kv2 v2.
         * @member {number} v2
         * @memberof pb_kv2
         * @instance
         */
        pb_kv2.prototype.v2 = 0;
    
        /**
         * Creates a new pb_kv2 instance using the specified properties.
         * @function create
         * @memberof pb_kv2
         * @static
         * @param {Ipb_kv2=} [properties] Properties to set
         * @returns {pb_kv2} pb_kv2 instance
         */
        pb_kv2.create = function create(properties) {
            return new pb_kv2(properties);
        };
    
        /**
         * Encodes the specified pb_kv2 message. Does not implicitly {@link pb_kv2.verify|verify} messages.
         * @function encode
         * @memberof pb_kv2
         * @static
         * @param {Ipb_kv2} message pb_kv2 message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_kv2.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.k != null && Object.hasOwnProperty.call(message, "k"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.k);
            if (message.v != null && Object.hasOwnProperty.call(message, "v"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.v);
            if (message.v2 != null && Object.hasOwnProperty.call(message, "v2"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.v2);
            return writer;
        };
    
        /**
         * Encodes the specified pb_kv2 message, length delimited. Does not implicitly {@link pb_kv2.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_kv2
         * @static
         * @param {Ipb_kv2} message pb_kv2 message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_kv2.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_kv2 message from the specified reader or buffer.
         * @function decode
         * @memberof pb_kv2
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_kv2} pb_kv2
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_kv2.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_kv2();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.k = reader.int32();
                        break;
                    }
                case 2: {
                        message.v = reader.int32();
                        break;
                    }
                case 3: {
                        message.v2 = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a pb_kv2 message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_kv2
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_kv2} pb_kv2
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_kv2.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_kv2 message.
         * @function verify
         * @memberof pb_kv2
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_kv2.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.k != null && message.hasOwnProperty("k"))
                if (!$util.isInteger(message.k))
                    return "k: integer expected";
            if (message.v != null && message.hasOwnProperty("v"))
                if (!$util.isInteger(message.v))
                    return "v: integer expected";
            if (message.v2 != null && message.hasOwnProperty("v2"))
                if (!$util.isInteger(message.v2))
                    return "v2: integer expected";
            return null;
        };
    
        /**
         * Creates a pb_kv2 message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_kv2
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_kv2} pb_kv2
         */
        pb_kv2.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_kv2)
                return object;
            var message = new $root.pb_kv2();
            if (object.k != null)
                message.k = object.k | 0;
            if (object.v != null)
                message.v = object.v | 0;
            if (object.v2 != null)
                message.v2 = object.v2 | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a pb_kv2 message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_kv2
         * @static
         * @param {pb_kv2} message pb_kv2
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_kv2.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.k = 0;
                object.v = 0;
                object.v2 = 0;
            }
            if (message.k != null && message.hasOwnProperty("k"))
                object.k = message.k;
            if (message.v != null && message.hasOwnProperty("v"))
                object.v = message.v;
            if (message.v2 != null && message.hasOwnProperty("v2"))
                object.v2 = message.v2;
            return object;
        };
    
        /**
         * Converts this pb_kv2 to JSON.
         * @function toJSON
         * @memberof pb_kv2
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_kv2.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_kv2
         * @function getTypeUrl
         * @memberof pb_kv2
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_kv2.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_kv2";
        };
    
        return pb_kv2;
    })();
    
    $root.pb_growup = (function() {
    
        /**
         * Properties of a pb_growup.
         * @exports Ipb_growup
         * @interface Ipb_growup
         * @property {number|null} [id] pb_growup id
         * @property {number|null} [index] pb_growup index
         * @property {number|null} [claim] pb_growup claim
         */
    
        /**
         * Constructs a new pb_growup.
         * @exports pb_growup
         * @classdesc Represents a pb_growup.
         * @implements Ipb_growup
         * @constructor
         * @param {Ipb_growup=} [properties] Properties to set
         */
        function pb_growup(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_growup id.
         * @member {number} id
         * @memberof pb_growup
         * @instance
         */
        pb_growup.prototype.id = 0;
    
        /**
         * pb_growup index.
         * @member {number} index
         * @memberof pb_growup
         * @instance
         */
        pb_growup.prototype.index = 0;
    
        /**
         * pb_growup claim.
         * @member {number} claim
         * @memberof pb_growup
         * @instance
         */
        pb_growup.prototype.claim = 0;
    
        /**
         * Creates a new pb_growup instance using the specified properties.
         * @function create
         * @memberof pb_growup
         * @static
         * @param {Ipb_growup=} [properties] Properties to set
         * @returns {pb_growup} pb_growup instance
         */
        pb_growup.create = function create(properties) {
            return new pb_growup(properties);
        };
    
        /**
         * Encodes the specified pb_growup message. Does not implicitly {@link pb_growup.verify|verify} messages.
         * @function encode
         * @memberof pb_growup
         * @static
         * @param {Ipb_growup} message pb_growup message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_growup.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.id);
            if (message.index != null && Object.hasOwnProperty.call(message, "index"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.index);
            if (message.claim != null && Object.hasOwnProperty.call(message, "claim"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.claim);
            return writer;
        };
    
        /**
         * Encodes the specified pb_growup message, length delimited. Does not implicitly {@link pb_growup.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_growup
         * @static
         * @param {Ipb_growup} message pb_growup message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_growup.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_growup message from the specified reader or buffer.
         * @function decode
         * @memberof pb_growup
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_growup} pb_growup
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_growup.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_growup();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.id = reader.int32();
                        break;
                    }
                case 2: {
                        message.index = reader.int32();
                        break;
                    }
                case 3: {
                        message.claim = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a pb_growup message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_growup
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_growup} pb_growup
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_growup.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_growup message.
         * @function verify
         * @memberof pb_growup
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_growup.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id))
                    return "id: integer expected";
            if (message.index != null && message.hasOwnProperty("index"))
                if (!$util.isInteger(message.index))
                    return "index: integer expected";
            if (message.claim != null && message.hasOwnProperty("claim"))
                if (!$util.isInteger(message.claim))
                    return "claim: integer expected";
            return null;
        };
    
        /**
         * Creates a pb_growup message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_growup
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_growup} pb_growup
         */
        pb_growup.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_growup)
                return object;
            var message = new $root.pb_growup();
            if (object.id != null)
                message.id = object.id | 0;
            if (object.index != null)
                message.index = object.index | 0;
            if (object.claim != null)
                message.claim = object.claim | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a pb_growup message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_growup
         * @static
         * @param {pb_growup} message pb_growup
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_growup.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = 0;
                object.index = 0;
                object.claim = 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.index != null && message.hasOwnProperty("index"))
                object.index = message.index;
            if (message.claim != null && message.hasOwnProperty("claim"))
                object.claim = message.claim;
            return object;
        };
    
        /**
         * Converts this pb_growup to JSON.
         * @function toJSON
         * @memberof pb_growup
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_growup.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_growup
         * @function getTypeUrl
         * @memberof pb_growup
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_growup.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_growup";
        };
    
        return pb_growup;
    })();
    
    $root.pb_puzzle = (function() {
    
        /**
         * Properties of a pb_puzzle.
         * @exports Ipb_puzzle
         * @interface Ipb_puzzle
         * @property {number|null} [id] pb_puzzle id
         * @property {number|null} [next] pb_puzzle next
         * @property {number|null} [cur] pb_puzzle cur
         * @property {Array.<Ipb_kv>|null} [pos] pb_puzzle pos
         * @property {Array.<number>|null} [bag] pb_puzzle bag
         * @property {number|null} [num] pb_puzzle num
         * @property {number|null} [ring] pb_puzzle ring
         * @property {number|null} [siz] pb_puzzle siz
         */
    
        /**
         * Constructs a new pb_puzzle.
         * @exports pb_puzzle
         * @classdesc Represents a pb_puzzle.
         * @implements Ipb_puzzle
         * @constructor
         * @param {Ipb_puzzle=} [properties] Properties to set
         */
        function pb_puzzle(properties) {
            this.pos = [];
            this.bag = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_puzzle id.
         * @member {number} id
         * @memberof pb_puzzle
         * @instance
         */
        pb_puzzle.prototype.id = 0;
    
        /**
         * pb_puzzle next.
         * @member {number} next
         * @memberof pb_puzzle
         * @instance
         */
        pb_puzzle.prototype.next = 0;
    
        /**
         * pb_puzzle cur.
         * @member {number} cur
         * @memberof pb_puzzle
         * @instance
         */
        pb_puzzle.prototype.cur = 0;
    
        /**
         * pb_puzzle pos.
         * @member {Array.<Ipb_kv>} pos
         * @memberof pb_puzzle
         * @instance
         */
        pb_puzzle.prototype.pos = $util.emptyArray;
    
        /**
         * pb_puzzle bag.
         * @member {Array.<number>} bag
         * @memberof pb_puzzle
         * @instance
         */
        pb_puzzle.prototype.bag = $util.emptyArray;
    
        /**
         * pb_puzzle num.
         * @member {number} num
         * @memberof pb_puzzle
         * @instance
         */
        pb_puzzle.prototype.num = 0;
    
        /**
         * pb_puzzle ring.
         * @member {number} ring
         * @memberof pb_puzzle
         * @instance
         */
        pb_puzzle.prototype.ring = 0;
    
        /**
         * pb_puzzle siz.
         * @member {number} siz
         * @memberof pb_puzzle
         * @instance
         */
        pb_puzzle.prototype.siz = 0;
    
        /**
         * Creates a new pb_puzzle instance using the specified properties.
         * @function create
         * @memberof pb_puzzle
         * @static
         * @param {Ipb_puzzle=} [properties] Properties to set
         * @returns {pb_puzzle} pb_puzzle instance
         */
        pb_puzzle.create = function create(properties) {
            return new pb_puzzle(properties);
        };
    
        /**
         * Encodes the specified pb_puzzle message. Does not implicitly {@link pb_puzzle.verify|verify} messages.
         * @function encode
         * @memberof pb_puzzle
         * @static
         * @param {Ipb_puzzle} message pb_puzzle message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_puzzle.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.id);
            if (message.next != null && Object.hasOwnProperty.call(message, "next"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.next);
            if (message.cur != null && Object.hasOwnProperty.call(message, "cur"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.cur);
            if (message.pos != null && message.pos.length)
                for (var i = 0; i < message.pos.length; ++i)
                    $root.pb_kv.encode(message.pos[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.bag != null && message.bag.length)
                for (var i = 0; i < message.bag.length; ++i)
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.bag[i]);
            if (message.num != null && Object.hasOwnProperty.call(message, "num"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.num);
            if (message.ring != null && Object.hasOwnProperty.call(message, "ring"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.ring);
            if (message.siz != null && Object.hasOwnProperty.call(message, "siz"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.siz);
            return writer;
        };
    
        /**
         * Encodes the specified pb_puzzle message, length delimited. Does not implicitly {@link pb_puzzle.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_puzzle
         * @static
         * @param {Ipb_puzzle} message pb_puzzle message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_puzzle.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_puzzle message from the specified reader or buffer.
         * @function decode
         * @memberof pb_puzzle
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_puzzle} pb_puzzle
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_puzzle.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_puzzle();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.id = reader.int32();
                        break;
                    }
                case 2: {
                        message.next = reader.int32();
                        break;
                    }
                case 3: {
                        message.cur = reader.int32();
                        break;
                    }
                case 4: {
                        if (!(message.pos && message.pos.length))
                            message.pos = [];
                        message.pos.push($root.pb_kv.decode(reader, reader.uint32()));
                        break;
                    }
                case 5: {
                        if (!(message.bag && message.bag.length))
                            message.bag = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.bag.push(reader.int32());
                        } else
                            message.bag.push(reader.int32());
                        break;
                    }
                case 6: {
                        message.num = reader.int32();
                        break;
                    }
                case 7: {
                        message.ring = reader.int32();
                        break;
                    }
                case 8: {
                        message.siz = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a pb_puzzle message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_puzzle
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_puzzle} pb_puzzle
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_puzzle.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_puzzle message.
         * @function verify
         * @memberof pb_puzzle
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_puzzle.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id))
                    return "id: integer expected";
            if (message.next != null && message.hasOwnProperty("next"))
                if (!$util.isInteger(message.next))
                    return "next: integer expected";
            if (message.cur != null && message.hasOwnProperty("cur"))
                if (!$util.isInteger(message.cur))
                    return "cur: integer expected";
            if (message.pos != null && message.hasOwnProperty("pos")) {
                if (!Array.isArray(message.pos))
                    return "pos: array expected";
                for (var i = 0; i < message.pos.length; ++i) {
                    var error = $root.pb_kv.verify(message.pos[i]);
                    if (error)
                        return "pos." + error;
                }
            }
            if (message.bag != null && message.hasOwnProperty("bag")) {
                if (!Array.isArray(message.bag))
                    return "bag: array expected";
                for (var i = 0; i < message.bag.length; ++i)
                    if (!$util.isInteger(message.bag[i]))
                        return "bag: integer[] expected";
            }
            if (message.num != null && message.hasOwnProperty("num"))
                if (!$util.isInteger(message.num))
                    return "num: integer expected";
            if (message.ring != null && message.hasOwnProperty("ring"))
                if (!$util.isInteger(message.ring))
                    return "ring: integer expected";
            if (message.siz != null && message.hasOwnProperty("siz"))
                if (!$util.isInteger(message.siz))
                    return "siz: integer expected";
            return null;
        };
    
        /**
         * Creates a pb_puzzle message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_puzzle
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_puzzle} pb_puzzle
         */
        pb_puzzle.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_puzzle)
                return object;
            var message = new $root.pb_puzzle();
            if (object.id != null)
                message.id = object.id | 0;
            if (object.next != null)
                message.next = object.next | 0;
            if (object.cur != null)
                message.cur = object.cur | 0;
            if (object.pos) {
                if (!Array.isArray(object.pos))
                    throw TypeError(".pb_puzzle.pos: array expected");
                message.pos = [];
                for (var i = 0; i < object.pos.length; ++i) {
                    if (typeof object.pos[i] !== "object")
                        throw TypeError(".pb_puzzle.pos: object expected");
                    message.pos[i] = $root.pb_kv.fromObject(object.pos[i]);
                }
            }
            if (object.bag) {
                if (!Array.isArray(object.bag))
                    throw TypeError(".pb_puzzle.bag: array expected");
                message.bag = [];
                for (var i = 0; i < object.bag.length; ++i)
                    message.bag[i] = object.bag[i] | 0;
            }
            if (object.num != null)
                message.num = object.num | 0;
            if (object.ring != null)
                message.ring = object.ring | 0;
            if (object.siz != null)
                message.siz = object.siz | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a pb_puzzle message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_puzzle
         * @static
         * @param {pb_puzzle} message pb_puzzle
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_puzzle.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.pos = [];
                object.bag = [];
            }
            if (options.defaults) {
                object.id = 0;
                object.next = 0;
                object.cur = 0;
                object.num = 0;
                object.ring = 0;
                object.siz = 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.next != null && message.hasOwnProperty("next"))
                object.next = message.next;
            if (message.cur != null && message.hasOwnProperty("cur"))
                object.cur = message.cur;
            if (message.pos && message.pos.length) {
                object.pos = [];
                for (var j = 0; j < message.pos.length; ++j)
                    object.pos[j] = $root.pb_kv.toObject(message.pos[j], options);
            }
            if (message.bag && message.bag.length) {
                object.bag = [];
                for (var j = 0; j < message.bag.length; ++j)
                    object.bag[j] = message.bag[j];
            }
            if (message.num != null && message.hasOwnProperty("num"))
                object.num = message.num;
            if (message.ring != null && message.hasOwnProperty("ring"))
                object.ring = message.ring;
            if (message.siz != null && message.hasOwnProperty("siz"))
                object.siz = message.siz;
            return object;
        };
    
        /**
         * Converts this pb_puzzle to JSON.
         * @function toJSON
         * @memberof pb_puzzle
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_puzzle.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_puzzle
         * @function getTypeUrl
         * @memberof pb_puzzle
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_puzzle.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_puzzle";
        };
    
        return pb_puzzle;
    })();
    
    $root.pb_give_role = (function() {
    
        /**
         * Properties of a pb_give_role.
         * @exports Ipb_give_role
         * @interface Ipb_give_role
         * @property {number|Long} uid64 pb_give_role uid64
         * @property {string} channel pb_give_role channel
         * @property {number} lv pb_give_role lv
         * @property {number|null} [lbox] pb_give_role lbox
         * @property {string} name pb_give_role name
         * @property {number} logo pb_give_role logo
         */
    
        /**
         * Constructs a new pb_give_role.
         * @exports pb_give_role
         * @classdesc Represents a pb_give_role.
         * @implements Ipb_give_role
         * @constructor
         * @param {Ipb_give_role=} [properties] Properties to set
         */
        function pb_give_role(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_give_role uid64.
         * @member {number|Long} uid64
         * @memberof pb_give_role
         * @instance
         */
        pb_give_role.prototype.uid64 = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * pb_give_role channel.
         * @member {string} channel
         * @memberof pb_give_role
         * @instance
         */
        pb_give_role.prototype.channel = "";
    
        /**
         * pb_give_role lv.
         * @member {number} lv
         * @memberof pb_give_role
         * @instance
         */
        pb_give_role.prototype.lv = 0;
    
        /**
         * pb_give_role lbox.
         * @member {number} lbox
         * @memberof pb_give_role
         * @instance
         */
        pb_give_role.prototype.lbox = 0;
    
        /**
         * pb_give_role name.
         * @member {string} name
         * @memberof pb_give_role
         * @instance
         */
        pb_give_role.prototype.name = "";
    
        /**
         * pb_give_role logo.
         * @member {number} logo
         * @memberof pb_give_role
         * @instance
         */
        pb_give_role.prototype.logo = 0;
    
        /**
         * Creates a new pb_give_role instance using the specified properties.
         * @function create
         * @memberof pb_give_role
         * @static
         * @param {Ipb_give_role=} [properties] Properties to set
         * @returns {pb_give_role} pb_give_role instance
         */
        pb_give_role.create = function create(properties) {
            return new pb_give_role(properties);
        };
    
        /**
         * Encodes the specified pb_give_role message. Does not implicitly {@link pb_give_role.verify|verify} messages.
         * @function encode
         * @memberof pb_give_role
         * @static
         * @param {Ipb_give_role} message pb_give_role message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_give_role.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int64(message.uid64);
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.channel);
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.lv);
            if (message.lbox != null && Object.hasOwnProperty.call(message, "lbox"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.lbox);
            writer.uint32(/* id 5, wireType 2 =*/42).string(message.name);
            writer.uint32(/* id 6, wireType 0 =*/48).int32(message.logo);
            return writer;
        };
    
        /**
         * Encodes the specified pb_give_role message, length delimited. Does not implicitly {@link pb_give_role.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_give_role
         * @static
         * @param {Ipb_give_role} message pb_give_role message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_give_role.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_give_role message from the specified reader or buffer.
         * @function decode
         * @memberof pb_give_role
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_give_role} pb_give_role
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_give_role.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_give_role();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.uid64 = reader.int64();
                        break;
                    }
                case 2: {
                        message.channel = reader.string();
                        break;
                    }
                case 3: {
                        message.lv = reader.int32();
                        break;
                    }
                case 4: {
                        message.lbox = reader.int32();
                        break;
                    }
                case 5: {
                        message.name = reader.string();
                        break;
                    }
                case 6: {
                        message.logo = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("uid64"))
                throw $util.ProtocolError("missing required 'uid64'", { instance: message });
            if (!message.hasOwnProperty("channel"))
                throw $util.ProtocolError("missing required 'channel'", { instance: message });
            if (!message.hasOwnProperty("lv"))
                throw $util.ProtocolError("missing required 'lv'", { instance: message });
            if (!message.hasOwnProperty("name"))
                throw $util.ProtocolError("missing required 'name'", { instance: message });
            if (!message.hasOwnProperty("logo"))
                throw $util.ProtocolError("missing required 'logo'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a pb_give_role message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_give_role
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_give_role} pb_give_role
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_give_role.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_give_role message.
         * @function verify
         * @memberof pb_give_role
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_give_role.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.uid64) && !(message.uid64 && $util.isInteger(message.uid64.low) && $util.isInteger(message.uid64.high)))
                return "uid64: integer|Long expected";
            if (!$util.isString(message.channel))
                return "channel: string expected";
            if (!$util.isInteger(message.lv))
                return "lv: integer expected";
            if (message.lbox != null && message.hasOwnProperty("lbox"))
                if (!$util.isInteger(message.lbox))
                    return "lbox: integer expected";
            if (!$util.isString(message.name))
                return "name: string expected";
            if (!$util.isInteger(message.logo))
                return "logo: integer expected";
            return null;
        };
    
        /**
         * Creates a pb_give_role message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_give_role
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_give_role} pb_give_role
         */
        pb_give_role.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_give_role)
                return object;
            var message = new $root.pb_give_role();
            if (object.uid64 != null)
                if ($util.Long)
                    (message.uid64 = $util.Long.fromValue(object.uid64)).unsigned = false;
                else if (typeof object.uid64 === "string")
                    message.uid64 = parseInt(object.uid64, 10);
                else if (typeof object.uid64 === "number")
                    message.uid64 = object.uid64;
                else if (typeof object.uid64 === "object")
                    message.uid64 = new $util.LongBits(object.uid64.low >>> 0, object.uid64.high >>> 0).toNumber();
            if (object.channel != null)
                message.channel = String(object.channel);
            if (object.lv != null)
                message.lv = object.lv | 0;
            if (object.lbox != null)
                message.lbox = object.lbox | 0;
            if (object.name != null)
                message.name = String(object.name);
            if (object.logo != null)
                message.logo = object.logo | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a pb_give_role message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_give_role
         * @static
         * @param {pb_give_role} message pb_give_role
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_give_role.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.uid64 = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.uid64 = options.longs === String ? "0" : 0;
                object.channel = "";
                object.lv = 0;
                object.lbox = 0;
                object.name = "";
                object.logo = 0;
            }
            if (message.uid64 != null && message.hasOwnProperty("uid64"))
                if (typeof message.uid64 === "number")
                    object.uid64 = options.longs === String ? String(message.uid64) : message.uid64;
                else
                    object.uid64 = options.longs === String ? $util.Long.prototype.toString.call(message.uid64) : options.longs === Number ? new $util.LongBits(message.uid64.low >>> 0, message.uid64.high >>> 0).toNumber() : message.uid64;
            if (message.channel != null && message.hasOwnProperty("channel"))
                object.channel = message.channel;
            if (message.lv != null && message.hasOwnProperty("lv"))
                object.lv = message.lv;
            if (message.lbox != null && message.hasOwnProperty("lbox"))
                object.lbox = message.lbox;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.logo != null && message.hasOwnProperty("logo"))
                object.logo = message.logo;
            return object;
        };
    
        /**
         * Converts this pb_give_role to JSON.
         * @function toJSON
         * @memberof pb_give_role
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_give_role.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_give_role
         * @function getTypeUrl
         * @memberof pb_give_role
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_give_role.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_give_role";
        };
    
        return pb_give_role;
    })();
    
    $root.pb_give_order = (function() {
    
        /**
         * Properties of a pb_give_order.
         * @exports Ipb_give_order
         * @interface Ipb_give_order
         * @property {number|Long|null} [id] pb_give_order id
         * @property {number|null} [type] pb_give_order type
         * @property {number|null} [num] pb_give_order num
         * @property {number|null} [status] pb_give_order status
         * @property {Ipb_give_role|null} [role] pb_give_order role
         * @property {number|null} [cd] pb_give_order cd
         */
    
        /**
         * Constructs a new pb_give_order.
         * @exports pb_give_order
         * @classdesc Represents a pb_give_order.
         * @implements Ipb_give_order
         * @constructor
         * @param {Ipb_give_order=} [properties] Properties to set
         */
        function pb_give_order(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_give_order id.
         * @member {number|Long} id
         * @memberof pb_give_order
         * @instance
         */
        pb_give_order.prototype.id = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * pb_give_order type.
         * @member {number} type
         * @memberof pb_give_order
         * @instance
         */
        pb_give_order.prototype.type = 0;
    
        /**
         * pb_give_order num.
         * @member {number} num
         * @memberof pb_give_order
         * @instance
         */
        pb_give_order.prototype.num = 0;
    
        /**
         * pb_give_order status.
         * @member {number} status
         * @memberof pb_give_order
         * @instance
         */
        pb_give_order.prototype.status = 0;
    
        /**
         * pb_give_order role.
         * @member {Ipb_give_role|null|undefined} role
         * @memberof pb_give_order
         * @instance
         */
        pb_give_order.prototype.role = null;
    
        /**
         * pb_give_order cd.
         * @member {number} cd
         * @memberof pb_give_order
         * @instance
         */
        pb_give_order.prototype.cd = 0;
    
        /**
         * Creates a new pb_give_order instance using the specified properties.
         * @function create
         * @memberof pb_give_order
         * @static
         * @param {Ipb_give_order=} [properties] Properties to set
         * @returns {pb_give_order} pb_give_order instance
         */
        pb_give_order.create = function create(properties) {
            return new pb_give_order(properties);
        };
    
        /**
         * Encodes the specified pb_give_order message. Does not implicitly {@link pb_give_order.verify|verify} messages.
         * @function encode
         * @memberof pb_give_order
         * @static
         * @param {Ipb_give_order} message pb_give_order message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_give_order.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.id);
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.type);
            if (message.num != null && Object.hasOwnProperty.call(message, "num"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.num);
            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.status);
            if (message.role != null && Object.hasOwnProperty.call(message, "role"))
                $root.pb_give_role.encode(message.role, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.cd != null && Object.hasOwnProperty.call(message, "cd"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.cd);
            return writer;
        };
    
        /**
         * Encodes the specified pb_give_order message, length delimited. Does not implicitly {@link pb_give_order.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_give_order
         * @static
         * @param {Ipb_give_order} message pb_give_order message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_give_order.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_give_order message from the specified reader or buffer.
         * @function decode
         * @memberof pb_give_order
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_give_order} pb_give_order
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_give_order.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_give_order();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.id = reader.int64();
                        break;
                    }
                case 2: {
                        message.type = reader.uint32();
                        break;
                    }
                case 3: {
                        message.num = reader.int32();
                        break;
                    }
                case 4: {
                        message.status = reader.uint32();
                        break;
                    }
                case 5: {
                        message.role = $root.pb_give_role.decode(reader, reader.uint32());
                        break;
                    }
                case 6: {
                        message.cd = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a pb_give_order message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_give_order
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_give_order} pb_give_order
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_give_order.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_give_order message.
         * @function verify
         * @memberof pb_give_order
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_give_order.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                    return "id: integer|Long expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isInteger(message.type))
                    return "type: integer expected";
            if (message.num != null && message.hasOwnProperty("num"))
                if (!$util.isInteger(message.num))
                    return "num: integer expected";
            if (message.status != null && message.hasOwnProperty("status"))
                if (!$util.isInteger(message.status))
                    return "status: integer expected";
            if (message.role != null && message.hasOwnProperty("role")) {
                var error = $root.pb_give_role.verify(message.role);
                if (error)
                    return "role." + error;
            }
            if (message.cd != null && message.hasOwnProperty("cd"))
                if (!$util.isInteger(message.cd))
                    return "cd: integer expected";
            return null;
        };
    
        /**
         * Creates a pb_give_order message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_give_order
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_give_order} pb_give_order
         */
        pb_give_order.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_give_order)
                return object;
            var message = new $root.pb_give_order();
            if (object.id != null)
                if ($util.Long)
                    (message.id = $util.Long.fromValue(object.id)).unsigned = false;
                else if (typeof object.id === "string")
                    message.id = parseInt(object.id, 10);
                else if (typeof object.id === "number")
                    message.id = object.id;
                else if (typeof object.id === "object")
                    message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber();
            if (object.type != null)
                message.type = object.type >>> 0;
            if (object.num != null)
                message.num = object.num | 0;
            if (object.status != null)
                message.status = object.status >>> 0;
            if (object.role != null) {
                if (typeof object.role !== "object")
                    throw TypeError(".pb_give_order.role: object expected");
                message.role = $root.pb_give_role.fromObject(object.role);
            }
            if (object.cd != null)
                message.cd = object.cd | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a pb_give_order message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_give_order
         * @static
         * @param {pb_give_order} message pb_give_order
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_give_order.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.id = options.longs === String ? "0" : 0;
                object.type = 0;
                object.num = 0;
                object.status = 0;
                object.role = null;
                object.cd = 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                if (typeof message.id === "number")
                    object.id = options.longs === String ? String(message.id) : message.id;
                else
                    object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber() : message.id;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            if (message.num != null && message.hasOwnProperty("num"))
                object.num = message.num;
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = message.status;
            if (message.role != null && message.hasOwnProperty("role"))
                object.role = $root.pb_give_role.toObject(message.role, options);
            if (message.cd != null && message.hasOwnProperty("cd"))
                object.cd = message.cd;
            return object;
        };
    
        /**
         * Converts this pb_give_order to JSON.
         * @function toJSON
         * @memberof pb_give_order
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_give_order.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_give_order
         * @function getTypeUrl
         * @memberof pb_give_order
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_give_order.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_give_order";
        };
    
        return pb_give_order;
    })();
    
    $root.pb_give_log = (function() {
    
        /**
         * Properties of a pb_give_log.
         * @exports Ipb_give_log
         * @interface Ipb_give_log
         * @property {string|null} [name] pb_give_log name
         * @property {number|null} [num] pb_give_log num
         * @property {number|null} [tax] pb_give_log tax
         * @property {number|Long|null} [time] pb_give_log time
         */
    
        /**
         * Constructs a new pb_give_log.
         * @exports pb_give_log
         * @classdesc Represents a pb_give_log.
         * @implements Ipb_give_log
         * @constructor
         * @param {Ipb_give_log=} [properties] Properties to set
         */
        function pb_give_log(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_give_log name.
         * @member {string} name
         * @memberof pb_give_log
         * @instance
         */
        pb_give_log.prototype.name = "";
    
        /**
         * pb_give_log num.
         * @member {number} num
         * @memberof pb_give_log
         * @instance
         */
        pb_give_log.prototype.num = 0;
    
        /**
         * pb_give_log tax.
         * @member {number} tax
         * @memberof pb_give_log
         * @instance
         */
        pb_give_log.prototype.tax = 0;
    
        /**
         * pb_give_log time.
         * @member {number|Long} time
         * @memberof pb_give_log
         * @instance
         */
        pb_give_log.prototype.time = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * Creates a new pb_give_log instance using the specified properties.
         * @function create
         * @memberof pb_give_log
         * @static
         * @param {Ipb_give_log=} [properties] Properties to set
         * @returns {pb_give_log} pb_give_log instance
         */
        pb_give_log.create = function create(properties) {
            return new pb_give_log(properties);
        };
    
        /**
         * Encodes the specified pb_give_log message. Does not implicitly {@link pb_give_log.verify|verify} messages.
         * @function encode
         * @memberof pb_give_log
         * @static
         * @param {Ipb_give_log} message pb_give_log message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_give_log.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
            if (message.num != null && Object.hasOwnProperty.call(message, "num"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.num);
            if (message.tax != null && Object.hasOwnProperty.call(message, "tax"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.tax);
            if (message.time != null && Object.hasOwnProperty.call(message, "time"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.time);
            return writer;
        };
    
        /**
         * Encodes the specified pb_give_log message, length delimited. Does not implicitly {@link pb_give_log.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_give_log
         * @static
         * @param {Ipb_give_log} message pb_give_log message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_give_log.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_give_log message from the specified reader or buffer.
         * @function decode
         * @memberof pb_give_log
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_give_log} pb_give_log
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_give_log.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_give_log();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.name = reader.string();
                        break;
                    }
                case 2: {
                        message.num = reader.int32();
                        break;
                    }
                case 3: {
                        message.tax = reader.int32();
                        break;
                    }
                case 4: {
                        message.time = reader.int64();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a pb_give_log message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_give_log
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_give_log} pb_give_log
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_give_log.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_give_log message.
         * @function verify
         * @memberof pb_give_log
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_give_log.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.num != null && message.hasOwnProperty("num"))
                if (!$util.isInteger(message.num))
                    return "num: integer expected";
            if (message.tax != null && message.hasOwnProperty("tax"))
                if (!$util.isInteger(message.tax))
                    return "tax: integer expected";
            if (message.time != null && message.hasOwnProperty("time"))
                if (!$util.isInteger(message.time) && !(message.time && $util.isInteger(message.time.low) && $util.isInteger(message.time.high)))
                    return "time: integer|Long expected";
            return null;
        };
    
        /**
         * Creates a pb_give_log message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_give_log
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_give_log} pb_give_log
         */
        pb_give_log.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_give_log)
                return object;
            var message = new $root.pb_give_log();
            if (object.name != null)
                message.name = String(object.name);
            if (object.num != null)
                message.num = object.num | 0;
            if (object.tax != null)
                message.tax = object.tax | 0;
            if (object.time != null)
                if ($util.Long)
                    (message.time = $util.Long.fromValue(object.time)).unsigned = false;
                else if (typeof object.time === "string")
                    message.time = parseInt(object.time, 10);
                else if (typeof object.time === "number")
                    message.time = object.time;
                else if (typeof object.time === "object")
                    message.time = new $util.LongBits(object.time.low >>> 0, object.time.high >>> 0).toNumber();
            return message;
        };
    
        /**
         * Creates a plain object from a pb_give_log message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_give_log
         * @static
         * @param {pb_give_log} message pb_give_log
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_give_log.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.name = "";
                object.num = 0;
                object.tax = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.time = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.time = options.longs === String ? "0" : 0;
            }
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.num != null && message.hasOwnProperty("num"))
                object.num = message.num;
            if (message.tax != null && message.hasOwnProperty("tax"))
                object.tax = message.tax;
            if (message.time != null && message.hasOwnProperty("time"))
                if (typeof message.time === "number")
                    object.time = options.longs === String ? String(message.time) : message.time;
                else
                    object.time = options.longs === String ? $util.Long.prototype.toString.call(message.time) : options.longs === Number ? new $util.LongBits(message.time.low >>> 0, message.time.high >>> 0).toNumber() : message.time;
            return object;
        };
    
        /**
         * Converts this pb_give_log to JSON.
         * @function toJSON
         * @memberof pb_give_log
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_give_log.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_give_log
         * @function getTypeUrl
         * @memberof pb_give_log
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_give_log.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_give_log";
        };
    
        return pb_give_log;
    })();
    
    $root.pb_qlt_pvp_enemy = (function() {
    
        /**
         * Properties of a pb_qlt_pvp_enemy.
         * @exports Ipb_qlt_pvp_enemy
         * @interface Ipb_qlt_pvp_enemy
         * @property {number|null} [idx] pb_qlt_pvp_enemy idx
         * @property {number|null} [logo] pb_qlt_pvp_enemy logo
         * @property {string|null} [name] pb_qlt_pvp_enemy name
         * @property {string|null} [cluster] pb_qlt_pvp_enemy cluster
         * @property {number|null} [lv] pb_qlt_pvp_enemy lv
         * @property {number|null} [lbox] pb_qlt_pvp_enemy lbox
         * @property {Array.<Ipb_unit>|null} [camp] pb_qlt_pvp_enemy camp
         * @property {Array.<number>|null} [skls] pb_qlt_pvp_enemy skls
         * @property {Array.<number>|null} [hide] pb_qlt_pvp_enemy hide
         * @property {number|Long|null} [uid] pb_qlt_pvp_enemy uid
         * @property {number|Long|null} [power] pb_qlt_pvp_enemy power
         * @property {number|null} [isFight] pb_qlt_pvp_enemy isFight
         * @property {string|null} [gname] pb_qlt_pvp_enemy gname
         */
    
        /**
         * Constructs a new pb_qlt_pvp_enemy.
         * @exports pb_qlt_pvp_enemy
         * @classdesc Represents a pb_qlt_pvp_enemy.
         * @implements Ipb_qlt_pvp_enemy
         * @constructor
         * @param {Ipb_qlt_pvp_enemy=} [properties] Properties to set
         */
        function pb_qlt_pvp_enemy(properties) {
            this.camp = [];
            this.skls = [];
            this.hide = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_qlt_pvp_enemy idx.
         * @member {number} idx
         * @memberof pb_qlt_pvp_enemy
         * @instance
         */
        pb_qlt_pvp_enemy.prototype.idx = 0;
    
        /**
         * pb_qlt_pvp_enemy logo.
         * @member {number} logo
         * @memberof pb_qlt_pvp_enemy
         * @instance
         */
        pb_qlt_pvp_enemy.prototype.logo = 0;
    
        /**
         * pb_qlt_pvp_enemy name.
         * @member {string} name
         * @memberof pb_qlt_pvp_enemy
         * @instance
         */
        pb_qlt_pvp_enemy.prototype.name = "";
    
        /**
         * pb_qlt_pvp_enemy cluster.
         * @member {string} cluster
         * @memberof pb_qlt_pvp_enemy
         * @instance
         */
        pb_qlt_pvp_enemy.prototype.cluster = "";
    
        /**
         * pb_qlt_pvp_enemy lv.
         * @member {number} lv
         * @memberof pb_qlt_pvp_enemy
         * @instance
         */
        pb_qlt_pvp_enemy.prototype.lv = 0;
    
        /**
         * pb_qlt_pvp_enemy lbox.
         * @member {number} lbox
         * @memberof pb_qlt_pvp_enemy
         * @instance
         */
        pb_qlt_pvp_enemy.prototype.lbox = 0;
    
        /**
         * pb_qlt_pvp_enemy camp.
         * @member {Array.<Ipb_unit>} camp
         * @memberof pb_qlt_pvp_enemy
         * @instance
         */
        pb_qlt_pvp_enemy.prototype.camp = $util.emptyArray;
    
        /**
         * pb_qlt_pvp_enemy skls.
         * @member {Array.<number>} skls
         * @memberof pb_qlt_pvp_enemy
         * @instance
         */
        pb_qlt_pvp_enemy.prototype.skls = $util.emptyArray;
    
        /**
         * pb_qlt_pvp_enemy hide.
         * @member {Array.<number>} hide
         * @memberof pb_qlt_pvp_enemy
         * @instance
         */
        pb_qlt_pvp_enemy.prototype.hide = $util.emptyArray;
    
        /**
         * pb_qlt_pvp_enemy uid.
         * @member {number|Long} uid
         * @memberof pb_qlt_pvp_enemy
         * @instance
         */
        pb_qlt_pvp_enemy.prototype.uid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * pb_qlt_pvp_enemy power.
         * @member {number|Long} power
         * @memberof pb_qlt_pvp_enemy
         * @instance
         */
        pb_qlt_pvp_enemy.prototype.power = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * pb_qlt_pvp_enemy isFight.
         * @member {number} isFight
         * @memberof pb_qlt_pvp_enemy
         * @instance
         */
        pb_qlt_pvp_enemy.prototype.isFight = 0;
    
        /**
         * pb_qlt_pvp_enemy gname.
         * @member {string} gname
         * @memberof pb_qlt_pvp_enemy
         * @instance
         */
        pb_qlt_pvp_enemy.prototype.gname = "";
    
        /**
         * Creates a new pb_qlt_pvp_enemy instance using the specified properties.
         * @function create
         * @memberof pb_qlt_pvp_enemy
         * @static
         * @param {Ipb_qlt_pvp_enemy=} [properties] Properties to set
         * @returns {pb_qlt_pvp_enemy} pb_qlt_pvp_enemy instance
         */
        pb_qlt_pvp_enemy.create = function create(properties) {
            return new pb_qlt_pvp_enemy(properties);
        };
    
        /**
         * Encodes the specified pb_qlt_pvp_enemy message. Does not implicitly {@link pb_qlt_pvp_enemy.verify|verify} messages.
         * @function encode
         * @memberof pb_qlt_pvp_enemy
         * @static
         * @param {Ipb_qlt_pvp_enemy} message pb_qlt_pvp_enemy message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_qlt_pvp_enemy.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.idx != null && Object.hasOwnProperty.call(message, "idx"))
                writer.uint32(/* id 1, wireType 0 =*/8).sint32(message.idx);
            if (message.logo != null && Object.hasOwnProperty.call(message, "logo"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.logo);
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.name);
            if (message.cluster != null && Object.hasOwnProperty.call(message, "cluster"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.cluster);
            if (message.lv != null && Object.hasOwnProperty.call(message, "lv"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.lv);
            if (message.lbox != null && Object.hasOwnProperty.call(message, "lbox"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.lbox);
            if (message.camp != null && message.camp.length)
                for (var i = 0; i < message.camp.length; ++i)
                    $root.pb_unit.encode(message.camp[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.skls != null && message.skls.length)
                for (var i = 0; i < message.skls.length; ++i)
                    writer.uint32(/* id 8, wireType 0 =*/64).sint32(message.skls[i]);
            if (message.hide != null && message.hide.length)
                for (var i = 0; i < message.hide.length; ++i)
                    writer.uint32(/* id 9, wireType 0 =*/72).sint32(message.hide[i]);
            if (message.uid != null && Object.hasOwnProperty.call(message, "uid"))
                writer.uint32(/* id 10, wireType 0 =*/80).int64(message.uid);
            if (message.power != null && Object.hasOwnProperty.call(message, "power"))
                writer.uint32(/* id 11, wireType 0 =*/88).int64(message.power);
            if (message.isFight != null && Object.hasOwnProperty.call(message, "isFight"))
                writer.uint32(/* id 12, wireType 0 =*/96).int32(message.isFight);
            if (message.gname != null && Object.hasOwnProperty.call(message, "gname"))
                writer.uint32(/* id 13, wireType 2 =*/106).string(message.gname);
            return writer;
        };
    
        /**
         * Encodes the specified pb_qlt_pvp_enemy message, length delimited. Does not implicitly {@link pb_qlt_pvp_enemy.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_qlt_pvp_enemy
         * @static
         * @param {Ipb_qlt_pvp_enemy} message pb_qlt_pvp_enemy message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_qlt_pvp_enemy.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_qlt_pvp_enemy message from the specified reader or buffer.
         * @function decode
         * @memberof pb_qlt_pvp_enemy
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_qlt_pvp_enemy} pb_qlt_pvp_enemy
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_qlt_pvp_enemy.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_qlt_pvp_enemy();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.idx = reader.sint32();
                        break;
                    }
                case 2: {
                        message.logo = reader.int32();
                        break;
                    }
                case 3: {
                        message.name = reader.string();
                        break;
                    }
                case 4: {
                        message.cluster = reader.string();
                        break;
                    }
                case 5: {
                        message.lv = reader.int32();
                        break;
                    }
                case 6: {
                        message.lbox = reader.int32();
                        break;
                    }
                case 7: {
                        if (!(message.camp && message.camp.length))
                            message.camp = [];
                        message.camp.push($root.pb_unit.decode(reader, reader.uint32()));
                        break;
                    }
                case 8: {
                        if (!(message.skls && message.skls.length))
                            message.skls = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.skls.push(reader.sint32());
                        } else
                            message.skls.push(reader.sint32());
                        break;
                    }
                case 9: {
                        if (!(message.hide && message.hide.length))
                            message.hide = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.hide.push(reader.sint32());
                        } else
                            message.hide.push(reader.sint32());
                        break;
                    }
                case 10: {
                        message.uid = reader.int64();
                        break;
                    }
                case 11: {
                        message.power = reader.int64();
                        break;
                    }
                case 12: {
                        message.isFight = reader.int32();
                        break;
                    }
                case 13: {
                        message.gname = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a pb_qlt_pvp_enemy message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_qlt_pvp_enemy
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_qlt_pvp_enemy} pb_qlt_pvp_enemy
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_qlt_pvp_enemy.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_qlt_pvp_enemy message.
         * @function verify
         * @memberof pb_qlt_pvp_enemy
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_qlt_pvp_enemy.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.idx != null && message.hasOwnProperty("idx"))
                if (!$util.isInteger(message.idx))
                    return "idx: integer expected";
            if (message.logo != null && message.hasOwnProperty("logo"))
                if (!$util.isInteger(message.logo))
                    return "logo: integer expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.cluster != null && message.hasOwnProperty("cluster"))
                if (!$util.isString(message.cluster))
                    return "cluster: string expected";
            if (message.lv != null && message.hasOwnProperty("lv"))
                if (!$util.isInteger(message.lv))
                    return "lv: integer expected";
            if (message.lbox != null && message.hasOwnProperty("lbox"))
                if (!$util.isInteger(message.lbox))
                    return "lbox: integer expected";
            if (message.camp != null && message.hasOwnProperty("camp")) {
                if (!Array.isArray(message.camp))
                    return "camp: array expected";
                for (var i = 0; i < message.camp.length; ++i) {
                    var error = $root.pb_unit.verify(message.camp[i]);
                    if (error)
                        return "camp." + error;
                }
            }
            if (message.skls != null && message.hasOwnProperty("skls")) {
                if (!Array.isArray(message.skls))
                    return "skls: array expected";
                for (var i = 0; i < message.skls.length; ++i)
                    if (!$util.isInteger(message.skls[i]))
                        return "skls: integer[] expected";
            }
            if (message.hide != null && message.hasOwnProperty("hide")) {
                if (!Array.isArray(message.hide))
                    return "hide: array expected";
                for (var i = 0; i < message.hide.length; ++i)
                    if (!$util.isInteger(message.hide[i]))
                        return "hide: integer[] expected";
            }
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (!$util.isInteger(message.uid) && !(message.uid && $util.isInteger(message.uid.low) && $util.isInteger(message.uid.high)))
                    return "uid: integer|Long expected";
            if (message.power != null && message.hasOwnProperty("power"))
                if (!$util.isInteger(message.power) && !(message.power && $util.isInteger(message.power.low) && $util.isInteger(message.power.high)))
                    return "power: integer|Long expected";
            if (message.isFight != null && message.hasOwnProperty("isFight"))
                if (!$util.isInteger(message.isFight))
                    return "isFight: integer expected";
            if (message.gname != null && message.hasOwnProperty("gname"))
                if (!$util.isString(message.gname))
                    return "gname: string expected";
            return null;
        };
    
        /**
         * Creates a pb_qlt_pvp_enemy message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_qlt_pvp_enemy
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_qlt_pvp_enemy} pb_qlt_pvp_enemy
         */
        pb_qlt_pvp_enemy.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_qlt_pvp_enemy)
                return object;
            var message = new $root.pb_qlt_pvp_enemy();
            if (object.idx != null)
                message.idx = object.idx | 0;
            if (object.logo != null)
                message.logo = object.logo | 0;
            if (object.name != null)
                message.name = String(object.name);
            if (object.cluster != null)
                message.cluster = String(object.cluster);
            if (object.lv != null)
                message.lv = object.lv | 0;
            if (object.lbox != null)
                message.lbox = object.lbox | 0;
            if (object.camp) {
                if (!Array.isArray(object.camp))
                    throw TypeError(".pb_qlt_pvp_enemy.camp: array expected");
                message.camp = [];
                for (var i = 0; i < object.camp.length; ++i) {
                    if (typeof object.camp[i] !== "object")
                        throw TypeError(".pb_qlt_pvp_enemy.camp: object expected");
                    message.camp[i] = $root.pb_unit.fromObject(object.camp[i]);
                }
            }
            if (object.skls) {
                if (!Array.isArray(object.skls))
                    throw TypeError(".pb_qlt_pvp_enemy.skls: array expected");
                message.skls = [];
                for (var i = 0; i < object.skls.length; ++i)
                    message.skls[i] = object.skls[i] | 0;
            }
            if (object.hide) {
                if (!Array.isArray(object.hide))
                    throw TypeError(".pb_qlt_pvp_enemy.hide: array expected");
                message.hide = [];
                for (var i = 0; i < object.hide.length; ++i)
                    message.hide[i] = object.hide[i] | 0;
            }
            if (object.uid != null)
                if ($util.Long)
                    (message.uid = $util.Long.fromValue(object.uid)).unsigned = false;
                else if (typeof object.uid === "string")
                    message.uid = parseInt(object.uid, 10);
                else if (typeof object.uid === "number")
                    message.uid = object.uid;
                else if (typeof object.uid === "object")
                    message.uid = new $util.LongBits(object.uid.low >>> 0, object.uid.high >>> 0).toNumber();
            if (object.power != null)
                if ($util.Long)
                    (message.power = $util.Long.fromValue(object.power)).unsigned = false;
                else if (typeof object.power === "string")
                    message.power = parseInt(object.power, 10);
                else if (typeof object.power === "number")
                    message.power = object.power;
                else if (typeof object.power === "object")
                    message.power = new $util.LongBits(object.power.low >>> 0, object.power.high >>> 0).toNumber();
            if (object.isFight != null)
                message.isFight = object.isFight | 0;
            if (object.gname != null)
                message.gname = String(object.gname);
            return message;
        };
    
        /**
         * Creates a plain object from a pb_qlt_pvp_enemy message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_qlt_pvp_enemy
         * @static
         * @param {pb_qlt_pvp_enemy} message pb_qlt_pvp_enemy
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_qlt_pvp_enemy.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.camp = [];
                object.skls = [];
                object.hide = [];
            }
            if (options.defaults) {
                object.idx = 0;
                object.logo = 0;
                object.name = "";
                object.cluster = "";
                object.lv = 0;
                object.lbox = 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.uid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.uid = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.power = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.power = options.longs === String ? "0" : 0;
                object.isFight = 0;
                object.gname = "";
            }
            if (message.idx != null && message.hasOwnProperty("idx"))
                object.idx = message.idx;
            if (message.logo != null && message.hasOwnProperty("logo"))
                object.logo = message.logo;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.cluster != null && message.hasOwnProperty("cluster"))
                object.cluster = message.cluster;
            if (message.lv != null && message.hasOwnProperty("lv"))
                object.lv = message.lv;
            if (message.lbox != null && message.hasOwnProperty("lbox"))
                object.lbox = message.lbox;
            if (message.camp && message.camp.length) {
                object.camp = [];
                for (var j = 0; j < message.camp.length; ++j)
                    object.camp[j] = $root.pb_unit.toObject(message.camp[j], options);
            }
            if (message.skls && message.skls.length) {
                object.skls = [];
                for (var j = 0; j < message.skls.length; ++j)
                    object.skls[j] = message.skls[j];
            }
            if (message.hide && message.hide.length) {
                object.hide = [];
                for (var j = 0; j < message.hide.length; ++j)
                    object.hide[j] = message.hide[j];
            }
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (typeof message.uid === "number")
                    object.uid = options.longs === String ? String(message.uid) : message.uid;
                else
                    object.uid = options.longs === String ? $util.Long.prototype.toString.call(message.uid) : options.longs === Number ? new $util.LongBits(message.uid.low >>> 0, message.uid.high >>> 0).toNumber() : message.uid;
            if (message.power != null && message.hasOwnProperty("power"))
                if (typeof message.power === "number")
                    object.power = options.longs === String ? String(message.power) : message.power;
                else
                    object.power = options.longs === String ? $util.Long.prototype.toString.call(message.power) : options.longs === Number ? new $util.LongBits(message.power.low >>> 0, message.power.high >>> 0).toNumber() : message.power;
            if (message.isFight != null && message.hasOwnProperty("isFight"))
                object.isFight = message.isFight;
            if (message.gname != null && message.hasOwnProperty("gname"))
                object.gname = message.gname;
            return object;
        };
    
        /**
         * Converts this pb_qlt_pvp_enemy to JSON.
         * @function toJSON
         * @memberof pb_qlt_pvp_enemy
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_qlt_pvp_enemy.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_qlt_pvp_enemy
         * @function getTypeUrl
         * @memberof pb_qlt_pvp_enemy
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_qlt_pvp_enemy.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_qlt_pvp_enemy";
        };
    
        return pb_qlt_pvp_enemy;
    })();
    
    $root.pb_qloger = (function() {
    
        /**
         * Properties of a pb_qloger.
         * @exports Ipb_qloger
         * @interface Ipb_qloger
         * @property {number|Long} vid pb_qloger vid
         * @property {Ipb_smbr|null} [aMbr] pb_qloger aMbr
         * @property {Ipb_smbr|null} [dMbr] pb_qloger dMbr
         * @property {number|null} [time] pb_qloger time
         * @property {boolean|null} [win] pb_qloger win
         * @property {number|null} [delta] pb_qloger delta
         * @property {Array.<number>|null} [aSkls] pb_qloger aSkls
         * @property {Array.<number>|null} [dSkls] pb_qloger dSkls
         */
    
        /**
         * Constructs a new pb_qloger.
         * @exports pb_qloger
         * @classdesc Represents a pb_qloger.
         * @implements Ipb_qloger
         * @constructor
         * @param {Ipb_qloger=} [properties] Properties to set
         */
        function pb_qloger(properties) {
            this.aSkls = [];
            this.dSkls = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_qloger vid.
         * @member {number|Long} vid
         * @memberof pb_qloger
         * @instance
         */
        pb_qloger.prototype.vid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * pb_qloger aMbr.
         * @member {Ipb_smbr|null|undefined} aMbr
         * @memberof pb_qloger
         * @instance
         */
        pb_qloger.prototype.aMbr = null;
    
        /**
         * pb_qloger dMbr.
         * @member {Ipb_smbr|null|undefined} dMbr
         * @memberof pb_qloger
         * @instance
         */
        pb_qloger.prototype.dMbr = null;
    
        /**
         * pb_qloger time.
         * @member {number} time
         * @memberof pb_qloger
         * @instance
         */
        pb_qloger.prototype.time = 0;
    
        /**
         * pb_qloger win.
         * @member {boolean} win
         * @memberof pb_qloger
         * @instance
         */
        pb_qloger.prototype.win = false;
    
        /**
         * pb_qloger delta.
         * @member {number} delta
         * @memberof pb_qloger
         * @instance
         */
        pb_qloger.prototype.delta = 0;
    
        /**
         * pb_qloger aSkls.
         * @member {Array.<number>} aSkls
         * @memberof pb_qloger
         * @instance
         */
        pb_qloger.prototype.aSkls = $util.emptyArray;
    
        /**
         * pb_qloger dSkls.
         * @member {Array.<number>} dSkls
         * @memberof pb_qloger
         * @instance
         */
        pb_qloger.prototype.dSkls = $util.emptyArray;
    
        /**
         * Creates a new pb_qloger instance using the specified properties.
         * @function create
         * @memberof pb_qloger
         * @static
         * @param {Ipb_qloger=} [properties] Properties to set
         * @returns {pb_qloger} pb_qloger instance
         */
        pb_qloger.create = function create(properties) {
            return new pb_qloger(properties);
        };
    
        /**
         * Encodes the specified pb_qloger message. Does not implicitly {@link pb_qloger.verify|verify} messages.
         * @function encode
         * @memberof pb_qloger
         * @static
         * @param {Ipb_qloger} message pb_qloger message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_qloger.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int64(message.vid);
            if (message.aMbr != null && Object.hasOwnProperty.call(message, "aMbr"))
                $root.pb_smbr.encode(message.aMbr, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.dMbr != null && Object.hasOwnProperty.call(message, "dMbr"))
                $root.pb_smbr.encode(message.dMbr, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.time != null && Object.hasOwnProperty.call(message, "time"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.time);
            if (message.win != null && Object.hasOwnProperty.call(message, "win"))
                writer.uint32(/* id 5, wireType 0 =*/40).bool(message.win);
            if (message.delta != null && Object.hasOwnProperty.call(message, "delta"))
                writer.uint32(/* id 6, wireType 0 =*/48).sint32(message.delta);
            if (message.aSkls != null && message.aSkls.length)
                for (var i = 0; i < message.aSkls.length; ++i)
                    writer.uint32(/* id 7, wireType 0 =*/56).sint32(message.aSkls[i]);
            if (message.dSkls != null && message.dSkls.length)
                for (var i = 0; i < message.dSkls.length; ++i)
                    writer.uint32(/* id 8, wireType 0 =*/64).sint32(message.dSkls[i]);
            return writer;
        };
    
        /**
         * Encodes the specified pb_qloger message, length delimited. Does not implicitly {@link pb_qloger.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_qloger
         * @static
         * @param {Ipb_qloger} message pb_qloger message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_qloger.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_qloger message from the specified reader or buffer.
         * @function decode
         * @memberof pb_qloger
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_qloger} pb_qloger
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_qloger.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_qloger();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.vid = reader.int64();
                        break;
                    }
                case 2: {
                        message.aMbr = $root.pb_smbr.decode(reader, reader.uint32());
                        break;
                    }
                case 3: {
                        message.dMbr = $root.pb_smbr.decode(reader, reader.uint32());
                        break;
                    }
                case 4: {
                        message.time = reader.int32();
                        break;
                    }
                case 5: {
                        message.win = reader.bool();
                        break;
                    }
                case 6: {
                        message.delta = reader.sint32();
                        break;
                    }
                case 7: {
                        if (!(message.aSkls && message.aSkls.length))
                            message.aSkls = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.aSkls.push(reader.sint32());
                        } else
                            message.aSkls.push(reader.sint32());
                        break;
                    }
                case 8: {
                        if (!(message.dSkls && message.dSkls.length))
                            message.dSkls = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.dSkls.push(reader.sint32());
                        } else
                            message.dSkls.push(reader.sint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("vid"))
                throw $util.ProtocolError("missing required 'vid'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a pb_qloger message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_qloger
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_qloger} pb_qloger
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_qloger.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_qloger message.
         * @function verify
         * @memberof pb_qloger
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_qloger.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.vid) && !(message.vid && $util.isInteger(message.vid.low) && $util.isInteger(message.vid.high)))
                return "vid: integer|Long expected";
            if (message.aMbr != null && message.hasOwnProperty("aMbr")) {
                var error = $root.pb_smbr.verify(message.aMbr);
                if (error)
                    return "aMbr." + error;
            }
            if (message.dMbr != null && message.hasOwnProperty("dMbr")) {
                var error = $root.pb_smbr.verify(message.dMbr);
                if (error)
                    return "dMbr." + error;
            }
            if (message.time != null && message.hasOwnProperty("time"))
                if (!$util.isInteger(message.time))
                    return "time: integer expected";
            if (message.win != null && message.hasOwnProperty("win"))
                if (typeof message.win !== "boolean")
                    return "win: boolean expected";
            if (message.delta != null && message.hasOwnProperty("delta"))
                if (!$util.isInteger(message.delta))
                    return "delta: integer expected";
            if (message.aSkls != null && message.hasOwnProperty("aSkls")) {
                if (!Array.isArray(message.aSkls))
                    return "aSkls: array expected";
                for (var i = 0; i < message.aSkls.length; ++i)
                    if (!$util.isInteger(message.aSkls[i]))
                        return "aSkls: integer[] expected";
            }
            if (message.dSkls != null && message.hasOwnProperty("dSkls")) {
                if (!Array.isArray(message.dSkls))
                    return "dSkls: array expected";
                for (var i = 0; i < message.dSkls.length; ++i)
                    if (!$util.isInteger(message.dSkls[i]))
                        return "dSkls: integer[] expected";
            }
            return null;
        };
    
        /**
         * Creates a pb_qloger message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_qloger
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_qloger} pb_qloger
         */
        pb_qloger.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_qloger)
                return object;
            var message = new $root.pb_qloger();
            if (object.vid != null)
                if ($util.Long)
                    (message.vid = $util.Long.fromValue(object.vid)).unsigned = false;
                else if (typeof object.vid === "string")
                    message.vid = parseInt(object.vid, 10);
                else if (typeof object.vid === "number")
                    message.vid = object.vid;
                else if (typeof object.vid === "object")
                    message.vid = new $util.LongBits(object.vid.low >>> 0, object.vid.high >>> 0).toNumber();
            if (object.aMbr != null) {
                if (typeof object.aMbr !== "object")
                    throw TypeError(".pb_qloger.aMbr: object expected");
                message.aMbr = $root.pb_smbr.fromObject(object.aMbr);
            }
            if (object.dMbr != null) {
                if (typeof object.dMbr !== "object")
                    throw TypeError(".pb_qloger.dMbr: object expected");
                message.dMbr = $root.pb_smbr.fromObject(object.dMbr);
            }
            if (object.time != null)
                message.time = object.time | 0;
            if (object.win != null)
                message.win = Boolean(object.win);
            if (object.delta != null)
                message.delta = object.delta | 0;
            if (object.aSkls) {
                if (!Array.isArray(object.aSkls))
                    throw TypeError(".pb_qloger.aSkls: array expected");
                message.aSkls = [];
                for (var i = 0; i < object.aSkls.length; ++i)
                    message.aSkls[i] = object.aSkls[i] | 0;
            }
            if (object.dSkls) {
                if (!Array.isArray(object.dSkls))
                    throw TypeError(".pb_qloger.dSkls: array expected");
                message.dSkls = [];
                for (var i = 0; i < object.dSkls.length; ++i)
                    message.dSkls[i] = object.dSkls[i] | 0;
            }
            return message;
        };
    
        /**
         * Creates a plain object from a pb_qloger message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_qloger
         * @static
         * @param {pb_qloger} message pb_qloger
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_qloger.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.aSkls = [];
                object.dSkls = [];
            }
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.vid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.vid = options.longs === String ? "0" : 0;
                object.aMbr = null;
                object.dMbr = null;
                object.time = 0;
                object.win = false;
                object.delta = 0;
            }
            if (message.vid != null && message.hasOwnProperty("vid"))
                if (typeof message.vid === "number")
                    object.vid = options.longs === String ? String(message.vid) : message.vid;
                else
                    object.vid = options.longs === String ? $util.Long.prototype.toString.call(message.vid) : options.longs === Number ? new $util.LongBits(message.vid.low >>> 0, message.vid.high >>> 0).toNumber() : message.vid;
            if (message.aMbr != null && message.hasOwnProperty("aMbr"))
                object.aMbr = $root.pb_smbr.toObject(message.aMbr, options);
            if (message.dMbr != null && message.hasOwnProperty("dMbr"))
                object.dMbr = $root.pb_smbr.toObject(message.dMbr, options);
            if (message.time != null && message.hasOwnProperty("time"))
                object.time = message.time;
            if (message.win != null && message.hasOwnProperty("win"))
                object.win = message.win;
            if (message.delta != null && message.hasOwnProperty("delta"))
                object.delta = message.delta;
            if (message.aSkls && message.aSkls.length) {
                object.aSkls = [];
                for (var j = 0; j < message.aSkls.length; ++j)
                    object.aSkls[j] = message.aSkls[j];
            }
            if (message.dSkls && message.dSkls.length) {
                object.dSkls = [];
                for (var j = 0; j < message.dSkls.length; ++j)
                    object.dSkls[j] = message.dSkls[j];
            }
            return object;
        };
    
        /**
         * Converts this pb_qloger to JSON.
         * @function toJSON
         * @memberof pb_qloger
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_qloger.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_qloger
         * @function getTypeUrl
         * @memberof pb_qloger
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_qloger.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_qloger";
        };
    
        return pb_qloger;
    })();
    
    $root.pb_qvideo = (function() {
    
        /**
         * Properties of a pb_qvideo.
         * @exports Ipb_qvideo
         * @interface Ipb_qvideo
         * @property {Array.<Ipb_unit>|null} [atk] pb_qvideo atk
         * @property {Array.<Ipb_unit>|null} [def] pb_qvideo def
         * @property {Array.<Uint8Array>|null} [frames] pb_qvideo frames
         * @property {Array.<Ipb_hurts>|null} [hurts] pb_qvideo hurts
         * @property {boolean} win pb_qvideo win
         */
    
        /**
         * Constructs a new pb_qvideo.
         * @exports pb_qvideo
         * @classdesc Represents a pb_qvideo.
         * @implements Ipb_qvideo
         * @constructor
         * @param {Ipb_qvideo=} [properties] Properties to set
         */
        function pb_qvideo(properties) {
            this.atk = [];
            this.def = [];
            this.frames = [];
            this.hurts = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_qvideo atk.
         * @member {Array.<Ipb_unit>} atk
         * @memberof pb_qvideo
         * @instance
         */
        pb_qvideo.prototype.atk = $util.emptyArray;
    
        /**
         * pb_qvideo def.
         * @member {Array.<Ipb_unit>} def
         * @memberof pb_qvideo
         * @instance
         */
        pb_qvideo.prototype.def = $util.emptyArray;
    
        /**
         * pb_qvideo frames.
         * @member {Array.<Uint8Array>} frames
         * @memberof pb_qvideo
         * @instance
         */
        pb_qvideo.prototype.frames = $util.emptyArray;
    
        /**
         * pb_qvideo hurts.
         * @member {Array.<Ipb_hurts>} hurts
         * @memberof pb_qvideo
         * @instance
         */
        pb_qvideo.prototype.hurts = $util.emptyArray;
    
        /**
         * pb_qvideo win.
         * @member {boolean} win
         * @memberof pb_qvideo
         * @instance
         */
        pb_qvideo.prototype.win = false;
    
        /**
         * Creates a new pb_qvideo instance using the specified properties.
         * @function create
         * @memberof pb_qvideo
         * @static
         * @param {Ipb_qvideo=} [properties] Properties to set
         * @returns {pb_qvideo} pb_qvideo instance
         */
        pb_qvideo.create = function create(properties) {
            return new pb_qvideo(properties);
        };
    
        /**
         * Encodes the specified pb_qvideo message. Does not implicitly {@link pb_qvideo.verify|verify} messages.
         * @function encode
         * @memberof pb_qvideo
         * @static
         * @param {Ipb_qvideo} message pb_qvideo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_qvideo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.atk != null && message.atk.length)
                for (var i = 0; i < message.atk.length; ++i)
                    $root.pb_unit.encode(message.atk[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.def != null && message.def.length)
                for (var i = 0; i < message.def.length; ++i)
                    $root.pb_unit.encode(message.def[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.frames != null && message.frames.length)
                for (var i = 0; i < message.frames.length; ++i)
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.frames[i]);
            if (message.hurts != null && message.hurts.length)
                for (var i = 0; i < message.hurts.length; ++i)
                    $root.pb_hurts.encode(message.hurts[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            writer.uint32(/* id 5, wireType 0 =*/40).bool(message.win);
            return writer;
        };
    
        /**
         * Encodes the specified pb_qvideo message, length delimited. Does not implicitly {@link pb_qvideo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_qvideo
         * @static
         * @param {Ipb_qvideo} message pb_qvideo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_qvideo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_qvideo message from the specified reader or buffer.
         * @function decode
         * @memberof pb_qvideo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_qvideo} pb_qvideo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_qvideo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_qvideo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.atk && message.atk.length))
                            message.atk = [];
                        message.atk.push($root.pb_unit.decode(reader, reader.uint32()));
                        break;
                    }
                case 2: {
                        if (!(message.def && message.def.length))
                            message.def = [];
                        message.def.push($root.pb_unit.decode(reader, reader.uint32()));
                        break;
                    }
                case 3: {
                        if (!(message.frames && message.frames.length))
                            message.frames = [];
                        message.frames.push(reader.bytes());
                        break;
                    }
                case 4: {
                        if (!(message.hurts && message.hurts.length))
                            message.hurts = [];
                        message.hurts.push($root.pb_hurts.decode(reader, reader.uint32()));
                        break;
                    }
                case 5: {
                        message.win = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("win"))
                throw $util.ProtocolError("missing required 'win'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a pb_qvideo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_qvideo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_qvideo} pb_qvideo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_qvideo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_qvideo message.
         * @function verify
         * @memberof pb_qvideo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_qvideo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.atk != null && message.hasOwnProperty("atk")) {
                if (!Array.isArray(message.atk))
                    return "atk: array expected";
                for (var i = 0; i < message.atk.length; ++i) {
                    var error = $root.pb_unit.verify(message.atk[i]);
                    if (error)
                        return "atk." + error;
                }
            }
            if (message.def != null && message.hasOwnProperty("def")) {
                if (!Array.isArray(message.def))
                    return "def: array expected";
                for (var i = 0; i < message.def.length; ++i) {
                    var error = $root.pb_unit.verify(message.def[i]);
                    if (error)
                        return "def." + error;
                }
            }
            if (message.frames != null && message.hasOwnProperty("frames")) {
                if (!Array.isArray(message.frames))
                    return "frames: array expected";
                for (var i = 0; i < message.frames.length; ++i)
                    if (!(message.frames[i] && typeof message.frames[i].length === "number" || $util.isString(message.frames[i])))
                        return "frames: buffer[] expected";
            }
            if (message.hurts != null && message.hasOwnProperty("hurts")) {
                if (!Array.isArray(message.hurts))
                    return "hurts: array expected";
                for (var i = 0; i < message.hurts.length; ++i) {
                    var error = $root.pb_hurts.verify(message.hurts[i]);
                    if (error)
                        return "hurts." + error;
                }
            }
            if (typeof message.win !== "boolean")
                return "win: boolean expected";
            return null;
        };
    
        /**
         * Creates a pb_qvideo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_qvideo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_qvideo} pb_qvideo
         */
        pb_qvideo.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_qvideo)
                return object;
            var message = new $root.pb_qvideo();
            if (object.atk) {
                if (!Array.isArray(object.atk))
                    throw TypeError(".pb_qvideo.atk: array expected");
                message.atk = [];
                for (var i = 0; i < object.atk.length; ++i) {
                    if (typeof object.atk[i] !== "object")
                        throw TypeError(".pb_qvideo.atk: object expected");
                    message.atk[i] = $root.pb_unit.fromObject(object.atk[i]);
                }
            }
            if (object.def) {
                if (!Array.isArray(object.def))
                    throw TypeError(".pb_qvideo.def: array expected");
                message.def = [];
                for (var i = 0; i < object.def.length; ++i) {
                    if (typeof object.def[i] !== "object")
                        throw TypeError(".pb_qvideo.def: object expected");
                    message.def[i] = $root.pb_unit.fromObject(object.def[i]);
                }
            }
            if (object.frames) {
                if (!Array.isArray(object.frames))
                    throw TypeError(".pb_qvideo.frames: array expected");
                message.frames = [];
                for (var i = 0; i < object.frames.length; ++i)
                    if (typeof object.frames[i] === "string")
                        $util.base64.decode(object.frames[i], message.frames[i] = $util.newBuffer($util.base64.length(object.frames[i])), 0);
                    else if (object.frames[i].length >= 0)
                        message.frames[i] = object.frames[i];
            }
            if (object.hurts) {
                if (!Array.isArray(object.hurts))
                    throw TypeError(".pb_qvideo.hurts: array expected");
                message.hurts = [];
                for (var i = 0; i < object.hurts.length; ++i) {
                    if (typeof object.hurts[i] !== "object")
                        throw TypeError(".pb_qvideo.hurts: object expected");
                    message.hurts[i] = $root.pb_hurts.fromObject(object.hurts[i]);
                }
            }
            if (object.win != null)
                message.win = Boolean(object.win);
            return message;
        };
    
        /**
         * Creates a plain object from a pb_qvideo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_qvideo
         * @static
         * @param {pb_qvideo} message pb_qvideo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_qvideo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.atk = [];
                object.def = [];
                object.frames = [];
                object.hurts = [];
            }
            if (options.defaults)
                object.win = false;
            if (message.atk && message.atk.length) {
                object.atk = [];
                for (var j = 0; j < message.atk.length; ++j)
                    object.atk[j] = $root.pb_unit.toObject(message.atk[j], options);
            }
            if (message.def && message.def.length) {
                object.def = [];
                for (var j = 0; j < message.def.length; ++j)
                    object.def[j] = $root.pb_unit.toObject(message.def[j], options);
            }
            if (message.frames && message.frames.length) {
                object.frames = [];
                for (var j = 0; j < message.frames.length; ++j)
                    object.frames[j] = options.bytes === String ? $util.base64.encode(message.frames[j], 0, message.frames[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.frames[j]) : message.frames[j];
            }
            if (message.hurts && message.hurts.length) {
                object.hurts = [];
                for (var j = 0; j < message.hurts.length; ++j)
                    object.hurts[j] = $root.pb_hurts.toObject(message.hurts[j], options);
            }
            if (message.win != null && message.hasOwnProperty("win"))
                object.win = message.win;
            return object;
        };
    
        /**
         * Converts this pb_qvideo to JSON.
         * @function toJSON
         * @memberof pb_qvideo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_qvideo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_qvideo
         * @function getTypeUrl
         * @memberof pb_qvideo
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_qvideo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_qvideo";
        };
    
        return pb_qvideo;
    })();
    
    $root.pb_qlog = (function() {
    
        /**
         * Properties of a pb_qlog.
         * @exports Ipb_qlog
         * @interface Ipb_qlog
         * @property {Array.<Ipb_qvideo>|null} [video] pb_qlog video
         * @property {Ipb_smbr|null} [aMbr] pb_qlog aMbr
         * @property {Ipb_smbr|null} [dMbr] pb_qlog dMbr
         * @property {number|null} [time] pb_qlog time
         * @property {boolean|null} [win] pb_qlog win
         * @property {number|null} [delta] pb_qlog delta
         * @property {Array.<number>|null} [aSkls] pb_qlog aSkls
         * @property {Array.<number>|null} [dSkls] pb_qlog dSkls
         */
    
        /**
         * Constructs a new pb_qlog.
         * @exports pb_qlog
         * @classdesc Represents a pb_qlog.
         * @implements Ipb_qlog
         * @constructor
         * @param {Ipb_qlog=} [properties] Properties to set
         */
        function pb_qlog(properties) {
            this.video = [];
            this.aSkls = [];
            this.dSkls = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * pb_qlog video.
         * @member {Array.<Ipb_qvideo>} video
         * @memberof pb_qlog
         * @instance
         */
        pb_qlog.prototype.video = $util.emptyArray;
    
        /**
         * pb_qlog aMbr.
         * @member {Ipb_smbr|null|undefined} aMbr
         * @memberof pb_qlog
         * @instance
         */
        pb_qlog.prototype.aMbr = null;
    
        /**
         * pb_qlog dMbr.
         * @member {Ipb_smbr|null|undefined} dMbr
         * @memberof pb_qlog
         * @instance
         */
        pb_qlog.prototype.dMbr = null;
    
        /**
         * pb_qlog time.
         * @member {number} time
         * @memberof pb_qlog
         * @instance
         */
        pb_qlog.prototype.time = 0;
    
        /**
         * pb_qlog win.
         * @member {boolean} win
         * @memberof pb_qlog
         * @instance
         */
        pb_qlog.prototype.win = false;
    
        /**
         * pb_qlog delta.
         * @member {number} delta
         * @memberof pb_qlog
         * @instance
         */
        pb_qlog.prototype.delta = 0;
    
        /**
         * pb_qlog aSkls.
         * @member {Array.<number>} aSkls
         * @memberof pb_qlog
         * @instance
         */
        pb_qlog.prototype.aSkls = $util.emptyArray;
    
        /**
         * pb_qlog dSkls.
         * @member {Array.<number>} dSkls
         * @memberof pb_qlog
         * @instance
         */
        pb_qlog.prototype.dSkls = $util.emptyArray;
    
        /**
         * Creates a new pb_qlog instance using the specified properties.
         * @function create
         * @memberof pb_qlog
         * @static
         * @param {Ipb_qlog=} [properties] Properties to set
         * @returns {pb_qlog} pb_qlog instance
         */
        pb_qlog.create = function create(properties) {
            return new pb_qlog(properties);
        };
    
        /**
         * Encodes the specified pb_qlog message. Does not implicitly {@link pb_qlog.verify|verify} messages.
         * @function encode
         * @memberof pb_qlog
         * @static
         * @param {Ipb_qlog} message pb_qlog message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_qlog.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.video != null && message.video.length)
                for (var i = 0; i < message.video.length; ++i)
                    $root.pb_qvideo.encode(message.video[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.aMbr != null && Object.hasOwnProperty.call(message, "aMbr"))
                $root.pb_smbr.encode(message.aMbr, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.dMbr != null && Object.hasOwnProperty.call(message, "dMbr"))
                $root.pb_smbr.encode(message.dMbr, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.time != null && Object.hasOwnProperty.call(message, "time"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.time);
            if (message.win != null && Object.hasOwnProperty.call(message, "win"))
                writer.uint32(/* id 5, wireType 0 =*/40).bool(message.win);
            if (message.delta != null && Object.hasOwnProperty.call(message, "delta"))
                writer.uint32(/* id 6, wireType 0 =*/48).sint32(message.delta);
            if (message.aSkls != null && message.aSkls.length)
                for (var i = 0; i < message.aSkls.length; ++i)
                    writer.uint32(/* id 7, wireType 0 =*/56).sint32(message.aSkls[i]);
            if (message.dSkls != null && message.dSkls.length)
                for (var i = 0; i < message.dSkls.length; ++i)
                    writer.uint32(/* id 8, wireType 0 =*/64).sint32(message.dSkls[i]);
            return writer;
        };
    
        /**
         * Encodes the specified pb_qlog message, length delimited. Does not implicitly {@link pb_qlog.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb_qlog
         * @static
         * @param {Ipb_qlog} message pb_qlog message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        pb_qlog.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a pb_qlog message from the specified reader or buffer.
         * @function decode
         * @memberof pb_qlog
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb_qlog} pb_qlog
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_qlog.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb_qlog();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.video && message.video.length))
                            message.video = [];
                        message.video.push($root.pb_qvideo.decode(reader, reader.uint32()));
                        break;
                    }
                case 2: {
                        message.aMbr = $root.pb_smbr.decode(reader, reader.uint32());
                        break;
                    }
                case 3: {
                        message.dMbr = $root.pb_smbr.decode(reader, reader.uint32());
                        break;
                    }
                case 4: {
                        message.time = reader.int32();
                        break;
                    }
                case 5: {
                        message.win = reader.bool();
                        break;
                    }
                case 6: {
                        message.delta = reader.sint32();
                        break;
                    }
                case 7: {
                        if (!(message.aSkls && message.aSkls.length))
                            message.aSkls = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.aSkls.push(reader.sint32());
                        } else
                            message.aSkls.push(reader.sint32());
                        break;
                    }
                case 8: {
                        if (!(message.dSkls && message.dSkls.length))
                            message.dSkls = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.dSkls.push(reader.sint32());
                        } else
                            message.dSkls.push(reader.sint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a pb_qlog message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb_qlog
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb_qlog} pb_qlog
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        pb_qlog.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a pb_qlog message.
         * @function verify
         * @memberof pb_qlog
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        pb_qlog.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.video != null && message.hasOwnProperty("video")) {
                if (!Array.isArray(message.video))
                    return "video: array expected";
                for (var i = 0; i < message.video.length; ++i) {
                    var error = $root.pb_qvideo.verify(message.video[i]);
                    if (error)
                        return "video." + error;
                }
            }
            if (message.aMbr != null && message.hasOwnProperty("aMbr")) {
                var error = $root.pb_smbr.verify(message.aMbr);
                if (error)
                    return "aMbr." + error;
            }
            if (message.dMbr != null && message.hasOwnProperty("dMbr")) {
                var error = $root.pb_smbr.verify(message.dMbr);
                if (error)
                    return "dMbr." + error;
            }
            if (message.time != null && message.hasOwnProperty("time"))
                if (!$util.isInteger(message.time))
                    return "time: integer expected";
            if (message.win != null && message.hasOwnProperty("win"))
                if (typeof message.win !== "boolean")
                    return "win: boolean expected";
            if (message.delta != null && message.hasOwnProperty("delta"))
                if (!$util.isInteger(message.delta))
                    return "delta: integer expected";
            if (message.aSkls != null && message.hasOwnProperty("aSkls")) {
                if (!Array.isArray(message.aSkls))
                    return "aSkls: array expected";
                for (var i = 0; i < message.aSkls.length; ++i)
                    if (!$util.isInteger(message.aSkls[i]))
                        return "aSkls: integer[] expected";
            }
            if (message.dSkls != null && message.hasOwnProperty("dSkls")) {
                if (!Array.isArray(message.dSkls))
                    return "dSkls: array expected";
                for (var i = 0; i < message.dSkls.length; ++i)
                    if (!$util.isInteger(message.dSkls[i]))
                        return "dSkls: integer[] expected";
            }
            return null;
        };
    
        /**
         * Creates a pb_qlog message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof pb_qlog
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {pb_qlog} pb_qlog
         */
        pb_qlog.fromObject = function fromObject(object) {
            if (object instanceof $root.pb_qlog)
                return object;
            var message = new $root.pb_qlog();
            if (object.video) {
                if (!Array.isArray(object.video))
                    throw TypeError(".pb_qlog.video: array expected");
                message.video = [];
                for (var i = 0; i < object.video.length; ++i) {
                    if (typeof object.video[i] !== "object")
                        throw TypeError(".pb_qlog.video: object expected");
                    message.video[i] = $root.pb_qvideo.fromObject(object.video[i]);
                }
            }
            if (object.aMbr != null) {
                if (typeof object.aMbr !== "object")
                    throw TypeError(".pb_qlog.aMbr: object expected");
                message.aMbr = $root.pb_smbr.fromObject(object.aMbr);
            }
            if (object.dMbr != null) {
                if (typeof object.dMbr !== "object")
                    throw TypeError(".pb_qlog.dMbr: object expected");
                message.dMbr = $root.pb_smbr.fromObject(object.dMbr);
            }
            if (object.time != null)
                message.time = object.time | 0;
            if (object.win != null)
                message.win = Boolean(object.win);
            if (object.delta != null)
                message.delta = object.delta | 0;
            if (object.aSkls) {
                if (!Array.isArray(object.aSkls))
                    throw TypeError(".pb_qlog.aSkls: array expected");
                message.aSkls = [];
                for (var i = 0; i < object.aSkls.length; ++i)
                    message.aSkls[i] = object.aSkls[i] | 0;
            }
            if (object.dSkls) {
                if (!Array.isArray(object.dSkls))
                    throw TypeError(".pb_qlog.dSkls: array expected");
                message.dSkls = [];
                for (var i = 0; i < object.dSkls.length; ++i)
                    message.dSkls[i] = object.dSkls[i] | 0;
            }
            return message;
        };
    
        /**
         * Creates a plain object from a pb_qlog message. Also converts values to other types if specified.
         * @function toObject
         * @memberof pb_qlog
         * @static
         * @param {pb_qlog} message pb_qlog
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        pb_qlog.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.video = [];
                object.aSkls = [];
                object.dSkls = [];
            }
            if (options.defaults) {
                object.aMbr = null;
                object.dMbr = null;
                object.time = 0;
                object.win = false;
                object.delta = 0;
            }
            if (message.video && message.video.length) {
                object.video = [];
                for (var j = 0; j < message.video.length; ++j)
                    object.video[j] = $root.pb_qvideo.toObject(message.video[j], options);
            }
            if (message.aMbr != null && message.hasOwnProperty("aMbr"))
                object.aMbr = $root.pb_smbr.toObject(message.aMbr, options);
            if (message.dMbr != null && message.hasOwnProperty("dMbr"))
                object.dMbr = $root.pb_smbr.toObject(message.dMbr, options);
            if (message.time != null && message.hasOwnProperty("time"))
                object.time = message.time;
            if (message.win != null && message.hasOwnProperty("win"))
                object.win = message.win;
            if (message.delta != null && message.hasOwnProperty("delta"))
                object.delta = message.delta;
            if (message.aSkls && message.aSkls.length) {
                object.aSkls = [];
                for (var j = 0; j < message.aSkls.length; ++j)
                    object.aSkls[j] = message.aSkls[j];
            }
            if (message.dSkls && message.dSkls.length) {
                object.dSkls = [];
                for (var j = 0; j < message.dSkls.length; ++j)
                    object.dSkls[j] = message.dSkls[j];
            }
            return object;
        };
    
        /**
         * Converts this pb_qlog to JSON.
         * @function toJSON
         * @memberof pb_qlog
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        pb_qlog.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for pb_qlog
         * @function getTypeUrl
         * @memberof pb_qlog
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        pb_qlog.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/pb_qlog";
        };
    
        return pb_qlog;
    })();
    
    $root.power_rank = (function() {
    
        /**
         * Properties of a power_rank.
         * @exports Ipower_rank
         * @interface Ipower_rank
         * @property {number|null} [id] power_rank id
         * @property {Ipb_give_role|null} [player] power_rank player
         * @property {number|null} [score] power_rank score
         */
    
        /**
         * Constructs a new power_rank.
         * @exports power_rank
         * @classdesc Represents a power_rank.
         * @implements Ipower_rank
         * @constructor
         * @param {Ipower_rank=} [properties] Properties to set
         */
        function power_rank(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * power_rank id.
         * @member {number} id
         * @memberof power_rank
         * @instance
         */
        power_rank.prototype.id = 0;
    
        /**
         * power_rank player.
         * @member {Ipb_give_role|null|undefined} player
         * @memberof power_rank
         * @instance
         */
        power_rank.prototype.player = null;
    
        /**
         * power_rank score.
         * @member {number} score
         * @memberof power_rank
         * @instance
         */
        power_rank.prototype.score = 0;
    
        /**
         * Creates a new power_rank instance using the specified properties.
         * @function create
         * @memberof power_rank
         * @static
         * @param {Ipower_rank=} [properties] Properties to set
         * @returns {power_rank} power_rank instance
         */
        power_rank.create = function create(properties) {
            return new power_rank(properties);
        };
    
        /**
         * Encodes the specified power_rank message. Does not implicitly {@link power_rank.verify|verify} messages.
         * @function encode
         * @memberof power_rank
         * @static
         * @param {Ipower_rank} message power_rank message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        power_rank.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.id);
            if (message.player != null && Object.hasOwnProperty.call(message, "player"))
                $root.pb_give_role.encode(message.player, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.score != null && Object.hasOwnProperty.call(message, "score"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.score);
            return writer;
        };
    
        /**
         * Encodes the specified power_rank message, length delimited. Does not implicitly {@link power_rank.verify|verify} messages.
         * @function encodeDelimited
         * @memberof power_rank
         * @static
         * @param {Ipower_rank} message power_rank message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        power_rank.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a power_rank message from the specified reader or buffer.
         * @function decode
         * @memberof power_rank
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {power_rank} power_rank
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        power_rank.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.power_rank();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.id = reader.uint32();
                        break;
                    }
                case 2: {
                        message.player = $root.pb_give_role.decode(reader, reader.uint32());
                        break;
                    }
                case 3: {
                        message.score = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a power_rank message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof power_rank
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {power_rank} power_rank
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        power_rank.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a power_rank message.
         * @function verify
         * @memberof power_rank
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        power_rank.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id))
                    return "id: integer expected";
            if (message.player != null && message.hasOwnProperty("player")) {
                var error = $root.pb_give_role.verify(message.player);
                if (error)
                    return "player." + error;
            }
            if (message.score != null && message.hasOwnProperty("score"))
                if (!$util.isInteger(message.score))
                    return "score: integer expected";
            return null;
        };
    
        /**
         * Creates a power_rank message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof power_rank
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {power_rank} power_rank
         */
        power_rank.fromObject = function fromObject(object) {
            if (object instanceof $root.power_rank)
                return object;
            var message = new $root.power_rank();
            if (object.id != null)
                message.id = object.id >>> 0;
            if (object.player != null) {
                if (typeof object.player !== "object")
                    throw TypeError(".power_rank.player: object expected");
                message.player = $root.pb_give_role.fromObject(object.player);
            }
            if (object.score != null)
                message.score = object.score | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a power_rank message. Also converts values to other types if specified.
         * @function toObject
         * @memberof power_rank
         * @static
         * @param {power_rank} message power_rank
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        power_rank.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = 0;
                object.player = null;
                object.score = 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.player != null && message.hasOwnProperty("player"))
                object.player = $root.pb_give_role.toObject(message.player, options);
            if (message.score != null && message.hasOwnProperty("score"))
                object.score = message.score;
            return object;
        };
    
        /**
         * Converts this power_rank to JSON.
         * @function toJSON
         * @memberof power_rank
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        power_rank.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for power_rank
         * @function getTypeUrl
         * @memberof power_rank
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        power_rank.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/power_rank";
        };
    
        return power_rank;
    })();
    
    $root.power_task = (function() {
    
        /**
         * Properties of a power_task.
         * @exports Ipower_task
         * @interface Ipower_task
         * @property {number} id power_task id
         * @property {number|null} [type] power_task type
         * @property {number|null} [cd] power_task cd
         * @property {number|null} [num] power_task num
         * @property {number|null} [dotId] power_task dotId
         * @property {number|null} [flag] power_task flag
         */
    
        /**
         * Constructs a new power_task.
         * @exports power_task
         * @classdesc Represents a power_task.
         * @implements Ipower_task
         * @constructor
         * @param {Ipower_task=} [properties] Properties to set
         */
        function power_task(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * power_task id.
         * @member {number} id
         * @memberof power_task
         * @instance
         */
        power_task.prototype.id = 0;
    
        /**
         * power_task type.
         * @member {number} type
         * @memberof power_task
         * @instance
         */
        power_task.prototype.type = 0;
    
        /**
         * power_task cd.
         * @member {number} cd
         * @memberof power_task
         * @instance
         */
        power_task.prototype.cd = 0;
    
        /**
         * power_task num.
         * @member {number} num
         * @memberof power_task
         * @instance
         */
        power_task.prototype.num = 0;
    
        /**
         * power_task dotId.
         * @member {number} dotId
         * @memberof power_task
         * @instance
         */
        power_task.prototype.dotId = 0;
    
        /**
         * power_task flag.
         * @member {number} flag
         * @memberof power_task
         * @instance
         */
        power_task.prototype.flag = 0;
    
        /**
         * Creates a new power_task instance using the specified properties.
         * @function create
         * @memberof power_task
         * @static
         * @param {Ipower_task=} [properties] Properties to set
         * @returns {power_task} power_task instance
         */
        power_task.create = function create(properties) {
            return new power_task(properties);
        };
    
        /**
         * Encodes the specified power_task message. Does not implicitly {@link power_task.verify|verify} messages.
         * @function encode
         * @memberof power_task
         * @static
         * @param {Ipower_task} message power_task message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        power_task.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.id);
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.type);
            if (message.cd != null && Object.hasOwnProperty.call(message, "cd"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.cd);
            if (message.num != null && Object.hasOwnProperty.call(message, "num"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.num);
            if (message.dotId != null && Object.hasOwnProperty.call(message, "dotId"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.dotId);
            if (message.flag != null && Object.hasOwnProperty.call(message, "flag"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.flag);
            return writer;
        };
    
        /**
         * Encodes the specified power_task message, length delimited. Does not implicitly {@link power_task.verify|verify} messages.
         * @function encodeDelimited
         * @memberof power_task
         * @static
         * @param {Ipower_task} message power_task message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        power_task.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a power_task message from the specified reader or buffer.
         * @function decode
         * @memberof power_task
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {power_task} power_task
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        power_task.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.power_task();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.id = reader.uint32();
                        break;
                    }
                case 2: {
                        message.type = reader.uint32();
                        break;
                    }
                case 3: {
                        message.cd = reader.int32();
                        break;
                    }
                case 4: {
                        message.num = reader.int32();
                        break;
                    }
                case 5: {
                        message.dotId = reader.uint32();
                        break;
                    }
                case 6: {
                        message.flag = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("id"))
                throw $util.ProtocolError("missing required 'id'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a power_task message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof power_task
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {power_task} power_task
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        power_task.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a power_task message.
         * @function verify
         * @memberof power_task
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        power_task.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.id))
                return "id: integer expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isInteger(message.type))
                    return "type: integer expected";
            if (message.cd != null && message.hasOwnProperty("cd"))
                if (!$util.isInteger(message.cd))
                    return "cd: integer expected";
            if (message.num != null && message.hasOwnProperty("num"))
                if (!$util.isInteger(message.num))
                    return "num: integer expected";
            if (message.dotId != null && message.hasOwnProperty("dotId"))
                if (!$util.isInteger(message.dotId))
                    return "dotId: integer expected";
            if (message.flag != null && message.hasOwnProperty("flag"))
                if (!$util.isInteger(message.flag))
                    return "flag: integer expected";
            return null;
        };
    
        /**
         * Creates a power_task message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof power_task
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {power_task} power_task
         */
        power_task.fromObject = function fromObject(object) {
            if (object instanceof $root.power_task)
                return object;
            var message = new $root.power_task();
            if (object.id != null)
                message.id = object.id >>> 0;
            if (object.type != null)
                message.type = object.type >>> 0;
            if (object.cd != null)
                message.cd = object.cd | 0;
            if (object.num != null)
                message.num = object.num | 0;
            if (object.dotId != null)
                message.dotId = object.dotId >>> 0;
            if (object.flag != null)
                message.flag = object.flag >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a power_task message. Also converts values to other types if specified.
         * @function toObject
         * @memberof power_task
         * @static
         * @param {power_task} message power_task
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        power_task.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = 0;
                object.type = 0;
                object.cd = 0;
                object.num = 0;
                object.dotId = 0;
                object.flag = 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            if (message.cd != null && message.hasOwnProperty("cd"))
                object.cd = message.cd;
            if (message.num != null && message.hasOwnProperty("num"))
                object.num = message.num;
            if (message.dotId != null && message.hasOwnProperty("dotId"))
                object.dotId = message.dotId;
            if (message.flag != null && message.hasOwnProperty("flag"))
                object.flag = message.flag;
            return object;
        };
    
        /**
         * Converts this power_task to JSON.
         * @function toJSON
         * @memberof power_task
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        power_task.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for power_task
         * @function getTypeUrl
         * @memberof power_task
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        power_task.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/power_task";
        };
    
        return power_task;
    })();
    
    $root.dot_info = (function() {
    
        /**
         * Properties of a dot_info.
         * @exports Idot_info
         * @interface Idot_info
         * @property {number|null} [id] dot_info id
         * @property {number|null} [powerId] dot_info powerId
         * @property {number|null} [degree] dot_info degree
         * @property {number|null} [max] dot_info max
         * @property {number|null} [status] dot_info status
         * @property {number|null} [item] dot_info item
         * @property {Array.<Ipb_item>|null} [buff] dot_info buff
         * @property {number|null} [tmpId] dot_info tmpId
         * @property {Array.<number>|null} [skill] dot_info skill
         * @property {number|null} [cd] dot_info cd
         * @property {number|null} [cd2] dot_info cd2
         * @property {number|null} [cd3] dot_info cd3
         * @property {number|null} [cd4] dot_info cd4
         * @property {number|null} [cd5] dot_info cd5
         */
    
        /**
         * Constructs a new dot_info.
         * @exports dot_info
         * @classdesc Represents a dot_info.
         * @implements Idot_info
         * @constructor
         * @param {Idot_info=} [properties] Properties to set
         */
        function dot_info(properties) {
            this.buff = [];
            this.skill = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * dot_info id.
         * @member {number} id
         * @memberof dot_info
         * @instance
         */
        dot_info.prototype.id = 0;
    
        /**
         * dot_info powerId.
         * @member {number} powerId
         * @memberof dot_info
         * @instance
         */
        dot_info.prototype.powerId = 0;
    
        /**
         * dot_info degree.
         * @member {number} degree
         * @memberof dot_info
         * @instance
         */
        dot_info.prototype.degree = 0;
    
        /**
         * dot_info max.
         * @member {number} max
         * @memberof dot_info
         * @instance
         */
        dot_info.prototype.max = 0;
    
        /**
         * dot_info status.
         * @member {number} status
         * @memberof dot_info
         * @instance
         */
        dot_info.prototype.status = 0;
    
        /**
         * dot_info item.
         * @member {number} item
         * @memberof dot_info
         * @instance
         */
        dot_info.prototype.item = 0;
    
        /**
         * dot_info buff.
         * @member {Array.<Ipb_item>} buff
         * @memberof dot_info
         * @instance
         */
        dot_info.prototype.buff = $util.emptyArray;
    
        /**
         * dot_info tmpId.
         * @member {number} tmpId
         * @memberof dot_info
         * @instance
         */
        dot_info.prototype.tmpId = 0;
    
        /**
         * dot_info skill.
         * @member {Array.<number>} skill
         * @memberof dot_info
         * @instance
         */
        dot_info.prototype.skill = $util.emptyArray;
    
        /**
         * dot_info cd.
         * @member {number} cd
         * @memberof dot_info
         * @instance
         */
        dot_info.prototype.cd = 0;
    
        /**
         * dot_info cd2.
         * @member {number} cd2
         * @memberof dot_info
         * @instance
         */
        dot_info.prototype.cd2 = 0;
    
        /**
         * dot_info cd3.
         * @member {number} cd3
         * @memberof dot_info
         * @instance
         */
        dot_info.prototype.cd3 = 0;
    
        /**
         * dot_info cd4.
         * @member {number} cd4
         * @memberof dot_info
         * @instance
         */
        dot_info.prototype.cd4 = 0;
    
        /**
         * dot_info cd5.
         * @member {number} cd5
         * @memberof dot_info
         * @instance
         */
        dot_info.prototype.cd5 = 0;
    
        /**
         * Creates a new dot_info instance using the specified properties.
         * @function create
         * @memberof dot_info
         * @static
         * @param {Idot_info=} [properties] Properties to set
         * @returns {dot_info} dot_info instance
         */
        dot_info.create = function create(properties) {
            return new dot_info(properties);
        };
    
        /**
         * Encodes the specified dot_info message. Does not implicitly {@link dot_info.verify|verify} messages.
         * @function encode
         * @memberof dot_info
         * @static
         * @param {Idot_info} message dot_info message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        dot_info.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.id);
            if (message.powerId != null && Object.hasOwnProperty.call(message, "powerId"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.powerId);
            if (message.degree != null && Object.hasOwnProperty.call(message, "degree"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.degree);
            if (message.max != null && Object.hasOwnProperty.call(message, "max"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.max);
            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.status);
            if (message.item != null && Object.hasOwnProperty.call(message, "item"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.item);
            if (message.buff != null && message.buff.length)
                for (var i = 0; i < message.buff.length; ++i)
                    $root.pb_item.encode(message.buff[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.tmpId != null && Object.hasOwnProperty.call(message, "tmpId"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.tmpId);
            if (message.skill != null && message.skill.length)
                for (var i = 0; i < message.skill.length; ++i)
                    writer.uint32(/* id 9, wireType 0 =*/72).int32(message.skill[i]);
            if (message.cd != null && Object.hasOwnProperty.call(message, "cd"))
                writer.uint32(/* id 10, wireType 0 =*/80).int32(message.cd);
            if (message.cd2 != null && Object.hasOwnProperty.call(message, "cd2"))
                writer.uint32(/* id 11, wireType 0 =*/88).int32(message.cd2);
            if (message.cd3 != null && Object.hasOwnProperty.call(message, "cd3"))
                writer.uint32(/* id 12, wireType 0 =*/96).int32(message.cd3);
            if (message.cd4 != null && Object.hasOwnProperty.call(message, "cd4"))
                writer.uint32(/* id 13, wireType 0 =*/104).int32(message.cd4);
            if (message.cd5 != null && Object.hasOwnProperty.call(message, "cd5"))
                writer.uint32(/* id 14, wireType 0 =*/112).int32(message.cd5);
            return writer;
        };
    
        /**
         * Encodes the specified dot_info message, length delimited. Does not implicitly {@link dot_info.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dot_info
         * @static
         * @param {Idot_info} message dot_info message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        dot_info.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a dot_info message from the specified reader or buffer.
         * @function decode
         * @memberof dot_info
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dot_info} dot_info
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        dot_info.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.dot_info();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.id = reader.uint32();
                        break;
                    }
                case 2: {
                        message.powerId = reader.uint32();
                        break;
                    }
                case 3: {
                        message.degree = reader.int32();
                        break;
                    }
                case 4: {
                        message.max = reader.int32();
                        break;
                    }
                case 5: {
                        message.status = reader.uint32();
                        break;
                    }
                case 6: {
                        message.item = reader.int32();
                        break;
                    }
                case 7: {
                        if (!(message.buff && message.buff.length))
                            message.buff = [];
                        message.buff.push($root.pb_item.decode(reader, reader.uint32()));
                        break;
                    }
                case 8: {
                        message.tmpId = reader.int32();
                        break;
                    }
                case 9: {
                        if (!(message.skill && message.skill.length))
                            message.skill = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.skill.push(reader.int32());
                        } else
                            message.skill.push(reader.int32());
                        break;
                    }
                case 10: {
                        message.cd = reader.int32();
                        break;
                    }
                case 11: {
                        message.cd2 = reader.int32();
                        break;
                    }
                case 12: {
                        message.cd3 = reader.int32();
                        break;
                    }
                case 13: {
                        message.cd4 = reader.int32();
                        break;
                    }
                case 14: {
                        message.cd5 = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a dot_info message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dot_info
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dot_info} dot_info
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        dot_info.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a dot_info message.
         * @function verify
         * @memberof dot_info
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        dot_info.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id))
                    return "id: integer expected";
            if (message.powerId != null && message.hasOwnProperty("powerId"))
                if (!$util.isInteger(message.powerId))
                    return "powerId: integer expected";
            if (message.degree != null && message.hasOwnProperty("degree"))
                if (!$util.isInteger(message.degree))
                    return "degree: integer expected";
            if (message.max != null && message.hasOwnProperty("max"))
                if (!$util.isInteger(message.max))
                    return "max: integer expected";
            if (message.status != null && message.hasOwnProperty("status"))
                if (!$util.isInteger(message.status))
                    return "status: integer expected";
            if (message.item != null && message.hasOwnProperty("item"))
                if (!$util.isInteger(message.item))
                    return "item: integer expected";
            if (message.buff != null && message.hasOwnProperty("buff")) {
                if (!Array.isArray(message.buff))
                    return "buff: array expected";
                for (var i = 0; i < message.buff.length; ++i) {
                    var error = $root.pb_item.verify(message.buff[i]);
                    if (error)
                        return "buff." + error;
                }
            }
            if (message.tmpId != null && message.hasOwnProperty("tmpId"))
                if (!$util.isInteger(message.tmpId))
                    return "tmpId: integer expected";
            if (message.skill != null && message.hasOwnProperty("skill")) {
                if (!Array.isArray(message.skill))
                    return "skill: array expected";
                for (var i = 0; i < message.skill.length; ++i)
                    if (!$util.isInteger(message.skill[i]))
                        return "skill: integer[] expected";
            }
            if (message.cd != null && message.hasOwnProperty("cd"))
                if (!$util.isInteger(message.cd))
                    return "cd: integer expected";
            if (message.cd2 != null && message.hasOwnProperty("cd2"))
                if (!$util.isInteger(message.cd2))
                    return "cd2: integer expected";
            if (message.cd3 != null && message.hasOwnProperty("cd3"))
                if (!$util.isInteger(message.cd3))
                    return "cd3: integer expected";
            if (message.cd4 != null && message.hasOwnProperty("cd4"))
                if (!$util.isInteger(message.cd4))
                    return "cd4: integer expected";
            if (message.cd5 != null && message.hasOwnProperty("cd5"))
                if (!$util.isInteger(message.cd5))
                    return "cd5: integer expected";
            return null;
        };
    
        /**
         * Creates a dot_info message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dot_info
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dot_info} dot_info
         */
        dot_info.fromObject = function fromObject(object) {
            if (object instanceof $root.dot_info)
                return object;
            var message = new $root.dot_info();
            if (object.id != null)
                message.id = object.id >>> 0;
            if (object.powerId != null)
                message.powerId = object.powerId >>> 0;
            if (object.degree != null)
                message.degree = object.degree | 0;
            if (object.max != null)
                message.max = object.max | 0;
            if (object.status != null)
                message.status = object.status >>> 0;
            if (object.item != null)
                message.item = object.item | 0;
            if (object.buff) {
                if (!Array.isArray(object.buff))
                    throw TypeError(".dot_info.buff: array expected");
                message.buff = [];
                for (var i = 0; i < object.buff.length; ++i) {
                    if (typeof object.buff[i] !== "object")
                        throw TypeError(".dot_info.buff: object expected");
                    message.buff[i] = $root.pb_item.fromObject(object.buff[i]);
                }
            }
            if (object.tmpId != null)
                message.tmpId = object.tmpId | 0;
            if (object.skill) {
                if (!Array.isArray(object.skill))
                    throw TypeError(".dot_info.skill: array expected");
                message.skill = [];
                for (var i = 0; i < object.skill.length; ++i)
                    message.skill[i] = object.skill[i] | 0;
            }
            if (object.cd != null)
                message.cd = object.cd | 0;
            if (object.cd2 != null)
                message.cd2 = object.cd2 | 0;
            if (object.cd3 != null)
                message.cd3 = object.cd3 | 0;
            if (object.cd4 != null)
                message.cd4 = object.cd4 | 0;
            if (object.cd5 != null)
                message.cd5 = object.cd5 | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a dot_info message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dot_info
         * @static
         * @param {dot_info} message dot_info
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        dot_info.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.buff = [];
                object.skill = [];
            }
            if (options.defaults) {
                object.id = 0;
                object.powerId = 0;
                object.degree = 0;
                object.max = 0;
                object.status = 0;
                object.item = 0;
                object.tmpId = 0;
                object.cd = 0;
                object.cd2 = 0;
                object.cd3 = 0;
                object.cd4 = 0;
                object.cd5 = 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.powerId != null && message.hasOwnProperty("powerId"))
                object.powerId = message.powerId;
            if (message.degree != null && message.hasOwnProperty("degree"))
                object.degree = message.degree;
            if (message.max != null && message.hasOwnProperty("max"))
                object.max = message.max;
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = message.status;
            if (message.item != null && message.hasOwnProperty("item"))
                object.item = message.item;
            if (message.buff && message.buff.length) {
                object.buff = [];
                for (var j = 0; j < message.buff.length; ++j)
                    object.buff[j] = $root.pb_item.toObject(message.buff[j], options);
            }
            if (message.tmpId != null && message.hasOwnProperty("tmpId"))
                object.tmpId = message.tmpId;
            if (message.skill && message.skill.length) {
                object.skill = [];
                for (var j = 0; j < message.skill.length; ++j)
                    object.skill[j] = message.skill[j];
            }
            if (message.cd != null && message.hasOwnProperty("cd"))
                object.cd = message.cd;
            if (message.cd2 != null && message.hasOwnProperty("cd2"))
                object.cd2 = message.cd2;
            if (message.cd3 != null && message.hasOwnProperty("cd3"))
                object.cd3 = message.cd3;
            if (message.cd4 != null && message.hasOwnProperty("cd4"))
                object.cd4 = message.cd4;
            if (message.cd5 != null && message.hasOwnProperty("cd5"))
                object.cd5 = message.cd5;
            return object;
        };
    
        /**
         * Converts this dot_info to JSON.
         * @function toJSON
         * @memberof dot_info
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        dot_info.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for dot_info
         * @function getTypeUrl
         * @memberof dot_info
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        dot_info.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/dot_info";
        };
    
        return dot_info;
    })();
    
    $root.dot_log = (function() {
    
        /**
         * Properties of a dot_log.
         * @exports Idot_log
         * @interface Idot_log
         * @property {number|null} [type] dot_log type
         * @property {number|null} [degree] dot_log degree
         * @property {string|null} [time] dot_log time
         * @property {number|null} [id] dot_log id
         * @property {number|null} [add] dot_log add
         */
    
        /**
         * Constructs a new dot_log.
         * @exports dot_log
         * @classdesc Represents a dot_log.
         * @implements Idot_log
         * @constructor
         * @param {Idot_log=} [properties] Properties to set
         */
        function dot_log(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * dot_log type.
         * @member {number} type
         * @memberof dot_log
         * @instance
         */
        dot_log.prototype.type = 0;
    
        /**
         * dot_log degree.
         * @member {number} degree
         * @memberof dot_log
         * @instance
         */
        dot_log.prototype.degree = 0;
    
        /**
         * dot_log time.
         * @member {string} time
         * @memberof dot_log
         * @instance
         */
        dot_log.prototype.time = "";
    
        /**
         * dot_log id.
         * @member {number} id
         * @memberof dot_log
         * @instance
         */
        dot_log.prototype.id = 0;
    
        /**
         * dot_log add.
         * @member {number} add
         * @memberof dot_log
         * @instance
         */
        dot_log.prototype.add = 0;
    
        /**
         * Creates a new dot_log instance using the specified properties.
         * @function create
         * @memberof dot_log
         * @static
         * @param {Idot_log=} [properties] Properties to set
         * @returns {dot_log} dot_log instance
         */
        dot_log.create = function create(properties) {
            return new dot_log(properties);
        };
    
        /**
         * Encodes the specified dot_log message. Does not implicitly {@link dot_log.verify|verify} messages.
         * @function encode
         * @memberof dot_log
         * @static
         * @param {Idot_log} message dot_log message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        dot_log.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.type);
            if (message.degree != null && Object.hasOwnProperty.call(message, "degree"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.degree);
            if (message.time != null && Object.hasOwnProperty.call(message, "time"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.time);
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.id);
            if (message.add != null && Object.hasOwnProperty.call(message, "add"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.add);
            return writer;
        };
    
        /**
         * Encodes the specified dot_log message, length delimited. Does not implicitly {@link dot_log.verify|verify} messages.
         * @function encodeDelimited
         * @memberof dot_log
         * @static
         * @param {Idot_log} message dot_log message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        dot_log.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a dot_log message from the specified reader or buffer.
         * @function decode
         * @memberof dot_log
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {dot_log} dot_log
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        dot_log.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.dot_log();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.type = reader.uint32();
                        break;
                    }
                case 2: {
                        message.degree = reader.int32();
                        break;
                    }
                case 3: {
                        message.time = reader.string();
                        break;
                    }
                case 4: {
                        message.id = reader.int32();
                        break;
                    }
                case 5: {
                        message.add = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a dot_log message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof dot_log
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {dot_log} dot_log
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        dot_log.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a dot_log message.
         * @function verify
         * @memberof dot_log
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        dot_log.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isInteger(message.type))
                    return "type: integer expected";
            if (message.degree != null && message.hasOwnProperty("degree"))
                if (!$util.isInteger(message.degree))
                    return "degree: integer expected";
            if (message.time != null && message.hasOwnProperty("time"))
                if (!$util.isString(message.time))
                    return "time: string expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id))
                    return "id: integer expected";
            if (message.add != null && message.hasOwnProperty("add"))
                if (!$util.isInteger(message.add))
                    return "add: integer expected";
            return null;
        };
    
        /**
         * Creates a dot_log message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof dot_log
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {dot_log} dot_log
         */
        dot_log.fromObject = function fromObject(object) {
            if (object instanceof $root.dot_log)
                return object;
            var message = new $root.dot_log();
            if (object.type != null)
                message.type = object.type >>> 0;
            if (object.degree != null)
                message.degree = object.degree | 0;
            if (object.time != null)
                message.time = String(object.time);
            if (object.id != null)
                message.id = object.id | 0;
            if (object.add != null)
                message.add = object.add | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a dot_log message. Also converts values to other types if specified.
         * @function toObject
         * @memberof dot_log
         * @static
         * @param {dot_log} message dot_log
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        dot_log.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.type = 0;
                object.degree = 0;
                object.time = "";
                object.id = 0;
                object.add = 0;
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            if (message.degree != null && message.hasOwnProperty("degree"))
                object.degree = message.degree;
            if (message.time != null && message.hasOwnProperty("time"))
                object.time = message.time;
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.add != null && message.hasOwnProperty("add"))
                object.add = message.add;
            return object;
        };
    
        /**
         * Converts this dot_log to JSON.
         * @function toJSON
         * @memberof dot_log
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        dot_log.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for dot_log
         * @function getTypeUrl
         * @memberof dot_log
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        dot_log.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/dot_log";
        };
    
        return dot_log;
    })();
    
    $root.power_monster = (function() {
    
        /**
         * Properties of a power_monster.
         * @exports Ipower_monster
         * @interface Ipower_monster
         * @property {number} id power_monster id
         * @property {Array.<Ipb_unit>|null} [camp] power_monster camp
         * @property {Array.<number>|null} [buff] power_monster buff
         */
    
        /**
         * Constructs a new power_monster.
         * @exports power_monster
         * @classdesc Represents a power_monster.
         * @implements Ipower_monster
         * @constructor
         * @param {Ipower_monster=} [properties] Properties to set
         */
        function power_monster(properties) {
            this.camp = [];
            this.buff = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * power_monster id.
         * @member {number} id
         * @memberof power_monster
         * @instance
         */
        power_monster.prototype.id = 0;
    
        /**
         * power_monster camp.
         * @member {Array.<Ipb_unit>} camp
         * @memberof power_monster
         * @instance
         */
        power_monster.prototype.camp = $util.emptyArray;
    
        /**
         * power_monster buff.
         * @member {Array.<number>} buff
         * @memberof power_monster
         * @instance
         */
        power_monster.prototype.buff = $util.emptyArray;
    
        /**
         * Creates a new power_monster instance using the specified properties.
         * @function create
         * @memberof power_monster
         * @static
         * @param {Ipower_monster=} [properties] Properties to set
         * @returns {power_monster} power_monster instance
         */
        power_monster.create = function create(properties) {
            return new power_monster(properties);
        };
    
        /**
         * Encodes the specified power_monster message. Does not implicitly {@link power_monster.verify|verify} messages.
         * @function encode
         * @memberof power_monster
         * @static
         * @param {Ipower_monster} message power_monster message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        power_monster.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.id);
            if (message.camp != null && message.camp.length)
                for (var i = 0; i < message.camp.length; ++i)
                    $root.pb_unit.encode(message.camp[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.buff != null && message.buff.length)
                for (var i = 0; i < message.buff.length; ++i)
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.buff[i]);
            return writer;
        };
    
        /**
         * Encodes the specified power_monster message, length delimited. Does not implicitly {@link power_monster.verify|verify} messages.
         * @function encodeDelimited
         * @memberof power_monster
         * @static
         * @param {Ipower_monster} message power_monster message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        power_monster.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a power_monster message from the specified reader or buffer.
         * @function decode
         * @memberof power_monster
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {power_monster} power_monster
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        power_monster.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.power_monster();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.id = reader.int32();
                        break;
                    }
                case 2: {
                        if (!(message.camp && message.camp.length))
                            message.camp = [];
                        message.camp.push($root.pb_unit.decode(reader, reader.uint32()));
                        break;
                    }
                case 3: {
                        if (!(message.buff && message.buff.length))
                            message.buff = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.buff.push(reader.int32());
                        } else
                            message.buff.push(reader.int32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("id"))
                throw $util.ProtocolError("missing required 'id'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a power_monster message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof power_monster
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {power_monster} power_monster
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        power_monster.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a power_monster message.
         * @function verify
         * @memberof power_monster
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        power_monster.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.id))
                return "id: integer expected";
            if (message.camp != null && message.hasOwnProperty("camp")) {
                if (!Array.isArray(message.camp))
                    return "camp: array expected";
                for (var i = 0; i < message.camp.length; ++i) {
                    var error = $root.pb_unit.verify(message.camp[i]);
                    if (error)
                        return "camp." + error;
                }
            }
            if (message.buff != null && message.hasOwnProperty("buff")) {
                if (!Array.isArray(message.buff))
                    return "buff: array expected";
                for (var i = 0; i < message.buff.length; ++i)
                    if (!$util.isInteger(message.buff[i]))
                        return "buff: integer[] expected";
            }
            return null;
        };
    
        /**
         * Creates a power_monster message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof power_monster
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {power_monster} power_monster
         */
        power_monster.fromObject = function fromObject(object) {
            if (object instanceof $root.power_monster)
                return object;
            var message = new $root.power_monster();
            if (object.id != null)
                message.id = object.id | 0;
            if (object.camp) {
                if (!Array.isArray(object.camp))
                    throw TypeError(".power_monster.camp: array expected");
                message.camp = [];
                for (var i = 0; i < object.camp.length; ++i) {
                    if (typeof object.camp[i] !== "object")
                        throw TypeError(".power_monster.camp: object expected");
                    message.camp[i] = $root.pb_unit.fromObject(object.camp[i]);
                }
            }
            if (object.buff) {
                if (!Array.isArray(object.buff))
                    throw TypeError(".power_monster.buff: array expected");
                message.buff = [];
                for (var i = 0; i < object.buff.length; ++i)
                    message.buff[i] = object.buff[i] | 0;
            }
            return message;
        };
    
        /**
         * Creates a plain object from a power_monster message. Also converts values to other types if specified.
         * @function toObject
         * @memberof power_monster
         * @static
         * @param {power_monster} message power_monster
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        power_monster.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.camp = [];
                object.buff = [];
            }
            if (options.defaults)
                object.id = 0;
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.camp && message.camp.length) {
                object.camp = [];
                for (var j = 0; j < message.camp.length; ++j)
                    object.camp[j] = $root.pb_unit.toObject(message.camp[j], options);
            }
            if (message.buff && message.buff.length) {
                object.buff = [];
                for (var j = 0; j < message.buff.length; ++j)
                    object.buff[j] = message.buff[j];
            }
            return object;
        };
    
        /**
         * Converts this power_monster to JSON.
         * @function toJSON
         * @memberof power_monster
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        power_monster.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for power_monster
         * @function getTypeUrl
         * @memberof power_monster
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        power_monster.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/power_monster";
        };
    
        return power_monster;
    })();
    
    $root.power_skill = (function() {
    
        /**
         * Properties of a power_skill.
         * @exports Ipower_skill
         * @interface Ipower_skill
         * @property {number} id power_skill id
         * @property {string|null} [name] power_skill name
         * @property {Array.<number>|null} [skill] power_skill skill
         * @property {number|null} [cd] power_skill cd
         */
    
        /**
         * Constructs a new power_skill.
         * @exports power_skill
         * @classdesc Represents a power_skill.
         * @implements Ipower_skill
         * @constructor
         * @param {Ipower_skill=} [properties] Properties to set
         */
        function power_skill(properties) {
            this.skill = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * power_skill id.
         * @member {number} id
         * @memberof power_skill
         * @instance
         */
        power_skill.prototype.id = 0;
    
        /**
         * power_skill name.
         * @member {string} name
         * @memberof power_skill
         * @instance
         */
        power_skill.prototype.name = "";
    
        /**
         * power_skill skill.
         * @member {Array.<number>} skill
         * @memberof power_skill
         * @instance
         */
        power_skill.prototype.skill = $util.emptyArray;
    
        /**
         * power_skill cd.
         * @member {number} cd
         * @memberof power_skill
         * @instance
         */
        power_skill.prototype.cd = 0;
    
        /**
         * Creates a new power_skill instance using the specified properties.
         * @function create
         * @memberof power_skill
         * @static
         * @param {Ipower_skill=} [properties] Properties to set
         * @returns {power_skill} power_skill instance
         */
        power_skill.create = function create(properties) {
            return new power_skill(properties);
        };
    
        /**
         * Encodes the specified power_skill message. Does not implicitly {@link power_skill.verify|verify} messages.
         * @function encode
         * @memberof power_skill
         * @static
         * @param {Ipower_skill} message power_skill message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        power_skill.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.id);
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
            if (message.skill != null && message.skill.length)
                for (var i = 0; i < message.skill.length; ++i)
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.skill[i]);
            if (message.cd != null && Object.hasOwnProperty.call(message, "cd"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.cd);
            return writer;
        };
    
        /**
         * Encodes the specified power_skill message, length delimited. Does not implicitly {@link power_skill.verify|verify} messages.
         * @function encodeDelimited
         * @memberof power_skill
         * @static
         * @param {Ipower_skill} message power_skill message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        power_skill.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a power_skill message from the specified reader or buffer.
         * @function decode
         * @memberof power_skill
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {power_skill} power_skill
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        power_skill.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.power_skill();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.id = reader.int32();
                        break;
                    }
                case 2: {
                        message.name = reader.string();
                        break;
                    }
                case 3: {
                        if (!(message.skill && message.skill.length))
                            message.skill = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.skill.push(reader.int32());
                        } else
                            message.skill.push(reader.int32());
                        break;
                    }
                case 4: {
                        message.cd = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("id"))
                throw $util.ProtocolError("missing required 'id'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a power_skill message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof power_skill
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {power_skill} power_skill
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        power_skill.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a power_skill message.
         * @function verify
         * @memberof power_skill
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        power_skill.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.id))
                return "id: integer expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.skill != null && message.hasOwnProperty("skill")) {
                if (!Array.isArray(message.skill))
                    return "skill: array expected";
                for (var i = 0; i < message.skill.length; ++i)
                    if (!$util.isInteger(message.skill[i]))
                        return "skill: integer[] expected";
            }
            if (message.cd != null && message.hasOwnProperty("cd"))
                if (!$util.isInteger(message.cd))
                    return "cd: integer expected";
            return null;
        };
    
        /**
         * Creates a power_skill message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof power_skill
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {power_skill} power_skill
         */
        power_skill.fromObject = function fromObject(object) {
            if (object instanceof $root.power_skill)
                return object;
            var message = new $root.power_skill();
            if (object.id != null)
                message.id = object.id | 0;
            if (object.name != null)
                message.name = String(object.name);
            if (object.skill) {
                if (!Array.isArray(object.skill))
                    throw TypeError(".power_skill.skill: array expected");
                message.skill = [];
                for (var i = 0; i < object.skill.length; ++i)
                    message.skill[i] = object.skill[i] | 0;
            }
            if (object.cd != null)
                message.cd = object.cd | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a power_skill message. Also converts values to other types if specified.
         * @function toObject
         * @memberof power_skill
         * @static
         * @param {power_skill} message power_skill
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        power_skill.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.skill = [];
            if (options.defaults) {
                object.id = 0;
                object.name = "";
                object.cd = 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.skill && message.skill.length) {
                object.skill = [];
                for (var j = 0; j < message.skill.length; ++j)
                    object.skill[j] = message.skill[j];
            }
            if (message.cd != null && message.hasOwnProperty("cd"))
                object.cd = message.cd;
            return object;
        };
    
        /**
         * Converts this power_skill to JSON.
         * @function toJSON
         * @memberof power_skill
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        power_skill.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for power_skill
         * @function getTypeUrl
         * @memberof power_skill
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        power_skill.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/power_skill";
        };
    
        return power_skill;
    })();
    
    $root.power_manager = (function() {
    
        /**
         * Properties of a power_manager.
         * @exports Ipower_manager
         * @interface Ipower_manager
         * @property {string|null} [udk] power_manager udk
         * @property {string|null} [cluster] power_manager cluster
         * @property {number|Long|null} [uid] power_manager uid
         */
    
        /**
         * Constructs a new power_manager.
         * @exports power_manager
         * @classdesc Represents a power_manager.
         * @implements Ipower_manager
         * @constructor
         * @param {Ipower_manager=} [properties] Properties to set
         */
        function power_manager(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * power_manager udk.
         * @member {string} udk
         * @memberof power_manager
         * @instance
         */
        power_manager.prototype.udk = "";
    
        /**
         * power_manager cluster.
         * @member {string} cluster
         * @memberof power_manager
         * @instance
         */
        power_manager.prototype.cluster = "";
    
        /**
         * power_manager uid.
         * @member {number|Long} uid
         * @memberof power_manager
         * @instance
         */
        power_manager.prototype.uid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
        /**
         * Creates a new power_manager instance using the specified properties.
         * @function create
         * @memberof power_manager
         * @static
         * @param {Ipower_manager=} [properties] Properties to set
         * @returns {power_manager} power_manager instance
         */
        power_manager.create = function create(properties) {
            return new power_manager(properties);
        };
    
        /**
         * Encodes the specified power_manager message. Does not implicitly {@link power_manager.verify|verify} messages.
         * @function encode
         * @memberof power_manager
         * @static
         * @param {Ipower_manager} message power_manager message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        power_manager.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.udk != null && Object.hasOwnProperty.call(message, "udk"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.udk);
            if (message.cluster != null && Object.hasOwnProperty.call(message, "cluster"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.cluster);
            if (message.uid != null && Object.hasOwnProperty.call(message, "uid"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.uid);
            return writer;
        };
    
        /**
         * Encodes the specified power_manager message, length delimited. Does not implicitly {@link power_manager.verify|verify} messages.
         * @function encodeDelimited
         * @memberof power_manager
         * @static
         * @param {Ipower_manager} message power_manager message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        power_manager.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a power_manager message from the specified reader or buffer.
         * @function decode
         * @memberof power_manager
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {power_manager} power_manager
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        power_manager.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.power_manager();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.udk = reader.string();
                        break;
                    }
                case 2: {
                        message.cluster = reader.string();
                        break;
                    }
                case 3: {
                        message.uid = reader.int64();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a power_manager message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof power_manager
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {power_manager} power_manager
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        power_manager.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a power_manager message.
         * @function verify
         * @memberof power_manager
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        power_manager.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.udk != null && message.hasOwnProperty("udk"))
                if (!$util.isString(message.udk))
                    return "udk: string expected";
            if (message.cluster != null && message.hasOwnProperty("cluster"))
                if (!$util.isString(message.cluster))
                    return "cluster: string expected";
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (!$util.isInteger(message.uid) && !(message.uid && $util.isInteger(message.uid.low) && $util.isInteger(message.uid.high)))
                    return "uid: integer|Long expected";
            return null;
        };
    
        /**
         * Creates a power_manager message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof power_manager
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {power_manager} power_manager
         */
        power_manager.fromObject = function fromObject(object) {
            if (object instanceof $root.power_manager)
                return object;
            var message = new $root.power_manager();
            if (object.udk != null)
                message.udk = String(object.udk);
            if (object.cluster != null)
                message.cluster = String(object.cluster);
            if (object.uid != null)
                if ($util.Long)
                    (message.uid = $util.Long.fromValue(object.uid)).unsigned = false;
                else if (typeof object.uid === "string")
                    message.uid = parseInt(object.uid, 10);
                else if (typeof object.uid === "number")
                    message.uid = object.uid;
                else if (typeof object.uid === "object")
                    message.uid = new $util.LongBits(object.uid.low >>> 0, object.uid.high >>> 0).toNumber();
            return message;
        };
    
        /**
         * Creates a plain object from a power_manager message. Also converts values to other types if specified.
         * @function toObject
         * @memberof power_manager
         * @static
         * @param {power_manager} message power_manager
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        power_manager.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.udk = "";
                object.cluster = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.uid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.uid = options.longs === String ? "0" : 0;
            }
            if (message.udk != null && message.hasOwnProperty("udk"))
                object.udk = message.udk;
            if (message.cluster != null && message.hasOwnProperty("cluster"))
                object.cluster = message.cluster;
            if (message.uid != null && message.hasOwnProperty("uid"))
                if (typeof message.uid === "number")
                    object.uid = options.longs === String ? String(message.uid) : message.uid;
                else
                    object.uid = options.longs === String ? $util.Long.prototype.toString.call(message.uid) : options.longs === Number ? new $util.LongBits(message.uid.low >>> 0, message.uid.high >>> 0).toNumber() : message.uid;
            return object;
        };
    
        /**
         * Converts this power_manager to JSON.
         * @function toJSON
         * @memberof power_manager
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        power_manager.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for power_manager
         * @function getTypeUrl
         * @memberof power_manager
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        power_manager.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/power_manager";
        };
    
        return power_manager;
    })();
    
    $root.stower_breed = (function() {
    
        /**
         * Properties of a stower_breed.
         * @exports Istower_breed
         * @interface Istower_breed
         * @property {number} id stower_breed id
         * @property {number} pid1 stower_breed pid1
         * @property {number} pid2 stower_breed pid2
         * @property {number} cd stower_breed cd
         * @property {number} egg stower_breed egg
         */
    
        /**
         * Constructs a new stower_breed.
         * @exports stower_breed
         * @classdesc Represents a stower_breed.
         * @implements Istower_breed
         * @constructor
         * @param {Istower_breed=} [properties] Properties to set
         */
        function stower_breed(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * stower_breed id.
         * @member {number} id
         * @memberof stower_breed
         * @instance
         */
        stower_breed.prototype.id = 0;
    
        /**
         * stower_breed pid1.
         * @member {number} pid1
         * @memberof stower_breed
         * @instance
         */
        stower_breed.prototype.pid1 = 0;
    
        /**
         * stower_breed pid2.
         * @member {number} pid2
         * @memberof stower_breed
         * @instance
         */
        stower_breed.prototype.pid2 = 0;
    
        /**
         * stower_breed cd.
         * @member {number} cd
         * @memberof stower_breed
         * @instance
         */
        stower_breed.prototype.cd = 0;
    
        /**
         * stower_breed egg.
         * @member {number} egg
         * @memberof stower_breed
         * @instance
         */
        stower_breed.prototype.egg = 0;
    
        /**
         * Creates a new stower_breed instance using the specified properties.
         * @function create
         * @memberof stower_breed
         * @static
         * @param {Istower_breed=} [properties] Properties to set
         * @returns {stower_breed} stower_breed instance
         */
        stower_breed.create = function create(properties) {
            return new stower_breed(properties);
        };
    
        /**
         * Encodes the specified stower_breed message. Does not implicitly {@link stower_breed.verify|verify} messages.
         * @function encode
         * @memberof stower_breed
         * @static
         * @param {Istower_breed} message stower_breed message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        stower_breed.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).sint32(message.id);
            writer.uint32(/* id 2, wireType 0 =*/16).sint32(message.pid1);
            writer.uint32(/* id 3, wireType 0 =*/24).sint32(message.pid2);
            writer.uint32(/* id 4, wireType 0 =*/32).int32(message.cd);
            writer.uint32(/* id 5, wireType 0 =*/40).sint32(message.egg);
            return writer;
        };
    
        /**
         * Encodes the specified stower_breed message, length delimited. Does not implicitly {@link stower_breed.verify|verify} messages.
         * @function encodeDelimited
         * @memberof stower_breed
         * @static
         * @param {Istower_breed} message stower_breed message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        stower_breed.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a stower_breed message from the specified reader or buffer.
         * @function decode
         * @memberof stower_breed
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {stower_breed} stower_breed
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        stower_breed.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.stower_breed();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.id = reader.sint32();
                        break;
                    }
                case 2: {
                        message.pid1 = reader.sint32();
                        break;
                    }
                case 3: {
                        message.pid2 = reader.sint32();
                        break;
                    }
                case 4: {
                        message.cd = reader.int32();
                        break;
                    }
                case 5: {
                        message.egg = reader.sint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("id"))
                throw $util.ProtocolError("missing required 'id'", { instance: message });
            if (!message.hasOwnProperty("pid1"))
                throw $util.ProtocolError("missing required 'pid1'", { instance: message });
            if (!message.hasOwnProperty("pid2"))
                throw $util.ProtocolError("missing required 'pid2'", { instance: message });
            if (!message.hasOwnProperty("cd"))
                throw $util.ProtocolError("missing required 'cd'", { instance: message });
            if (!message.hasOwnProperty("egg"))
                throw $util.ProtocolError("missing required 'egg'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a stower_breed message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof stower_breed
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {stower_breed} stower_breed
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        stower_breed.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a stower_breed message.
         * @function verify
         * @memberof stower_breed
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        stower_breed.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.id))
                return "id: integer expected";
            if (!$util.isInteger(message.pid1))
                return "pid1: integer expected";
            if (!$util.isInteger(message.pid2))
                return "pid2: integer expected";
            if (!$util.isInteger(message.cd))
                return "cd: integer expected";
            if (!$util.isInteger(message.egg))
                return "egg: integer expected";
            return null;
        };
    
        /**
         * Creates a stower_breed message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof stower_breed
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {stower_breed} stower_breed
         */
        stower_breed.fromObject = function fromObject(object) {
            if (object instanceof $root.stower_breed)
                return object;
            var message = new $root.stower_breed();
            if (object.id != null)
                message.id = object.id | 0;
            if (object.pid1 != null)
                message.pid1 = object.pid1 | 0;
            if (object.pid2 != null)
                message.pid2 = object.pid2 | 0;
            if (object.cd != null)
                message.cd = object.cd | 0;
            if (object.egg != null)
                message.egg = object.egg | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a stower_breed message. Also converts values to other types if specified.
         * @function toObject
         * @memberof stower_breed
         * @static
         * @param {stower_breed} message stower_breed
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        stower_breed.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = 0;
                object.pid1 = 0;
                object.pid2 = 0;
                object.cd = 0;
                object.egg = 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.pid1 != null && message.hasOwnProperty("pid1"))
                object.pid1 = message.pid1;
            if (message.pid2 != null && message.hasOwnProperty("pid2"))
                object.pid2 = message.pid2;
            if (message.cd != null && message.hasOwnProperty("cd"))
                object.cd = message.cd;
            if (message.egg != null && message.hasOwnProperty("egg"))
                object.egg = message.egg;
            return object;
        };
    
        /**
         * Converts this stower_breed to JSON.
         * @function toJSON
         * @memberof stower_breed
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        stower_breed.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for stower_breed
         * @function getTypeUrl
         * @memberof stower_breed
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        stower_breed.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/stower_breed";
        };
    
        return stower_breed;
    })();
    
    $root.stower_lucky = (function() {
    
        /**
         * Properties of a stower_lucky.
         * @exports Istower_lucky
         * @interface Istower_lucky
         * @property {number} id stower_lucky id
         * @property {Array.<number>|null} [ratio] stower_lucky ratio
         */
    
        /**
         * Constructs a new stower_lucky.
         * @exports stower_lucky
         * @classdesc Represents a stower_lucky.
         * @implements Istower_lucky
         * @constructor
         * @param {Istower_lucky=} [properties] Properties to set
         */
        function stower_lucky(properties) {
            this.ratio = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * stower_lucky id.
         * @member {number} id
         * @memberof stower_lucky
         * @instance
         */
        stower_lucky.prototype.id = 0;
    
        /**
         * stower_lucky ratio.
         * @member {Array.<number>} ratio
         * @memberof stower_lucky
         * @instance
         */
        stower_lucky.prototype.ratio = $util.emptyArray;
    
        /**
         * Creates a new stower_lucky instance using the specified properties.
         * @function create
         * @memberof stower_lucky
         * @static
         * @param {Istower_lucky=} [properties] Properties to set
         * @returns {stower_lucky} stower_lucky instance
         */
        stower_lucky.create = function create(properties) {
            return new stower_lucky(properties);
        };
    
        /**
         * Encodes the specified stower_lucky message. Does not implicitly {@link stower_lucky.verify|verify} messages.
         * @function encode
         * @memberof stower_lucky
         * @static
         * @param {Istower_lucky} message stower_lucky message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        stower_lucky.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).sint32(message.id);
            if (message.ratio != null && message.ratio.length)
                for (var i = 0; i < message.ratio.length; ++i)
                    writer.uint32(/* id 2, wireType 0 =*/16).sint32(message.ratio[i]);
            return writer;
        };
    
        /**
         * Encodes the specified stower_lucky message, length delimited. Does not implicitly {@link stower_lucky.verify|verify} messages.
         * @function encodeDelimited
         * @memberof stower_lucky
         * @static
         * @param {Istower_lucky} message stower_lucky message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        stower_lucky.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a stower_lucky message from the specified reader or buffer.
         * @function decode
         * @memberof stower_lucky
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {stower_lucky} stower_lucky
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        stower_lucky.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.stower_lucky();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.id = reader.sint32();
                        break;
                    }
                case 2: {
                        if (!(message.ratio && message.ratio.length))
                            message.ratio = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.ratio.push(reader.sint32());
                        } else
                            message.ratio.push(reader.sint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("id"))
                throw $util.ProtocolError("missing required 'id'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a stower_lucky message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof stower_lucky
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {stower_lucky} stower_lucky
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        stower_lucky.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a stower_lucky message.
         * @function verify
         * @memberof stower_lucky
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        stower_lucky.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (!$util.isInteger(message.id))
                return "id: integer expected";
            if (message.ratio != null && message.hasOwnProperty("ratio")) {
                if (!Array.isArray(message.ratio))
                    return "ratio: array expected";
                for (var i = 0; i < message.ratio.length; ++i)
                    if (!$util.isInteger(message.ratio[i]))
                        return "ratio: integer[] expected";
            }
            return null;
        };
    
        /**
         * Creates a stower_lucky message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof stower_lucky
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {stower_lucky} stower_lucky
         */
        stower_lucky.fromObject = function fromObject(object) {
            if (object instanceof $root.stower_lucky)
                return object;
            var message = new $root.stower_lucky();
            if (object.id != null)
                message.id = object.id | 0;
            if (object.ratio) {
                if (!Array.isArray(object.ratio))
                    throw TypeError(".stower_lucky.ratio: array expected");
                message.ratio = [];
                for (var i = 0; i < object.ratio.length; ++i)
                    message.ratio[i] = object.ratio[i] | 0;
            }
            return message;
        };
    
        /**
         * Creates a plain object from a stower_lucky message. Also converts values to other types if specified.
         * @function toObject
         * @memberof stower_lucky
         * @static
         * @param {stower_lucky} message stower_lucky
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        stower_lucky.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.ratio = [];
            if (options.defaults)
                object.id = 0;
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.ratio && message.ratio.length) {
                object.ratio = [];
                for (var j = 0; j < message.ratio.length; ++j)
                    object.ratio[j] = message.ratio[j];
            }
            return object;
        };
    
        /**
         * Converts this stower_lucky to JSON.
         * @function toJSON
         * @memberof stower_lucky
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        stower_lucky.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for stower_lucky
         * @function getTypeUrl
         * @memberof stower_lucky
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        stower_lucky.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/stower_lucky";
        };
    
        return stower_lucky;
    })();
    
    $root.power_log = (function() {
    
        /**
         * Properties of a power_log.
         * @exports Ipower_log
         * @interface Ipower_log
         * @property {number|null} [type] power_log type
         * @property {number|null} [job] power_log job
         * @property {string|null} [time] power_log time
         * @property {string|null} [name] power_log name
         * @property {number|null} [point] power_log point
         * @property {number|null} [buff] power_log buff
         */
    
        /**
         * Constructs a new power_log.
         * @exports power_log
         * @classdesc Represents a power_log.
         * @implements Ipower_log
         * @constructor
         * @param {Ipower_log=} [properties] Properties to set
         */
        function power_log(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * power_log type.
         * @member {number} type
         * @memberof power_log
         * @instance
         */
        power_log.prototype.type = 0;
    
        /**
         * power_log job.
         * @member {number} job
         * @memberof power_log
         * @instance
         */
        power_log.prototype.job = 0;
    
        /**
         * power_log time.
         * @member {string} time
         * @memberof power_log
         * @instance
         */
        power_log.prototype.time = "";
    
        /**
         * power_log name.
         * @member {string} name
         * @memberof power_log
         * @instance
         */
        power_log.prototype.name = "";
    
        /**
         * power_log point.
         * @member {number} point
         * @memberof power_log
         * @instance
         */
        power_log.prototype.point = 0;
    
        /**
         * power_log buff.
         * @member {number} buff
         * @memberof power_log
         * @instance
         */
        power_log.prototype.buff = 0;
    
        /**
         * Creates a new power_log instance using the specified properties.
         * @function create
         * @memberof power_log
         * @static
         * @param {Ipower_log=} [properties] Properties to set
         * @returns {power_log} power_log instance
         */
        power_log.create = function create(properties) {
            return new power_log(properties);
        };
    
        /**
         * Encodes the specified power_log message. Does not implicitly {@link power_log.verify|verify} messages.
         * @function encode
         * @memberof power_log
         * @static
         * @param {Ipower_log} message power_log message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        power_log.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.type);
            if (message.job != null && Object.hasOwnProperty.call(message, "job"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.job);
            if (message.time != null && Object.hasOwnProperty.call(message, "time"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.time);
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.name);
            if (message.point != null && Object.hasOwnProperty.call(message, "point"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.point);
            if (message.buff != null && Object.hasOwnProperty.call(message, "buff"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.buff);
            return writer;
        };
    
        /**
         * Encodes the specified power_log message, length delimited. Does not implicitly {@link power_log.verify|verify} messages.
         * @function encodeDelimited
         * @memberof power_log
         * @static
         * @param {Ipower_log} message power_log message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        power_log.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a power_log message from the specified reader or buffer.
         * @function decode
         * @memberof power_log
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {power_log} power_log
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        power_log.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.power_log();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.type = reader.uint32();
                        break;
                    }
                case 2: {
                        message.job = reader.int32();
                        break;
                    }
                case 3: {
                        message.time = reader.string();
                        break;
                    }
                case 4: {
                        message.name = reader.string();
                        break;
                    }
                case 5: {
                        message.point = reader.int32();
                        break;
                    }
                case 6: {
                        message.buff = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a power_log message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof power_log
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {power_log} power_log
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        power_log.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a power_log message.
         * @function verify
         * @memberof power_log
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        power_log.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isInteger(message.type))
                    return "type: integer expected";
            if (message.job != null && message.hasOwnProperty("job"))
                if (!$util.isInteger(message.job))
                    return "job: integer expected";
            if (message.time != null && message.hasOwnProperty("time"))
                if (!$util.isString(message.time))
                    return "time: string expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.point != null && message.hasOwnProperty("point"))
                if (!$util.isInteger(message.point))
                    return "point: integer expected";
            if (message.buff != null && message.hasOwnProperty("buff"))
                if (!$util.isInteger(message.buff))
                    return "buff: integer expected";
            return null;
        };
    
        /**
         * Creates a power_log message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof power_log
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {power_log} power_log
         */
        power_log.fromObject = function fromObject(object) {
            if (object instanceof $root.power_log)
                return object;
            var message = new $root.power_log();
            if (object.type != null)
                message.type = object.type >>> 0;
            if (object.job != null)
                message.job = object.job | 0;
            if (object.time != null)
                message.time = String(object.time);
            if (object.name != null)
                message.name = String(object.name);
            if (object.point != null)
                message.point = object.point | 0;
            if (object.buff != null)
                message.buff = object.buff | 0;
            return message;
        };
    
        /**
         * Creates a plain object from a power_log message. Also converts values to other types if specified.
         * @function toObject
         * @memberof power_log
         * @static
         * @param {power_log} message power_log
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        power_log.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.type = 0;
                object.job = 0;
                object.time = "";
                object.name = "";
                object.point = 0;
                object.buff = 0;
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = message.type;
            if (message.job != null && message.hasOwnProperty("job"))
                object.job = message.job;
            if (message.time != null && message.hasOwnProperty("time"))
                object.time = message.time;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.point != null && message.hasOwnProperty("point"))
                object.point = message.point;
            if (message.buff != null && message.hasOwnProperty("buff"))
                object.buff = message.buff;
            return object;
        };
    
        /**
         * Converts this power_log to JSON.
         * @function toJSON
         * @memberof power_log
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        power_log.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Gets the default type url for power_log
         * @function getTypeUrl
         * @memberof power_log
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        power_log.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/power_log";
        };
    
        return power_log;
    })();

    return $root;
});
