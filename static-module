export function encodepb_player(message) {
  let bb = popByteBuffer();
  _encodepb_player(message, bb);
  return toUint8Array(bb);
}

function _encodepb_player(message, bb) {
  // required string name = 1;
  let $name = message.name;
  if ($name !== undefined) {
    writeVarint32(bb, 10);
    writeString(bb, $name);
  }

  // required int32 logo = 2;
  let $logo = message.logo;
  if ($logo !== undefined) {
    writeVarint32(bb, 16);
    writeVarint64(bb, intToLong($logo));
  }

  // optional int32 gid = 3;
  let $gid = message.gid;
  if ($gid !== undefined) {
    writeVarint32(bb, 24);
    writeVarint64(bb, intToLong($gid));
  }

  // optional string gname = 4;
  let $gname = message.gname;
  if ($gname !== undefined) {
    writeVarint32(bb, 34);
    writeString(bb, $gname);
  }

  // optional int32 border = 5;
  let $border = message.border;
  if ($border !== undefined) {
    writeVarint32(bb, 40);
    writeVarint64(bb, intToLong($border));
  }

  // optional int32 glv = 6;
  let $glv = message.glv;
  if ($glv !== undefined) {
    writeVarint32(bb, 48);
    writeVarint64(bb, intToLong($glv));
  }

  // optional string country = 7;
  let $country = message.country;
  if ($country !== undefined) {
    writeVarint32(bb, 58);
    writeString(bb, $country);
  }

  // optional string sds = 8;
  let $sds = message.sds;
  if ($sds !== undefined) {
    writeVarint32(bb, 66);
    writeString(bb, $sds);
  }

  // optional string city = 9;
  let $city = message.city;
  if ($city !== undefined) {
    writeVarint32(bb, 74);
    writeString(bb, $city);
  }
}

export function decodepb_player(binary) {
  return _decodepb_player(wrapByteBuffer(binary));
}

function _decodepb_player(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // required string name = 1;
      case 1: {
        message.name = readString(bb, readVarint32(bb));
        break;
      }

      // required int32 logo = 2;
      case 2: {
        message.logo = readVarint32(bb);
        break;
      }

      // optional int32 gid = 3;
      case 3: {
        message.gid = readVarint32(bb);
        break;
      }

      // optional string gname = 4;
      case 4: {
        message.gname = readString(bb, readVarint32(bb));
        break;
      }

      // optional int32 border = 5;
      case 5: {
        message.border = readVarint32(bb);
        break;
      }

      // optional int32 glv = 6;
      case 6: {
        message.glv = readVarint32(bb);
        break;
      }

      // optional string country = 7;
      case 7: {
        message.country = readString(bb, readVarint32(bb));
        break;
      }

      // optional string sds = 8;
      case 8: {
        message.sds = readString(bb, readVarint32(bb));
        break;
      }

      // optional string city = 9;
      case 9: {
        message.city = readString(bb, readVarint32(bb));
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  if (message.name === undefined)
    throw new Error("Missing required field: name");

  if (message.logo === undefined)
    throw new Error("Missing required field: logo");

  return message;
}

export function encodepb_server(message) {
  let bb = popByteBuffer();
  _encodepb_server(message, bb);
  return toUint8Array(bb);
}

function _encodepb_server(message, bb) {
  // required int32 sid = 1;
  let $sid = message.sid;
  if ($sid !== undefined) {
    writeVarint32(bb, 8);
    writeVarint64(bb, intToLong($sid));
  }

  // required string sname = 2;
  let $sname = message.sname;
  if ($sname !== undefined) {
    writeVarint32(bb, 18);
    writeString(bb, $sname);
  }

  // optional string pname = 3;
  let $pname = message.pname;
  if ($pname !== undefined) {
    writeVarint32(bb, 26);
    writeString(bb, $pname);
  }

  // optional int32 plogo = 4;
  let $plogo = message.plogo;
  if ($plogo !== undefined) {
    writeVarint32(bb, 32);
    writeVarint64(bb, intToLong($plogo));
  }

  // optional int32 plv = 5;
  let $plv = message.plv;
  if ($plv !== undefined) {
    writeVarint32(bb, 40);
    writeVarint64(bb, intToLong($plv));
  }

  // optional int32 flag = 6;
  let $flag = message.flag;
  if ($flag !== undefined) {
    writeVarint32(bb, 48);
    writeVarint64(bb, intToLong($flag));
  }

  // optional int32 uid = 7;
  let $uid = message.uid;
  if ($uid !== undefined) {
    writeVarint32(bb, 56);
    writeVarint64(bb, intToLong($uid));
  }

  // optional int32 border = 8;
  let $border = message.border;
  if ($border !== undefined) {
    writeVarint32(bb, 64);
    writeVarint64(bb, intToLong($border));
  }

  // optional int32 login_cd = 9;
  let $login_cd = message.login_cd;
  if ($login_cd !== undefined) {
    writeVarint32(bb, 72);
    writeVarint64(bb, intToLong($login_cd));
  }
}

export function decodepb_server(binary) {
  return _decodepb_server(wrapByteBuffer(binary));
}

function _decodepb_server(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // required int32 sid = 1;
      case 1: {
        message.sid = readVarint32(bb);
        break;
      }

      // required string sname = 2;
      case 2: {
        message.sname = readString(bb, readVarint32(bb));
        break;
      }

      // optional string pname = 3;
      case 3: {
        message.pname = readString(bb, readVarint32(bb));
        break;
      }

      // optional int32 plogo = 4;
      case 4: {
        message.plogo = readVarint32(bb);
        break;
      }

      // optional int32 plv = 5;
      case 5: {
        message.plv = readVarint32(bb);
        break;
      }

      // optional int32 flag = 6;
      case 6: {
        message.flag = readVarint32(bb);
        break;
      }

      // optional int32 uid = 7;
      case 7: {
        message.uid = readVarint32(bb);
        break;
      }

      // optional int32 border = 8;
      case 8: {
        message.border = readVarint32(bb);
        break;
      }

      // optional int32 login_cd = 9;
      case 9: {
        message.login_cd = readVarint32(bb);
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  if (message.sid === undefined)
    throw new Error("Missing required field: sid");

  if (message.sname === undefined)
    throw new Error("Missing required field: sname");

  return message;
}

export function encodepb_item(message) {
  let bb = popByteBuffer();
  _encodepb_item(message, bb);
  return toUint8Array(bb);
}

function _encodepb_item(message, bb) {
  // required int32 id = 1;
  let $id = message.id;
  if ($id !== undefined) {
    writeVarint32(bb, 8);
    writeVarint64(bb, intToLong($id));
  }

  // required int64 num = 2;
  let $num = message.num;
  if ($num !== undefined) {
    writeVarint32(bb, 16);
    writeVarint64(bb, $num);
  }
}

export function decodepb_item(binary) {
  return _decodepb_item(wrapByteBuffer(binary));
}

function _decodepb_item(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // required int32 id = 1;
      case 1: {
        message.id = readVarint32(bb);
        break;
      }

      // required int64 num = 2;
      case 2: {
        message.num = readVarint64(bb, /* unsigned */ false);
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  if (message.id === undefined)
    throw new Error("Missing required field: id");

  if (message.num === undefined)
    throw new Error("Missing required field: num");

  return message;
}

export function encodepb_equip(message) {
  let bb = popByteBuffer();
  _encodepb_equip(message, bb);
  return toUint8Array(bb);
}

function _encodepb_equip(message, bb) {
  // required int32 id = 1;
  let $id = message.id;
  if ($id !== undefined) {
    writeVarint32(bb, 8);
    writeVarint64(bb, intToLong($id));
  }

  // required uint32 num = 2;
  let $num = message.num;
  if ($num !== undefined) {
    writeVarint32(bb, 16);
    writeVarint32(bb, $num);
  }

  // optional int32 eid = 3;
  let $eid = message.eid;
  if ($eid !== undefined) {
    writeVarint32(bb, 24);
    writeVarint64(bb, intToLong($eid));
  }

  // optional int32 hid = 4;
  let $hid = message.hid;
  if ($hid !== undefined) {
    writeVarint32(bb, 32);
    writeVarint64(bb, intToLong($hid));
  }
}

export function decodepb_equip(binary) {
  return _decodepb_equip(wrapByteBuffer(binary));
}

function _decodepb_equip(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // required int32 id = 1;
      case 1: {
        message.id = readVarint32(bb);
        break;
      }

      // required uint32 num = 2;
      case 2: {
        message.num = readVarint32(bb) >>> 0;
        break;
      }

      // optional int32 eid = 3;
      case 3: {
        message.eid = readVarint32(bb);
        break;
      }

      // optional int32 hid = 4;
      case 4: {
        message.hid = readVarint32(bb);
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  if (message.id === undefined)
    throw new Error("Missing required field: id");

  if (message.num === undefined)
    throw new Error("Missing required field: num");

  return message;
}

export function encodepb_bag(message) {
  let bb = popByteBuffer();
  _encodepb_bag(message, bb);
  return toUint8Array(bb);
}

function _encodepb_bag(message, bb) {
  // repeated pb_item items = 1;
  let array$items = message.items;
  if (array$items !== undefined) {
    for (let value of array$items) {
      writeVarint32(bb, 10);
      let nested = popByteBuffer();
      _encodepb_item(value, nested);
      writeVarint32(bb, nested.limit);
      writeByteBuffer(bb, nested);
      pushByteBuffer(nested);
    }
  }

  // repeated pb_equip equips = 2;
  let array$equips = message.equips;
  if (array$equips !== undefined) {
    for (let value of array$equips) {
      writeVarint32(bb, 18);
      let nested = popByteBuffer();
      _encodepb_equip(value, nested);
      writeVarint32(bb, nested.limit);
      writeByteBuffer(bb, nested);
      pushByteBuffer(nested);
    }
  }
}

export function decodepb_bag(binary) {
  return _decodepb_bag(wrapByteBuffer(binary));
}

function _decodepb_bag(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // repeated pb_item items = 1;
      case 1: {
        let limit = pushTemporaryLength(bb);
        let values = message.items || (message.items = []);
        values.push(_decodepb_item(bb));
        bb.limit = limit;
        break;
      }

      // repeated pb_equip equips = 2;
      case 2: {
        let limit = pushTemporaryLength(bb);
        let values = message.equips || (message.equips = []);
        values.push(_decodepb_equip(bb));
        bb.limit = limit;
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  return message;
}

export function encodepb_hero_qlc(message) {
  let bb = popByteBuffer();
  _encodepb_hero_qlc(message, bb);
  return toUint8Array(bb);
}

function _encodepb_hero_qlc(message, bb) {
  // optional int32 lv = 1;
  let $lv = message.lv;
  if ($lv !== undefined) {
    writeVarint32(bb, 8);
    writeVarint64(bb, intToLong($lv));
  }

  // optional int32 atk = 2;
  let $atk = message.atk;
  if ($atk !== undefined) {
    writeVarint32(bb, 16);
    writeVarint64(bb, intToLong($atk));
  }

  // optional int32 hp = 3;
  let $hp = message.hp;
  if ($hp !== undefined) {
    writeVarint32(bb, 24);
    writeVarint64(bb, intToLong($hp));
  }

  // optional int32 spd = 4;
  let $spd = message.spd;
  if ($spd !== undefined) {
    writeVarint32(bb, 32);
    writeVarint64(bb, intToLong($spd));
  }

  // optional int64 attr_idx = 5;
  let $attr_idx = message.attr_idx;
  if ($attr_idx !== undefined) {
    writeVarint32(bb, 40);
    writeVarint64(bb, $attr_idx);
  }

  // optional int32 time = 6;
  let $time = message.time;
  if ($time !== undefined) {
    writeVarint32(bb, 48);
    writeVarint64(bb, intToLong($time));
  }

  // optional int32 cd = 7;
  let $cd = message.cd;
  if ($cd !== undefined) {
    writeVarint32(bb, 56);
    writeVarint64(bb, intToLong($cd));
  }
}

export function decodepb_hero_qlc(binary) {
  return _decodepb_hero_qlc(wrapByteBuffer(binary));
}

function _decodepb_hero_qlc(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // optional int32 lv = 1;
      case 1: {
        message.lv = readVarint32(bb);
        break;
      }

      // optional int32 atk = 2;
      case 2: {
        message.atk = readVarint32(bb);
        break;
      }

      // optional int32 hp = 3;
      case 3: {
        message.hp = readVarint32(bb);
        break;
      }

      // optional int32 spd = 4;
      case 4: {
        message.spd = readVarint32(bb);
        break;
      }

      // optional int64 attr_idx = 5;
      case 5: {
        message.attr_idx = readVarint64(bb, /* unsigned */ false);
        break;
      }

      // optional int32 time = 6;
      case 6: {
        message.time = readVarint32(bb);
        break;
      }

      // optional int32 cd = 7;
      case 7: {
        message.cd = readVarint32(bb);
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  return message;
}

export function encodepb_hero_qlt(message) {
  let bb = popByteBuffer();
  _encodepb_hero_qlt(message, bb);
  return toUint8Array(bb);
}

function _encodepb_hero_qlt(message, bb) {
  // optional pb_hero_qlc qlc = 1;
  let $qlc = message.qlc;
  if ($qlc !== undefined) {
    writeVarint32(bb, 10);
    let nested = popByteBuffer();
    _encodepb_hero_qlc($qlc, nested);
    writeVarint32(bb, nested.limit);
    writeByteBuffer(bb, nested);
    pushByteBuffer(nested);
  }

  // repeated pb_hero_qlc qlcs = 2;
  let array$qlcs = message.qlcs;
  if (array$qlcs !== undefined) {
    for (let value of array$qlcs) {
      writeVarint32(bb, 18);
      let nested = popByteBuffer();
      _encodepb_hero_qlc(value, nested);
      writeVarint32(bb, nested.limit);
      writeByteBuffer(bb, nested);
      pushByteBuffer(nested);
    }
  }

  // optional int64 attr_idx = 3;
  let $attr_idx = message.attr_idx;
  if ($attr_idx !== undefined) {
    writeVarint32(bb, 24);
    writeVarint64(bb, $attr_idx);
  }
}

export function decodepb_hero_qlt(binary) {
  return _decodepb_hero_qlt(wrapByteBuffer(binary));
}

function _decodepb_hero_qlt(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // optional pb_hero_qlc qlc = 1;
      case 1: {
        let limit = pushTemporaryLength(bb);
        message.qlc = _decodepb_hero_qlc(bb);
        bb.limit = limit;
        break;
      }

      // repeated pb_hero_qlc qlcs = 2;
      case 2: {
        let limit = pushTemporaryLength(bb);
        let values = message.qlcs || (message.qlcs = []);
        values.push(_decodepb_hero_qlc(bb));
        bb.limit = limit;
        break;
      }

      // optional int64 attr_idx = 3;
      case 3: {
        message.attr_idx = readVarint64(bb, /* unsigned */ false);
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  return message;
}

export function encodepb_tree(message) {
  let bb = popByteBuffer();
  _encodepb_tree(message, bb);
  return toUint8Array(bb);
}

function _encodepb_tree(message, bb) {
  // optional int32 lv = 1;
  let $lv = message.lv;
  if ($lv !== undefined) {
    writeVarint32(bb, 8);
    writeVarint64(bb, intToLong($lv));
  }

  // optional int32 blv = 2;
  let $blv = message.blv;
  if ($blv !== undefined) {
    writeVarint32(bb, 16);
    writeVarint64(bb, intToLong($blv));
  }

  // repeated int32 bra = 3;
  let array$bra = message.bra;
  if (array$bra !== undefined) {
    let packed = popByteBuffer();
    for (let value of array$bra) {
      writeVarint64(packed, intToLong(value));
    }
    writeVarint32(bb, 26);
    writeVarint32(bb, packed.offset);
    writeByteBuffer(bb, packed);
    pushByteBuffer(packed);
  }
}

export function decodepb_tree(binary) {
  return _decodepb_tree(wrapByteBuffer(binary));
}

function _decodepb_tree(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // optional int32 lv = 1;
      case 1: {
        message.lv = readVarint32(bb);
        break;
      }

      // optional int32 blv = 2;
      case 2: {
        message.blv = readVarint32(bb);
        break;
      }

      // repeated int32 bra = 3;
      case 3: {
        let values = message.bra || (message.bra = []);
        if ((tag & 7) === 2) {
          let outerLimit = pushTemporaryLength(bb);
          while (!isAtEnd(bb)) {
            values.push(readVarint32(bb));
          }
          bb.limit = outerLimit;
        } else {
          values.push(readVarint32(bb));
        }
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  return message;
}

export function encodepb_hero(message) {
  let bb = popByteBuffer();
  _encodepb_hero(message, bb);
  return toUint8Array(bb);
}

function _encodepb_hero(message, bb) {
  // required int32 hid = 1;
  let $hid = message.hid;
  if ($hid !== undefined) {
    writeVarint32(bb, 8);
    writeVarint64(bb, intToLong($hid));
  }

  // required int32 id = 2;
  let $id = message.id;
  if ($id !== undefined) {
    writeVarint32(bb, 16);
    writeVarint64(bb, intToLong($id));
  }

  // required int32 lv = 3;
  let $lv = message.lv;
  if ($lv !== undefined) {
    writeVarint32(bb, 24);
    writeVarint64(bb, intToLong($lv));
  }

  // required int32 star = 4;
  let $star = message.star;
  if ($star !== undefined) {
    writeVarint32(bb, 32);
    writeVarint64(bb, intToLong($star));
  }

  // optional int32 flag = 5;
  let $flag = message.flag;
  if ($flag !== undefined) {
    writeVarint32(bb, 40);
    writeVarint64(bb, intToLong($flag));
  }

  // repeated pb_equip equips = 6;
  let array$equips = message.equips;
  if (array$equips !== undefined) {
    for (let value of array$equips) {
      writeVarint32(bb, 50);
      let nested = popByteBuffer();
      _encodepb_equip(value, nested);
      writeVarint32(bb, nested.limit);
      writeByteBuffer(bb, nested);
      pushByteBuffer(nested);
    }
  }

  // optional int32 wake = 7;
  let $wake = message.wake;
  if ($wake !== undefined) {
    writeVarint32(bb, 56);
    writeVarint64(bb, intToLong($wake));
  }

  // repeated int32 jade = 8;
  let array$jade = message.jade;
  if (array$jade !== undefined) {
    let packed = popByteBuffer();
    for (let value of array$jade) {
      writeVarint64(packed, intToLong(value));
    }
    writeVarint32(bb, 66);
    writeVarint32(bb, packed.offset);
    writeByteBuffer(bb, packed);
    pushByteBuffer(packed);
  }

  // optional bool visit = 9;
  let $visit = message.visit;
  if ($visit !== undefined) {
    writeVarint32(bb, 72);
    writeByte(bb, $visit ? 1 : 0);
  }

  // repeated int32 skill_id = 10;
  let array$skill_id = message.skill_id;
  if (array$skill_id !== undefined) {
    let packed = popByteBuffer();
    for (let value of array$skill_id) {
      writeVarint64(packed, intToLong(value));
    }
    writeVarint32(bb, 82);
    writeVarint32(bb, packed.offset);
    writeByteBuffer(bb, packed);
    pushByteBuffer(packed);
  }

  // repeated pb_sattr sattrs = 11;
  let array$sattrs = message.sattrs;
  if (array$sattrs !== undefined) {
    for (let value of array$sattrs) {
      writeVarint32(bb, 90);
      let nested = popByteBuffer();
      _encodepb_sattr(value, nested);
      writeVarint32(bb, nested.limit);
      writeByteBuffer(bb, nested);
      pushByteBuffer(nested);
    }
  }

  // optional pb_hero_qlt qlt = 12;
  let $qlt = message.qlt;
  if ($qlt !== undefined) {
    writeVarint32(bb, 98);
    let nested = popByteBuffer();
    _encodepb_hero_qlt($qlt, nested);
    writeVarint32(bb, nested.limit);
    writeByteBuffer(bb, nested);
    pushByteBuffer(nested);
  }

  // optional pb_tree tree = 13;
  let $tree = message.tree;
  if ($tree !== undefined) {
    writeVarint32(bb, 106);
    let nested = popByteBuffer();
    _encodepb_tree($tree, nested);
    writeVarint32(bb, nested.limit);
    writeByteBuffer(bb, nested);
    pushByteBuffer(nested);
  }
}

export function decodepb_hero(binary) {
  return _decodepb_hero(wrapByteBuffer(binary));
}

function _decodepb_hero(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // required int32 hid = 1;
      case 1: {
        message.hid = readVarint32(bb);
        break;
      }

      // required int32 id = 2;
      case 2: {
        message.id = readVarint32(bb);
        break;
      }

      // required int32 lv = 3;
      case 3: {
        message.lv = readVarint32(bb);
        break;
      }

      // required int32 star = 4;
      case 4: {
        message.star = readVarint32(bb);
        break;
      }

      // optional int32 flag = 5;
      case 5: {
        message.flag = readVarint32(bb);
        break;
      }

      // repeated pb_equip equips = 6;
      case 6: {
        let limit = pushTemporaryLength(bb);
        let values = message.equips || (message.equips = []);
        values.push(_decodepb_equip(bb));
        bb.limit = limit;
        break;
      }

      // optional int32 wake = 7;
      case 7: {
        message.wake = readVarint32(bb);
        break;
      }

      // repeated int32 jade = 8;
      case 8: {
        let values = message.jade || (message.jade = []);
        if ((tag & 7) === 2) {
          let outerLimit = pushTemporaryLength(bb);
          while (!isAtEnd(bb)) {
            values.push(readVarint32(bb));
          }
          bb.limit = outerLimit;
        } else {
          values.push(readVarint32(bb));
        }
        break;
      }

      // optional bool visit = 9;
      case 9: {
        message.visit = !!readByte(bb);
        break;
      }

      // repeated int32 skill_id = 10;
      case 10: {
        let values = message.skill_id || (message.skill_id = []);
        if ((tag & 7) === 2) {
          let outerLimit = pushTemporaryLength(bb);
          while (!isAtEnd(bb)) {
            values.push(readVarint32(bb));
          }
          bb.limit = outerLimit;
        } else {
          values.push(readVarint32(bb));
        }
        break;
      }

      // repeated pb_sattr sattrs = 11;
      case 11: {
        let limit = pushTemporaryLength(bb);
        let values = message.sattrs || (message.sattrs = []);
        values.push(_decodepb_sattr(bb));
        bb.limit = limit;
        break;
      }

      // optional pb_hero_qlt qlt = 12;
      case 12: {
        let limit = pushTemporaryLength(bb);
        message.qlt = _decodepb_hero_qlt(bb);
        bb.limit = limit;
        break;
      }

      // optional pb_tree tree = 13;
      case 13: {
        let limit = pushTemporaryLength(bb);
        message.tree = _decodepb_tree(bb);
        bb.limit = limit;
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  if (message.hid === undefined)
    throw new Error("Missing required field: hid");

  if (message.id === undefined)
    throw new Error("Missing required field: id");

  if (message.lv === undefined)
    throw new Error("Missing required field: lv");

  if (message.star === undefined)
    throw new Error("Missing required field: star");

  return message;
}

export function encodepb_sattr(message) {
  let bb = popByteBuffer();
  _encodepb_sattr(message, bb);
  return toUint8Array(bb);
}

function _encodepb_sattr(message, bb) {
  // optional int32 id = 1;
  let $id = message.id;
  if ($id !== undefined) {
    writeVarint32(bb, 8);
    writeVarint64(bb, intToLong($id));
  }

  // optional int32 attr = 2;
  let $attr = message.attr;
  if ($attr !== undefined) {
    writeVarint32(bb, 16);
    writeVarint64(bb, intToLong($attr));
  }

  // optional int32 value = 3;
  let $value = message.value;
  if ($value !== undefined) {
    writeVarint32(bb, 24);
    writeVarint64(bb, intToLong($value));
  }
}

export function decodepb_sattr(binary) {
  return _decodepb_sattr(wrapByteBuffer(binary));
}

function _decodepb_sattr(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // optional int32 id = 1;
      case 1: {
        message.id = readVarint32(bb);
        break;
      }

      // optional int32 attr = 2;
      case 2: {
        message.attr = readVarint32(bb);
        break;
      }

      // optional int32 value = 3;
      case 3: {
        message.value = readVarint32(bb);
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  return message;
}

export function encodepb_dup(message) {
  let bb = popByteBuffer();
  _encodepb_dup(message, bb);
  return toUint8Array(bb);
}

function _encodepb_dup(message, bb) {
  // optional int32 id = 1;
  let $id = message.id;
  if ($id !== undefined) {
    writeVarint32(bb, 8);
    writeVarint64(bb, intToLong($id));
  }

  // repeated int32 bids = 2;
  let array$bids = message.bids;
  if (array$bids !== undefined) {
    let packed = popByteBuffer();
    for (let value of array$bids) {
      writeVarint64(packed, intToLong(value));
    }
    writeVarint32(bb, 18);
    writeVarint32(bb, packed.offset);
    writeByteBuffer(bb, packed);
    pushByteBuffer(packed);
  }

  // optional int32 sts = 3;
  let $sts = message.sts;
  if ($sts !== undefined) {
    writeVarint32(bb, 24);
    writeVarint64(bb, intToLong($sts));
  }

  // optional int32 mid = 4;
  let $mid = message.mid;
  if ($mid !== undefined) {
    writeVarint32(bb, 32);
    writeVarint64(bb, intToLong($mid));
  }

  // optional int32 rid = 5;
  let $rid = message.rid;
  if ($rid !== undefined) {
    writeVarint32(bb, 40);
    writeVarint64(bb, intToLong($rid));
  }

  // optional int32 skip = 6;
  let $skip = message.skip;
  if ($skip !== undefined) {
    writeVarint32(bb, 48);
    writeVarint64(bb, intToLong($skip));
  }
}

export function decodepb_dup(binary) {
  return _decodepb_dup(wrapByteBuffer(binary));
}

function _decodepb_dup(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // optional int32 id = 1;
      case 1: {
        message.id = readVarint32(bb);
        break;
      }

      // repeated int32 bids = 2;
      case 2: {
        let values = message.bids || (message.bids = []);
        if ((tag & 7) === 2) {
          let outerLimit = pushTemporaryLength(bb);
          while (!isAtEnd(bb)) {
            values.push(readVarint32(bb));
          }
          bb.limit = outerLimit;
        } else {
          values.push(readVarint32(bb));
        }
        break;
      }

      // optional int32 sts = 3;
      case 3: {
        message.sts = readVarint32(bb);
        break;
      }

      // optional int32 mid = 4;
      case 4: {
        message.mid = readVarint32(bb);
        break;
      }

      // optional int32 rid = 5;
      case 5: {
        message.rid = readVarint32(bb);
        break;
      }

      // optional int32 skip = 6;
      case 6: {
        message.skip = readVarint32(bb);
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  return message;
}

export function encodepb_embr(message) {
  let bb = popByteBuffer();
  _encodepb_embr(message, bb);
  return toUint8Array(bb);
}

function _encodepb_embr(message, bb) {
  // optional int32 uid = 1;
  let $uid = message.uid;
  if ($uid !== undefined) {
    writeVarint32(bb, 8);
    writeVarint64(bb, intToLong($uid));
  }

  // optional int32 lv = 2;
  let $lv = message.lv;
  if ($lv !== undefined) {
    writeVarint32(bb, 16);
    writeVarint64(bb, intToLong($lv));
  }

  // optional int32 status = 3;
  let $status = message.status;
  if ($status !== undefined) {
    writeVarint32(bb, 24);
    writeVarint64(bb, intToLong($status));
  }

  // optional string stime = 4;
  let $stime = message.stime;
  if ($stime !== undefined) {
    writeVarint32(bb, 34);
    writeString(bb, $stime);
  }

  // optional int32 logo = 5;
  let $logo = message.logo;
  if ($logo !== undefined) {
    writeVarint32(bb, 40);
    writeVarint64(bb, intToLong($logo));
  }

  // optional string name = 6;
  let $name = message.name;
  if ($name !== undefined) {
    writeVarint32(bb, 50);
    writeString(bb, $name);
  }

  // optional int32 border = 7;
  let $border = message.border;
  if ($border !== undefined) {
    writeVarint32(bb, 56);
    writeVarint64(bb, intToLong($border));
  }

  // optional int32 id = 8;
  let $id = message.id;
  if ($id !== undefined) {
    writeVarint32(bb, 64);
    writeVarint64(bb, intToLong($id));
  }
}

export function decodepb_embr(binary) {
  return _decodepb_embr(wrapByteBuffer(binary));
}

function _decodepb_embr(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // optional int32 uid = 1;
      case 1: {
        message.uid = readVarint32(bb);
        break;
      }

      // optional int32 lv = 2;
      case 2: {
        message.lv = readVarint32(bb);
        break;
      }

      // optional int32 status = 3;
      case 3: {
        message.status = readVarint32(bb);
        break;
      }

      // optional string stime = 4;
      case 4: {
        message.stime = readString(bb, readVarint32(bb));
        break;
      }

      // optional int32 logo = 5;
      case 5: {
        message.logo = readVarint32(bb);
        break;
      }

      // optional string name = 6;
      case 6: {
        message.name = readString(bb, readVarint32(bb));
        break;
      }

      // optional int32 border = 7;
      case 7: {
        message.border = readVarint32(bb);
        break;
      }

      // optional int32 id = 8;
      case 8: {
        message.id = readVarint32(bb);
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  return message;
}

export function encodepb_scell(message) {
  let bb = popByteBuffer();
  _encodepb_scell(message, bb);
  return toUint8Array(bb);
}

function _encodepb_scell(message, bb) {
  // optional int32 pos = 1;
  let $pos = message.pos;
  if ($pos !== undefined) {
    writeVarint32(bb, 8);
    writeVarint64(bb, intToLong($pos));
  }

  // optional int32 status = 2;
  let $status = message.status;
  if ($status !== undefined) {
    writeVarint32(bb, 16);
    writeVarint64(bb, intToLong($status));
  }

  // optional int32 id = 3;
  let $id = message.id;
  if ($id !== undefined) {
    writeVarint32(bb, 24);
    writeVarint64(bb, intToLong($id));
  }

  // repeated int32 ids1 = 4;
  let array$ids1 = message.ids1;
  if (array$ids1 !== undefined) {
    let packed = popByteBuffer();
    for (let value of array$ids1) {
      writeVarint64(packed, intToLong(value));
    }
    writeVarint32(bb, 34);
    writeVarint32(bb, packed.offset);
    writeByteBuffer(bb, packed);
    pushByteBuffer(packed);
  }

  // repeated int32 ids2 = 5;
  let array$ids2 = message.ids2;
  if (array$ids2 !== undefined) {
    let packed = popByteBuffer();
    for (let value of array$ids2) {
      writeVarint64(packed, intToLong(value));
    }
    writeVarint32(bb, 42);
    writeVarint32(bb, packed.offset);
    writeByteBuffer(bb, packed);
    pushByteBuffer(packed);
  }
}

export function decodepb_scell(binary) {
  return _decodepb_scell(wrapByteBuffer(binary));
}

function _decodepb_scell(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // optional int32 pos = 1;
      case 1: {
        message.pos = readVarint32(bb);
        break;
      }

      // optional int32 status = 2;
      case 2: {
        message.status = readVarint32(bb);
        break;
      }

      // optional int32 id = 3;
      case 3: {
        message.id = readVarint32(bb);
        break;
      }

      // repeated int32 ids1 = 4;
      case 4: {
        let values = message.ids1 || (message.ids1 = []);
        if ((tag & 7) === 2) {
          let outerLimit = pushTemporaryLength(bb);
          while (!isAtEnd(bb)) {
            values.push(readVarint32(bb));
          }
          bb.limit = outerLimit;
        } else {
          values.push(readVarint32(bb));
        }
        break;
      }

      // repeated int32 ids2 = 5;
      case 5: {
        let values = message.ids2 || (message.ids2 = []);
        if ((tag & 7) === 2) {
          let outerLimit = pushTemporaryLength(bb);
          while (!isAtEnd(bb)) {
            values.push(readVarint32(bb));
          }
          bb.limit = outerLimit;
        } else {
          values.push(readVarint32(bb));
        }
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  return message;
}

export function encodepb_sbuilding(message) {
  let bb = popByteBuffer();
  _encodepb_sbuilding(message, bb);
  return toUint8Array(bb);
}

function _encodepb_sbuilding(message, bb) {
  // optional sint32 lv = 1;
  let $lv = message.lv;
  if ($lv !== undefined) {
    writeVarint32(bb, 8);
    writeVarint32ZigZag(bb, $lv);
  }

  // optional sint32 cd = 2;
  let $cd = message.cd;
  if ($cd !== undefined) {
    writeVarint32(bb, 16);
    writeVarint32ZigZag(bb, $cd);
  }

  // optional sint32 num = 3;
  let $num = message.num;
  if ($num !== undefined) {
    writeVarint32(bb, 24);
    writeVarint32ZigZag(bb, $num);
  }
}

export function decodepb_sbuilding(binary) {
  return _decodepb_sbuilding(wrapByteBuffer(binary));
}

function _decodepb_sbuilding(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // optional sint32 lv = 1;
      case 1: {
        message.lv = readVarint32ZigZag(bb);
        break;
      }

      // optional sint32 cd = 2;
      case 2: {
        message.cd = readVarint32ZigZag(bb);
        break;
      }

      // optional sint32 num = 3;
      case 3: {
        message.num = readVarint32ZigZag(bb);
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  return message;
}

export function encodepb_sscell(message) {
  let bb = popByteBuffer();
  _encodepb_sscell(message, bb);
  return toUint8Array(bb);
}

function _encodepb_sscell(message, bb) {
  // optional int32 pos = 1;
  let $pos = message.pos;
  if ($pos !== undefined) {
    writeVarint32(bb, 8);
    writeVarint64(bb, intToLong($pos));
  }

  // optional int32 status = 2;
  let $status = message.status;
  if ($status !== undefined) {
    writeVarint32(bb, 16);
    writeVarint64(bb, intToLong($status));
  }

  // optional int32 id = 3;
  let $id = message.id;
  if ($id !== undefined) {
    writeVarint32(bb, 24);
    writeVarint64(bb, intToLong($id));
  }

  // optional int32 boss_id = 4;
  let $boss_id = message.boss_id;
  if ($boss_id !== undefined) {
    writeVarint32(bb, 32);
    writeVarint64(bb, intToLong($boss_id));
  }

  // repeated int32 boss_hp = 5;
  let array$boss_hp = message.boss_hp;
  if (array$boss_hp !== undefined) {
    let packed = popByteBuffer();
    for (let value of array$boss_hp) {
      writeVarint64(packed, intToLong(value));
    }
    writeVarint32(bb, 42);
    writeVarint32(bb, packed.offset);
    writeByteBuffer(bb, packed);
    pushByteBuffer(packed);
  }

  // optional pb_pmbr mbr = 6;
  let $mbr = message.mbr;
  if ($mbr !== undefined) {
    writeVarint32(bb, 50);
    let nested = popByteBuffer();
    _encodepb_pmbr($mbr, nested);
    writeVarint32(bb, nested.limit);
    writeByteBuffer(bb, nested);
    pushByteBuffer(nested);
  }

  // optional int32 hid = 7;
  let $hid = message.hid;
  if ($hid !== undefined) {
    writeVarint32(bb, 56);
    writeVarint64(bb, intToLong($hid));
  }

  // optional int32 cd = 8;
  let $cd = message.cd;
  if ($cd !== undefined) {
    writeVarint32(bb, 64);
    writeVarint64(bb, intToLong($cd));
  }

  // optional int32 lv = 9;
  let $lv = message.lv;
  if ($lv !== undefined) {
    writeVarint32(bb, 72);
    writeVarint64(bb, intToLong($lv));
  }

  // optional int32 add = 10;
  let $add = message.add;
  if ($add !== undefined) {
    writeVarint32(bb, 80);
    writeVarint64(bb, intToLong($add));
  }

  // optional int32 times = 11;
  let $times = message.times;
  if ($times !== undefined) {
    writeVarint32(bb, 88);
    writeVarint64(bb, intToLong($times));
  }

  // optional int32 rid = 12;
  let $rid = message.rid;
  if ($rid !== undefined) {
    writeVarint32(bb, 96);
    writeVarint64(bb, intToLong($rid));
  }

  // optional int32 wake = 13;
  let $wake = message.wake;
  if ($wake !== undefined) {
    writeVarint32(bb, 104);
    writeVarint64(bb, intToLong($wake));
  }

  // optional int32 rlv = 14;
  let $rlv = message.rlv;
  if ($rlv !== undefined) {
    writeVarint32(bb, 112);
    writeVarint64(bb, intToLong($rlv));
  }

  // optional int32 rqlv = 15;
  let $rqlv = message.rqlv;
  if ($rqlv !== undefined) {
    writeVarint32(bb, 120);
    writeVarint64(bb, intToLong($rqlv));
  }
}

export function decodepb_sscell(binary) {
  return _decodepb_sscell(wrapByteBuffer(binary));
}

function _decodepb_sscell(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // optional int32 pos = 1;
      case 1: {
        message.pos = readVarint32(bb);
        break;
      }

      // optional int32 status = 2;
      case 2: {
        message.status = readVarint32(bb);
        break;
      }

      // optional int32 id = 3;
      case 3: {
        message.id = readVarint32(bb);
        break;
      }

      // optional int32 boss_id = 4;
      case 4: {
        message.boss_id = readVarint32(bb);
        break;
      }

      // repeated int32 boss_hp = 5;
      case 5: {
        let values = message.boss_hp || (message.boss_hp = []);
        if ((tag & 7) === 2) {
          let outerLimit = pushTemporaryLength(bb);
          while (!isAtEnd(bb)) {
            values.push(readVarint32(bb));
          }
          bb.limit = outerLimit;
        } else {
          values.push(readVarint32(bb));
        }
        break;
      }

      // optional pb_pmbr mbr = 6;
      case 6: {
        let limit = pushTemporaryLength(bb);
        message.mbr = _decodepb_pmbr(bb);
        bb.limit = limit;
        break;
      }

      // optional int32 hid = 7;
      case 7: {
        message.hid = readVarint32(bb);
        break;
      }

      // optional int32 cd = 8;
      case 8: {
        message.cd = readVarint32(bb);
        break;
      }

      // optional int32 lv = 9;
      case 9: {
        message.lv = readVarint32(bb);
        break;
      }

      // optional int32 add = 10;
      case 10: {
        message.add = readVarint32(bb);
        break;
      }

      // optional int32 times = 11;
      case 11: {
        message.times = readVarint32(bb);
        break;
      }

      // optional int32 rid = 12;
      case 12: {
        message.rid = readVarint32(bb);
        break;
      }

      // optional int32 wake = 13;
      case 13: {
        message.wake = readVarint32(bb);
        break;
      }

      // optional int32 rlv = 14;
      case 14: {
        message.rlv = readVarint32(bb);
        break;
      }

      // optional int32 rqlv = 15;
      case 15: {
        message.rqlv = readVarint32(bb);
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  return message;
}

export function encodepb_ssevent(message) {
  let bb = popByteBuffer();
  _encodepb_ssevent(message, bb);
  return toUint8Array(bb);
}

function _encodepb_ssevent(message, bb) {
  // optional int32 id = 1;
  let $id = message.id;
  if ($id !== undefined) {
    writeVarint32(bb, 8);
    writeVarint64(bb, intToLong($id));
  }

  // optional int32 num = 2;
  let $num = message.num;
  if ($num !== undefined) {
    writeVarint32(bb, 16);
    writeVarint64(bb, intToLong($num));
  }

  // optional int32 lv_item = 3;
  let $lv_item = message.lv_item;
  if ($lv_item !== undefined) {
    writeVarint32(bb, 24);
    writeVarint64(bb, intToLong($lv_item));
  }

  // optional int32 score = 4;
  let $score = message.score;
  if ($score !== undefined) {
    writeVarint32(bb, 32);
    writeVarint64(bb, intToLong($score));
  }

  // optional int32 num2 = 5;
  let $num2 = message.num2;
  if ($num2 !== undefined) {
    writeVarint32(bb, 40);
    writeVarint64(bb, intToLong($num2));
  }

  // repeated pb_bag reward = 6;
  let array$reward = message.reward;
  if (array$reward !== undefined) {
    for (let value of array$reward) {
      writeVarint32(bb, 50);
      let nested = popByteBuffer();
      _encodepb_bag(value, nested);
      writeVarint32(bb, nested.limit);
      writeByteBuffer(bb, nested);
      pushByteBuffer(nested);
    }
  }
}

export function decodepb_ssevent(binary) {
  return _decodepb_ssevent(wrapByteBuffer(binary));
}

function _decodepb_ssevent(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // optional int32 id = 1;
      case 1: {
        message.id = readVarint32(bb);
        break;
      }

      // optional int32 num = 2;
      case 2: {
        message.num = readVarint32(bb);
        break;
      }

      // optional int32 lv_item = 3;
      case 3: {
        message.lv_item = readVarint32(bb);
        break;
      }

      // optional int32 score = 4;
      case 4: {
        message.score = readVarint32(bb);
        break;
      }

      // optional int32 num2 = 5;
      case 5: {
        message.num2 = readVarint32(bb);
        break;
      }

      // repeated pb_bag reward = 6;
      case 6: {
        let limit = pushTemporaryLength(bb);
        let values = message.reward || (message.reward = []);
        values.push(_decodepb_bag(bb));
        bb.limit = limit;
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  return message;
}

export function encodepb_sssweep(message) {
  let bb = popByteBuffer();
  _encodepb_sssweep(message, bb);
  return toUint8Array(bb);
}

function _encodepb_sssweep(message, bb) {
  // optional int32 pos = 1;
  let $pos = message.pos;
  if ($pos !== undefined) {
    writeVarint32(bb, 8);
    writeVarint64(bb, intToLong($pos));
  }

  // optional int32 hid = 2;
  let $hid = message.hid;
  if ($hid !== undefined) {
    writeVarint32(bb, 16);
    writeVarint64(bb, intToLong($hid));
  }
}

export function decodepb_sssweep(binary) {
  return _decodepb_sssweep(wrapByteBuffer(binary));
}

function _decodepb_sssweep(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // optional int32 pos = 1;
      case 1: {
        message.pos = readVarint32(bb);
        break;
      }

      // optional int32 hid = 2;
      case 2: {
        message.hid = readVarint32(bb);
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  return message;
}

export function encodepb_gacha(message) {
  let bb = popByteBuffer();
  _encodepb_gacha(message, bb);
  return toUint8Array(bb);
}

function _encodepb_gacha(message, bb) {
  // required int32 item = 1;
  let $item = message.item;
  if ($item !== undefined) {
    writeVarint32(bb, 8);
    writeVarint64(bb, intToLong($item));
  }

  // required int32 gem = 2;
  let $gem = message.gem;
  if ($gem !== undefined) {
    writeVarint32(bb, 16);
    writeVarint64(bb, intToLong($gem));
  }

  // optional int32 id = 3;
  let $id = message.id;
  if ($id !== undefined) {
    writeVarint32(bb, 24);
    writeVarint64(bb, intToLong($id));
  }

  // optional int32 act = 4;
  let $act = message.act;
  if ($act !== undefined) {
    writeVarint32(bb, 32);
    writeVarint64(bb, intToLong($act));
  }

  // optional int32 cd = 5;
  let $cd = message.cd;
  if ($cd !== undefined) {
    writeVarint32(bb, 40);
    writeVarint64(bb, intToLong($cd));
  }
}

export function decodepb_gacha(binary) {
  return _decodepb_gacha(wrapByteBuffer(binary));
}

function _decodepb_gacha(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // required int32 item = 1;
      case 1: {
        message.item = readVarint32(bb);
        break;
      }

      // required int32 gem = 2;
      case 2: {
        message.gem = readVarint32(bb);
        break;
      }

      // optional int32 id = 3;
      case 3: {
        message.id = readVarint32(bb);
        break;
      }

      // optional int32 act = 4;
      case 4: {
        message.act = readVarint32(bb);
        break;
      }

      // optional int32 cd = 5;
      case 5: {
        message.cd = readVarint32(bb);
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  if (message.item === undefined)
    throw new Error("Missing required field: item");

  if (message.gem === undefined)
    throw new Error("Missing required field: gem");

  return message;
}

export function encodepb_mail(message) {
  let bb = popByteBuffer();
  _encodepb_mail(message, bb);
  return toUint8Array(bb);
}

function _encodepb_mail(message, bb) {
  // required int32 mid = 1;
  let $mid = message.mid;
  if ($mid !== undefined) {
    writeVarint32(bb, 8);
    writeVarint64(bb, intToLong($mid));
  }

  // required int32 id = 2;
  let $id = message.id;
  if ($id !== undefined) {
    writeVarint32(bb, 16);
    writeVarint64(bb, intToLong($id));
  }

  // optional int64 uid = 3;
  let $uid = message.uid;
  if ($uid !== undefined) {
    writeVarint32(bb, 24);
    writeVarint64(bb, $uid);
  }

  // required int32 flag = 4;
  let $flag = message.flag;
  if ($flag !== undefined) {
    writeVarint32(bb, 32);
    writeVarint64(bb, intToLong($flag));
  }

  // required int32 send_time = 5;
  let $send_time = message.send_time;
  if ($send_time !== undefined) {
    writeVarint32(bb, 40);
    writeVarint64(bb, intToLong($send_time));
  }

  // optional string title = 6;
  let $title = message.title;
  if ($title !== undefined) {
    writeVarint32(bb, 50);
    writeString(bb, $title);
  }

  // optional string from = 7;
  let $from = message.from;
  if ($from !== undefined) {
    writeVarint32(bb, 58);
    writeString(bb, $from);
  }

  // optional string content = 8;
  let $content = message.content;
  if ($content !== undefined) {
    writeVarint32(bb, 66);
    writeString(bb, $content);
  }

  // optional string content_o = 9;
  let $content_o = message.content_o;
  if ($content_o !== undefined) {
    writeVarint32(bb, 74);
    writeString(bb, $content_o);
  }

  // optional pb_bag affix = 10;
  let $affix = message.affix;
  if ($affix !== undefined) {
    writeVarint32(bb, 82);
    let nested = popByteBuffer();
    _encodepb_bag($affix, nested);
    writeVarint32(bb, nested.limit);
    writeByteBuffer(bb, nested);
    pushByteBuffer(nested);
  }
}

export function decodepb_mail(binary) {
  return _decodepb_mail(wrapByteBuffer(binary));
}

function _decodepb_mail(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // required int32 mid = 1;
      case 1: {
        message.mid = readVarint32(bb);
        break;
      }

      // required int32 id = 2;
      case 2: {
        message.id = readVarint32(bb);
        break;
      }

      // optional int64 uid = 3;
      case 3: {
        message.uid = readVarint64(bb, /* unsigned */ false);
        break;
      }

      // required int32 flag = 4;
      case 4: {
        message.flag = readVarint32(bb);
        break;
      }

      // required int32 send_time = 5;
      case 5: {
        message.send_time = readVarint32(bb);
        break;
      }

      // optional string title = 6;
      case 6: {
        message.title = readString(bb, readVarint32(bb));
        break;
      }

      // optional string from = 7;
      case 7: {
        message.from = readString(bb, readVarint32(bb));
        break;
      }

      // optional string content = 8;
      case 8: {
        message.content = readString(bb, readVarint32(bb));
        break;
      }

      // optional string content_o = 9;
      case 9: {
        message.content_o = readString(bb, readVarint32(bb));
        break;
      }

      // optional pb_bag affix = 10;
      case 10: {
        let limit = pushTemporaryLength(bb);
        message.affix = _decodepb_bag(bb);
        bb.limit = limit;
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  if (message.mid === undefined)
    throw new Error("Missing required field: mid");

  if (message.id === undefined)
    throw new Error("Missing required field: id");

  if (message.flag === undefined)
    throw new Error("Missing required field: flag");

  if (message.send_time === undefined)
    throw new Error("Missing required field: send_time");

  return message;
}

export function encodepb_cunit(message) {
  let bb = popByteBuffer();
  _encodepb_cunit(message, bb);
  return toUint8Array(bb);
}

function _encodepb_cunit(message, bb) {
  // required int32 id = 1;
  let $id = message.id;
  if ($id !== undefined) {
    writeVarint32(bb, 8);
    writeVarint64(bb, intToLong($id));
  }

  // optional int32 lv = 2;
  let $lv = message.lv;
  if ($lv !== undefined) {
    writeVarint32(bb, 16);
    writeVarint64(bb, intToLong($lv));
  }

  // optional int32 star = 3;
  let $star = message.star;
  if ($star !== undefined) {
    writeVarint32(bb, 24);
    writeVarint64(bb, intToLong($star));
  }

  // optional int64 power = 4;
  let $power = message.power;
  if ($power !== undefined) {
    writeVarint32(bb, 32);
    writeVarint64(bb, $power);
  }

  // optional int32 hp = 5;
  let $hp = message.hp;
  if ($hp !== undefined) {
    writeVarint32(bb, 40);
    writeVarint64(bb, intToLong($hp));
  }

  // optional int32 atk = 6;
  let $atk = message.atk;
  if ($atk !== undefined) {
    writeVarint32(bb, 48);
    writeVarint64(bb, intToLong($atk));
  }

  // optional int32 armor = 7;
  let $armor = message.armor;
  if ($armor !== undefined) {
    writeVarint32(bb, 56);
    writeVarint64(bb, intToLong($armor));
  }

  // optional int32 spd = 8;
  let $spd = message.spd;
  if ($spd !== undefined) {
    writeVarint32(bb, 64);
    writeVarint64(bb, intToLong($spd));
  }

  // optional int32 wake = 9;
  let $wake = message.wake;
  if ($wake !== undefined) {
    writeVarint32(bb, 72);
    writeVarint64(bb, intToLong($wake));
  }

  // optional int32 skin = 10;
  let $skin = message.skin;
  if ($skin !== undefined) {
    writeVarint32(bb, 80);
    writeVarint64(bb, intToLong($skin));
  }

  // optional int32 stl = 11;
  let $stl = message.stl;
  if ($stl !== undefined) {
    writeVarint32(bb, 88);
    writeVarint64(bb, intToLong($stl));
  }

  // optional int32 qlv = 12;
  let $qlv = message.qlv;
  if ($qlv !== undefined) {
    writeVarint32(bb, 96);
    writeVarint64(bb, intToLong($qlv));
  }

  // optional pb_tree tree = 13;
  let $tree = message.tree;
  if ($tree !== undefined) {
    writeVarint32(bb, 106);
    let nested = popByteBuffer();
    _encodepb_tree($tree, nested);
    writeVarint32(bb, nested.limit);
    writeByteBuffer(bb, nested);
    pushByteBuffer(nested);
  }

  // optional int32 core = 14;
  let $core = message.core;
  if ($core !== undefined) {
    writeVarint32(bb, 112);
    writeVarint64(bb, intToLong($core));
  }
}

export function decodepb_cunit(binary) {
  return _decodepb_cunit(wrapByteBuffer(binary));
}

function _decodepb_cunit(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // required int32 id = 1;
      case 1: {
        message.id = readVarint32(bb);
        break;
      }

      // optional int32 lv = 2;
      case 2: {
        message.lv = readVarint32(bb);
        break;
      }

      // optional int32 star = 3;
      case 3: {
        message.star = readVarint32(bb);
        break;
      }

      // optional int64 power = 4;
      case 4: {
        message.power = readVarint64(bb, /* unsigned */ false);
        break;
      }

      // optional int32 hp = 5;
      case 5: {
        message.hp = readVarint32(bb);
        break;
      }

      // optional int32 atk = 6;
      case 6: {
        message.atk = readVarint32(bb);
        break;
      }

      // optional int32 armor = 7;
      case 7: {
        message.armor = readVarint32(bb);
        break;
      }

      // optional int32 spd = 8;
      case 8: {
        message.spd = readVarint32(bb);
        break;
      }

      // optional int32 wake = 9;
      case 9: {
        message.wake = readVarint32(bb);
        break;
      }

      // optional int32 skin = 10;
      case 10: {
        message.skin = readVarint32(bb);
        break;
      }

      // optional int32 stl = 11;
      case 11: {
        message.stl = readVarint32(bb);
        break;
      }

      // optional int32 qlv = 12;
      case 12: {
        message.qlv = readVarint32(bb);
        break;
      }

      // optional pb_tree tree = 13;
      case 13: {
        let limit = pushTemporaryLength(bb);
        message.tree = _decodepb_tree(bb);
        bb.limit = limit;
        break;
      }

      // optional int32 core = 14;
      case 14: {
        message.core = readVarint32(bb);
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  if (message.id === undefined)
    throw new Error("Missing required field: id");

  return message;
}

export function encodepb_chat(message) {
  let bb = popByteBuffer();
  _encodepb_chat(message, bb);
  return toUint8Array(bb);
}

function _encodepb_chat(message, bb) {
  // optional int64 uid = 1;
  let $uid = message.uid;
  if ($uid !== undefined) {
    writeVarint32(bb, 8);
    writeVarint64(bb, $uid);
  }

  // optional int32 logo = 2;
  let $logo = message.logo;
  if ($logo !== undefined) {
    writeVarint32(bb, 16);
    writeVarint64(bb, intToLong($logo));
  }

  // optional int32 lv = 3;
  let $lv = message.lv;
  if ($lv !== undefined) {
    writeVarint32(bb, 24);
    writeVarint64(bb, intToLong($lv));
  }

  // optional int32 vip = 4;
  let $vip = message.vip;
  if ($vip !== undefined) {
    writeVarint32(bb, 32);
    writeVarint64(bb, intToLong($vip));
  }

  // optional string name = 5;
  let $name = message.name;
  if ($name !== undefined) {
    writeVarint32(bb, 42);
    writeString(bb, $name);
  }

  // optional int32 type = 6;
  let $type = message.type;
  if ($type !== undefined) {
    writeVarint32(bb, 48);
    writeVarint64(bb, intToLong($type));
  }

  // optional string text = 7;
  let $text = message.text;
  if ($text !== undefined) {
    writeVarint32(bb, 58);
    writeString(bb, $text);
  }

  // optional int32 time = 8;
  let $time = message.time;
  if ($time !== undefined) {
    writeVarint32(bb, 64);
    writeVarint64(bb, intToLong($time));
  }

  // optional int32 share_id = 9;
  let $share_id = message.share_id;
  if ($share_id !== undefined) {
    writeVarint32(bb, 72);
    writeVarint64(bb, intToLong($share_id));
  }

  // optional int32 hero_id = 10;
  let $hero_id = message.hero_id;
  if ($hero_id !== undefined) {
    writeVarint32(bb, 80);
    writeVarint64(bb, intToLong($hero_id));
  }

  // optional int32 final_rank = 11;
  let $final_rank = message.final_rank;
  if ($final_rank !== undefined) {
    writeVarint32(bb, 88);
    writeVarint64(bb, intToLong($final_rank));
  }

  // optional int32 gid = 12;
  let $gid = message.gid;
  if ($gid !== undefined) {
    writeVarint32(bb, 96);
    writeVarint64(bb, intToLong($gid));
  }

  // optional string gname = 13;
  let $gname = message.gname;
  if ($gname !== undefined) {
    writeVarint32(bb, 106);
    writeString(bb, $gname);
  }

  // optional int32 glv = 14;
  let $glv = message.glv;
  if ($glv !== undefined) {
    writeVarint32(bb, 112);
    writeVarint64(bb, intToLong($glv));
  }

  // optional string gmsg = 15;
  let $gmsg = message.gmsg;
  if ($gmsg !== undefined) {
    writeVarint32(bb, 122);
    writeString(bb, $gmsg);
  }

  // optional int32 gFight = 16;
  let $gFight = message.gFight;
  if ($gFight !== undefined) {
    writeVarint32(bb, 128);
    writeVarint64(bb, intToLong($gFight));
  }

  // optional int32 border = 17;
  let $border = message.border;
  if ($border !== undefined) {
    writeVarint32(bb, 136);
    writeVarint64(bb, intToLong($border));
  }

  // optional pb_hteam hteam = 18;
  let $hteam = message.hteam;
  if ($hteam !== undefined) {
    writeVarint32(bb, 146);
    let nested = popByteBuffer();
    _encodepb_hteam($hteam, nested);
    writeVarint32(bb, nested.limit);
    writeByteBuffer(bb, nested);
    pushByteBuffer(nested);
  }

  // optional string country = 19;
  let $country = message.country;
  if ($country !== undefined) {
    writeVarint32(bb, 154);
    writeString(bb, $country);
  }

  // optional string sds = 20;
  let $sds = message.sds;
  if ($sds !== undefined) {
    writeVarint32(bb, 162);
    writeString(bb, $sds);
  }

  // optional string city = 21;
  let $city = message.city;
  if ($city !== undefined) {
    writeVarint32(bb, 170);
    writeString(bb, $city);
  }

  // optional int64 emblem = 22;
  let $emblem = message.emblem;
  if ($emblem !== undefined) {
    writeVarint32(bb, 176);
    writeVarint64(bb, $emblem);
  }
}

export function decodepb_chat(binary) {
  return _decodepb_chat(wrapByteBuffer(binary));
}

function _decodepb_chat(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // optional int64 uid = 1;
      case 1: {
        message.uid = readVarint64(bb, /* unsigned */ false);
        break;
      }

      // optional int32 logo = 2;
      case 2: {
        message.logo = readVarint32(bb);
        break;
      }

      // optional int32 lv = 3;
      case 3: {
        message.lv = readVarint32(bb);
        break;
      }

      // optional int32 vip = 4;
      case 4: {
        message.vip = readVarint32(bb);
        break;
      }

      // optional string name = 5;
      case 5: {
        message.name = readString(bb, readVarint32(bb));
        break;
      }

      // optional int32 type = 6;
      case 6: {
        message.type = readVarint32(bb);
        break;
      }

      // optional string text = 7;
      case 7: {
        message.text = readString(bb, readVarint32(bb));
        break;
      }

      // optional int32 time = 8;
      case 8: {
        message.time = readVarint32(bb);
        break;
      }

      // optional int32 share_id = 9;
      case 9: {
        message.share_id = readVarint32(bb);
        break;
      }

      // optional int32 hero_id = 10;
      case 10: {
        message.hero_id = readVarint32(bb);
        break;
      }

      // optional int32 final_rank = 11;
      case 11: {
        message.final_rank = readVarint32(bb);
        break;
      }

      // optional int32 gid = 12;
      case 12: {
        message.gid = readVarint32(bb);
        break;
      }

      // optional string gname = 13;
      case 13: {
        message.gname = readString(bb, readVarint32(bb));
        break;
      }

      // optional int32 glv = 14;
      case 14: {
        message.glv = readVarint32(bb);
        break;
      }

      // optional string gmsg = 15;
      case 15: {
        message.gmsg = readString(bb, readVarint32(bb));
        break;
      }

      // optional int32 gFight = 16;
      case 16: {
        message.gFight = readVarint32(bb);
        break;
      }

      // optional int32 border = 17;
      case 17: {
        message.border = readVarint32(bb);
        break;
      }

      // optional pb_hteam hteam = 18;
      case 18: {
        let limit = pushTemporaryLength(bb);
        message.hteam = _decodepb_hteam(bb);
        bb.limit = limit;
        break;
      }

      // optional string country = 19;
      case 19: {
        message.country = readString(bb, readVarint32(bb));
        break;
      }

      // optional string sds = 20;
      case 20: {
        message.sds = readString(bb, readVarint32(bb));
        break;
      }

      // optional string city = 21;
      case 21: {
        message.city = readString(bb, readVarint32(bb));
        break;
      }

      // optional int64 emblem = 22;
      case 22: {
        message.emblem = readVarint64(bb, /* unsigned */ false);
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  return message;
}

export function encodepb_upfile(message) {
  let bb = popByteBuffer();
  _encodepb_upfile(message, bb);
  return toUint8Array(bb);
}

function _encodepb_upfile(message, bb) {
  // required string md5 = 1;
  let $md5 = message.md5;
  if ($md5 !== undefined) {
    writeVarint32(bb, 10);
    writeString(bb, $md5);
  }

  // required string path = 2;
  let $path = message.path;
  if ($path !== undefined) {
    writeVarint32(bb, 18);
    writeString(bb, $path);
  }
}

export function decodepb_upfile(binary) {
  return _decodepb_upfile(wrapByteBuffer(binary));
}

function _decodepb_upfile(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // required string md5 = 1;
      case 1: {
        message.md5 = readString(bb, readVarint32(bb));
        break;
      }

      // required string path = 2;
      case 2: {
        message.path = readString(bb, readVarint32(bb));
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  if (message.md5 === undefined)
    throw new Error("Missing required field: md5");

  if (message.path === undefined)
    throw new Error("Missing required field: path");

  return message;
}

export function encodepb_good(message) {
  let bb = popByteBuffer();
  _encodepb_good(message, bb);
  return toUint8Array(bb);
}

function _encodepb_good(message, bb) {
  // required int32 id = 1;
  let $id = message.id;
  if ($id !== undefined) {
    writeVarint32(bb, 8);
    writeVarint64(bb, intToLong($id));
  }

  // required int32 type = 2;
  let $type = message.type;
  if ($type !== undefined) {
    writeVarint32(bb, 16);
    writeVarint64(bb, intToLong($type));
  }

  // required int32 count = 3;
  let $count = message.count;
  if ($count !== undefined) {
    writeVarint32(bb, 24);
    writeVarint64(bb, intToLong($count));
  }

  // required int32 excel_id = 4;
  let $excel_id = message.excel_id;
  if ($excel_id !== undefined) {
    writeVarint32(bb, 32);
    writeVarint64(bb, intToLong($excel_id));
  }

  // optional int32 bought = 5;
  let $bought = message.bought;
  if ($bought !== undefined) {
    writeVarint32(bb, 40);
    writeVarint64(bb, intToLong($bought));
  }
}

export function decodepb_good(binary) {
  return _decodepb_good(wrapByteBuffer(binary));
}

function _decodepb_good(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // required int32 id = 1;
      case 1: {
        message.id = readVarint32(bb);
        break;
      }

      // required int32 type = 2;
      case 2: {
        message.type = readVarint32(bb);
        break;
      }

      // required int32 count = 3;
      case 3: {
        message.count = readVarint32(bb);
        break;
      }

      // required int32 excel_id = 4;
      case 4: {
        message.excel_id = readVarint32(bb);
        break;
      }

      // optional int32 bought = 5;
      case 5: {
        message.bought = readVarint32(bb);
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  if (message.id === undefined)
    throw new Error("Missing required field: id");

  if (message.type === undefined)
    throw new Error("Missing required field: type");

  if (message.count === undefined)
    throw new Error("Missing required field: count");

  if (message.excel_id === undefined)
    throw new Error("Missing required field: excel_id");

  return message;
}

export function encodepb_onepay(message) {
  let bb = popByteBuffer();
  _encodepb_onepay(message, bb);
  return toUint8Array(bb);
}

function _encodepb_onepay(message, bb) {
  // required string tid = 1;
  let $tid = message.tid;
  if ($tid !== undefined) {
    writeVarint32(bb, 10);
    writeString(bb, $tid);
  }

  // optional string txid = 2;
  let $txid = message.txid;
  if ($txid !== undefined) {
    writeVarint32(bb, 18);
    writeString(bb, $txid);
  }

  // optional string tdate = 3;
  let $tdate = message.tdate;
  if ($tdate !== undefined) {
    writeVarint32(bb, 26);
    writeString(bb, $tdate);
  }
}

export function decodepb_onepay(binary) {
  return _decodepb_onepay(wrapByteBuffer(binary));
}

function _decodepb_onepay(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // required string tid = 1;
      case 1: {
        message.tid = readString(bb, readVarint32(bb));
        break;
      }

      // optional string txid = 2;
      case 2: {
        message.txid = readString(bb, readVarint32(bb));
        break;
      }

      // optional string tdate = 3;
      case 3: {
        message.tdate = readString(bb, readVarint32(bb));
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  if (message.tid === undefined)
    throw new Error("Missing required field: tid");

  return message;
}

export function encodepb_hook(message) {
  let bb = popByteBuffer();
  _encodepb_hook(message, bb);
  return toUint8Array(bb);
}

function _encodepb_hook(message, bb) {
  // required sint32 status = 1;
  let $status = message.status;
  if ($status !== undefined) {
    writeVarint32(bb, 8);
    writeVarint32ZigZag(bb, $status);
  }

  // optional int32 hook_stage = 2;
  let $hook_stage = message.hook_stage;
  if ($hook_stage !== undefined) {
    writeVarint32(bb, 16);
    writeVarint64(bb, intToLong($hook_stage));
  }

  // optional int32 boss_cd = 3;
  let $boss_cd = message.boss_cd;
  if ($boss_cd !== undefined) {
    writeVarint32(bb, 24);
    writeVarint64(bb, intToLong($boss_cd));
  }

  // optional int32 poker_cd = 4;
  let $poker_cd = message.poker_cd;
  if ($poker_cd !== undefined) {
    writeVarint32(bb, 32);
    writeVarint64(bb, intToLong($poker_cd));
  }

  // optional pb_bag reward = 5;
  let $reward = message.reward;
  if ($reward !== undefined) {
    writeVarint32(bb, 42);
    let nested = popByteBuffer();
    _encodepb_bag($reward, nested);
    writeVarint32(bb, nested.limit);
    writeByteBuffer(bb, nested);
    pushByteBuffer(nested);
  }

  // optional int32 pve_stage = 6;
  let $pve_stage = message.pve_stage;
  if ($pve_stage !== undefined) {
    writeVarint32(bb, 48);
    writeVarint64(bb, intToLong($pve_stage));
  }

  // optional pb_bag extra = 7;
  let $extra = message.extra;
  if ($extra !== undefined) {
    writeVarint32(bb, 58);
    let nested = popByteBuffer();
    _encodepb_bag($extra, nested);
    writeVarint32(bb, nested.limit);
    writeByteBuffer(bb, nested);
    pushByteBuffer(nested);
  }

  // repeated pb_item ids = 8;
  let array$ids = message.ids;
  if (array$ids !== undefined) {
    for (let value of array$ids) {
      writeVarint32(bb, 66);
      let nested = popByteBuffer();
      _encodepb_item(value, nested);
      writeVarint32(bb, nested.limit);
      writeByteBuffer(bb, nested);
      pushByteBuffer(nested);
    }
  }

  // optional uint32 hard_stage = 9;
  let $hard_stage = message.hard_stage;
  if ($hard_stage !== undefined) {
    writeVarint32(bb, 72);
    writeVarint32(bb, $hard_stage);
  }
}

export function decodepb_hook(binary) {
  return _decodepb_hook(wrapByteBuffer(binary));
}

function _decodepb_hook(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // required sint32 status = 1;
      case 1: {
        message.status = readVarint32ZigZag(bb);
        break;
      }

      // optional int32 hook_stage = 2;
      case 2: {
        message.hook_stage = readVarint32(bb);
        break;
      }

      // optional int32 boss_cd = 3;
      case 3: {
        message.boss_cd = readVarint32(bb);
        break;
      }

      // optional int32 poker_cd = 4;
      case 4: {
        message.poker_cd = readVarint32(bb);
        break;
      }

      // optional pb_bag reward = 5;
      case 5: {
        let limit = pushTemporaryLength(bb);
        message.reward = _decodepb_bag(bb);
        bb.limit = limit;
        break;
      }

      // optional int32 pve_stage = 6;
      case 6: {
        message.pve_stage = readVarint32(bb);
        break;
      }

      // optional pb_bag extra = 7;
      case 7: {
        let limit = pushTemporaryLength(bb);
        message.extra = _decodepb_bag(bb);
        bb.limit = limit;
        break;
      }

      // repeated pb_item ids = 8;
      case 8: {
        let limit = pushTemporaryLength(bb);
        let values = message.ids || (message.ids = []);
        values.push(_decodepb_item(bb));
        bb.limit = limit;
        break;
      }

      // optional uint32 hard_stage = 9;
      case 9: {
        message.hard_stage = readVarint32(bb) >>> 0;
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  if (message.status === undefined)
    throw new Error("Missing required field: status");

  return message;
}

export function encodepb_frd(message) {
  let bb = popByteBuffer();
  _encodepb_frd(message, bb);
  return toUint8Array(bb);
}

function _encodepb_frd(message, bb) {
  // required int32 logo = 1;
  let $logo = message.logo;
  if ($logo !== undefined) {
    writeVarint32(bb, 8);
    writeVarint64(bb, intToLong($logo));
  }

  // required string name = 2;
  let $name = message.name;
  if ($name !== undefined) {
    writeVarint32(bb, 18);
    writeString(bb, $name);
  }

  // required int32 lv = 3;
  let $lv = message.lv;
  if ($lv !== undefined) {
    writeVarint32(bb, 24);
    writeVarint64(bb, intToLong($lv));
  }

  // optional int32 flag = 4;
  let $flag = message.flag;
  if ($flag !== undefined) {
    writeVarint32(bb, 32);
    writeVarint64(bb, intToLong($flag));
  }

  // optional int64 uid = 5;
  let $uid = message.uid;
  if ($uid !== undefined) {
    writeVarint32(bb, 40);
    writeVarint64(bb, $uid);
  }

  // optional int32 last = 6;
  let $last = message.last;
  if ($last !== undefined) {
    writeVarint32(bb, 48);
    writeVarint64(bb, intToLong($last));
  }

  // optional int64 power = 7;
  let $power = message.power;
  if ($power !== undefined) {
    writeVarint32(bb, 56);
    writeVarint64(bb, $power);
  }

  // optional int32 border = 8;
  let $border = message.border;
  if ($border !== undefined) {
    writeVarint32(bb, 64);
    writeVarint64(bb, intToLong($border));
  }

  // optional string country = 9;
  let $country = message.country;
  if ($country !== undefined) {
    writeVarint32(bb, 74);
    writeString(bb, $country);
  }

  // optional string sds = 10;
  let $sds = message.sds;
  if ($sds !== undefined) {
    writeVarint32(bb, 82);
    writeString(bb, $sds);
  }

  // optional string city = 11;
  let $city = message.city;
  if ($city !== undefined) {
    writeVarint32(bb, 90);
    writeString(bb, $city);
  }

  // optional int64 emblem = 12;
  let $emblem = message.emblem;
  if ($emblem !== undefined) {
    writeVarint32(bb, 96);
    writeVarint64(bb, $emblem);
  }
}

export function decodepb_frd(binary) {
  return _decodepb_frd(wrapByteBuffer(binary));
}

function _decodepb_frd(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // required int32 logo = 1;
      case 1: {
        message.logo = readVarint32(bb);
        break;
      }

      // required string name = 2;
      case 2: {
        message.name = readString(bb, readVarint32(bb));
        break;
      }

      // required int32 lv = 3;
      case 3: {
        message.lv = readVarint32(bb);
        break;
      }

      // optional int32 flag = 4;
      case 4: {
        message.flag = readVarint32(bb);
        break;
      }

      // optional int64 uid = 5;
      case 5: {
        message.uid = readVarint64(bb, /* unsigned */ false);
        break;
      }

      // optional int32 last = 6;
      case 6: {
        message.last = readVarint32(bb);
        break;
      }

      // optional int64 power = 7;
      case 7: {
        message.power = readVarint64(bb, /* unsigned */ false);
        break;
      }

      // optional int32 border = 8;
      case 8: {
        message.border = readVarint32(bb);
        break;
      }

      // optional string country = 9;
      case 9: {
        message.country = readString(bb, readVarint32(bb));
        break;
      }

      // optional string sds = 10;
      case 10: {
        message.sds = readString(bb, readVarint32(bb));
        break;
      }

      // optional string city = 11;
      case 11: {
        message.city = readString(bb, readVarint32(bb));
        break;
      }

      // optional int64 emblem = 12;
      case 12: {
        message.emblem = readVarint64(bb, /* unsigned */ false);
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  if (message.logo === undefined)
    throw new Error("Missing required field: logo");

  if (message.name === undefined)
    throw new Error("Missing required field: name");

  if (message.lv === undefined)
    throw new Error("Missing required field: lv");

  return message;
}

export function encodepb_friend(message) {
  let bb = popByteBuffer();
  _encodepb_friend(message, bb);
  return toUint8Array(bb);
}

function _encodepb_friend(message, bb) {
  // repeated pb_frd friends = 1;
  let array$friends = message.friends;
  if (array$friends !== undefined) {
    for (let value of array$friends) {
      writeVarint32(bb, 10);
      let nested = popByteBuffer();
      _encodepb_frd(value, nested);
      writeVarint32(bb, nested.limit);
      writeByteBuffer(bb, nested);
      pushByteBuffer(nested);
    }
  }

  // required int32 love = 2;
  let $love = message.love;
  if ($love !== undefined) {
    writeVarint32(bb, 16);
    writeVarint64(bb, intToLong($love));
  }

  // required int32 cd = 3;
  let $cd = message.cd;
  if ($cd !== undefined) {
    writeVarint32(bb, 24);
    writeVarint64(bb, intToLong($cd));
  }

  // repeated pb_frd apply = 4;
  let array$apply = message.apply;
  if (array$apply !== undefined) {
    for (let value of array$apply) {
      writeVarint32(bb, 34);
      let nested = popByteBuffer();
      _encodepb_frd(value, nested);
      writeVarint32(bb, nested.limit);
      writeByteBuffer(bb, nested);
      pushByteBuffer(nested);
    }
  }

  // repeated pb_frd recmd = 5;
  let array$recmd = message.recmd;
  if (array$recmd !== undefined) {
    for (let value of array$recmd) {
      writeVarint32(bb, 42);
      let nested = popByteBuffer();
      _encodepb_frd(value, nested);
      writeVarint32(bb, nested.limit);
      writeByteBuffer(bb, nested);
      pushByteBuffer(nested);
    }
  }
}

export function decodepb_friend(binary) {
  return _decodepb_friend(wrapByteBuffer(binary));
}

function _decodepb_friend(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // repeated pb_frd friends = 1;
      case 1: {
        let limit = pushTemporaryLength(bb);
        let values = message.friends || (message.friends = []);
        values.push(_decodepb_frd(bb));
        bb.limit = limit;
        break;
      }

      // required int32 love = 2;
      case 2: {
        message.love = readVarint32(bb);
        break;
      }

      // required int32 cd = 3;
      case 3: {
        message.cd = readVarint32(bb);
        break;
      }

      // repeated pb_frd apply = 4;
      case 4: {
        let limit = pushTemporaryLength(bb);
        let values = message.apply || (message.apply = []);
        values.push(_decodepb_frd(bb));
        bb.limit = limit;
        break;
      }

      // repeated pb_frd recmd = 5;
      case 5: {
        let limit = pushTemporaryLength(bb);
        let values = message.recmd || (message.recmd = []);
        values.push(_decodepb_frd(bb));
        bb.limit = limit;
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  if (message.love === undefined)
    throw new Error("Missing required field: love");

  if (message.cd === undefined)
    throw new Error("Missing required field: cd");

  return message;
}

export function encodepb_casino_item(message) {
  let bb = popByteBuffer();
  _encodepb_casino_item(message, bb);
  return toUint8Array(bb);
}

function _encodepb_casino_item(message, bb) {
  // required int32 type = 1;
  let $type = message.type;
  if ($type !== undefined) {
    writeVarint32(bb, 8);
    writeVarint64(bb, intToLong($type));
  }

  // required int32 id = 2;
  let $id = message.id;
  if ($id !== undefined) {
    writeVarint32(bb, 16);
    writeVarint64(bb, intToLong($id));
  }

  // required int32 count = 3;
  let $count = message.count;
  if ($count !== undefined) {
    writeVarint32(bb, 24);
    writeVarint64(bb, intToLong($count));
  }

  // optional int32 cool = 4;
  let $cool = message.cool;
  if ($cool !== undefined) {
    writeVarint32(bb, 32);
    writeVarint64(bb, intToLong($cool));
  }

  // optional int32 limitBuy = 5;
  let $limitBuy = message.limitBuy;
  if ($limitBuy !== undefined) {
    writeVarint32(bb, 40);
    writeVarint64(bb, intToLong($limitBuy));
  }

  // optional int32 weight = 6;
  let $weight = message.weight;
  if ($weight !== undefined) {
    writeVarint32(bb, 48);
    writeVarint64(bb, intToLong($weight));
  }
}

export function decodepb_casino_item(binary) {
  return _decodepb_casino_item(wrapByteBuffer(binary));
}

function _decodepb_casino_item(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // required int32 type = 1;
      case 1: {
        message.type = readVarint32(bb);
        break;
      }

      // required int32 id = 2;
      case 2: {
        message.id = readVarint32(bb);
        break;
      }

      // required int32 count = 3;
      case 3: {
        message.count = readVarint32(bb);
        break;
      }

      // optional int32 cool = 4;
      case 4: {
        message.cool = readVarint32(bb);
        break;
      }

      // optional int32 limitBuy = 5;
      case 5: {
        message.limitBuy = readVarint32(bb);
        break;
      }

      // optional int32 weight = 6;
      case 6: {
        message.weight = readVarint32(bb);
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  if (message.type === undefined)
    throw new Error("Missing required field: type");

  if (message.id === undefined)
    throw new Error("Missing required field: id");

  if (message.count === undefined)
    throw new Error("Missing required field: count");

  return message;
}

export function encodepb_casino_msg(message) {
  let bb = popByteBuffer();
  _encodepb_casino_msg(message, bb);
  return toUint8Array(bb);
}

function _encodepb_casino_msg(message, bb) {
  // required string name = 1;
  let $name = message.name;
  if ($name !== undefined) {
    writeVarint32(bb, 10);
    writeString(bb, $name);
  }

  // required int32 type = 2;
  let $type = message.type;
  if ($type !== undefined) {
    writeVarint32(bb, 16);
    writeVarint64(bb, intToLong($type));
  }

  // required int32 id = 3;
  let $id = message.id;
  if ($id !== undefined) {
    writeVarint32(bb, 24);
    writeVarint64(bb, intToLong($id));
  }

  // required int32 count = 4;
  let $count = message.count;
  if ($count !== undefined) {
    writeVarint32(bb, 32);
    writeVarint64(bb, intToLong($count));
  }
}

export function decodepb_casino_msg(binary) {
  return _decodepb_casino_msg(wrapByteBuffer(binary));
}

function _decodepb_casino_msg(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // required string name = 1;
      case 1: {
        message.name = readString(bb, readVarint32(bb));
        break;
      }

      // required int32 type = 2;
      case 2: {
        message.type = readVarint32(bb);
        break;
      }

      // required int32 id = 3;
      case 3: {
        message.id = readVarint32(bb);
        break;
      }

      // required int32 count = 4;
      case 4: {
        message.count = readVarint32(bb);
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  if (message.name === undefined)
    throw new Error("Missing required field: name");

  if (message.type === undefined)
    throw new Error("Missing required field: type");

  if (message.id === undefined)
    throw new Error("Missing required field: id");

  if (message.count === undefined)
    throw new Error("Missing required field: count");

  return message;
}

export function encodepb_gmember(message) {
  let bb = popByteBuffer();
  _encodepb_gmember(message, bb);
  return toUint8Array(bb);
}

function _encodepb_gmember(message, bb) {
  // required int64 uid = 1;
  let $uid = message.uid;
  if ($uid !== undefined) {
    writeVarint32(bb, 8);
    writeVarint64(bb, $uid);
  }

  // required string name = 2;
  let $name = message.name;
  if ($name !== undefined) {
    writeVarint32(bb, 18);
    writeString(bb, $name);
  }

  // optional int32 lv = 3;
  let $lv = message.lv;
  if ($lv !== undefined) {
    writeVarint32(bb, 24);
    writeVarint64(bb, intToLong($lv));
  }

  // optional int32 logo = 4;
  let $logo = message.logo;
  if ($logo !== undefined) {
    writeVarint32(bb, 32);
    writeVarint64(bb, intToLong($logo));
  }

  // optional int32 last = 5;
  let $last = message.last;
  if ($last !== undefined) {
    writeVarint32(bb, 40);
    writeVarint64(bb, intToLong($last));
  }

  // optional int32 title = 6;
  let $title = message.title;
  if ($title !== undefined) {
    writeVarint32(bb, 48);
    writeVarint64(bb, intToLong($title));
  }

  // optional int64 power = 7;
  let $power = message.power;
  if ($power !== undefined) {
    writeVarint32(bb, 56);
    writeVarint64(bb, $power);
  }

  // optional int32 gfight = 8;
  let $gfight = message.gfight;
  if ($gfight !== undefined) {
    writeVarint32(bb, 64);
    writeVarint64(bb, intToLong($gfight));
  }

  // optional int32 border = 9;
  let $border = message.border;
  if ($border !== undefined) {
    writeVarint32(bb, 72);
    writeVarint64(bb, intToLong($border));
  }

  // optional int32 cwar = 10;
  let $cwar = message.cwar;
  if ($cwar !== undefined) {
    writeVarint32(bb, 80);
    writeVarint64(bb, intToLong($cwar));
  }

  // optional string country = 11;
  let $country = message.country;
  if ($country !== undefined) {
    writeVarint32(bb, 90);
    writeString(bb, $country);
  }

  // optional string sds = 12;
  let $sds = message.sds;
  if ($sds !== undefined) {
    writeVarint32(bb, 98);
    writeString(bb, $sds);
  }

  // optional string city = 13;
  let $city = message.city;
  if ($city !== undefined) {
    writeVarint32(bb, 106);
    writeString(bb, $city);
  }

  // optional int64 emblem = 14;
  let $emblem = message.emblem;
  if ($emblem !== undefined) {
    writeVarint32(bb, 112);
    writeVarint64(bb, $emblem);
  }
}

export function decodepb_gmember(binary) {
  return _decodepb_gmember(wrapByteBuffer(binary));
}

function _decodepb_gmember(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // required int64 uid = 1;
      case 1: {
        message.uid = readVarint64(bb, /* unsigned */ false);
        break;
      }

      // required string name = 2;
      case 2: {
        message.name = readString(bb, readVarint32(bb));
        break;
      }

      // optional int32 lv = 3;
      case 3: {
        message.lv = readVarint32(bb);
        break;
      }

      // optional int32 logo = 4;
      case 4: {
        message.logo = readVarint32(bb);
        break;
      }

      // optional int32 last = 5;
      case 5: {
        message.last = readVarint32(bb);
        break;
      }

      // optional int32 title = 6;
      case 6: {
        message.title = readVarint32(bb);
        break;
      }

      // optional int64 power = 7;
      case 7: {
        message.power = readVarint64(bb, /* unsigned */ false);
        break;
      }

      // optional int32 gfight = 8;
      case 8: {
        message.gfight = readVarint32(bb);
        break;
      }

      // optional int32 border = 9;
      case 9: {
        message.border = readVarint32(bb);
        break;
      }

      // optional int32 cwar = 10;
      case 10: {
        message.cwar = readVarint32(bb);
        break;
      }

      // optional string country = 11;
      case 11: {
        message.country = readString(bb, readVarint32(bb));
        break;
      }

      // optional string sds = 12;
      case 12: {
        message.sds = readString(bb, readVarint32(bb));
        break;
      }

      // optional string city = 13;
      case 13: {
        message.city = readString(bb, readVarint32(bb));
        break;
      }

      // optional int64 emblem = 14;
      case 14: {
        message.emblem = readVarint64(bb, /* unsigned */ false);
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  if (message.uid === undefined)
    throw new Error("Missing required field: uid");

  if (message.name === undefined)
    throw new Error("Missing required field: name");

  return message;
}

export function encodepb_guild(message) {
  let bb = popByteBuffer();
  _encodepb_guild(message, bb);
  return toUint8Array(bb);
}

function _encodepb_guild(message, bb) {
  // required int32 id = 1;
  let $id = message.id;
  if ($id !== undefined) {
    writeVarint32(bb, 8);
    writeVarint64(bb, intToLong($id));
  }

  // required string name = 2;
  let $name = message.name;
  if ($name !== undefined) {
    writeVarint32(bb, 18);
    writeString(bb, $name);
  }

  // required int32 logo = 3;
  let $logo = message.logo;
  if ($logo !== undefined) {
    writeVarint32(bb, 24);
    writeVarint64(bb, intToLong($logo));
  }

  // required int32 exp = 4;
  let $exp = message.exp;
  if ($exp !== undefined) {
    writeVarint32(bb, 32);
    writeVarint64(bb, intToLong($exp));
  }

  // optional string notice = 5;
  let $notice = message.notice;
  if ($notice !== undefined) {
    writeVarint32(bb, 42);
    writeString(bb, $notice);
  }

  // optional int64 power = 6;
  let $power = message.power;
  if ($power !== undefined) {
    writeVarint32(bb, 48);
    writeVarint64(bb, $power);
  }

  // optional int32 rank = 7;
  let $rank = message.rank;
  if ($rank !== undefined) {
    writeVarint32(bb, 56);
    writeVarint64(bb, intToLong($rank));
  }

  // optional int32 members = 8;
  let $members = message.members;
  if ($members !== undefined) {
    writeVarint32(bb, 64);
    writeVarint64(bb, intToLong($members));
  }

  // optional string pname = 9;
  let $pname = message.pname;
  if ($pname !== undefined) {
    writeVarint32(bb, 74);
    writeString(bb, $pname);
  }

  // optional int32 dismiss_cd = 10;
  let $dismiss_cd = message.dismiss_cd;
  if ($dismiss_cd !== undefined) {
    writeVarint32(bb, 80);
    writeVarint64(bb, intToLong($dismiss_cd));
  }

  // optional int32 flag = 11;
  let $flag = message.flag;
  if ($flag !== undefined) {
    writeVarint32(bb, 88);
    writeVarint64(bb, intToLong($flag));
  }
}

export function decodepb_guild(binary) {
  return _decodepb_guild(wrapByteBuffer(binary));
}

function _decodepb_guild(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // required int32 id = 1;
      case 1: {
        message.id = readVarint32(bb);
        break;
      }

      // required string name = 2;
      case 2: {
        message.name = readString(bb, readVarint32(bb));
        break;
      }

      // required int32 logo = 3;
      case 3: {
        message.logo = readVarint32(bb);
        break;
      }

      // required int32 exp = 4;
      case 4: {
        message.exp = readVarint32(bb);
        break;
      }

      // optional string notice = 5;
      case 5: {
        message.notice = readString(bb, readVarint32(bb));
        break;
      }

      // optional int64 power = 6;
      case 6: {
        message.power = readVarint64(bb, /* unsigned */ false);
        break;
      }

      // optional int32 rank = 7;
      case 7: {
        message.rank = readVarint32(bb);
        break;
      }

      // optional int32 members = 8;
      case 8: {
        message.members = readVarint32(bb);
        break;
      }

      // optional string pname = 9;
      case 9: {
        message.pname = readString(bb, readVarint32(bb));
        break;
      }

      // optional int32 dismiss_cd = 10;
      case 10: {
        message.dismiss_cd = readVarint32(bb);
        break;
      }

      // optional int32 flag = 11;
      case 11: {
        message.flag = readVarint32(bb);
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  if (message.id === undefined)
    throw new Error("Missing required field: id");

  if (message.name === undefined)
    throw new Error("Missing required field: name");

  if (message.logo === undefined)
    throw new Error("Missing required field: logo");

  if (message.exp === undefined)
    throw new Error("Missing required field: exp");

  return message;
}

export function encodepb_glog(message) {
  let bb = popByteBuffer();
  _encodepb_glog(message, bb);
  return toUint8Array(bb);
}

function _encodepb_glog(message, bb) {
  // required int32 type = 1;
  let $type = message.type;
  if ($type !== undefined) {
    writeVarint32(bb, 8);
    writeVarint64(bb, intToLong($type));
  }

  // optional int32 time = 2;
  let $time = message.time;
  if ($time !== undefined) {
    writeVarint32(bb, 16);
    writeVarint64(bb, intToLong($time));
  }

  // optional string obj_name = 3;
  let $obj_name = message.obj_name;
  if ($obj_name !== undefined) {
    writeVarint32(bb, 26);
    writeString(bb, $obj_name);
  }

  // optional string do_name = 4;
  let $do_name = message.do_name;
  if ($do_name !== undefined) {
    writeVarint32(bb, 34);
    writeString(bb, $do_name);
  }
}

export function decodepb_glog(binary) {
  return _decodepb_glog(wrapByteBuffer(binary));
}

function _decodepb_glog(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // required int32 type = 1;
      case 1: {
        message.type = readVarint32(bb);
        break;
      }

      // optional int32 time = 2;
      case 2: {
        message.time = readVarint32(bb);
        break;
      }

      // optional string obj_name = 3;
      case 3: {
        message.obj_name = readString(bb, readVarint32(bb));
        break;
      }

      // optional string do_name = 4;
      case 4: {
        message.do_name = readString(bb, readVarint32(bb));
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  if (message.type === undefined)
    throw new Error("Missing required field: type");

  return message;
}

export function encodepb_unit(message) {
  let bb = popByteBuffer();
  _encodepb_unit(message, bb);
  return toUint8Array(bb);
}

function _encodepb_unit(message, bb) {
  // optional int32 hid = 1;
  let $hid = message.hid;
  if ($hid !== undefined) {
    writeVarint32(bb, 8);
    writeVarint64(bb, intToLong($hid));
  }

  // optional int32 id = 2;
  let $id = message.id;
  if ($id !== undefined) {
    writeVarint32(bb, 16);
    writeVarint64(bb, intToLong($id));
  }

  // optional int32 pos = 3;
  let $pos = message.pos;
  if ($pos !== undefined) {
    writeVarint32(bb, 24);
    writeVarint64(bb, intToLong($pos));
  }

  // optional int32 lv = 4;
  let $lv = message.lv;
  if ($lv !== undefined) {
    writeVarint32(bb, 32);
    writeVarint64(bb, intToLong($lv));
  }

  // optional int32 star = 5;
  let $star = message.star;
  if ($star !== undefined) {
    writeVarint32(bb, 40);
    writeVarint64(bb, intToLong($star));
  }

  // optional int32 energy = 6;
  let $energy = message.energy;
  if ($energy !== undefined) {
    writeVarint32(bb, 48);
    writeVarint64(bb, intToLong($energy));
  }

  // optional int32 hpp = 7;
  let $hpp = message.hpp;
  if ($hpp !== undefined) {
    writeVarint32(bb, 56);
    writeVarint64(bb, intToLong($hpp));
  }

  // optional int32 wake = 8;
  let $wake = message.wake;
  if ($wake !== undefined) {
    writeVarint32(bb, 64);
    writeVarint64(bb, intToLong($wake));
  }

  // optional int32 skin = 9;
  let $skin = message.skin;
  if ($skin !== undefined) {
    writeVarint32(bb, 72);
    writeVarint64(bb, intToLong($skin));
  }

  // optional int32 stl = 10;
  let $stl = message.stl;
  if ($stl !== undefined) {
    writeVarint32(bb, 80);
    writeVarint64(bb, intToLong($stl));
  }

  // optional int32 flag = 11;
  let $flag = message.flag;
  if ($flag !== undefined) {
    writeVarint32(bb, 88);
    writeVarint64(bb, intToLong($flag));
  }

  // optional int32 ex2 = 12;
  let $ex2 = message.ex2;
  if ($ex2 !== undefined) {
    writeVarint32(bb, 96);
    writeVarint64(bb, intToLong($ex2));
  }

  // optional int32 core = 13;
  let $core = message.core;
  if ($core !== undefined) {
    writeVarint32(bb, 104);
    writeVarint64(bb, intToLong($core));
  }

  // optional int32 ex4 = 14;
  let $ex4 = message.ex4;
  if ($ex4 !== undefined) {
    writeVarint32(bb, 112);
    writeVarint64(bb, intToLong($ex4));
  }

  // repeated int32 bra = 15;
  let array$bra = message.bra;
  if (array$bra !== undefined) {
    let packed = popByteBuffer();
    for (let value of array$bra) {
      writeVarint64(packed, intToLong(value));
    }
    writeVarint32(bb, 122);
    writeVarint32(bb, packed.offset);
    writeByteBuffer(bb, packed);
    pushByteBuffer(packed);
  }
}

export function decodepb_unit(binary) {
  return _decodepb_unit(wrapByteBuffer(binary));
}

function _decodepb_unit(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // optional int32 hid = 1;
      case 1: {
        message.hid = readVarint32(bb);
        break;
      }

      // optional int32 id = 2;
      case 2: {
        message.id = readVarint32(bb);
        break;
      }

      // optional int32 pos = 3;
      case 3: {
        message.pos = readVarint32(bb);
        break;
      }

      // optional int32 lv = 4;
      case 4: {
        message.lv = readVarint32(bb);
        break;
      }

      // optional int32 star = 5;
      case 5: {
        message.star = readVarint32(bb);
        break;
      }

      // optional int32 energy = 6;
      case 6: {
        message.energy = readVarint32(bb);
        break;
      }

      // optional int32 hpp = 7;
      case 7: {
        message.hpp = readVarint32(bb);
        break;
      }

      // optional int32 wake = 8;
      case 8: {
        message.wake = readVarint32(bb);
        break;
      }

      // optional int32 skin = 9;
      case 9: {
        message.skin = readVarint32(bb);
        break;
      }

      // optional int32 stl = 10;
      case 10: {
        message.stl = readVarint32(bb);
        break;
      }

      // optional int32 flag = 11;
      case 11: {
        message.flag = readVarint32(bb);
        break;
      }

      // optional int32 ex2 = 12;
      case 12: {
        message.ex2 = readVarint32(bb);
        break;
      }

      // optional int32 core = 13;
      case 13: {
        message.core = readVarint32(bb);
        break;
      }

      // optional int32 ex4 = 14;
      case 14: {
        message.ex4 = readVarint32(bb);
        break;
      }

      // repeated int32 bra = 15;
      case 15: {
        let values = message.bra || (message.bra = []);
        if ((tag & 7) === 2) {
          let outerLimit = pushTemporaryLength(bb);
          while (!isAtEnd(bb)) {
            values.push(readVarint32(bb));
          }
          bb.limit = outerLimit;
        } else {
          values.push(readVarint32(bb));
        }
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  return message;
}

export function encodepb_strial(message) {
  let bb = popByteBuffer();
  _encodepb_strial(message, bb);
  return toUint8Array(bb);
}

function _encodepb_strial(message, bb) {
  // required int32 id = 1;
  let $id = message.id;
  if ($id !== undefined) {
    writeVarint32(bb, 8);
    writeVarint64(bb, intToLong($id));
  }

  // required int32 tl = 2;
  let $tl = message.tl;
  if ($tl !== undefined) {
    writeVarint32(bb, 16);
    writeVarint64(bb, intToLong($tl));
  }

  // required int32 cd = 3;
  let $cd = message.cd;
  if ($cd !== undefined) {
    writeVarint32(bb, 24);
    writeVarint64(bb, intToLong($cd));
  }
}

export function decodepb_strial(binary) {
  return _decodepb_strial(wrapByteBuffer(binary));
}

function _decodepb_strial(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // required int32 id = 1;
      case 1: {
        message.id = readVarint32(bb);
        break;
      }

      // required int32 tl = 2;
      case 2: {
        message.tl = readVarint32(bb);
        break;
      }

      // required int32 cd = 3;
      case 3: {
        message.cd = readVarint32(bb);
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  if (message.id === undefined)
    throw new Error("Missing required field: id");

  if (message.tl === undefined)
    throw new Error("Missing required field: tl");

  if (message.cd === undefined)
    throw new Error("Missing required field: cd");

  return message;
}

export function encodepb_trial(message) {
  let bb = popByteBuffer();
  _encodepb_trial(message, bb);
  return toUint8Array(bb);
}

function _encodepb_trial(message, bb) {
  // required int32 logo = 1;
  let $logo = message.logo;
  if ($logo !== undefined) {
    writeVarint32(bb, 8);
    writeVarint64(bb, intToLong($logo));
  }

  // required int32 lv = 2;
  let $lv = message.lv;
  if ($lv !== undefined) {
    writeVarint32(bb, 16);
    writeVarint64(bb, intToLong($lv));
  }

  // required string name = 3;
  let $name = message.name;
  if ($name !== undefined) {
    writeVarint32(bb, 26);
    writeString(bb, $name);
  }

  // optional int64 power = 4;
  let $power = message.power;
  if ($power !== undefined) {
    writeVarint32(bb, 32);
    writeVarint64(bb, $power);
  }

  // optional int32 stage = 5;
  let $stage = message.stage;
  if ($stage !== undefined) {
    writeVarint32(bb, 40);
    writeVarint64(bb, intToLong($stage));
  }

  // optional pb_evideo video = 6;
  let $video = message.video;
  if ($video !== undefined) {
    writeVarint32(bb, 50);
    let nested = popByteBuffer();
    _encodepb_evideo($video, nested);
    writeVarint32(bb, nested.limit);
    writeByteBuffer(bb, nested);
    pushByteBuffer(nested);
  }

  // optional int32 border = 7;
  let $border = message.border;
  if ($border !== undefined) {
    writeVarint32(bb, 56);
    writeVarint64(bb, intToLong($border));
  }

  // optional int64 uid = 8;
  let $uid = message.uid;
  if ($uid !== undefined) {
    writeVarint32(bb, 64);
    writeVarint64(bb, $uid);
  }
}

export function decodepb_trial(binary) {
  return _decodepb_trial(wrapByteBuffer(binary));
}

function _decodepb_trial(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // required int32 logo = 1;
      case 1: {
        message.logo = readVarint32(bb);
        break;
      }

      // required int32 lv = 2;
      case 2: {
        message.lv = readVarint32(bb);
        break;
      }

      // required string name = 3;
      case 3: {
        message.name = readString(bb, readVarint32(bb));
        break;
      }

      // optional int64 power = 4;
      case 4: {
        message.power = readVarint64(bb, /* unsigned */ false);
        break;
      }

      // optional int32 stage = 5;
      case 5: {
        message.stage = readVarint32(bb);
        break;
      }

      // optional pb_evideo video = 6;
      case 6: {
        let limit = pushTemporaryLength(bb);
        message.video = _decodepb_evideo(bb);
        bb.limit = limit;
        break;
      }

      // optional int32 border = 7;
      case 7: {
        message.border = readVarint32(bb);
        break;
      }

      // optional int64 uid = 8;
      case 8: {
        message.uid = readVarint64(bb, /* unsigned */ false);
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  if (message.logo === undefined)
    throw new Error("Missing required field: logo");

  if (message.lv === undefined)
    throw new Error("Missing required field: lv");

  if (message.name === undefined)
    throw new Error("Missing required field: name");

  return message;
}

export function encodepb_plog(message) {
  let bb = popByteBuffer();
  _encodepb_plog(message, bb);
  return toUint8Array(bb);
}

function _encodepb_plog(message, bb) {
  // required pb_pmbr rival = 1;
  let $rival = message.rival;
  if ($rival !== undefined) {
    writeVarint32(bb, 10);
    let nested = popByteBuffer();
    _encodepb_pmbr($rival, nested);
    writeVarint32(bb, nested.limit);
    writeByteBuffer(bb, nested);
    pushByteBuffer(nested);
  }

  // required bool atk = 2;
  let $atk = message.atk;
  if ($atk !== undefined) {
    writeVarint32(bb, 16);
    writeByte(bb, $atk ? 1 : 0);
  }

  // required bool win = 3;
  let $win = message.win;
  if ($win !== undefined) {
    writeVarint32(bb, 24);
    writeByte(bb, $win ? 1 : 0);
  }

  // repeated int32 vid = 4;
  let array$vid = message.vid;
  if (array$vid !== undefined) {
    let packed = popByteBuffer();
    for (let value of array$vid) {
      writeVarint64(packed, intToLong(value));
    }
    writeVarint32(bb, 34);
    writeVarint32(bb, packed.offset);
    writeByteBuffer(bb, packed);
    pushByteBuffer(packed);
  }

  // required int32 time = 5;
  let $time = message.time;
  if ($time !== undefined) {
    writeVarint32(bb, 40);
    writeVarint64(bb, intToLong($time));
  }

  // required int32 score = 6;
  let $score = message.score;
  if ($score !== undefined) {
    writeVarint32(bb, 48);
    writeVarint64(bb, intToLong($score));
  }

  // repeated bool wins = 7;
  let array$wins = message.wins;
  if (array$wins !== undefined) {
    let packed = popByteBuffer();
    for (let value of array$wins) {
      writeByte(packed, value ? 1 : 0);
    }
    writeVarint32(bb, 58);
    writeVarint32(bb, packed.offset);
    writeByteBuffer(bb, packed);
    pushByteBuffer(packed);
  }
}

export function decodepb_plog(binary) {
  return _decodepb_plog(wrapByteBuffer(binary));
}

function _decodepb_plog(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // required pb_pmbr rival = 1;
      case 1: {
        let limit = pushTemporaryLength(bb);
        message.rival = _decodepb_pmbr(bb);
        bb.limit = limit;
        break;
      }

      // required bool atk = 2;
      case 2: {
        message.atk = !!readByte(bb);
        break;
      }

      // required bool win = 3;
      case 3: {
        message.win = !!readByte(bb);
        break;
      }

      // repeated int32 vid = 4;
      case 4: {
        let values = message.vid || (message.vid = []);
        if ((tag & 7) === 2) {
          let outerLimit = pushTemporaryLength(bb);
          while (!isAtEnd(bb)) {
            values.push(readVarint32(bb));
          }
          bb.limit = outerLimit;
        } else {
          values.push(readVarint32(bb));
        }
        break;
      }

      // required int32 time = 5;
      case 5: {
        message.time = readVarint32(bb);
        break;
      }

      // required int32 score = 6;
      case 6: {
        message.score = readVarint32(bb);
        break;
      }

      // repeated bool wins = 7;
      case 7: {
        let values = message.wins || (message.wins = []);
        if ((tag & 7) === 2) {
          let outerLimit = pushTemporaryLength(bb);
          while (!isAtEnd(bb)) {
            values.push(!!readByte(bb));
          }
          bb.limit = outerLimit;
        } else {
          values.push(!!readByte(bb));
        }
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  if (message.rival === undefined)
    throw new Error("Missing required field: rival");

  if (message.atk === undefined)
    throw new Error("Missing required field: atk");

  if (message.win === undefined)
    throw new Error("Missing required field: win");

  if (message.time === undefined)
    throw new Error("Missing required field: time");

  if (message.score === undefined)
    throw new Error("Missing required field: score");

  return message;
}

export function encodepb_p3plog(message) {
  let bb = popByteBuffer();
  _encodepb_p3plog(message, bb);
  return toUint8Array(bb);
}

function _encodepb_p3plog(message, bb) {
  // optional pb_p3pmbr def = 1;
  let $def = message.def;
  if ($def !== undefined) {
    writeVarint32(bb, 10);
    let nested = popByteBuffer();
    _encodepb_p3pmbr($def, nested);
    writeVarint32(bb, nested.limit);
    writeByteBuffer(bb, nested);
    pushByteBuffer(nested);
  }

  // optional bool atk = 2;
  let $atk = message.atk;
  if ($atk !== undefined) {
    writeVarint32(bb, 16);
    writeByte(bb, $atk ? 1 : 0);
  }

  // optional bool win = 3;
  let $win = message.win;
  if ($win !== undefined) {
    writeVarint32(bb, 24);
    writeByte(bb, $win ? 1 : 0);
  }

  // optional int32 vid = 4;
  let $vid = message.vid;
  if ($vid !== undefined) {
    writeVarint32(bb, 32);
    writeVarint64(bb, intToLong($vid));
  }

  // optional int32 time = 5;
  let $time = message.time;
  if ($time !== undefined) {
    writeVarint32(bb, 40);
    writeVarint64(bb, intToLong($time));
  }

  // optional int32 score = 6;
  let $score = message.score;
  if ($score !== undefined) {
    writeVarint32(bb, 48);
    writeVarint64(bb, intToLong($score));
  }
}

export function decodepb_p3plog(binary) {
  return _decodepb_p3plog(wrapByteBuffer(binary));
}

function _decodepb_p3plog(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // optional pb_p3pmbr def = 1;
      case 1: {
        let limit = pushTemporaryLength(bb);
        message.def = _decodepb_p3pmbr(bb);
        bb.limit = limit;
        break;
      }

      // optional bool atk = 2;
      case 2: {
        message.atk = !!readByte(bb);
        break;
      }

      // optional bool win = 3;
      case 3: {
        message.win = !!readByte(bb);
        break;
      }

      // optional int32 vid = 4;
      case 4: {
        message.vid = readVarint32(bb);
        break;
      }

      // optional int32 time = 5;
      case 5: {
        message.time = readVarint32(bb);
        break;
      }

      // optional int32 score = 6;
      case 6: {
        message.score = readVarint32(bb);
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  return message;
}

export function encodepb_pmbr(message) {
  let bb = popByteBuffer();
  _encodepb_pmbr(message, bb);
  return toUint8Array(bb);
}

function _encodepb_pmbr(message, bb) {
  // optional string name = 1;
  let $name = message.name;
  if ($name !== undefined) {
    writeVarint32(bb, 10);
    writeString(bb, $name);
  }

  // optional int64 uid = 2;
  let $uid = message.uid;
  if ($uid !== undefined) {
    writeVarint32(bb, 16);
    writeVarint64(bb, $uid);
  }

  // optional int32 lv = 3;
  let $lv = message.lv;
  if ($lv !== undefined) {
    writeVarint32(bb, 24);
    writeVarint64(bb, intToLong($lv));
  }

  // optional int32 logo = 4;
  let $logo = message.logo;
  if ($logo !== undefined) {
    writeVarint32(bb, 32);
    writeVarint64(bb, intToLong($logo));
  }

  // optional int32 score = 5;
  let $score = message.score;
  if ($score !== undefined) {
    writeVarint32(bb, 40);
    writeVarint64(bb, intToLong($score));
  }

  // optional int64 power = 6;
  let $power = message.power;
  if ($power !== undefined) {
    writeVarint32(bb, 48);
    writeVarint64(bb, $power);
  }

  // optional int32 rank = 7;
  let $rank = message.rank;
  if ($rank !== undefined) {
    writeVarint32(bb, 56);
    writeVarint64(bb, intToLong($rank));
  }

  // optional string gname = 8;
  let $gname = message.gname;
  if ($gname !== undefined) {
    writeVarint32(bb, 66);
    writeString(bb, $gname);
  }

  // optional int32 trank = 9;
  let $trank = message.trank;
  if ($trank !== undefined) {
    writeVarint32(bb, 72);
    writeVarint64(bb, intToLong($trank));
  }

  // optional int32 tscore = 10;
  let $tscore = message.tscore;
  if ($tscore !== undefined) {
    writeVarint32(bb, 80);
    writeVarint64(bb, intToLong($tscore));
  }

  // repeated pb_unit camp = 11;
  let array$camp = message.camp;
  if (array$camp !== undefined) {
    for (let value of array$camp) {
      writeVarint32(bb, 90);
      let nested = popByteBuffer();
      _encodepb_unit(value, nested);
      writeVarint32(bb, nested.limit);
      writeByteBuffer(bb, nested);
      pushByteBuffer(nested);
    }
  }

  // optional int32 win = 12;
  let $win = message.win;
  if ($win !== undefined) {
    writeVarint32(bb, 96);
    writeVarint64(bb, intToLong($win));
  }

  // optional int32 fight = 13;
  let $fight = message.fight;
  if ($fight !== undefined) {
    writeVarint32(bb, 104);
    writeVarint64(bb, intToLong($fight));
  }

  // optional int32 sid = 14;
  let $sid = message.sid;
  if ($sid !== undefined) {
    writeVarint32(bb, 112);
    writeVarint64(bb, intToLong($sid));
  }

  // optional int32 border = 15;
  let $border = message.border;
  if ($border !== undefined) {
    writeVarint32(bb, 120);
    writeVarint64(bb, intToLong($border));
  }

  // optional int32 ptype = 16;
  let $ptype = message.ptype;
  if ($ptype !== undefined) {
    writeVarint32(bb, 128);
    writeVarint64(bb, intToLong($ptype));
  }

  // optional int64 emblem = 17;
  let $emblem = message.emblem;
  if ($emblem !== undefined) {
    writeVarint32(bb, 136);
    writeVarint64(bb, $emblem);
  }
}

export function decodepb_pmbr(binary) {
  return _decodepb_pmbr(wrapByteBuffer(binary));
}

function _decodepb_pmbr(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // optional string name = 1;
      case 1: {
        message.name = readString(bb, readVarint32(bb));
        break;
      }

      // optional int64 uid = 2;
      case 2: {
        message.uid = readVarint64(bb, /* unsigned */ false);
        break;
      }

      // optional int32 lv = 3;
      case 3: {
        message.lv = readVarint32(bb);
        break;
      }

      // optional int32 logo = 4;
      case 4: {
        message.logo = readVarint32(bb);
        break;
      }

      // optional int32 score = 5;
      case 5: {
        message.score = readVarint32(bb);
        break;
      }

      // optional int64 power = 6;
      case 6: {
        message.power = readVarint64(bb, /* unsigned */ false);
        break;
      }

      // optional int32 rank = 7;
      case 7: {
        message.rank = readVarint32(bb);
        break;
      }

      // optional string gname = 8;
      case 8: {
        message.gname = readString(bb, readVarint32(bb));
        break;
      }

      // optional int32 trank = 9;
      case 9: {
        message.trank = readVarint32(bb);
        break;
      }

      // optional int32 tscore = 10;
      case 10: {
        message.tscore = readVarint32(bb);
        break;
      }

      // repeated pb_unit camp = 11;
      case 11: {
        let limit = pushTemporaryLength(bb);
        let values = message.camp || (message.camp = []);
        values.push(_decodepb_unit(bb));
        bb.limit = limit;
        break;
      }

      // optional int32 win = 12;
      case 12: {
        message.win = readVarint32(bb);
        break;
      }

      // optional int32 fight = 13;
      case 13: {
        message.fight = readVarint32(bb);
        break;
      }

      // optional int32 sid = 14;
      case 14: {
        message.sid = readVarint32(bb);
        break;
      }

      // optional int32 border = 15;
      case 15: {
        message.border = readVarint32(bb);
        break;
      }

      // optional int32 ptype = 16;
      case 16: {
        message.ptype = readVarint32(bb);
        break;
      }

      // optional int64 emblem = 17;
      case 17: {
        message.emblem = readVarint64(bb, /* unsigned */ false);
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  return message;
}

export function encodepb_p3pmbr(message) {
  let bb = popByteBuffer();
  _encodepb_p3pmbr(message, bb);
  return toUint8Array(bb);
}

function _encodepb_p3pmbr(message, bb) {
  // optional string name = 1;
  let $name = message.name;
  if ($name !== undefined) {
    writeVarint32(bb, 10);
    writeString(bb, $name);
  }

  // optional int64 uid = 2;
  let $uid = message.uid;
  if ($uid !== undefined) {
    writeVarint32(bb, 16);
    writeVarint64(bb, $uid);
  }

  // optional int32 lv = 3;
  let $lv = message.lv;
  if ($lv !== undefined) {
    writeVarint32(bb, 24);
    writeVarint64(bb, intToLong($lv));
  }

  // optional int32 logo = 4;
  let $logo = message.logo;
  if ($logo !== undefined) {
    writeVarint32(bb, 32);
    writeVarint64(bb, intToLong($logo));
  }

  // optional int32 lbox = 5;
  let $lbox = message.lbox;
  if ($lbox !== undefined) {
    writeVarint32(bb, 40);
    writeVarint64(bb, intToLong($lbox));
  }

  // optional int64 power = 6;
  let $power = message.power;
  if ($power !== undefined) {
    writeVarint32(bb, 48);
    writeVarint64(bb, $power);
  }

  // optional int32 rank = 7;
  let $rank = message.rank;
  if ($rank !== undefined) {
    writeVarint32(bb, 56);
    writeVarint64(bb, intToLong($rank));
  }

  // optional int32 score = 8;
  let $score = message.score;
  if ($score !== undefined) {
    writeVarint32(bb, 64);
    writeVarint64(bb, intToLong($score));
  }

  // repeated pb_unit camp = 9;
  let array$camp = message.camp;
  if (array$camp !== undefined) {
    for (let value of array$camp) {
      writeVarint32(bb, 74);
      let nested = popByteBuffer();
      _encodepb_unit(value, nested);
      writeVarint32(bb, nested.limit);
      writeByteBuffer(bb, nested);
      pushByteBuffer(nested);
    }
  }

  // optional int64 emblem = 10;
  let $emblem = message.emblem;
  if ($emblem !== undefined) {
    writeVarint32(bb, 80);
    writeVarint64(bb, $emblem);
  }
}

export function decodepb_p3pmbr(binary) {
  return _decodepb_p3pmbr(wrapByteBuffer(binary));
}

function _decodepb_p3pmbr(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // optional string name = 1;
      case 1: {
        message.name = readString(bb, readVarint32(bb));
        break;
      }

      // optional int64 uid = 2;
      case 2: {
        message.uid = readVarint64(bb, /* unsigned */ false);
        break;
      }

      // optional int32 lv = 3;
      case 3: {
        message.lv = readVarint32(bb);
        break;
      }

      // optional int32 logo = 4;
      case 4: {
        message.logo = readVarint32(bb);
        break;
      }

      // optional int32 lbox = 5;
      case 5: {
        message.lbox = readVarint32(bb);
        break;
      }

      // optional int64 power = 6;
      case 6: {
        message.power = readVarint64(bb, /* unsigned */ false);
        break;
      }

      // optional int32 rank = 7;
      case 7: {
        message.rank = readVarint32(bb);
        break;
      }

      // optional int32 score = 8;
      case 8: {
        message.score = readVarint32(bb);
        break;
      }

      // repeated pb_unit camp = 9;
      case 9: {
        let limit = pushTemporaryLength(bb);
        let values = message.camp || (message.camp = []);
        values.push(_decodepb_unit(bb));
        bb.limit = limit;
        break;
      }

      // optional int64 emblem = 10;
      case 10: {
        message.emblem = readVarint64(bb, /* unsigned */ false);
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  return message;
}

export function encodepb_smbr(message) {
  let bb = popByteBuffer();
  _encodepb_smbr(message, bb);
  return toUint8Array(bb);
}

function _encodepb_smbr(message, bb) {
  // optional string name = 1;
  let $name = message.name;
  if ($name !== undefined) {
    writeVarint32(bb, 10);
    writeString(bb, $name);
  }

  // optional int64 uid = 2;
  let $uid = message.uid;
  if ($uid !== undefined) {
    writeVarint32(bb, 16);
    writeVarint64(bb, $uid);
  }

  // optional int32 lv = 3;
  let $lv = message.lv;
  if ($lv !== undefined) {
    writeVarint32(bb, 24);
    writeVarint64(bb, intToLong($lv));
  }

  // optional int32 logo = 4;
  let $logo = message.logo;
  if ($logo !== undefined) {
    writeVarint32(bb, 32);
    writeVarint64(bb, intToLong($logo));
  }

  // optional int32 lbox = 5;
  let $lbox = message.lbox;
  if ($lbox !== undefined) {
    writeVarint32(bb, 40);
    writeVarint64(bb, intToLong($lbox));
  }

  // optional int32 score = 6;
  let $score = message.score;
  if ($score !== undefined) {
    writeVarint32(bb, 48);
    writeVarint64(bb, intToLong($score));
  }

  // optional int32 like = 7;
  let $like = message.like;
  if ($like !== undefined) {
    writeVarint32(bb, 56);
    writeVarint64(bb, intToLong($like));
  }

  // optional string cluster = 8;
  let $cluster = message.cluster;
  if ($cluster !== undefined) {
    writeVarint32(bb, 66);
    writeString(bb, $cluster);
  }

  // optional string udk = 9;
  let $udk = message.udk;
  if ($udk !== undefined) {
    writeVarint32(bb, 74);
    writeString(bb, $udk);
  }

  // optional string gname = 10;
  let $gname = message.gname;
  if ($gname !== undefined) {
    writeVarint32(bb, 82);
    writeString(bb, $gname);
  }

  // repeated pb_unit camp = 11;
  let array$camp = message.camp;
  if (array$camp !== undefined) {
    for (let value of array$camp) {
      writeVarint32(bb, 90);
      let nested = popByteBuffer();
      _encodepb_unit(value, nested);
      writeVarint32(bb, nested.limit);
      writeByteBuffer(bb, nested);
      pushByteBuffer(nested);
    }
  }

  // repeated int32 skls = 12;
  let array$skls = message.skls;
  if (array$skls !== undefined) {
    let packed = popByteBuffer();
    for (let value of array$skls) {
      writeVarint64(packed, intToLong(value));
    }
    writeVarint32(bb, 98);
    writeVarint32(bb, packed.offset);
    writeByteBuffer(bb, packed);
    pushByteBuffer(packed);
  }

  // optional sint64 power = 13;
  let $power = message.power;
  if ($power !== undefined) {
    writeVarint32(bb, 104);
    writeVarint64ZigZag(bb, $power);
  }

  // repeated sint32 hide = 14;
  let array$hide = message.hide;
  if (array$hide !== undefined) {
    let packed = popByteBuffer();
    for (let value of array$hide) {
      writeVarint32ZigZag(packed, value);
    }
    writeVarint32(bb, 114);
    writeVarint32(bb, packed.offset);
    writeByteBuffer(bb, packed);
    pushByteBuffer(packed);
  }

  // optional int64 emblem = 15;
  let $emblem = message.emblem;
  if ($emblem !== undefined) {
    writeVarint32(bb, 120);
    writeVarint64(bb, $emblem);
  }
}

export function decodepb_smbr(binary) {
  return _decodepb_smbr(wrapByteBuffer(binary));
}

function _decodepb_smbr(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // optional string name = 1;
      case 1: {
        message.name = readString(bb, readVarint32(bb));
        break;
      }

      // optional int64 uid = 2;
      case 2: {
        message.uid = readVarint64(bb, /* unsigned */ false);
        break;
      }

      // optional int32 lv = 3;
      case 3: {
        message.lv = readVarint32(bb);
        break;
      }

      // optional int32 logo = 4;
      case 4: {
        message.logo = readVarint32(bb);
        break;
      }

      // optional int32 lbox = 5;
      case 5: {
        message.lbox = readVarint32(bb);
        break;
      }

      // optional int32 score = 6;
      case 6: {
        message.score = readVarint32(bb);
        break;
      }

      // optional int32 like = 7;
      case 7: {
        message.like = readVarint32(bb);
        break;
      }

      // optional string cluster = 8;
      case 8: {
        message.cluster = readString(bb, readVarint32(bb));
        break;
      }

      // optional string udk = 9;
      case 9: {
        message.udk = readString(bb, readVarint32(bb));
        break;
      }

      // optional string gname = 10;
      case 10: {
        message.gname = readString(bb, readVarint32(bb));
        break;
      }

      // repeated pb_unit camp = 11;
      case 11: {
        let limit = pushTemporaryLength(bb);
        let values = message.camp || (message.camp = []);
        values.push(_decodepb_unit(bb));
        bb.limit = limit;
        break;
      }

      // repeated int32 skls = 12;
      case 12: {
        let values = message.skls || (message.skls = []);
        if ((tag & 7) === 2) {
          let outerLimit = pushTemporaryLength(bb);
          while (!isAtEnd(bb)) {
            values.push(readVarint32(bb));
          }
          bb.limit = outerLimit;
        } else {
          values.push(readVarint32(bb));
        }
        break;
      }

      // optional sint64 power = 13;
      case 13: {
        message.power = readVarint64ZigZag(bb);
        break;
      }

      // repeated sint32 hide = 14;
      case 14: {
        let values = message.hide || (message.hide = []);
        if ((tag & 7) === 2) {
          let outerLimit = pushTemporaryLength(bb);
          while (!isAtEnd(bb)) {
            values.push(readVarint32ZigZag(bb));
          }
          bb.limit = outerLimit;
        } else {
          values.push(readVarint32ZigZag(bb));
        }
        break;
      }

      // optional int64 emblem = 15;
      case 15: {
        message.emblem = readVarint64(bb, /* unsigned */ false);
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  return message;
}

export function encodepb_smbrs(message) {
  let bb = popByteBuffer();
  _encodepb_smbrs(message, bb);
  return toUint8Array(bb);
}

function _encodepb_smbrs(message, bb) {
  // repeated pb_smbr mbrs = 1;
  let array$mbrs = message.mbrs;
  if (array$mbrs !== undefined) {
    for (let value of array$mbrs) {
      writeVarint32(bb, 10);
      let nested = popByteBuffer();
      _encodepb_smbr(value, nested);
      writeVarint32(bb, nested.limit);
      writeByteBuffer(bb, nested);
      pushByteBuffer(nested);
    }
  }

  // optional int32 score = 2;
  let $score = message.score;
  if ($score !== undefined) {
    writeVarint32(bb, 16);
    writeVarint64(bb, intToLong($score));
  }

  // optional int32 rank = 3;
  let $rank = message.rank;
  if ($rank !== undefined) {
    writeVarint32(bb, 24);
    writeVarint64(bb, intToLong($rank));
  }

  // optional int32 like = 4;
  let $like = message.like;
  if ($like !== undefined) {
    writeVarint32(bb, 32);
    writeVarint64(bb, intToLong($like));
  }
}

export function decodepb_smbrs(binary) {
  return _decodepb_smbrs(wrapByteBuffer(binary));
}

function _decodepb_smbrs(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // repeated pb_smbr mbrs = 1;
      case 1: {
        let limit = pushTemporaryLength(bb);
        let values = message.mbrs || (message.mbrs = []);
        values.push(_decodepb_smbr(bb));
        bb.limit = limit;
        break;
      }

      // optional int32 score = 2;
      case 2: {
        message.score = readVarint32(bb);
        break;
      }

      // optional int32 rank = 3;
      case 3: {
        message.rank = readVarint32(bb);
        break;
      }

      // optional int32 like = 4;
      case 4: {
        message.like = readVarint32(bb);
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  return message;
}

export function encodepb_template(message) {
  let bb = popByteBuffer();
  _encodepb_template(message, bb);
  return toUint8Array(bb);
}

function _encodepb_template(message, bb) {
  // optional int32 id = 1;
  let $id = message.id;
  if ($id !== undefined) {
    writeVarint32(bb, 8);
    writeVarint64(bb, intToLong($id));
  }

  // optional string name = 2;
  let $name = message.name;
  if ($name !== undefined) {
    writeVarint32(bb, 18);
    writeString(bb, $name);
  }

  // repeated pb_buildings buildings = 3;
  let array$buildings = message.buildings;
  if (array$buildings !== undefined) {
    for (let value of array$buildings) {
      writeVarint32(bb, 26);
      let nested = popByteBuffer();
      _encodepb_buildings(value, nested);
      writeVarint32(bb, nested.limit);
      writeByteBuffer(bb, nested);
      pushByteBuffer(nested);
    }
  }

  // repeated pb_room rooms = 4;
  let array$rooms = message.rooms;
  if (array$rooms !== undefined) {
    for (let value of array$rooms) {
      writeVarint32(bb, 34);
      let nested = popByteBuffer();
      _encodepb_room(value, nested);
      writeVarint32(bb, nested.limit);
      writeByteBuffer(bb, nested);
      pushByteBuffer(nested);
    }
  }
}

export function decodepb_template(binary) {
  return _decodepb_template(wrapByteBuffer(binary));
}

function _decodepb_template(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // optional int32 id = 1;
      case 1: {
        message.id = readVarint32(bb);
        break;
      }

      // optional string name = 2;
      case 2: {
        message.name = readString(bb, readVarint32(bb));
        break;
      }

      // repeated pb_buildings buildings = 3;
      case 3: {
        let limit = pushTemporaryLength(bb);
        let values = message.buildings || (message.buildings = []);
        values.push(_decodepb_buildings(bb));
        bb.limit = limit;
        break;
      }

      // repeated pb_room rooms = 4;
      case 4: {
        let limit = pushTemporaryLength(bb);
        let values = message.rooms || (message.rooms = []);
        values.push(_decodepb_room(bb));
        bb.limit = limit;
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  return message;
}

export function encodepb_pvp(message) {
  let bb = popByteBuffer();
  _encodepb_pvp(message, bb);
  return toUint8Array(bb);
}

function _encodepb_pvp(message, bb) {
  // required int32 id = 1;
  let $id = message.id;
  if ($id !== undefined) {
    writeVarint32(bb, 8);
    writeVarint64(bb, intToLong($id));
  }

  // required sint32 status = 2;
  let $status = message.status;
  if ($status !== undefined) {
    writeVarint32(bb, 16);
    writeVarint32ZigZag(bb, $status);
  }

  // optional pb_pmbr self = 3;
  let $self = message.self;
  if ($self !== undefined) {
    writeVarint32(bb, 26);
    let nested = popByteBuffer();
    _encodepb_pmbr($self, nested);
    writeVarint32(bb, nested.limit);
    writeByteBuffer(bb, nested);
    pushByteBuffer(nested);
  }

  // optional int32 season_cd = 4;
  let $season_cd = message.season_cd;
  if ($season_cd !== undefined) {
    writeVarint32(bb, 32);
    writeVarint64(bb, intToLong($season_cd));
  }

  // optional int32 daily_cd = 5;
  let $daily_cd = message.daily_cd;
  if ($daily_cd !== undefined) {
    writeVarint32(bb, 40);
    writeVarint64(bb, intToLong($daily_cd));
  }
}

export function decodepb_pvp(binary) {
  return _decodepb_pvp(wrapByteBuffer(binary));
}

function _decodepb_pvp(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // required int32 id = 1;
      case 1: {
        message.id = readVarint32(bb);
        break;
      }

      // required sint32 status = 2;
      case 2: {
        message.status = readVarint32ZigZag(bb);
        break;
      }

      // optional pb_pmbr self = 3;
      case 3: {
        let limit = pushTemporaryLength(bb);
        message.self = _decodepb_pmbr(bb);
        bb.limit = limit;
        break;
      }

      // optional int32 season_cd = 4;
      case 4: {
        message.season_cd = readVarint32(bb);
        break;
      }

      // optional int32 daily_cd = 5;
      case 5: {
        message.daily_cd = readVarint32(bb);
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  if (message.id === undefined)
    throw new Error("Missing required field: id");

  if (message.status === undefined)
    throw new Error("Missing required field: status");

  return message;
}

export function encodepb_wpvp(message) {
  let bb = popByteBuffer();
  _encodepb_wpvp(message, bb);
  return toUint8Array(bb);
}

function _encodepb_wpvp(message, bb) {
  // required int32 wid = 1;
  let $wid = message.wid;
  if ($wid !== undefined) {
    writeVarint32(bb, 8);
    writeVarint64(bb, intToLong($wid));
  }

  // optional int32 flag = 2;
  let $flag = message.flag;
  if ($flag !== undefined) {
    writeVarint32(bb, 16);
    writeVarint64(bb, intToLong($flag));
  }

  // optional int32 cd = 3;
  let $cd = message.cd;
  if ($cd !== undefined) {
    writeVarint32(bb, 24);
    writeVarint64(bb, intToLong($cd));
  }
}

export function decodepb_wpvp(binary) {
  return _decodepb_wpvp(wrapByteBuffer(binary));
}

function _decodepb_wpvp(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // required int32 wid = 1;
      case 1: {
        message.wid = readVarint32(bb);
        break;
      }

      // optional int32 flag = 2;
      case 2: {
        message.flag = readVarint32(bb);
        break;
      }

      // optional int32 cd = 3;
      case 3: {
        message.cd = readVarint32(bb);
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  if (message.wid === undefined)
    throw new Error("Missing required field: wid");

  return message;
}

export function encodepb_wmbr(message) {
  let bb = popByteBuffer();
  _encodepb_wmbr(message, bb);
  return toUint8Array(bb);
}

function _encodepb_wmbr(message, bb) {
  // optional int64 uid = 1;
  let $uid = message.uid;
  if ($uid !== undefined) {
    writeVarint32(bb, 8);
    writeVarint64(bb, $uid);
  }

  // optional string gname = 2;
  let $gname = message.gname;
  if ($gname !== undefined) {
    writeVarint32(bb, 18);
    writeString(bb, $gname);
  }

  // optional int32 score = 3;
  let $score = message.score;
  if ($score !== undefined) {
    writeVarint32(bb, 24);
    writeVarint64(bb, intToLong($score));
  }

  // optional string name = 4;
  let $name = message.name;
  if ($name !== undefined) {
    writeVarint32(bb, 34);
    writeString(bb, $name);
  }

  // optional int32 logo = 5;
  let $logo = message.logo;
  if ($logo !== undefined) {
    writeVarint32(bb, 40);
    writeVarint64(bb, intToLong($logo));
  }

  // optional int32 lv = 6;
  let $lv = message.lv;
  if ($lv !== undefined) {
    writeVarint32(bb, 48);
    writeVarint64(bb, intToLong($lv));
  }

  // optional int64 power = 7;
  let $power = message.power;
  if ($power !== undefined) {
    writeVarint32(bb, 56);
    writeVarint64(bb, $power);
  }

  // optional int32 lbox = 8;
  let $lbox = message.lbox;
  if ($lbox !== undefined) {
    writeVarint32(bb, 64);
    writeVarint64(bb, intToLong($lbox));
  }

  // optional int32 like = 9;
  let $like = message.like;
  if ($like !== undefined) {
    writeVarint32(bb, 72);
    writeVarint64(bb, intToLong($like));
  }

  // optional bool king = 10;
  let $king = message.king;
  if ($king !== undefined) {
    writeVarint32(bb, 80);
    writeByte(bb, $king ? 1 : 0);
  }

  // optional int32 num = 11;
  let $num = message.num;
  if ($num !== undefined) {
    writeVarint32(bb, 88);
    writeVarint64(bb, intToLong($num));
  }

  // optional int64 emblem = 12;
  let $emblem = message.emblem;
  if ($emblem !== undefined) {
    writeVarint32(bb, 96);
    writeVarint64(bb, $emblem);
  }
}

export function decodepb_wmbr(binary) {
  return _decodepb_wmbr(wrapByteBuffer(binary));
}

function _decodepb_wmbr(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // optional int64 uid = 1;
      case 1: {
        message.uid = readVarint64(bb, /* unsigned */ false);
        break;
      }

      // optional string gname = 2;
      case 2: {
        message.gname = readString(bb, readVarint32(bb));
        break;
      }

      // optional int32 score = 3;
      case 3: {
        message.score = readVarint32(bb);
        break;
      }

      // optional string name = 4;
      case 4: {
        message.name = readString(bb, readVarint32(bb));
        break;
      }

      // optional int32 logo = 5;
      case 5: {
        message.logo = readVarint32(bb);
        break;
      }

      // optional int32 lv = 6;
      case 6: {
        message.lv = readVarint32(bb);
        break;
      }

      // optional int64 power = 7;
      case 7: {
        message.power = readVarint64(bb, /* unsigned */ false);
        break;
      }

      // optional int32 lbox = 8;
      case 8: {
        message.lbox = readVarint32(bb);
        break;
      }

      // optional int32 like = 9;
      case 9: {
        message.like = readVarint32(bb);
        break;
      }

      // optional bool king = 10;
      case 10: {
        message.king = !!readByte(bb);
        break;
      }

      // optional int32 num = 11;
      case 11: {
        message.num = readVarint32(bb);
        break;
      }

      // optional int64 emblem = 12;
      case 12: {
        message.emblem = readVarint64(bb, /* unsigned */ false);
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  return message;
}

export function encodepb_link(message) {
  let bb = popByteBuffer();
  _encodepb_link(message, bb);
  return toUint8Array(bb);
}

function _encodepb_link(message, bb) {
  // optional int32 cd = 1;
  let $cd = message.cd;
  if ($cd !== undefined) {
    writeVarint32(bb, 8);
    writeVarint64(bb, intToLong($cd));
  }

  // optional int32 win = 2;
  let $win = message.win;
  if ($win !== undefined) {
    writeVarint32(bb, 16);
    writeVarint64(bb, intToLong($win));
  }

  // optional int64 vid = 3;
  let $vid = message.vid;
  if ($vid !== undefined) {
    writeVarint32(bb, 24);
    writeVarint64(bb, $vid);
  }
}

export function decodepb_link(binary) {
  return _decodepb_link(wrapByteBuffer(binary));
}

function _decodepb_link(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // optional int32 cd = 1;
      case 1: {
        message.cd = readVarint32(bb);
        break;
      }

      // optional int32 win = 2;
      case 2: {
        message.win = readVarint32(bb);
        break;
      }

      // optional int64 vid = 3;
      case 3: {
        message.vid = readVarint64(bb, /* unsigned */ false);
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  return message;
}

export function encodepb_wlog(message) {
  let bb = popByteBuffer();
  _encodepb_wlog(message, bb);
  return toUint8Array(bb);
}

function _encodepb_wlog(message, bb) {
  // optional int64 vid = 1;
  let $vid = message.vid;
  if ($vid !== undefined) {
    writeVarint32(bb, 8);
    writeVarint64(bb, $vid);
  }

  // repeated pb_unit atk = 2;
  let array$atk = message.atk;
  if (array$atk !== undefined) {
    for (let value of array$atk) {
      writeVarint32(bb, 18);
      let nested = popByteBuffer();
      _encodepb_unit(value, nested);
      writeVarint32(bb, nested.limit);
      writeByteBuffer(bb, nested);
      pushByteBuffer(nested);
    }
  }

  // repeated pb_unit def = 3;
  let array$def = message.def;
  if (array$def !== undefined) {
    for (let value of array$def) {
      writeVarint32(bb, 26);
      let nested = popByteBuffer();
      _encodepb_unit(value, nested);
      writeVarint32(bb, nested.limit);
      writeByteBuffer(bb, nested);
      pushByteBuffer(nested);
    }
  }

  // required bool win = 4;
  let $win = message.win;
  if ($win !== undefined) {
    writeVarint32(bb, 32);
    writeByte(bb, $win ? 1 : 0);
  }
}

export function decodepb_wlog(binary) {
  return _decodepb_wlog(wrapByteBuffer(binary));
}

function _decodepb_wlog(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // optional int64 vid = 1;
      case 1: {
        message.vid = readVarint64(bb, /* unsigned */ false);
        break;
      }

      // repeated pb_unit atk = 2;
      case 2: {
        let limit = pushTemporaryLength(bb);
        let values = message.atk || (message.atk = []);
        values.push(_decodepb_unit(bb));
        bb.limit = limit;
        break;
      }

      // repeated pb_unit def = 3;
      case 3: {
        let limit = pushTemporaryLength(bb);
        let values = message.def || (message.def = []);
        values.push(_decodepb_unit(bb));
        bb.limit = limit;
        break;
      }

      // required bool win = 4;
      case 4: {
        message.win = !!readByte(bb);
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  if (message.win === undefined)
    throw new Error("Missing required field: win");

  return message;
}

export function encodepb_wvideo(message) {
  let bb = popByteBuffer();
  _encodepb_wvideo(message, bb);
  return toUint8Array(bb);
}

function _encodepb_wvideo(message, bb) {
  // repeated pb_unit atk = 1;
  let array$atk = message.atk;
  if (array$atk !== undefined) {
    for (let value of array$atk) {
      writeVarint32(bb, 10);
      let nested = popByteBuffer();
      _encodepb_unit(value, nested);
      writeVarint32(bb, nested.limit);
      writeByteBuffer(bb, nested);
      pushByteBuffer(nested);
    }
  }

  // repeated pb_unit def = 2;
  let array$def = message.def;
  if (array$def !== undefined) {
    for (let value of array$def) {
      writeVarint32(bb, 18);
      let nested = popByteBuffer();
      _encodepb_unit(value, nested);
      writeVarint32(bb, nested.limit);
      writeByteBuffer(bb, nested);
      pushByteBuffer(nested);
    }
  }

  // repeated bytes frames = 3;
  let array$frames = message.frames;
  if (array$frames !== undefined) {
    for (let value of array$frames) {
      writeVarint32(bb, 26);
      writeVarint32(bb, value.length), writeBytes(bb, value);
    }
  }

  // repeated pb_hurts hurts = 4;
  let array$hurts = message.hurts;
  if (array$hurts !== undefined) {
    for (let value of array$hurts) {
      writeVarint32(bb, 34);
      let nested = popByteBuffer();
      _encodepb_hurts(value, nested);
      writeVarint32(bb, nested.limit);
      writeByteBuffer(bb, nested);
      pushByteBuffer(nested);
    }
  }

  // required bool win = 5;
  let $win = message.win;
  if ($win !== undefined) {
    writeVarint32(bb, 40);
    writeByte(bb, $win ? 1 : 0);
  }
}

export function decodepb_wvideo(binary) {
  return _decodepb_wvideo(wrapByteBuffer(binary));
}

function _decodepb_wvideo(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // repeated pb_unit atk = 1;
      case 1: {
        let limit = pushTemporaryLength(bb);
        let values = message.atk || (message.atk = []);
        values.push(_decodepb_unit(bb));
        bb.limit = limit;
        break;
      }

      // repeated pb_unit def = 2;
      case 2: {
        let limit = pushTemporaryLength(bb);
        let values = message.def || (message.def = []);
        values.push(_decodepb_unit(bb));
        bb.limit = limit;
        break;
      }

      // repeated bytes frames = 3;
      case 3: {
        let values = message.frames || (message.frames = []);
        values.push(readBytes(bb, readVarint32(bb)));
        break;
      }

      // repeated pb_hurts hurts = 4;
      case 4: {
        let limit = pushTemporaryLength(bb);
        let values = message.hurts || (message.hurts = []);
        values.push(_decodepb_hurts(bb));
        bb.limit = limit;
        break;
      }

      // required bool win = 5;
      case 5: {
        message.win = !!readByte(bb);
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  if (message.win === undefined)
    throw new Error("Missing required field: win");

  return message;
}

export function encodepb_wscore(message) {
  let bb = popByteBuffer();
  _encodepb_wscore(message, bb);
  return toUint8Array(bb);
}

function _encodepb_wscore(message, bb) {
  // required sint32 score = 1;
  let $score = message.score;
  if ($score !== undefined) {
    writeVarint32(bb, 8);
    writeVarint32ZigZag(bb, $score);
  }

  // required sint32 delta = 2;
  let $delta = message.delta;
  if ($delta !== undefined) {
    writeVarint32(bb, 16);
    writeVarint32ZigZag(bb, $delta);
  }

  // optional bool king = 3;
  let $king = message.king;
  if ($king !== undefined) {
    writeVarint32(bb, 24);
    writeByte(bb, $king ? 1 : 0);
  }
}

export function decodepb_wscore(binary) {
  return _decodepb_wscore(wrapByteBuffer(binary));
}

function _decodepb_wscore(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // required sint32 score = 1;
      case 1: {
        message.score = readVarint32ZigZag(bb);
        break;
      }

      // required sint32 delta = 2;
      case 2: {
        message.delta = readVarint32ZigZag(bb);
        break;
      }

      // optional bool king = 3;
      case 3: {
        message.king = !!readByte(bb);
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  if (message.score === undefined)
    throw new Error("Missing required field: score");

  if (message.delta === undefined)
    throw new Error("Missing required field: delta");

  return message;
}

export function encodepb_wcamp(message) {
  let bb = popByteBuffer();
  _encodepb_wcamp(message, bb);
  return toUint8Array(bb);
}

function _encodepb_wcamp(message, bb) {
  // repeated pb_unit camp = 1;
  let array$camp = message.camp;
  if (array$camp !== undefined) {
    for (let value of array$camp) {
      writeVarint32(bb, 10);
      let nested = popByteBuffer();
      _encodepb_unit(value, nested);
      writeVarint32(bb, nested.limit);
      writeByteBuffer(bb, nested);
      pushByteBuffer(nested);
    }
  }
}

export function decodepb_wcamp(binary) {
  return _decodepb_wcamp(wrapByteBuffer(binary));
}

function _decodepb_wcamp(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // repeated pb_unit camp = 1;
      case 1: {
        let limit = pushTemporaryLength(bb);
        let values = message.camp || (message.camp = []);
        values.push(_decodepb_unit(bb));
        bb.limit = limit;
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  return message;
}

export function encodepb_wloger(message) {
  let bb = popByteBuffer();
  _encodepb_wloger(message, bb);
  return toUint8Array(bb);
}

function _encodepb_wloger(message, bb) {
  // required int64 vid = 1;
  let $vid = message.vid;
  if ($vid !== undefined) {
    writeVarint32(bb, 8);
    writeVarint64(bb, $vid);
  }

  // optional pb_wmbr mbr = 2;
  let $mbr = message.mbr;
  if ($mbr !== undefined) {
    writeVarint32(bb, 18);
    let nested = popByteBuffer();
    _encodepb_wmbr($mbr, nested);
    writeVarint32(bb, nested.limit);
    writeByteBuffer(bb, nested);
    pushByteBuffer(nested);
  }

  // optional int32 time = 3;
  let $time = message.time;
  if ($time !== undefined) {
    writeVarint32(bb, 24);
    writeVarint64(bb, intToLong($time));
  }

  // optional bool atk = 4;
  let $atk = message.atk;
  if ($atk !== undefined) {
    writeVarint32(bb, 32);
    writeByte(bb, $atk ? 1 : 0);
  }

  // optional bool win = 5;
  let $win = message.win;
  if ($win !== undefined) {
    writeVarint32(bb, 40);
    writeByte(bb, $win ? 1 : 0);
  }

  // optional sint32 delta = 6;
  let $delta = message.delta;
  if ($delta !== undefined) {
    writeVarint32(bb, 48);
    writeVarint32ZigZag(bb, $delta);
  }
}

export function decodepb_wloger(binary) {
  return _decodepb_wloger(wrapByteBuffer(binary));
}

function _decodepb_wloger(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // required int64 vid = 1;
      case 1: {
        message.vid = readVarint64(bb, /* unsigned */ false);
        break;
      }

      // optional pb_wmbr mbr = 2;
      case 2: {
        let limit = pushTemporaryLength(bb);
        message.mbr = _decodepb_wmbr(bb);
        bb.limit = limit;
        break;
      }

      // optional int32 time = 3;
      case 3: {
        message.time = readVarint32(bb);
        break;
      }

      // optional bool atk = 4;
      case 4: {
        message.atk = !!readByte(bb);
        break;
      }

      // optional bool win = 5;
      case 5: {
        message.win = !!readByte(bb);
        break;
      }

      // optional sint32 delta = 6;
      case 6: {
        message.delta = readVarint32ZigZag(bb);
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  if (message.vid === undefined)
    throw new Error("Missing required field: vid");

  return message;
}

export function encodepb_pvideo(message) {
  let bb = popByteBuffer();
  _encodepb_pvideo(message, bb);
  return toUint8Array(bb);
}

function _encodepb_pvideo(message, bb) {
  // optional int32 id = 1;
  let $id = message.id;
  if ($id !== undefined) {
    writeVarint32(bb, 8);
    writeVarint64(bb, intToLong($id));
  }

  // optional pb_pmbr atk = 2;
  let $atk = message.atk;
  if ($atk !== undefined) {
    writeVarint32(bb, 18);
    let nested = popByteBuffer();
    _encodepb_pmbr($atk, nested);
    writeVarint32(bb, nested.limit);
    writeByteBuffer(bb, nested);
    pushByteBuffer(nested);
  }

  // optional pb_pmbr def = 3;
  let $def = message.def;
  if ($def !== undefined) {
    writeVarint32(bb, 26);
    let nested = popByteBuffer();
    _encodepb_pmbr($def, nested);
    writeVarint32(bb, nested.limit);
    writeByteBuffer(bb, nested);
    pushByteBuffer(nested);
  }

  // required bool win = 4;
  let $win = message.win;
  if ($win !== undefined) {
    writeVarint32(bb, 32);
    writeByte(bb, $win ? 1 : 0);
  }

  // repeated bytes frames = 5;
  let array$frames = message.frames;
  if (array$frames !== undefined) {
    for (let value of array$frames) {
      writeVarint32(bb, 42);
      writeVarint32(bb, value.length), writeBytes(bb, value);
    }
  }

  // optional sint32 ascore = 6;
  let $ascore = message.ascore;
  if ($ascore !== undefined) {
    writeVarint32(bb, 48);
    writeVarint32ZigZag(bb, $ascore);
  }

  // optional sint32 dscore = 7;
  let $dscore = message.dscore;
  if ($dscore !== undefined) {
    writeVarint32(bb, 56);
    writeVarint32ZigZag(bb, $dscore);
  }

  // optional sint32 adelta = 8;
  let $adelta = message.adelta;
  if ($adelta !== undefined) {
    writeVarint32(bb, 64);
    writeVarint32ZigZag(bb, $adelta);
  }

  // optional sint32 ddelta = 9;
  let $ddelta = message.ddelta;
  if ($ddelta !== undefined) {
    writeVarint32(bb, 72);
    writeVarint32ZigZag(bb, $ddelta);
  }

  // repeated pb_hurts hurts = 10;
  let array$hurts = message.hurts;
  if (array$hurts !== undefined) {
    for (let value of array$hurts) {
      writeVarint32(bb, 82);
      let nested = popByteBuffer();
      _encodepb_hurts(value, nested);
      writeVarint32(bb, nested.limit);
      writeByteBuffer(bb, nested);
      pushByteBuffer(nested);
    }
  }

  // repeated pb_bag rewards = 11;
  let array$rewards = message.rewards;
  if (array$rewards !== undefined) {
    for (let value of array$rewards) {
      writeVarint32(bb, 90);
      let nested = popByteBuffer();
      _encodepb_bag(value, nested);
      writeVarint32(bb, nested.limit);
      writeByteBuffer(bb, nested);
      pushByteBuffer(nested);
    }
  }

  // optional int32 select = 12;
  let $select = message.select;
  if ($select !== undefined) {
    writeVarint32(bb, 96);
    writeVarint64(bb, intToLong($select));
  }
}

export function decodepb_pvideo(binary) {
  return _decodepb_pvideo(wrapByteBuffer(binary));
}

function _decodepb_pvideo(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // optional int32 id = 1;
      case 1: {
        message.id = readVarint32(bb);
        break;
      }

      // optional pb_pmbr atk = 2;
      case 2: {
        let limit = pushTemporaryLength(bb);
        message.atk = _decodepb_pmbr(bb);
        bb.limit = limit;
        break;
      }

      // optional pb_pmbr def = 3;
      case 3: {
        let limit = pushTemporaryLength(bb);
        message.def = _decodepb_pmbr(bb);
        bb.limit = limit;
        break;
      }

      // required bool win = 4;
      case 4: {
        message.win = !!readByte(bb);
        break;
      }

      // repeated bytes frames = 5;
      case 5: {
        let values = message.frames || (message.frames = []);
        values.push(readBytes(bb, readVarint32(bb)));
        break;
      }

      // optional sint32 ascore = 6;
      case 6: {
        message.ascore = readVarint32ZigZag(bb);
        break;
      }

      // optional sint32 dscore = 7;
      case 7: {
        message.dscore = readVarint32ZigZag(bb);
        break;
      }

      // optional sint32 adelta = 8;
      case 8: {
        message.adelta = readVarint32ZigZag(bb);
        break;
      }

      // optional sint32 ddelta = 9;
      case 9: {
        message.ddelta = readVarint32ZigZag(bb);
        break;
      }

      // repeated pb_hurts hurts = 10;
      case 10: {
        let limit = pushTemporaryLength(bb);
        let values = message.hurts || (message.hurts = []);
        values.push(_decodepb_hurts(bb));
        bb.limit = limit;
        break;
      }

      // repeated pb_bag rewards = 11;
      case 11: {
        let limit = pushTemporaryLength(bb);
        let values = message.rewards || (message.rewards = []);
        values.push(_decodepb_bag(bb));
        bb.limit = limit;
        break;
      }

      // optional int32 select = 12;
      case 12: {
        message.select = readVarint32(bb);
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  if (message.win === undefined)
    throw new Error("Missing required field: win");

  return message;
}

export function encodepb_p3pvideo(message) {
  let bb = popByteBuffer();
  _encodepb_p3pvideo(message, bb);
  return toUint8Array(bb);
}

function _encodepb_p3pvideo(message, bb) {
  // optional pb_p3pmbr atk = 1;
  let $atk = message.atk;
  if ($atk !== undefined) {
    writeVarint32(bb, 10);
    let nested = popByteBuffer();
    _encodepb_p3pmbr($atk, nested);
    writeVarint32(bb, nested.limit);
    writeByteBuffer(bb, nested);
    pushByteBuffer(nested);
  }

  // optional pb_p3pmbr def = 2;
  let $def = message.def;
  if ($def !== undefined) {
    writeVarint32(bb, 18);
    let nested = popByteBuffer();
    _encodepb_p3pmbr($def, nested);
    writeVarint32(bb, nested.limit);
    writeByteBuffer(bb, nested);
    pushByteBuffer(nested);
  }

  // required bool win = 3;
  let $win = message.win;
  if ($win !== undefined) {
    writeVarint32(bb, 24);
    writeByte(bb, $win ? 1 : 0);
  }

  // repeated bytes frames = 4;
  let array$frames = message.frames;
  if (array$frames !== undefined) {
    for (let value of array$frames) {
      writeVarint32(bb, 34);
      writeVarint32(bb, value.length), writeBytes(bb, value);
    }
  }

  // repeated pb_hurts hurts = 5;
  let array$hurts = message.hurts;
  if (array$hurts !== undefined) {
    for (let value of array$hurts) {
      writeVarint32(bb, 42);
      let nested = popByteBuffer();
      _encodepb_hurts(value, nested);
      writeVarint32(bb, nested.limit);
      writeByteBuffer(bb, nested);
      pushByteBuffer(nested);
    }
  }

  // optional sint32 ascore = 6;
  let $ascore = message.ascore;
  if ($ascore !== undefined) {
    writeVarint32(bb, 48);
    writeVarint32ZigZag(bb, $ascore);
  }

  // optional sint32 dscore = 7;
  let $dscore = message.dscore;
  if ($dscore !== undefined) {
    writeVarint32(bb, 56);
    writeVarint32ZigZag(bb, $dscore);
  }

  // optional sint32 adelta = 8;
  let $adelta = message.adelta;
  if ($adelta !== undefined) {
    writeVarint32(bb, 64);
    writeVarint32ZigZag(bb, $adelta);
  }

  // optional sint32 ddelta = 9;
  let $ddelta = message.ddelta;
  if ($ddelta !== undefined) {
    writeVarint32(bb, 72);
    writeVarint32ZigZag(bb, $ddelta);
  }

  // repeated pb_bag rewards = 10;
  let array$rewards = message.rewards;
  if (array$rewards !== undefined) {
    for (let value of array$rewards) {
      writeVarint32(bb, 82);
      let nested = popByteBuffer();
      _encodepb_bag(value, nested);
      writeVarint32(bb, nested.limit);
      writeByteBuffer(bb, nested);
      pushByteBuffer(nested);
    }
  }

  // optional int32 select = 11;
  let $select = message.select;
  if ($select !== undefined) {
    writeVarint32(bb, 88);
    writeVarint64(bb, intToLong($select));
  }
}

export function decodepb_p3pvideo(binary) {
  return _decodepb_p3pvideo(wrapByteBuffer(binary));
}

function _decodepb_p3pvideo(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // optional pb_p3pmbr atk = 1;
      case 1: {
        let limit = pushTemporaryLength(bb);
        message.atk = _decodepb_p3pmbr(bb);
        bb.limit = limit;
        break;
      }

      // optional pb_p3pmbr def = 2;
      case 2: {
        let limit = pushTemporaryLength(bb);
        message.def = _decodepb_p3pmbr(bb);
        bb.limit = limit;
        break;
      }

      // required bool win = 3;
      case 3: {
        message.win = !!readByte(bb);
        break;
      }

      // repeated bytes frames = 4;
      case 4: {
        let values = message.frames || (message.frames = []);
        values.push(readBytes(bb, readVarint32(bb)));
        break;
      }

      // repeated pb_hurts hurts = 5;
      case 5: {
        let limit = pushTemporaryLength(bb);
        let values = message.hurts || (message.hurts = []);
        values.push(_decodepb_hurts(bb));
        bb.limit = limit;
        break;
      }

      // optional sint32 ascore = 6;
      case 6: {
        message.ascore = readVarint32ZigZag(bb);
        break;
      }

      // optional sint32 dscore = 7;
      case 7: {
        message.dscore = readVarint32ZigZag(bb);
        break;
      }

      // optional sint32 adelta = 8;
      case 8: {
        message.adelta = readVarint32ZigZag(bb);
        break;
      }

      // optional sint32 ddelta = 9;
      case 9: {
        message.ddelta = readVarint32ZigZag(bb);
        break;
      }

      // repeated pb_bag rewards = 10;
      case 10: {
        let limit = pushTemporaryLength(bb);
        let values = message.rewards || (message.rewards = []);
        values.push(_decodepb_bag(bb));
        bb.limit = limit;
        break;
      }

      // optional int32 select = 11;
      case 11: {
        message.select = readVarint32(bb);
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  if (message.win === undefined)
    throw new Error("Missing required field: win");

  return message;
}

export function encodepb_htask_info(message) {
  let bb = popByteBuffer();
  _encodepb_htask_info(message, bb);
  return toUint8Array(bb);
}

function _encodepb_htask_info(message, bb) {
  // optional int32 tid = 1;
  let $tid = message.tid;
  if ($tid !== undefined) {
    writeVarint32(bb, 8);
    writeVarint64(bb, intToLong($tid));
  }

  // repeated int32 hids = 2;
  let array$hids = message.hids;
  if (array$hids !== undefined) {
    let packed = popByteBuffer();
    for (let value of array$hids) {
      writeVarint64(packed, intToLong(value));
    }
    writeVarint32(bb, 18);
    writeVarint32(bb, packed.offset);
    writeByteBuffer(bb, packed);
    pushByteBuffer(packed);
  }

  // repeated int32 heads = 3;
  let array$heads = message.heads;
  if (array$heads !== undefined) {
    let packed = popByteBuffer();
    for (let value of array$heads) {
      writeVarint64(packed, intToLong(value));
    }
    writeVarint32(bb, 26);
    writeVarint32(bb, packed.offset);
    writeByteBuffer(bb, packed);
    pushByteBuffer(packed);
  }
}

export function decodepb_htask_info(binary) {
  return _decodepb_htask_info(wrapByteBuffer(binary));
}

function _decodepb_htask_info(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // optional int32 tid = 1;
      case 1: {
        message.tid = readVarint32(bb);
        break;
      }

      // repeated int32 hids = 2;
      case 2: {
        let values = message.hids || (message.hids = []);
        if ((tag & 7) === 2) {
          let outerLimit = pushTemporaryLength(bb);
          while (!isAtEnd(bb)) {
            values.push(readVarint32(bb));
          }
          bb.limit = outerLimit;
        } else {
          values.push(readVarint32(bb));
        }
        break;
      }

      // repeated int32 heads = 3;
      case 3: {
        let values = message.heads || (message.heads = []);
        if ((tag & 7) === 2) {
          let outerLimit = pushTemporaryLength(bb);
          while (!isAtEnd(bb)) {
            values.push(readVarint32(bb));
          }
          bb.limit = outerLimit;
        } else {
          values.push(readVarint32(bb));
        }
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  return message;
}

export function encodepb_htask_cond(message) {
  let bb = popByteBuffer();
  _encodepb_htask_cond(message, bb);
  return toUint8Array(bb);
}

function _encodepb_htask_cond(message, bb) {
  // required int32 type = 1;
  let $type = message.type;
  if ($type !== undefined) {
    writeVarint32(bb, 8);
    writeVarint64(bb, intToLong($type));
  }

  // optional int32 faction = 2;
  let $faction = message.faction;
  if ($faction !== undefined) {
    writeVarint32(bb, 16);
    writeVarint64(bb, intToLong($faction));
  }
}

export function decodepb_htask_cond(binary) {
  return _decodepb_htask_cond(wrapByteBuffer(binary));
}

function _decodepb_htask_cond(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // required int32 type = 1;
      case 1: {
        message.type = readVarint32(bb);
        break;
      }

      // optional int32 faction = 2;
      case 2: {
        message.faction = readVarint32(bb);
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  if (message.type === undefined)
    throw new Error("Missing required field: type");

  return message;
}

export function encodepb_htask_sync(message) {
  let bb = popByteBuffer();
  _encodepb_htask_sync(message, bb);
  return toUint8Array(bb);
}

function _encodepb_htask_sync(message, bb) {
  // required int32 cd = 1;
  let $cd = message.cd;
  if ($cd !== undefined) {
    writeVarint32(bb, 8);
    writeVarint64(bb, intToLong($cd));
  }

  // repeated pb_htask tasks = 2;
  let array$tasks = message.tasks;
  if (array$tasks !== undefined) {
    for (let value of array$tasks) {
      writeVarint32(bb, 18);
      let nested = popByteBuffer();
      _encodepb_htask(value, nested);
      writeVarint32(bb, nested.limit);
      writeByteBuffer(bb, nested);
      pushByteBuffer(nested);
    }
  }
}

export function decodepb_htask_sync(binary) {
  return _decodepb_htask_sync(wrapByteBuffer(binary));
}

function _decodepb_htask_sync(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // required int32 cd = 1;
      case 1: {
        message.cd = readVarint32(bb);
        break;
      }

      // repeated pb_htask tasks = 2;
      case 2: {
        let limit = pushTemporaryLength(bb);
        let values = message.tasks || (message.tasks = []);
        values.push(_decodepb_htask(bb));
        bb.limit = limit;
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  if (message.cd === undefined)
    throw new Error("Missing required field: cd");

  return message;
}

export function encodepb_htask(message) {
  let bb = popByteBuffer();
  _encodepb_htask(message, bb);
  return toUint8Array(bb);
}

function _encodepb_htask(message, bb) {
  // required int32 tid = 1;
  let $tid = message.tid;
  if ($tid !== undefined) {
    writeVarint32(bb, 8);
    writeVarint64(bb, intToLong($tid));
  }

  // required int32 id = 2;
  let $id = message.id;
  if ($id !== undefined) {
    writeVarint32(bb, 16);
    writeVarint64(bb, intToLong($id));
  }

  // optional int32 cd = 3;
  let $cd = message.cd;
  if ($cd !== undefined) {
    writeVarint32(bb, 24);
    writeVarint64(bb, intToLong($cd));
  }

  // repeated pb_unit heroes = 4;
  let array$heroes = message.heroes;
  if (array$heroes !== undefined) {
    for (let value of array$heroes) {
      writeVarint32(bb, 34);
      let nested = popByteBuffer();
      _encodepb_unit(value, nested);
      writeVarint32(bb, nested.limit);
      writeByteBuffer(bb, nested);
      pushByteBuffer(nested);
    }
  }

  // optional pb_bag reward = 5;
  let $reward = message.reward;
  if ($reward !== undefined) {
    writeVarint32(bb, 42);
    let nested = popByteBuffer();
    _encodepb_bag($reward, nested);
    writeVarint32(bb, nested.limit);
    writeByteBuffer(bb, nested);
    pushByteBuffer(nested);
  }

  // repeated pb_htask_cond conds = 6;
  let array$conds = message.conds;
  if (array$conds !== undefined) {
    for (let value of array$conds) {
      writeVarint32(bb, 50);
      let nested = popByteBuffer();
      _encodepb_htask_cond(value, nested);
      writeVarint32(bb, nested.limit);
      writeByteBuffer(bb, nested);
      pushByteBuffer(nested);
    }
  }

  // optional int64 power = 7;
  let $power = message.power;
  if ($power !== undefined) {
    writeVarint32(bb, 56);
    writeVarint64(bb, $power);
  }

  // optional int32 lock = 8;
  let $lock = message.lock;
  if ($lock !== undefined) {
    writeVarint32(bb, 64);
    writeVarint64(bb, intToLong($lock));
  }

  // required int32 nameid = 9;
  let $nameid = message.nameid;
  if ($nameid !== undefined) {
    writeVarint32(bb, 72);
    writeVarint64(bb, intToLong($nameid));
  }

  // repeated int32 heads = 10;
  let array$heads = message.heads;
  if (array$heads !== undefined) {
    let packed = popByteBuffer();
    for (let value of array$heads) {
      writeVarint64(packed, intToLong(value));
    }
    writeVarint32(bb, 82);
    writeVarint32(bb, packed.offset);
    writeByteBuffer(bb, packed);
    pushByteBuffer(packed);
  }
}

export function decodepb_htask(binary) {
  return _decodepb_htask(wrapByteBuffer(binary));
}

function _decodepb_htask(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // required int32 tid = 1;
      case 1: {
        message.tid = readVarint32(bb);
        break;
      }

      // required int32 id = 2;
      case 2: {
        message.id = readVarint32(bb);
        break;
      }

      // optional int32 cd = 3;
      case 3: {
        message.cd = readVarint32(bb);
        break;
      }

      // repeated pb_unit heroes = 4;
      case 4: {
        let limit = pushTemporaryLength(bb);
        let values = message.heroes || (message.heroes = []);
        values.push(_decodepb_unit(bb));
        bb.limit = limit;
        break;
      }

      // optional pb_bag reward = 5;
      case 5: {
        let limit = pushTemporaryLength(bb);
        message.reward = _decodepb_bag(bb);
        bb.limit = limit;
        break;
      }

      // repeated pb_htask_cond conds = 6;
      case 6: {
        let limit = pushTemporaryLength(bb);
        let values = message.conds || (message.conds = []);
        values.push(_decodepb_htask_cond(bb));
        bb.limit = limit;
        break;
      }

      // optional int64 power = 7;
      case 7: {
        message.power = readVarint64(bb, /* unsigned */ false);
        break;
      }

      // optional int32 lock = 8;
      case 8: {
        message.lock = readVarint32(bb);
        break;
      }

      // required int32 nameid = 9;
      case 9: {
        message.nameid = readVarint32(bb);
        break;
      }

      // repeated int32 heads = 10;
      case 10: {
        let values = message.heads || (message.heads = []);
        if ((tag & 7) === 2) {
          let outerLimit = pushTemporaryLength(bb);
          while (!isAtEnd(bb)) {
            values.push(readVarint32(bb));
          }
          bb.limit = outerLimit;
        } else {
          values.push(readVarint32(bb));
        }
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  if (message.tid === undefined)
    throw new Error("Missing required field: tid");

  if (message.id === undefined)
    throw new Error("Missing required field: id");

  if (message.nameid === undefined)
    throw new Error("Missing required field: nameid");

  return message;
}

export function encodepb_evideo(message) {
  let bb = popByteBuffer();
  _encodepb_evideo(message, bb);
  return toUint8Array(bb);
}

function _encodepb_evideo(message, bb) {
  // repeated bytes frames = 1;
  let array$frames = message.frames;
  if (array$frames !== undefined) {
    for (let value of array$frames) {
      writeVarint32(bb, 10);
      writeVarint32(bb, value.length), writeBytes(bb, value);
    }
  }

  // optional bool win = 2;
  let $win = message.win;
  if ($win !== undefined) {
    writeVarint32(bb, 16);
    writeByte(bb, $win ? 1 : 0);
  }

  // optional pb_bag reward = 3;
  let $reward = message.reward;
  if ($reward !== undefined) {
    writeVarint32(bb, 26);
    let nested = popByteBuffer();
    _encodepb_bag($reward, nested);
    writeVarint32(bb, nested.limit);
    writeByteBuffer(bb, nested);
    pushByteBuffer(nested);
  }

  // repeated pb_unit camp = 4;
  let array$camp = message.camp;
  if (array$camp !== undefined) {
    for (let value of array$camp) {
      writeVarint32(bb, 34);
      let nested = popByteBuffer();
      _encodepb_unit(value, nested);
      writeVarint32(bb, nested.limit);
      writeByteBuffer(bb, nested);
      pushByteBuffer(nested);
    }
  }

  // repeated pb_hurts hurts = 5;
  let array$hurts = message.hurts;
  if (array$hurts !== undefined) {
    for (let value of array$hurts) {
      writeVarint32(bb, 42);
      let nested = popByteBuffer();
      _encodepb_hurts(value, nested);
      writeVarint32(bb, nested.limit);
      writeByteBuffer(bb, nested);
      pushByteBuffer(nested);
    }
  }
}

export function decodepb_evideo(binary) {
  return _decodepb_evideo(wrapByteBuffer(binary));
}

function _decodepb_evideo(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // repeated bytes frames = 1;
      case 1: {
        let values = message.frames || (message.frames = []);
        values.push(readBytes(bb, readVarint32(bb)));
        break;
      }

      // optional bool win = 2;
      case 2: {
        message.win = !!readByte(bb);
        break;
      }

      // optional pb_bag reward = 3;
      case 3: {
        let limit = pushTemporaryLength(bb);
        message.reward = _decodepb_bag(bb);
        bb.limit = limit;
        break;
      }

      // repeated pb_unit camp = 4;
      case 4: {
        let limit = pushTemporaryLength(bb);
        let values = message.camp || (message.camp = []);
        values.push(_decodepb_unit(bb));
        bb.limit = limit;
        break;
      }

      // repeated pb_hurts hurts = 5;
      case 5: {
        let limit = pushTemporaryLength(bb);
        let values = message.hurts || (message.hurts = []);
        values.push(_decodepb_hurts(bb));
        bb.limit = limit;
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  return message;
}

export function encodepb_hurts(message) {
  let bb = popByteBuffer();
  _encodepb_hurts(message, bb);
  return toUint8Array(bb);
}

function _encodepb_hurts(message, bb) {
  // required int32 pos = 1;
  let $pos = message.pos;
  if ($pos !== undefined) {
    writeVarint32(bb, 8);
    writeVarint64(bb, intToLong($pos));
  }

  // required int64 value = 2;
  let $value = message.value;
  if ($value !== undefined) {
    writeVarint32(bb, 16);
    writeVarint64(bb, $value);
  }

  // optional int64 heal = 3;
  let $heal = message.heal;
  if ($heal !== undefined) {
    writeVarint32(bb, 24);
    writeVarint64(bb, $heal);
  }

  // optional bool alive = 4;
  let $alive = message.alive;
  if ($alive !== undefined) {
    writeVarint32(bb, 32);
    writeByte(bb, $alive ? 1 : 0);
  }
}

export function decodepb_hurts(binary) {
  return _decodepb_hurts(wrapByteBuffer(binary));
}

function _decodepb_hurts(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // required int32 pos = 1;
      case 1: {
        message.pos = readVarint32(bb);
        break;
      }

      // required int64 value = 2;
      case 2: {
        message.value = readVarint64(bb, /* unsigned */ false);
        break;
      }

      // optional int64 heal = 3;
      case 3: {
        message.heal = readVarint64(bb, /* unsigned */ false);
        break;
      }

      // optional bool alive = 4;
      case 4: {
        message.alive = !!readByte(bb);
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  if (message.pos === undefined)
    throw new Error("Missing required field: pos");

  if (message.value === undefined)
    throw new Error("Missing required field: value");

  return message;
}

export function encodepb_alogin(message) {
  let bb = popByteBuffer();
  _encodepb_alogin(message, bb);
  return toUint8Array(bb);
}

function _encodepb_alogin(message, bb) {
  // required string flag = 1;
  let $flag = message.flag;
  if ($flag !== undefined) {
    writeVarint32(bb, 10);
    writeString(bb, $flag);
  }

  // optional int32 cd = 2;
  let $cd = message.cd;
  if ($cd !== undefined) {
    writeVarint32(bb, 16);
    writeVarint64(bb, intToLong($cd));
  }

  // optional int32 idx = 3;
  let $idx = message.idx;
  if ($idx !== undefined) {
    writeVarint32(bb, 24);
    writeVarint64(bb, intToLong($idx));
  }

  // optional int32 num = 4;
  let $num = message.num;
  if ($num !== undefined) {
    writeVarint32(bb, 32);
    writeVarint64(bb, intToLong($num));
  }

  // optional int32 cd2 = 5;
  let $cd2 = message.cd2;
  if ($cd2 !== undefined) {
    writeVarint32(bb, 40);
    writeVarint64(bb, intToLong($cd2));
  }

  // optional int32 first = 6;
  let $first = message.first;
  if ($first !== undefined) {
    writeVarint32(bb, 48);
    writeVarint64(bb, intToLong($first));
  }
}

export function decodepb_alogin(binary) {
  return _decodepb_alogin(wrapByteBuffer(binary));
}

function _decodepb_alogin(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // required string flag = 1;
      case 1: {
        message.flag = readString(bb, readVarint32(bb));
        break;
      }

      // optional int32 cd = 2;
      case 2: {
        message.cd = readVarint32(bb);
        break;
      }

      // optional int32 idx = 3;
      case 3: {
        message.idx = readVarint32(bb);
        break;
      }

      // optional int32 num = 4;
      case 4: {
        message.num = readVarint32(bb);
        break;
      }

      // optional int32 cd2 = 5;
      case 5: {
        message.cd2 = readVarint32(bb);
        break;
      }

      // optional int32 first = 6;
      case 6: {
        message.first = readVarint32(bb);
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  if (message.flag === undefined)
    throw new Error("Missing required field: flag");

  return message;
}

export function encodepb_act(message) {
  let bb = popByteBuffer();
  _encodepb_act(message, bb);
  return toUint8Array(bb);
}

function _encodepb_act(message, bb) {
  // required uint32 id = 1;
  let $id = message.id;
  if ($id !== undefined) {
    writeVarint32(bb, 8);
    writeVarint32(bb, $id);
  }

  // optional int32 status = 2;
  let $status = message.status;
  if ($status !== undefined) {
    writeVarint32(bb, 16);
    writeVarint64(bb, intToLong($status));
  }

  // optional uint32 cd = 3;
  let $cd = message.cd;
  if ($cd !== undefined) {
    writeVarint32(bb, 24);
    writeVarint32(bb, $cd);
  }

  // optional int32 limits = 4;
  let $limits = message.limits;
  if ($limits !== undefined) {
    writeVarint32(bb, 32);
    writeVarint64(bb, intToLong($limits));
  }

  // optional int32 read = 5;
  let $read = message.read;
  if ($read !== undefined) {
    writeVarint32(bb, 40);
    writeVarint64(bb, intToLong($read));
  }

  // optional uint32 next = 6;
  let $next = message.next;
  if ($next !== undefined) {
    writeVarint32(bb, 48);
    writeVarint32(bb, $next);
  }

  // optional int32 loop = 7;
  let $loop = message.loop;
  if ($loop !== undefined) {
    writeVarint32(bb, 56);
    writeVarint64(bb, intToLong($loop));
  }

  // optional int32 bomb = 8;
  let $bomb = message.bomb;
  if ($bomb !== undefined) {
    writeVarint32(bb, 64);
    writeVarint64(bb, intToLong($bomb));
  }

  // optional pb_monopoly monopoly = 9;
  let $monopoly = message.monopoly;
  if ($monopoly !== undefined) {
    writeVarint32(bb, 74);
    let nested = popByteBuffer();
    _encodepb_monopoly($monopoly, nested);
    writeVarint32(bb, nested.limit);
    writeByteBuffer(bb, nested);
    pushByteBuffer(nested);
  }

  // optional string code = 10;
  let $code = message.code;
  if ($code !== undefined) {
    writeVarint32(bb, 82);
    writeString(bb, $code);
  }

  // optional int32 limits2 = 11;
  let $limits2 = message.limits2;
  if ($limits2 !== undefined) {
    writeVarint32(bb, 88);
    writeVarint64(bb, intToLong($limits2));
  }

  // optional int32 bir = 12;
  let $bir = message.bir;
  if ($bir !== undefined) {
    writeVarint32(bb, 96);
    writeVarint64(bb, intToLong($bir));
  }

  // optional pb_kvs kv = 13;
  let $kv = message.kv;
  if ($kv !== undefined) {
    writeVarint32(bb, 106);
    let nested = popByteBuffer();
    _encodepb_kvs($kv, nested);
    writeVarint32(bb, nested.limit);
    writeByteBuffer(bb, nested);
    pushByteBuffer(nested);
  }

  // repeated pb_growup grow = 14;
  let array$grow = message.grow;
  if (array$grow !== undefined) {
    for (let value of array$grow) {
      writeVarint32(bb, 114);
      let nested = popByteBuffer();
      _encodepb_growup(value, nested);
      writeVarint32(bb, nested.limit);
      writeByteBuffer(bb, nested);
      pushByteBuffer(nested);
    }
  }
}

export function decodepb_act(binary) {
  return _decodepb_act(wrapByteBuffer(binary));
}

function _decodepb_act(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // required uint32 id = 1;
      case 1: {
        message.id = readVarint32(bb) >>> 0;
        break;
      }

      // optional int32 status = 2;
      case 2: {
        message.status = readVarint32(bb);
        break;
      }

      // optional uint32 cd = 3;
      case 3: {
        message.cd = readVarint32(bb) >>> 0;
        break;
      }

      // optional int32 limits = 4;
      case 4: {
        message.limits = readVarint32(bb);
        break;
      }

      // optional int32 read = 5;
      case 5: {
        message.read = readVarint32(bb);
        break;
      }

      // optional uint32 next = 6;
      case 6: {
        message.next = readVarint32(bb) >>> 0;
        break;
      }

      // optional int32 loop = 7;
      case 7: {
        message.loop = readVarint32(bb);
        break;
      }

      // optional int32 bomb = 8;
      case 8: {
        message.bomb = readVarint32(bb);
        break;
      }

      // optional pb_monopoly monopoly = 9;
      case 9: {
        let limit = pushTemporaryLength(bb);
        message.monopoly = _decodepb_monopoly(bb);
        bb.limit = limit;
        break;
      }

      // optional string code = 10;
      case 10: {
        message.code = readString(bb, readVarint32(bb));
        break;
      }

      // optional int32 limits2 = 11;
      case 11: {
        message.limits2 = readVarint32(bb);
        break;
      }

      // optional int32 bir = 12;
      case 12: {
        message.bir = readVarint32(bb);
        break;
      }

      // optional pb_kvs kv = 13;
      case 13: {
        let limit = pushTemporaryLength(bb);
        message.kv = _decodepb_kvs(bb);
        bb.limit = limit;
        break;
      }

      // repeated pb_growup grow = 14;
      case 14: {
        let limit = pushTemporaryLength(bb);
        let values = message.grow || (message.grow = []);
        values.push(_decodepb_growup(bb));
        bb.limit = limit;
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  if (message.id === undefined)
    throw new Error("Missing required field: id");

  return message;
}

export function encodepb_qstar(message) {
  let bb = popByteBuffer();
  _encodepb_qstar(message, bb);
  return toUint8Array(bb);
}

function _encodepb_qstar(message, bb) {
  // optional int64 uid = 1;
  let $uid = message.uid;
  if ($uid !== undefined) {
    writeVarint32(bb, 8);
    writeVarint64(bb, $uid);
  }

  // optional string name = 2;
  let $name = message.name;
  if ($name !== undefined) {
    writeVarint32(bb, 18);
    writeString(bb, $name);
  }

  // optional int32 logo = 3;
  let $logo = message.logo;
  if ($logo !== undefined) {
    writeVarint32(bb, 24);
    writeVarint64(bb, intToLong($logo));
  }

  // optional uint32 score = 4;
  let $score = message.score;
  if ($score !== undefined) {
    writeVarint32(bb, 32);
    writeVarint32(bb, $score);
  }
}

export function decodepb_qstar(binary) {
  return _decodepb_qstar(wrapByteBuffer(binary));
}

function _decodepb_qstar(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // optional int64 uid = 1;
      case 1: {
        message.uid = readVarint64(bb, /* unsigned */ false);
        break;
      }

      // optional string name = 2;
      case 2: {
        message.name = readString(bb, readVarint32(bb));
        break;
      }

      // optional int32 logo = 3;
      case 3: {
        message.logo = readVarint32(bb);
        break;
      }

      // optional uint32 score = 4;
      case 4: {
        message.score = readVarint32(bb) >>> 0;
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  return message;
}

export function encodepb_monopoly(message) {
  let bb = popByteBuffer();
  _encodepb_monopoly(message, bb);
  return toUint8Array(bb);
}

function _encodepb_monopoly(message, bb) {
  // required int32 pos = 1;
  let $pos = message.pos;
  if ($pos !== undefined) {
    writeVarint32(bb, 8);
    writeVarint64(bb, intToLong($pos));
  }

  // repeated int32 lv = 2;
  let array$lv = message.lv;
  if (array$lv !== undefined) {
    let packed = popByteBuffer();
    for (let value of array$lv) {
      writeVarint64(packed, intToLong(value));
    }
    writeVarint32(bb, 18);
    writeVarint32(bb, packed.offset);
    writeByteBuffer(bb, packed);
    pushByteBuffer(packed);
  }

  // optional int32 next_event = 3;
  let $next_event = message.next_event;
  if ($next_event !== undefined) {
    writeVarint32(bb, 24);
    writeVarint64(bb, intToLong($next_event));
  }

  // optional int32 star = 4;
  let $star = message.star;
  if ($star !== undefined) {
    writeVarint32(bb, 32);
    writeVarint64(bb, intToLong($star));
  }
}

export function decodepb_monopoly(binary) {
  return _decodepb_monopoly(wrapByteBuffer(binary));
}

function _decodepb_monopoly(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // required int32 pos = 1;
      case 1: {
        message.pos = readVarint32(bb);
        break;
      }

      // repeated int32 lv = 2;
      case 2: {
        let values = message.lv || (message.lv = []);
        if ((tag & 7) === 2) {
          let outerLimit = pushTemporaryLength(bb);
          while (!isAtEnd(bb)) {
            values.push(readVarint32(bb));
          }
          bb.limit = outerLimit;
        } else {
          values.push(readVarint32(bb));
        }
        break;
      }

      // optional int32 next_event = 3;
      case 3: {
        message.next_event = readVarint32(bb);
        break;
      }

      // optional int32 star = 4;
      case 4: {
        message.star = readVarint32(bb);
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  if (message.pos === undefined)
    throw new Error("Missing required field: pos");

  return message;
}

export function encodepb_monopoly_step(message) {
  let bb = popByteBuffer();
  _encodepb_monopoly_step(message, bb);
  return toUint8Array(bb);
}

function _encodepb_monopoly_step(message, bb) {
  // required int32 id = 1;
  let $id = message.id;
  if ($id !== undefined) {
    writeVarint32(bb, 8);
    writeVarint64(bb, intToLong($id));
  }

  // repeated pb_item reward = 2;
  let array$reward = message.reward;
  if (array$reward !== undefined) {
    for (let value of array$reward) {
      writeVarint32(bb, 18);
      let nested = popByteBuffer();
      _encodepb_item(value, nested);
      writeVarint32(bb, nested.limit);
      writeByteBuffer(bb, nested);
      pushByteBuffer(nested);
    }
  }

  // optional int32 star = 3;
  let $star = message.star;
  if ($star !== undefined) {
    writeVarint32(bb, 24);
    writeVarint64(bb, intToLong($star));
  }

  // optional int32 event = 4;
  let $event = message.event;
  if ($event !== undefined) {
    writeVarint32(bb, 32);
    writeVarint64(bb, intToLong($event));
  }

  // repeated int32 cards = 5;
  let array$cards = message.cards;
  if (array$cards !== undefined) {
    let packed = popByteBuffer();
    for (let value of array$cards) {
      writeVarint64(packed, intToLong(value));
    }
    writeVarint32(bb, 42);
    writeVarint32(bb, packed.offset);
    writeByteBuffer(bb, packed);
    pushByteBuffer(packed);
  }

  // optional int32 op_id = 6;
  let $op_id = message.op_id;
  if ($op_id !== undefined) {
    writeVarint32(bb, 48);
    writeVarint64(bb, intToLong($op_id));
  }
}

export function decodepb_monopoly_step(binary) {
  return _decodepb_monopoly_step(wrapByteBuffer(binary));
}

function _decodepb_monopoly_step(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // required int32 id = 1;
      case 1: {
        message.id = readVarint32(bb);
        break;
      }

      // repeated pb_item reward = 2;
      case 2: {
        let limit = pushTemporaryLength(bb);
        let values = message.reward || (message.reward = []);
        values.push(_decodepb_item(bb));
        bb.limit = limit;
        break;
      }

      // optional int32 star = 3;
      case 3: {
        message.star = readVarint32(bb);
        break;
      }

      // optional int32 event = 4;
      case 4: {
        message.event = readVarint32(bb);
        break;
      }

      // repeated int32 cards = 5;
      case 5: {
        let values = message.cards || (message.cards = []);
        if ((tag & 7) === 2) {
          let outerLimit = pushTemporaryLength(bb);
          while (!isAtEnd(bb)) {
            values.push(readVarint32(bb));
          }
          bb.limit = outerLimit;
        } else {
          values.push(readVarint32(bb));
        }
        break;
      }

      // optional int32 op_id = 6;
      case 6: {
        message.op_id = readVarint32(bb);
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  if (message.id === undefined)
    throw new Error("Missing required field: id");

  return message;
}

export function encodepb_dice_sweep(message) {
  let bb = popByteBuffer();
  _encodepb_dice_sweep(message, bb);
  return toUint8Array(bb);
}

function _encodepb_dice_sweep(message, bb) {
  // optional int32 type = 1;
  let $type = message.type;
  if ($type !== undefined) {
    writeVarint32(bb, 8);
    writeVarint64(bb, intToLong($type));
  }

  // repeated pb_monopoly_step steps = 2;
  let array$steps = message.steps;
  if (array$steps !== undefined) {
    for (let value of array$steps) {
      writeVarint32(bb, 18);
      let nested = popByteBuffer();
      _encodepb_monopoly_step(value, nested);
      writeVarint32(bb, nested.limit);
      writeByteBuffer(bb, nested);
      pushByteBuffer(nested);
    }
  }

  // optional int32 num1 = 3;
  let $num1 = message.num1;
  if ($num1 !== undefined) {
    writeVarint32(bb, 24);
    writeVarint64(bb, intToLong($num1));
  }

  // optional int32 num2 = 4;
  let $num2 = message.num2;
  if ($num2 !== undefined) {
    writeVarint32(bb, 32);
    writeVarint64(bb, intToLong($num2));
  }
}

export function decodepb_dice_sweep(binary) {
  return _decodepb_dice_sweep(wrapByteBuffer(binary));
}

function _decodepb_dice_sweep(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // optional int32 type = 1;
      case 1: {
        message.type = readVarint32(bb);
        break;
      }

      // repeated pb_monopoly_step steps = 2;
      case 2: {
        let limit = pushTemporaryLength(bb);
        let values = message.steps || (message.steps = []);
        values.push(_decodepb_monopoly_step(bb));
        bb.limit = limit;
        break;
      }

      // optional int32 num1 = 3;
      case 3: {
        message.num1 = readVarint32(bb);
        break;
      }

      // optional int32 num2 = 4;
      case 4: {
        message.num2 = readVarint32(bb);
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  return message;
}

export function encodepb_sact_item(message) {
  let bb = popByteBuffer();
  _encodepb_sact_item(message, bb);
  return toUint8Array(bb);
}

function _encodepb_sact_item(message, bb) {
  // required uint32 id = 1;
  let $id = message.id;
  if ($id !== undefined) {
    writeVarint32(bb, 8);
    writeVarint32(bb, $id);
  }

  // optional uint32 cd = 2;
  let $cd = message.cd;
  if ($cd !== undefined) {
    writeVarint32(bb, 16);
    writeVarint32(bb, $cd);
  }

  // optional int32 bomb = 3;
  let $bomb = message.bomb;
  if ($bomb !== undefined) {
    writeVarint32(bb, 24);
    writeVarint64(bb, intToLong($bomb));
  }

  // optional int32 limits = 4;
  let $limits = message.limits;
  if ($limits !== undefined) {
    writeVarint32(bb, 32);
    writeVarint64(bb, intToLong($limits));
  }

  // optional uint32 next = 5;
  let $next = message.next;
  if ($next !== undefined) {
    writeVarint32(bb, 40);
    writeVarint32(bb, $next);
  }

  // repeated pb_sact_maze maze = 6;
  let array$maze = message.maze;
  if (array$maze !== undefined) {
    for (let value of array$maze) {
      writeVarint32(bb, 50);
      let nested = popByteBuffer();
      _encodepb_sact_maze(value, nested);
      writeVarint32(bb, nested.limit);
      writeByteBuffer(bb, nested);
      pushByteBuffer(nested);
    }
  }

  // optional uint32 spec = 7;
  let $spec = message.spec;
  if ($spec !== undefined) {
    writeVarint32(bb, 56);
    writeVarint32(bb, $spec);
  }

  // repeated pb_kv log = 8;
  let array$log = message.log;
  if (array$log !== undefined) {
    for (let value of array$log) {
      writeVarint32(bb, 66);
      let nested = popByteBuffer();
      _encodepb_kv(value, nested);
      writeVarint32(bb, nested.limit);
      writeByteBuffer(bb, nested);
      pushByteBuffer(nested);
    }
  }
}

export function decodepb_sact_item(binary) {
  return _decodepb_sact_item(wrapByteBuffer(binary));
}

function _decodepb_sact_item(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // required uint32 id = 1;
      case 1: {
        message.id = readVarint32(bb) >>> 0;
        break;
      }

      // optional uint32 cd = 2;
      case 2: {
        message.cd = readVarint32(bb) >>> 0;
        break;
      }

      // optional int32 bomb = 3;
      case 3: {
        message.bomb = readVarint32(bb);
        break;
      }

      // optional int32 limits = 4;
      case 4: {
        message.limits = readVarint32(bb);
        break;
      }

      // optional uint32 next = 5;
      case 5: {
        message.next = readVarint32(bb) >>> 0;
        break;
      }

      // repeated pb_sact_maze maze = 6;
      case 6: {
        let limit = pushTemporaryLength(bb);
        let values = message.maze || (message.maze = []);
        values.push(_decodepb_sact_maze(bb));
        bb.limit = limit;
        break;
      }

      // optional uint32 spec = 7;
      case 7: {
        message.spec = readVarint32(bb) >>> 0;
        break;
      }

      // repeated pb_kv log = 8;
      case 8: {
        let limit = pushTemporaryLength(bb);
        let values = message.log || (message.log = []);
        values.push(_decodepb_kv(bb));
        bb.limit = limit;
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  if (message.id === undefined)
    throw new Error("Missing required field: id");

  return message;
}

export function encodepb_rabbit(message) {
  let bb = popByteBuffer();
  _encodepb_rabbit(message, bb);
  return toUint8Array(bb);
}

function _encodepb_rabbit(message, bb) {
  // optional int32 type = 1;
  let $type = message.type;
  if ($type !== undefined) {
    writeVarint32(bb, 8);
    writeVarint64(bb, intToLong($type));
  }

  // repeated pb_kv poses = 3;
  let array$poses = message.poses;
  if (array$poses !== undefined) {
    for (let value of array$poses) {
      writeVarint32(bb, 26);
      let nested = popByteBuffer();
      _encodepb_kv(value, nested);
      writeVarint32(bb, nested.limit);
      writeByteBuffer(bb, nested);
      pushByteBuffer(nested);
    }
  }
}

export function decodepb_rabbit(binary) {
  return _decodepb_rabbit(wrapByteBuffer(binary));
}

function _decodepb_rabbit(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // optional int32 type = 1;
      case 1: {
        message.type = readVarint32(bb);
        break;
      }

      // repeated pb_kv poses = 3;
      case 3: {
        let limit = pushTemporaryLength(bb);
        let values = message.poses || (message.poses = []);
        values.push(_decodepb_kv(bb));
        bb.limit = limit;
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  return message;
}

export function encodepb_ract_item(message) {
  let bb = popByteBuffer();
  _encodepb_ract_item(message, bb);
  return toUint8Array(bb);
}

function _encodepb_ract_item(message, bb) {
  // required uint32 id = 1;
  let $id = message.id;
  if ($id !== undefined) {
    writeVarint32(bb, 8);
    writeVarint32(bb, $id);
  }

  // repeated uint32 rewards = 2;
  let array$rewards = message.rewards;
  if (array$rewards !== undefined) {
    let packed = popByteBuffer();
    for (let value of array$rewards) {
      writeVarint32(packed, value);
    }
    writeVarint32(bb, 18);
    writeVarint32(bb, packed.offset);
    writeByteBuffer(bb, packed);
    pushByteBuffer(packed);
  }

  // repeated pb_item item = 3;
  let array$item = message.item;
  if (array$item !== undefined) {
    for (let value of array$item) {
      writeVarint32(bb, 26);
      let nested = popByteBuffer();
      _encodepb_item(value, nested);
      writeVarint32(bb, nested.limit);
      writeByteBuffer(bb, nested);
      pushByteBuffer(nested);
    }
  }

  // optional int32 day = 4;
  let $day = message.day;
  if ($day !== undefined) {
    writeVarint32(bb, 32);
    writeVarint64(bb, intToLong($day));
  }

  // optional int32 cd = 5;
  let $cd = message.cd;
  if ($cd !== undefined) {
    writeVarint32(bb, 40);
    writeVarint64(bb, intToLong($cd));
  }
}

export function decodepb_ract_item(binary) {
  return _decodepb_ract_item(wrapByteBuffer(binary));
}

function _decodepb_ract_item(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // required uint32 id = 1;
      case 1: {
        message.id = readVarint32(bb) >>> 0;
        break;
      }

      // repeated uint32 rewards = 2;
      case 2: {
        let values = message.rewards || (message.rewards = []);
        if ((tag & 7) === 2) {
          let outerLimit = pushTemporaryLength(bb);
          while (!isAtEnd(bb)) {
            values.push(readVarint32(bb) >>> 0);
          }
          bb.limit = outerLimit;
        } else {
          values.push(readVarint32(bb) >>> 0);
        }
        break;
      }

      // repeated pb_item item = 3;
      case 3: {
        let limit = pushTemporaryLength(bb);
        let values = message.item || (message.item = []);
        values.push(_decodepb_item(bb));
        bb.limit = limit;
        break;
      }

      // optional int32 day = 4;
      case 4: {
        message.day = readVarint32(bb);
        break;
      }

      // optional int32 cd = 5;
      case 5: {
        message.cd = readVarint32(bb);
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  if (message.id === undefined)
    throw new Error("Missing required field: id");

  return message;
}

export function encodepb_sact_maze(message) {
  let bb = popByteBuffer();
  _encodepb_sact_maze(message, bb);
  return toUint8Array(bb);
}

function _encodepb_sact_maze(message, bb) {
  // required int64 pos = 1;
  let $pos = message.pos;
  if ($pos !== undefined) {
    writeVarint32(bb, 8);
    writeVarint64(bb, $pos);
  }

  // optional int32 id = 2;
  let $id = message.id;
  if ($id !== undefined) {
    writeVarint32(bb, 16);
    writeVarint64(bb, intToLong($id));
  }

  // optional pb_bag rewards = 3;
  let $rewards = message.rewards;
  if ($rewards !== undefined) {
    writeVarint32(bb, 26);
    let nested = popByteBuffer();
    _encodepb_bag($rewards, nested);
    writeVarint32(bb, nested.limit);
    writeByteBuffer(bb, nested);
    pushByteBuffer(nested);
  }

  // optional int32 num = 4;
  let $num = message.num;
  if ($num !== undefined) {
    writeVarint32(bb, 32);
    writeVarint64(bb, intToLong($num));
  }
}

export function decodepb_sact_maze(binary) {
  return _decodepb_sact_maze(wrapByteBuffer(binary));
}

function _decodepb_sact_maze(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // required int64 pos = 1;
      case 1: {
        message.pos = readVarint64(bb, /* unsigned */ false);
        break;
      }

      // optional int32 id = 2;
      case 2: {
        message.id = readVarint32(bb);
        break;
      }

      // optional pb_bag rewards = 3;
      case 3: {
        let limit = pushTemporaryLength(bb);
        message.rewards = _decodepb_bag(bb);
        bb.limit = limit;
        break;
      }

      // optional int32 num = 4;
      case 4: {
        message.num = readVarint32(bb);
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  if (message.pos === undefined)
    throw new Error("Missing required field: pos");

  return message;
}

export function encodepb_sact_log(message) {
  let bb = popByteBuffer();
  _encodepb_sact_log(message, bb);
  return toUint8Array(bb);
}

function _encodepb_sact_log(message, bb) {
  // optional int32 time = 1;
  let $time = message.time;
  if ($time !== undefined) {
    writeVarint32(bb, 8);
    writeVarint64(bb, intToLong($time));
  }

  // optional int32 result = 2;
  let $result = message.result;
  if ($result !== undefined) {
    writeVarint32(bb, 16);
    writeVarint64(bb, intToLong($result));
  }
}

export function decodepb_sact_log(binary) {
  return _decodepb_sact_log(wrapByteBuffer(binary));
}

function _decodepb_sact_log(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // optional int32 time = 1;
      case 1: {
        message.time = readVarint32(bb);
        break;
      }

      // optional int32 result = 2;
      case 2: {
        message.result = readVarint32(bb);
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  return message;
}

export function encodepb_mact(message) {
  let bb = popByteBuffer();
  _encodepb_mact(message, bb);
  return toUint8Array(bb);
}

function _encodepb_mact(message, bb) {
  // required uint32 cd = 1;
  let $cd = message.cd;
  if ($cd !== undefined) {
    writeVarint32(bb, 8);
    writeVarint32(bb, $cd);
  }

  // repeated pb_item war = 2;
  let array$war = message.war;
  if (array$war !== undefined) {
    for (let value of array$war) {
      writeVarint32(bb, 18);
      let nested = popByteBuffer();
      _encodepb_item(value, nested);
      writeVarint32(bb, nested.limit);
      writeByteBuffer(bb, nested);
      pushByteBuffer(nested);
    }
  }

  // repeated pb_item htask = 3;
  let array$htask = message.htask;
  if (array$htask !== undefined) {
    for (let value of array$htask) {
      writeVarint32(bb, 26);
      let nested = popByteBuffer();
      _encodepb_item(value, nested);
      writeVarint32(bb, nested.limit);
      writeByteBuffer(bb, nested);
      pushByteBuffer(nested);
    }
  }

  // repeated pb_item hmerge = 4;
  let array$hmerge = message.hmerge;
  if (array$hmerge !== undefined) {
    for (let value of array$hmerge) {
      writeVarint32(bb, 34);
      let nested = popByteBuffer();
      _encodepb_item(value, nested);
      writeVarint32(bb, nested.limit);
      writeByteBuffer(bb, nested);
      pushByteBuffer(nested);
    }
  }

  // optional int32 space_st = 5;
  let $space_st = message.space_st;
  if ($space_st !== undefined) {
    writeVarint32(bb, 40);
    writeVarint64(bb, intToLong($space_st));
  }

  // repeated pb_item brave = 6;
  let array$brave = message.brave;
  if (array$brave !== undefined) {
    for (let value of array$brave) {
      writeVarint32(bb, 50);
      let nested = popByteBuffer();
      _encodepb_item(value, nested);
      writeVarint32(bb, nested.limit);
      writeByteBuffer(bb, nested);
      pushByteBuffer(nested);
    }
  }

  // optional int32 status = 7;
  let $status = message.status;
  if ($status !== undefined) {
    writeVarint32(bb, 56);
    writeVarint64(bb, intToLong($status));
  }

  // repeated pb_item hmerge2 = 8;
  let array$hmerge2 = message.hmerge2;
  if (array$hmerge2 !== undefined) {
    for (let value of array$hmerge2) {
      writeVarint32(bb, 66);
      let nested = popByteBuffer();
      _encodepb_item(value, nested);
      writeVarint32(bb, nested.limit);
      writeByteBuffer(bb, nested);
      pushByteBuffer(nested);
    }
  }

  // repeated pb_item high_casino = 9;
  let array$high_casino = message.high_casino;
  if (array$high_casino !== undefined) {
    for (let value of array$high_casino) {
      writeVarint32(bb, 74);
      let nested = popByteBuffer();
      _encodepb_item(value, nested);
      writeVarint32(bb, nested.limit);
      writeByteBuffer(bb, nested);
      pushByteBuffer(nested);
    }
  }
}

export function decodepb_mact(binary) {
  return _decodepb_mact(wrapByteBuffer(binary));
}

function _decodepb_mact(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // required uint32 cd = 1;
      case 1: {
        message.cd = readVarint32(bb) >>> 0;
        break;
      }

      // repeated pb_item war = 2;
      case 2: {
        let limit = pushTemporaryLength(bb);
        let values = message.war || (message.war = []);
        values.push(_decodepb_item(bb));
        bb.limit = limit;
        break;
      }

      // repeated pb_item htask = 3;
      case 3: {
        let limit = pushTemporaryLength(bb);
        let values = message.htask || (message.htask = []);
        values.push(_decodepb_item(bb));
        bb.limit = limit;
        break;
      }

      // repeated pb_item hmerge = 4;
      case 4: {
        let limit = pushTemporaryLength(bb);
        let values = message.hmerge || (message.hmerge = []);
        values.push(_decodepb_item(bb));
        bb.limit = limit;
        break;
      }

      // optional int32 space_st = 5;
      case 5: {
        message.space_st = readVarint32(bb);
        break;
      }

      // repeated pb_item brave = 6;
      case 6: {
        let limit = pushTemporaryLength(bb);
        let values = message.brave || (message.brave = []);
        values.push(_decodepb_item(bb));
        bb.limit = limit;
        break;
      }

      // optional int32 status = 7;
      case 7: {
        message.status = readVarint32(bb);
        break;
      }

      // repeated pb_item hmerge2 = 8;
      case 8: {
        let limit = pushTemporaryLength(bb);
        let values = message.hmerge2 || (message.hmerge2 = []);
        values.push(_decodepb_item(bb));
        bb.limit = limit;
        break;
      }

      // repeated pb_item high_casino = 9;
      case 9: {
        let limit = pushTemporaryLength(bb);
        let values = message.high_casino || (message.high_casino = []);
        values.push(_decodepb_item(bb));
        bb.limit = limit;
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  if (message.cd === undefined)
    throw new Error("Missing required field: cd");

  return message;
}

export function encodepb_task(message) {
  let bb = popByteBuffer();
  _encodepb_task(message, bb);
  return toUint8Array(bb);
}

function _encodepb_task(message, bb) {
  // required int32 id = 1;
  let $id = message.id;
  if ($id !== undefined) {
    writeVarint32(bb, 8);
    writeVarint64(bb, intToLong($id));
  }

  // required int32 count = 2;
  let $count = message.count;
  if ($count !== undefined) {
    writeVarint32(bb, 16);
    writeVarint64(bb, intToLong($count));
  }

  // required int32 is_claim = 3;
  let $is_claim = message.is_claim;
  if ($is_claim !== undefined) {
    writeVarint32(bb, 24);
    writeVarint64(bb, intToLong($is_claim));
  }
}

export function decodepb_task(binary) {
  return _decodepb_task(wrapByteBuffer(binary));
}

function _decodepb_task(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // required int32 id = 1;
      case 1: {
        message.id = readVarint32(bb);
        break;
      }

      // required int32 count = 2;
      case 2: {
        message.count = readVarint32(bb);
        break;
      }

      // required int32 is_claim = 3;
      case 3: {
        message.is_claim = readVarint32(bb);
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  if (message.id === undefined)
    throw new Error("Missing required field: id");

  if (message.count === undefined)
    throw new Error("Missing required field: count");

  if (message.is_claim === undefined)
    throw new Error("Missing required field: is_claim");

  return message;
}

export function encodepb_online(message) {
  let bb = popByteBuffer();
  _encodepb_online(message, bb);
  return toUint8Array(bb);
}

function _encodepb_online(message, bb) {
  // required int32 id = 1;
  let $id = message.id;
  if ($id !== undefined) {
    writeVarint32(bb, 8);
    writeVarint64(bb, intToLong($id));
  }

  // optional int32 cd = 2;
  let $cd = message.cd;
  if ($cd !== undefined) {
    writeVarint32(bb, 16);
    writeVarint64(bb, intToLong($cd));
  }
}

export function decodepb_online(binary) {
  return _decodepb_online(wrapByteBuffer(binary));
}

function _decodepb_online(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // required int32 id = 1;
      case 1: {
        message.id = readVarint32(bb);
        break;
      }

      // optional int32 cd = 2;
      case 2: {
        message.cd = readVarint32(bb);
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  if (message.id === undefined)
    throw new Error("Missing required field: id");

  return message;
}

export function encodepb_sachieve(message) {
  let bb = popByteBuffer();
  _encodepb_sachieve(message, bb);
  return toUint8Array(bb);
}

function _encodepb_sachieve(message, bb) {
  // repeated int32 num = 1;
  let array$num = message.num;
  if (array$num !== undefined) {
    let packed = popByteBuffer();
    for (let value of array$num) {
      writeVarint64(packed, intToLong(value));
    }
    writeVarint32(bb, 10);
    writeVarint32(bb, packed.offset);
    writeByteBuffer(bb, packed);
    pushByteBuffer(packed);
  }

  // repeated int32 id = 2;
  let array$id = message.id;
  if (array$id !== undefined) {
    let packed = popByteBuffer();
    for (let value of array$id) {
      writeVarint64(packed, intToLong(value));
    }
    writeVarint32(bb, 18);
    writeVarint32(bb, packed.offset);
    writeByteBuffer(bb, packed);
    pushByteBuffer(packed);
  }

  // repeated int32 curnum = 3;
  let array$curnum = message.curnum;
  if (array$curnum !== undefined) {
    let packed = popByteBuffer();
    for (let value of array$curnum) {
      writeVarint64(packed, intToLong(value));
    }
    writeVarint32(bb, 26);
    writeVarint32(bb, packed.offset);
    writeByteBuffer(bb, packed);
    pushByteBuffer(packed);
  }
}

export function decodepb_sachieve(binary) {
  return _decodepb_sachieve(wrapByteBuffer(binary));
}

function _decodepb_sachieve(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // repeated int32 num = 1;
      case 1: {
        let values = message.num || (message.num = []);
        if ((tag & 7) === 2) {
          let outerLimit = pushTemporaryLength(bb);
          while (!isAtEnd(bb)) {
            values.push(readVarint32(bb));
          }
          bb.limit = outerLimit;
        } else {
          values.push(readVarint32(bb));
        }
        break;
      }

      // repeated int32 id = 2;
      case 2: {
        let values = message.id || (message.id = []);
        if ((tag & 7) === 2) {
          let outerLimit = pushTemporaryLength(bb);
          while (!isAtEnd(bb)) {
            values.push(readVarint32(bb));
          }
          bb.limit = outerLimit;
        } else {
          values.push(readVarint32(bb));
        }
        break;
      }

      // repeated int32 curnum = 3;
      case 3: {
        let values = message.curnum || (message.curnum = []);
        if ((tag & 7) === 2) {
          let outerLimit = pushTemporaryLength(bb);
          while (!isAtEnd(bb)) {
            values.push(readVarint32(bb));
          }
          bb.limit = outerLimit;
        } else {
          values.push(readVarint32(bb));
        }
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  return message;
}

export function encodepb_hmarket(message) {
  let bb = popByteBuffer();
  _encodepb_hmarket(message, bb);
  return toUint8Array(bb);
}

function _encodepb_hmarket(message, bb) {
  // required int32 id = 1;
  let $id = message.id;
  if ($id !== undefined) {
    writeVarint32(bb, 8);
    writeVarint64(bb, intToLong($id));
  }

  // optional int32 num = 2;
  let $num = message.num;
  if ($num !== undefined) {
    writeVarint32(bb, 16);
    writeVarint64(bb, intToLong($num));
  }

  // optional int32 cd = 3;
  let $cd = message.cd;
  if ($cd !== undefined) {
    writeVarint32(bb, 24);
    writeVarint64(bb, intToLong($cd));
  }
}

export function decodepb_hmarket(binary) {
  return _decodepb_hmarket(wrapByteBuffer(binary));
}

function _decodepb_hmarket(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // required int32 id = 1;
      case 1: {
        message.id = readVarint32(bb);
        break;
      }

      // optional int32 num = 2;
      case 2: {
        message.num = readVarint32(bb);
        break;
      }

      // optional int32 cd = 3;
      case 3: {
        message.cd = readVarint32(bb);
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  if (message.id === undefined)
    throw new Error("Missing required field: id");

  return message;
}

export function encodepb_gmarket(message) {
  let bb = popByteBuffer();
  _encodepb_gmarket(message, bb);
  return toUint8Array(bb);
}

function _encodepb_gmarket(message, bb) {
  // required int32 id = 1;
  let $id = message.id;
  if ($id !== undefined) {
    writeVarint32(bb, 8);
    writeVarint64(bb, intToLong($id));
  }

  // optional int32 num = 2;
  let $num = message.num;
  if ($num !== undefined) {
    writeVarint32(bb, 16);
    writeVarint64(bb, intToLong($num));
  }

  // optional int32 gid = 3;
  let $gid = message.gid;
  if ($gid !== undefined) {
    writeVarint32(bb, 24);
    writeVarint64(bb, intToLong($gid));
  }
}

export function decodepb_gmarket(binary) {
  return _decodepb_gmarket(wrapByteBuffer(binary));
}

function _decodepb_gmarket(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // required int32 id = 1;
      case 1: {
        message.id = readVarint32(bb);
        break;
      }

      // optional int32 num = 2;
      case 2: {
        message.num = readVarint32(bb);
        break;
      }

      // optional int32 gid = 3;
      case 3: {
        message.gid = readVarint32(bb);
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  if (message.id === undefined)
    throw new Error("Missing required field: id");

  return message;
}

export function encodepb_gvrank(message) {
  let bb = popByteBuffer();
  _encodepb_gvrank(message, bb);
  return toUint8Array(bb);
}

function _encodepb_gvrank(message, bb) {
  // required int64 uid = 1;
  let $uid = message.uid;
  if ($uid !== undefined) {
    writeVarint32(bb, 8);
    writeVarint64(bb, $uid);
  }

  // optional string name = 2;
  let $name = message.name;
  if ($name !== undefined) {
    writeVarint32(bb, 18);
    writeString(bb, $name);
  }

  // optional int32 lv = 3;
  let $lv = message.lv;
  if ($lv !== undefined) {
    writeVarint32(bb, 24);
    writeVarint64(bb, intToLong($lv));
  }

  // optional int32 logo = 4;
  let $logo = message.logo;
  if ($logo !== undefined) {
    writeVarint32(bb, 32);
    writeVarint64(bb, intToLong($logo));
  }

  // required int64 hurt = 5;
  let $hurt = message.hurt;
  if ($hurt !== undefined) {
    writeVarint32(bb, 40);
    writeVarint64(bb, $hurt);
  }

  // optional pb_bag reward = 6;
  let $reward = message.reward;
  if ($reward !== undefined) {
    writeVarint32(bb, 50);
    let nested = popByteBuffer();
    _encodepb_bag($reward, nested);
    writeVarint32(bb, nested.limit);
    writeByteBuffer(bb, nested);
    pushByteBuffer(nested);
  }

  // optional int32 border = 7;
  let $border = message.border;
  if ($border !== undefined) {
    writeVarint32(bb, 56);
    writeVarint64(bb, intToLong($border));
  }
}

export function decodepb_gvrank(binary) {
  return _decodepb_gvrank(wrapByteBuffer(binary));
}

function _decodepb_gvrank(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // required int64 uid = 1;
      case 1: {
        message.uid = readVarint64(bb, /* unsigned */ false);
        break;
      }

      // optional string name = 2;
      case 2: {
        message.name = readString(bb, readVarint32(bb));
        break;
      }

      // optional int32 lv = 3;
      case 3: {
        message.lv = readVarint32(bb);
        break;
      }

      // optional int32 logo = 4;
      case 4: {
        message.logo = readVarint32(bb);
        break;
      }

      // required int64 hurt = 5;
      case 5: {
        message.hurt = readVarint64(bb, /* unsigned */ false);
        break;
      }

      // optional pb_bag reward = 6;
      case 6: {
        let limit = pushTemporaryLength(bb);
        message.reward = _decodepb_bag(bb);
        bb.limit = limit;
        break;
      }

      // optional int32 border = 7;
      case 7: {
        message.border = readVarint32(bb);
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  if (message.uid === undefined)
    throw new Error("Missing required field: uid");

  if (message.hurt === undefined)
    throw new Error("Missing required field: hurt");

  return message;
}

export function encodepb_gvrank_donate(message) {
  let bb = popByteBuffer();
  _encodepb_gvrank_donate(message, bb);
  return toUint8Array(bb);
}

function _encodepb_gvrank_donate(message, bb) {
  // required string name = 1;
  let $name = message.name;
  if ($name !== undefined) {
    writeVarint32(bb, 10);
    writeString(bb, $name);
  }

  // required int32 lv = 2;
  let $lv = message.lv;
  if ($lv !== undefined) {
    writeVarint32(bb, 16);
    writeVarint64(bb, intToLong($lv));
  }

  // required int32 logo = 3;
  let $logo = message.logo;
  if ($logo !== undefined) {
    writeVarint32(bb, 24);
    writeVarint64(bb, intToLong($logo));
  }

  // optional int32 num = 4;
  let $num = message.num;
  if ($num !== undefined) {
    writeVarint32(bb, 32);
    writeVarint64(bb, intToLong($num));
  }
}

export function decodepb_gvrank_donate(binary) {
  return _decodepb_gvrank_donate(wrapByteBuffer(binary));
}

function _decodepb_gvrank_donate(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // required string name = 1;
      case 1: {
        message.name = readString(bb, readVarint32(bb));
        break;
      }

      // required int32 lv = 2;
      case 2: {
        message.lv = readVarint32(bb);
        break;
      }

      // required int32 logo = 3;
      case 3: {
        message.logo = readVarint32(bb);
        break;
      }

      // optional int32 num = 4;
      case 4: {
        message.num = readVarint32(bb);
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  if (message.name === undefined)
    throw new Error("Missing required field: name");

  if (message.lv === undefined)
    throw new Error("Missing required field: lv");

  if (message.logo === undefined)
    throw new Error("Missing required field: logo");

  return message;
}

export function encodepb_bboss(message) {
  let bb = popByteBuffer();
  _encodepb_bboss(message, bb);
  return toUint8Array(bb);
}

function _encodepb_bboss(message, bb) {
  // required int32 uid = 1;
  let $uid = message.uid;
  if ($uid !== undefined) {
    writeVarint32(bb, 8);
    writeVarint64(bb, intToLong($uid));
  }

  // optional string name = 2;
  let $name = message.name;
  if ($name !== undefined) {
    writeVarint32(bb, 18);
    writeString(bb, $name);
  }

  // optional int32 lv = 3;
  let $lv = message.lv;
  if ($lv !== undefined) {
    writeVarint32(bb, 24);
    writeVarint64(bb, intToLong($lv));
  }

  // optional int32 logo = 4;
  let $logo = message.logo;
  if ($logo !== undefined) {
    writeVarint32(bb, 32);
    writeVarint64(bb, intToLong($logo));
  }

  // required uint64 hurt = 5;
  let $hurt = message.hurt;
  if ($hurt !== undefined) {
    writeVarint32(bb, 40);
    writeVarint64(bb, $hurt);
  }

  // optional int32 sid = 6;
  let $sid = message.sid;
  if ($sid !== undefined) {
    writeVarint32(bb, 48);
    writeVarint64(bb, intToLong($sid));
  }
}

export function decodepb_bboss(binary) {
  return _decodepb_bboss(wrapByteBuffer(binary));
}

function _decodepb_bboss(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // required int32 uid = 1;
      case 1: {
        message.uid = readVarint32(bb);
        break;
      }

      // optional string name = 2;
      case 2: {
        message.name = readString(bb, readVarint32(bb));
        break;
      }

      // optional int32 lv = 3;
      case 3: {
        message.lv = readVarint32(bb);
        break;
      }

      // optional int32 logo = 4;
      case 4: {
        message.logo = readVarint32(bb);
        break;
      }

      // required uint64 hurt = 5;
      case 5: {
        message.hurt = readVarint64(bb, /* unsigned */ true);
        break;
      }

      // optional int32 sid = 6;
      case 6: {
        message.sid = readVarint32(bb);
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  if (message.uid === undefined)
    throw new Error("Missing required field: uid");

  if (message.hurt === undefined)
    throw new Error("Missing required field: hurt");

  return message;
}

export function encodepb_gskl(message) {
  let bb = popByteBuffer();
  _encodepb_gskl(message, bb);
  return toUint8Array(bb);
}

function _encodepb_gskl(message, bb) {
  // required int32 id = 1;
  let $id = message.id;
  if ($id !== undefined) {
    writeVarint32(bb, 8);
    writeVarint64(bb, intToLong($id));
  }

  // required int32 lv = 2;
  let $lv = message.lv;
  if ($lv !== undefined) {
    writeVarint32(bb, 16);
    writeVarint64(bb, intToLong($lv));
  }
}

export function decodepb_gskl(binary) {
  return _decodepb_gskl(wrapByteBuffer(binary));
}

function _decodepb_gskl(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // required int32 id = 1;
      case 1: {
        message.id = readVarint32(bb);
        break;
      }

      // required int32 lv = 2;
      case 2: {
        message.lv = readVarint32(bb);
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  if (message.id === undefined)
    throw new Error("Missing required field: id");

  if (message.lv === undefined)
    throw new Error("Missing required field: lv");

  return message;
}

export function encodepb_bunit(message) {
  let bb = popByteBuffer();
  _encodepb_bunit(message, bb);
  return toUint8Array(bb);
}

function _encodepb_bunit(message, bb) {
  // optional int32 hid = 1;
  let $hid = message.hid;
  if ($hid !== undefined) {
    writeVarint32(bb, 8);
    writeVarint64(bb, intToLong($hid));
  }

  // optional int32 id = 2;
  let $id = message.id;
  if ($id !== undefined) {
    writeVarint32(bb, 16);
    writeVarint64(bb, intToLong($id));
  }

  // optional int32 lv = 3;
  let $lv = message.lv;
  if ($lv !== undefined) {
    writeVarint32(bb, 24);
    writeVarint64(bb, intToLong($lv));
  }

  // optional int32 star = 4;
  let $star = message.star;
  if ($star !== undefined) {
    writeVarint32(bb, 32);
    writeVarint64(bb, intToLong($star));
  }

  // optional int32 hpp = 5;
  let $hpp = message.hpp;
  if ($hpp !== undefined) {
    writeVarint32(bb, 40);
    writeVarint64(bb, intToLong($hpp));
  }

  // optional int32 pos = 6;
  let $pos = message.pos;
  if ($pos !== undefined) {
    writeVarint32(bb, 48);
    writeVarint64(bb, intToLong($pos));
  }

  // optional int32 wake = 7;
  let $wake = message.wake;
  if ($wake !== undefined) {
    writeVarint32(bb, 56);
    writeVarint64(bb, intToLong($wake));
  }

  // optional int32 revive = 8;
  let $revive = message.revive;
  if ($revive !== undefined) {
    writeVarint32(bb, 64);
    writeVarint64(bb, intToLong($revive));
  }

  // optional int32 skin = 9;
  let $skin = message.skin;
  if ($skin !== undefined) {
    writeVarint32(bb, 72);
    writeVarint64(bb, intToLong($skin));
  }

  // optional int32 flag = 10;
  let $flag = message.flag;
  if ($flag !== undefined) {
    writeVarint32(bb, 80);
    writeVarint64(bb, intToLong($flag));
  }

  // optional int32 qlv = 11;
  let $qlv = message.qlv;
  if ($qlv !== undefined) {
    writeVarint32(bb, 88);
    writeVarint64(bb, intToLong($qlv));
  }

  // optional int32 core = 12;
  let $core = message.core;
  if ($core !== undefined) {
    writeVarint32(bb, 96);
    writeVarint64(bb, intToLong($core));
  }
}

export function decodepb_bunit(binary) {
  return _decodepb_bunit(wrapByteBuffer(binary));
}

function _decodepb_bunit(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // optional int32 hid = 1;
      case 1: {
        message.hid = readVarint32(bb);
        break;
      }

      // optional int32 id = 2;
      case 2: {
        message.id = readVarint32(bb);
        break;
      }

      // optional int32 lv = 3;
      case 3: {
        message.lv = readVarint32(bb);
        break;
      }

      // optional int32 star = 4;
      case 4: {
        message.star = readVarint32(bb);
        break;
      }

      // optional int32 hpp = 5;
      case 5: {
        message.hpp = readVarint32(bb);
        break;
      }

      // optional int32 pos = 6;
      case 6: {
        message.pos = readVarint32(bb);
        break;
      }

      // optional int32 wake = 7;
      case 7: {
        message.wake = readVarint32(bb);
        break;
      }

      // optional int32 revive = 8;
      case 8: {
        message.revive = readVarint32(bb);
        break;
      }

      // optional int32 skin = 9;
      case 9: {
        message.skin = readVarint32(bb);
        break;
      }

      // optional int32 flag = 10;
      case 10: {
        message.flag = readVarint32(bb);
        break;
      }

      // optional int32 qlv = 11;
      case 11: {
        message.qlv = readVarint32(bb);
        break;
      }

      // optional int32 core = 12;
      case 12: {
        message.core = readVarint32(bb);
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  return message;
}

export function encodepb_benemy(message) {
  let bb = popByteBuffer();
  _encodepb_benemy(message, bb);
  return toUint8Array(bb);
}

function _encodepb_benemy(message, bb) {
  // required int32 logo = 1;
  let $logo = message.logo;
  if ($logo !== undefined) {
    writeVarint32(bb, 8);
    writeVarint64(bb, intToLong($logo));
  }

  // required int32 lv = 2;
  let $lv = message.lv;
  if ($lv !== undefined) {
    writeVarint32(bb, 16);
    writeVarint64(bb, intToLong($lv));
  }

  // required string name = 3;
  let $name = message.name;
  if ($name !== undefined) {
    writeVarint32(bb, 26);
    writeString(bb, $name);
  }

  // required int64 power = 4;
  let $power = message.power;
  if ($power !== undefined) {
    writeVarint32(bb, 32);
    writeVarint64(bb, $power);
  }

  // required int32 sid = 5;
  let $sid = message.sid;
  if ($sid !== undefined) {
    writeVarint32(bb, 40);
    writeVarint64(bb, intToLong($sid));
  }

  // repeated pb_bunit camp = 6;
  let array$camp = message.camp;
  if (array$camp !== undefined) {
    for (let value of array$camp) {
      writeVarint32(bb, 50);
      let nested = popByteBuffer();
      _encodepb_bunit(value, nested);
      writeVarint32(bb, nested.limit);
      writeByteBuffer(bb, nested);
      pushByteBuffer(nested);
    }
  }

  // optional int32 border = 7;
  let $border = message.border;
  if ($border !== undefined) {
    writeVarint32(bb, 56);
    writeVarint64(bb, intToLong($border));
  }
}

export function decodepb_benemy(binary) {
  return _decodepb_benemy(wrapByteBuffer(binary));
}

function _decodepb_benemy(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // required int32 logo = 1;
      case 1: {
        message.logo = readVarint32(bb);
        break;
      }

      // required int32 lv = 2;
      case 2: {
        message.lv = readVarint32(bb);
        break;
      }

      // required string name = 3;
      case 3: {
        message.name = readString(bb, readVarint32(bb));
        break;
      }

      // required int64 power = 4;
      case 4: {
        message.power = readVarint64(bb, /* unsigned */ false);
        break;
      }

      // required int32 sid = 5;
      case 5: {
        message.sid = readVarint32(bb);
        break;
      }

      // repeated pb_bunit camp = 6;
      case 6: {
        let limit = pushTemporaryLength(bb);
        let values = message.camp || (message.camp = []);
        values.push(_decodepb_bunit(bb));
        bb.limit = limit;
        break;
      }

      // optional int32 border = 7;
      case 7: {
        message.border = readVarint32(bb);
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  if (message.logo === undefined)
    throw new Error("Missing required field: logo");

  if (message.lv === undefined)
    throw new Error("Missing required field: lv");

  if (message.name === undefined)
    throw new Error("Missing required field: name");

  if (message.power === undefined)
    throw new Error("Missing required field: power");

  if (message.sid === undefined)
    throw new Error("Missing required field: sid");

  return message;
}

export function encodepb_ngwshold(message) {
  let bb = popByteBuffer();
  _encodepb_ngwshold(message, bb);
  return toUint8Array(bb);
}

function _encodepb_ngwshold(message, bb) {
  // optional int32 left = 1;
  let $left = message.left;
  if ($left !== undefined) {
    writeVarint32(bb, 8);
    writeVarint64(bb, intToLong($left));
  }

  // optional int32 total = 2;
  let $total = message.total;
  if ($total !== undefined) {
    writeVarint32(bb, 16);
    writeVarint64(bb, intToLong($total));
  }

  // repeated pb_ngwbuff buffs = 3;
  let array$buffs = message.buffs;
  if (array$buffs !== undefined) {
    for (let value of array$buffs) {
      writeVarint32(bb, 26);
      let nested = popByteBuffer();
      _encodepb_ngwbuff(value, nested);
      writeVarint32(bb, nested.limit);
      writeByteBuffer(bb, nested);
      pushByteBuffer(nested);
    }
  }

  // optional int64 power = 4;
  let $power = message.power;
  if ($power !== undefined) {
    writeVarint32(bb, 32);
    writeVarint64(bb, $power);
  }
}

export function decodepb_ngwshold(binary) {
  return _decodepb_ngwshold(wrapByteBuffer(binary));
}

function _decodepb_ngwshold(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // optional int32 left = 1;
      case 1: {
        message.left = readVarint32(bb);
        break;
      }

      // optional int32 total = 2;
      case 2: {
        message.total = readVarint32(bb);
        break;
      }

      // repeated pb_ngwbuff buffs = 3;
      case 3: {
        let limit = pushTemporaryLength(bb);
        let values = message.buffs || (message.buffs = []);
        values.push(_decodepb_ngwbuff(bb));
        bb.limit = limit;
        break;
      }

      // optional int64 power = 4;
      case 4: {
        message.power = readVarint64(bb, /* unsigned */ false);
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  return message;
}

export function encodepb_ngwrank(message) {
  let bb = popByteBuffer();
  _encodepb_ngwrank(message, bb);
  return toUint8Array(bb);
}

function _encodepb_ngwrank(message, bb) {
  // optional int32 gid = 1;
  let $gid = message.gid;
  if ($gid !== undefined) {
    writeVarint32(bb, 8);
    writeVarint64(bb, intToLong($gid));
  }

  // optional int32 score = 2;
  let $score = message.score;
  if ($score !== undefined) {
    writeVarint32(bb, 16);
    writeVarint64(bb, intToLong($score));
  }

  // optional int32 seg = 3;
  let $seg = message.seg;
  if ($seg !== undefined) {
    writeVarint32(bb, 24);
    writeVarint64(bb, intToLong($seg));
  }

  // optional int32 time = 4;
  let $time = message.time;
  if ($time !== undefined) {
    writeVarint32(bb, 32);
    writeVarint64(bb, intToLong($time));
  }

  // optional int32 logo = 5;
  let $logo = message.logo;
  if ($logo !== undefined) {
    writeVarint32(bb, 40);
    writeVarint64(bb, intToLong($logo));
  }

  // optional string name = 6;
  let $name = message.name;
  if ($name !== undefined) {
    writeVarint32(bb, 50);
    writeString(bb, $name);
  }

  // optional int64 power = 7;
  let $power = message.power;
  if ($power !== undefined) {
    writeVarint32(bb, 56);
    writeVarint64(bb, $power);
  }
}

export function decodepb_ngwrank(binary) {
  return _decodepb_ngwrank(wrapByteBuffer(binary));
}

function _decodepb_ngwrank(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // optional int32 gid = 1;
      case 1: {
        message.gid = readVarint32(bb);
        break;
      }

      // optional int32 score = 2;
      case 2: {
        message.score = readVarint32(bb);
        break;
      }

      // optional int32 seg = 3;
      case 3: {
        message.seg = readVarint32(bb);
        break;
      }

      // optional int32 time = 4;
      case 4: {
        message.time = readVarint32(bb);
        break;
      }

      // optional int32 logo = 5;
      case 5: {
        message.logo = readVarint32(bb);
        break;
      }

      // optional string name = 6;
      case 6: {
        message.name = readString(bb, readVarint32(bb));
        break;
      }

      // optional int64 power = 7;
      case 7: {
        message.power = readVarint64(bb, /* unsigned */ false);
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  return message;
}

export function encodepb_ngwprank(message) {
  let bb = popByteBuffer();
  _encodepb_ngwprank(message, bb);
  return toUint8Array(bb);
}

function _encodepb_ngwprank(message, bb) {
  // optional int64 uid = 1;
  let $uid = message.uid;
  if ($uid !== undefined) {
    writeVarint32(bb, 8);
    writeVarint64(bb, $uid);
  }

  // optional string name = 2;
  let $name = message.name;
  if ($name !== undefined) {
    writeVarint32(bb, 18);
    writeString(bb, $name);
  }

  // optional int32 lv = 3;
  let $lv = message.lv;
  if ($lv !== undefined) {
    writeVarint32(bb, 24);
    writeVarint64(bb, intToLong($lv));
  }

  // optional int32 logo = 4;
  let $logo = message.logo;
  if ($logo !== undefined) {
    writeVarint32(bb, 32);
    writeVarint64(bb, intToLong($logo));
  }

  // optional int32 lbox = 5;
  let $lbox = message.lbox;
  if ($lbox !== undefined) {
    writeVarint32(bb, 40);
    writeVarint64(bb, intToLong($lbox));
  }

  // optional string gname = 6;
  let $gname = message.gname;
  if ($gname !== undefined) {
    writeVarint32(bb, 50);
    writeString(bb, $gname);
  }

  // optional int32 score = 7;
  let $score = message.score;
  if ($score !== undefined) {
    writeVarint32(bb, 56);
    writeVarint64(bb, intToLong($score));
  }

  // optional int32 time = 8;
  let $time = message.time;
  if ($time !== undefined) {
    writeVarint32(bb, 64);
    writeVarint64(bb, intToLong($time));
  }

  // optional int64 power = 9;
  let $power = message.power;
  if ($power !== undefined) {
    writeVarint32(bb, 72);
    writeVarint64(bb, $power);
  }

  // repeated int32 daily = 10;
  let array$daily = message.daily;
  if (array$daily !== undefined) {
    let packed = popByteBuffer();
    for (let value of array$daily) {
      writeVarint64(packed, intToLong(value));
    }
    writeVarint32(bb, 82);
    writeVarint32(bb, packed.offset);
    writeByteBuffer(bb, packed);
    pushByteBuffer(packed);
  }
}

export function decodepb_ngwprank(binary) {
  return _decodepb_ngwprank(wrapByteBuffer(binary));
}

function _decodepb_ngwprank(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // optional int64 uid = 1;
      case 1: {
        message.uid = readVarint64(bb, /* unsigned */ false);
        break;
      }

      // optional string name = 2;
      case 2: {
        message.name = readString(bb, readVarint32(bb));
        break;
      }

      // optional int32 lv = 3;
      case 3: {
        message.lv = readVarint32(bb);
        break;
      }

      // optional int32 logo = 4;
      case 4: {
        message.logo = readVarint32(bb);
        break;
      }

      // optional int32 lbox = 5;
      case 5: {
        message.lbox = readVarint32(bb);
        break;
      }

      // optional string gname = 6;
      case 6: {
        message.gname = readString(bb, readVarint32(bb));
        break;
      }

      // optional int32 score = 7;
      case 7: {
        message.score = readVarint32(bb);
        break;
      }

      // optional int32 time = 8;
      case 8: {
        message.time = readVarint32(bb);
        break;
      }

      // optional int64 power = 9;
      case 9: {
        message.power = readVarint64(bb, /* unsigned */ false);
        break;
      }

      // repeated int32 daily = 10;
      case 10: {
        let values = message.daily || (message.daily = []);
        if ((tag & 7) === 2) {
          let outerLimit = pushTemporaryLength(bb);
          while (!isAtEnd(bb)) {
            values.push(readVarint32(bb));
          }
          bb.limit = outerLimit;
        } else {
          values.push(readVarint32(bb));
        }
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  return message;
}

export function encodepb_ngwbuff(message) {
  let bb = popByteBuffer();
  _encodepb_ngwbuff(message, bb);
  return toUint8Array(bb);
}

function _encodepb_ngwbuff(message, bb) {
  // optional int32 id = 1;
  let $id = message.id;
  if ($id !== undefined) {
    writeVarint32(bb, 8);
    writeVarint64(bb, intToLong($id));
  }

  // optional int32 num = 2;
  let $num = message.num;
  if ($num !== undefined) {
    writeVarint32(bb, 16);
    writeVarint64(bb, intToLong($num));
  }
}

export function decodepb_ngwbuff(binary) {
  return _decodepb_ngwbuff(wrapByteBuffer(binary));
}

function _decodepb_ngwbuff(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // optional int32 id = 1;
      case 1: {
        message.id = readVarint32(bb);
        break;
      }

      // optional int32 num = 2;
      case 2: {
        message.num = readVarint32(bb);
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  return message;
}

export function encodepb_ngwmbr(message) {
  let bb = popByteBuffer();
  _encodepb_ngwmbr(message, bb);
  return toUint8Array(bb);
}

function _encodepb_ngwmbr(message, bb) {
  // optional int32 idx = 1;
  let $idx = message.idx;
  if ($idx !== undefined) {
    writeVarint32(bb, 8);
    writeVarint64(bb, intToLong($idx));
  }

  // optional int32 logo = 2;
  let $logo = message.logo;
  if ($logo !== undefined) {
    writeVarint32(bb, 16);
    writeVarint64(bb, intToLong($logo));
  }

  // optional string gname = 3;
  let $gname = message.gname;
  if ($gname !== undefined) {
    writeVarint32(bb, 26);
    writeString(bb, $gname);
  }

  // optional int64 power = 4;
  let $power = message.power;
  if ($power !== undefined) {
    writeVarint32(bb, 32);
    writeVarint64(bb, $power);
  }

  // optional int32 lv = 5;
  let $lv = message.lv;
  if ($lv !== undefined) {
    writeVarint32(bb, 40);
    writeVarint64(bb, intToLong($lv));
  }

  // optional int32 lbox = 6;
  let $lbox = message.lbox;
  if ($lbox !== undefined) {
    writeVarint32(bb, 48);
    writeVarint64(bb, intToLong($lbox));
  }

  // repeated pb_unit unit = 7;
  let array$unit = message.unit;
  if (array$unit !== undefined) {
    for (let value of array$unit) {
      writeVarint32(bb, 58);
      let nested = popByteBuffer();
      _encodepb_unit(value, nested);
      writeVarint32(bb, nested.limit);
      writeByteBuffer(bb, nested);
      pushByteBuffer(nested);
    }
  }

  // optional int64 uid = 8;
  let $uid = message.uid;
  if ($uid !== undefined) {
    writeVarint32(bb, 64);
    writeVarint64(bb, $uid);
  }

  // optional int32 gid = 9;
  let $gid = message.gid;
  if ($gid !== undefined) {
    writeVarint32(bb, 72);
    writeVarint64(bb, intToLong($gid));
  }

  // optional int32 win = 10;
  let $win = message.win;
  if ($win !== undefined) {
    writeVarint32(bb, 80);
    writeVarint64(bb, intToLong($win));
  }
}

export function decodepb_ngwmbr(binary) {
  return _decodepb_ngwmbr(wrapByteBuffer(binary));
}

function _decodepb_ngwmbr(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // optional int32 idx = 1;
      case 1: {
        message.idx = readVarint32(bb);
        break;
      }

      // optional int32 logo = 2;
      case 2: {
        message.logo = readVarint32(bb);
        break;
      }

      // optional string gname = 3;
      case 3: {
        message.gname = readString(bb, readVarint32(bb));
        break;
      }

      // optional int64 power = 4;
      case 4: {
        message.power = readVarint64(bb, /* unsigned */ false);
        break;
      }

      // optional int32 lv = 5;
      case 5: {
        message.lv = readVarint32(bb);
        break;
      }

      // optional int32 lbox = 6;
      case 6: {
        message.lbox = readVarint32(bb);
        break;
      }

      // repeated pb_unit unit = 7;
      case 7: {
        let limit = pushTemporaryLength(bb);
        let values = message.unit || (message.unit = []);
        values.push(_decodepb_unit(bb));
        bb.limit = limit;
        break;
      }

      // optional int64 uid = 8;
      case 8: {
        message.uid = readVarint64(bb, /* unsigned */ false);
        break;
      }

      // optional int32 gid = 9;
      case 9: {
        message.gid = readVarint32(bb);
        break;
      }

      // optional int32 win = 10;
      case 10: {
        message.win = readVarint32(bb);
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  return message;
}

export function encodepb_clink(message) {
  let bb = popByteBuffer();
  _encodepb_clink(message, bb);
  return toUint8Array(bb);
}

function _encodepb_clink(message, bb) {
  // optional int32 cd = 1;
  let $cd = message.cd;
  if ($cd !== undefined) {
    writeVarint32(bb, 8);
    writeVarint64(bb, intToLong($cd));
  }

  // optional int32 atk = 2;
  let $atk = message.atk;
  if ($atk !== undefined) {
    writeVarint32(bb, 16);
    writeVarint64(bb, intToLong($atk));
  }

  // optional int32 def = 3;
  let $def = message.def;
  if ($def !== undefined) {
    writeVarint32(bb, 24);
    writeVarint64(bb, intToLong($def));
  }

  // optional int32 win = 4;
  let $win = message.win;
  if ($win !== undefined) {
    writeVarint32(bb, 32);
    writeVarint64(bb, intToLong($win));
  }

  // optional int64 vid = 5;
  let $vid = message.vid;
  if ($vid !== undefined) {
    writeVarint32(bb, 40);
    writeVarint64(bb, $vid);
  }
}

export function decodepb_clink(binary) {
  return _decodepb_clink(wrapByteBuffer(binary));
}

function _decodepb_clink(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // optional int32 cd = 1;
      case 1: {
        message.cd = readVarint32(bb);
        break;
      }

      // optional int32 atk = 2;
      case 2: {
        message.atk = readVarint32(bb);
        break;
      }

      // optional int32 def = 3;
      case 3: {
        message.def = readVarint32(bb);
        break;
      }

      // optional int32 win = 4;
      case 4: {
        message.win = readVarint32(bb);
        break;
      }

      // optional int64 vid = 5;
      case 5: {
        message.vid = readVarint64(bb, /* unsigned */ false);
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  return message;
}

export function encodepb_cgw_info(message) {
  let bb = popByteBuffer();
  _encodepb_cgw_info(message, bb);
  return toUint8Array(bb);
}

function _encodepb_cgw_info(message, bb) {
  // optional int32 id = 1;
  let $id = message.id;
  if ($id !== undefined) {
    writeVarint32(bb, 8);
    writeVarint64(bb, intToLong($id));
  }

  // optional int32 logo = 2;
  let $logo = message.logo;
  if ($logo !== undefined) {
    writeVarint32(bb, 16);
    writeVarint64(bb, intToLong($logo));
  }

  // optional int64 power = 3;
  let $power = message.power;
  if ($power !== undefined) {
    writeVarint32(bb, 24);
    writeVarint64(bb, $power);
  }

  // optional string name = 4;
  let $name = message.name;
  if ($name !== undefined) {
    writeVarint32(bb, 34);
    writeString(bb, $name);
  }
}

export function decodepb_cgw_info(binary) {
  return _decodepb_cgw_info(wrapByteBuffer(binary));
}

function _decodepb_cgw_info(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // optional int32 id = 1;
      case 1: {
        message.id = readVarint32(bb);
        break;
      }

      // optional int32 logo = 2;
      case 2: {
        message.logo = readVarint32(bb);
        break;
      }

      // optional int64 power = 3;
      case 3: {
        message.power = readVarint64(bb, /* unsigned */ false);
        break;
      }

      // optional string name = 4;
      case 4: {
        message.name = readString(bb, readVarint32(bb));
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  return message;
}

export function encodepb_cgw_mbr(message) {
  let bb = popByteBuffer();
  _encodepb_cgw_mbr(message, bb);
  return toUint8Array(bb);
}

function _encodepb_cgw_mbr(message, bb) {
  // optional int64 uid = 1;
  let $uid = message.uid;
  if ($uid !== undefined) {
    writeVarint32(bb, 8);
    writeVarint64(bb, $uid);
  }

  // optional int32 logo = 2;
  let $logo = message.logo;
  if ($logo !== undefined) {
    writeVarint32(bb, 16);
    writeVarint64(bb, intToLong($logo));
  }

  // optional int32 lv = 3;
  let $lv = message.lv;
  if ($lv !== undefined) {
    writeVarint32(bb, 24);
    writeVarint64(bb, intToLong($lv));
  }

  // optional int32 lbox = 4;
  let $lbox = message.lbox;
  if ($lbox !== undefined) {
    writeVarint32(bb, 32);
    writeVarint64(bb, intToLong($lbox));
  }

  // optional string name = 5;
  let $name = message.name;
  if ($name !== undefined) {
    writeVarint32(bb, 42);
    writeString(bb, $name);
  }

  // repeated pb_unit camp = 6;
  let array$camp = message.camp;
  if (array$camp !== undefined) {
    for (let value of array$camp) {
      writeVarint32(bb, 50);
      let nested = popByteBuffer();
      _encodepb_unit(value, nested);
      writeVarint32(bb, nested.limit);
      writeByteBuffer(bb, nested);
      pushByteBuffer(nested);
    }
  }
}

export function decodepb_cgw_mbr(binary) {
  return _decodepb_cgw_mbr(wrapByteBuffer(binary));
}

function _decodepb_cgw_mbr(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // optional int64 uid = 1;
      case 1: {
        message.uid = readVarint64(bb, /* unsigned */ false);
        break;
      }

      // optional int32 logo = 2;
      case 2: {
        message.logo = readVarint32(bb);
        break;
      }

      // optional int32 lv = 3;
      case 3: {
        message.lv = readVarint32(bb);
        break;
      }

      // optional int32 lbox = 4;
      case 4: {
        message.lbox = readVarint32(bb);
        break;
      }

      // optional string name = 5;
      case 5: {
        message.name = readString(bb, readVarint32(bb));
        break;
      }

      // repeated pb_unit camp = 6;
      case 6: {
        let limit = pushTemporaryLength(bb);
        let values = message.camp || (message.camp = []);
        values.push(_decodepb_unit(bb));
        bb.limit = limit;
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  return message;
}

export function encodepb_cgw_record(message) {
  let bb = popByteBuffer();
  _encodepb_cgw_record(message, bb);
  return toUint8Array(bb);
}

function _encodepb_cgw_record(message, bb) {
  // optional int32 gid = 1;
  let $gid = message.gid;
  if ($gid !== undefined) {
    writeVarint32(bb, 8);
    writeVarint64(bb, intToLong($gid));
  }

  // optional int32 logo = 2;
  let $logo = message.logo;
  if ($logo !== undefined) {
    writeVarint32(bb, 16);
    writeVarint64(bb, intToLong($logo));
  }

  // optional int32 vid = 3;
  let $vid = message.vid;
  if ($vid !== undefined) {
    writeVarint32(bb, 24);
    writeVarint64(bb, intToLong($vid));
  }

  // optional int32 cd = 4;
  let $cd = message.cd;
  if ($cd !== undefined) {
    writeVarint32(bb, 32);
    writeVarint64(bb, intToLong($cd));
  }

  // optional int32 flag = 5;
  let $flag = message.flag;
  if ($flag !== undefined) {
    writeVarint32(bb, 40);
    writeVarint64(bb, intToLong($flag));
  }

  // optional int64 power = 6;
  let $power = message.power;
  if ($power !== undefined) {
    writeVarint32(bb, 48);
    writeVarint64(bb, $power);
  }

  // optional string name = 7;
  let $name = message.name;
  if ($name !== undefined) {
    writeVarint32(bb, 58);
    writeString(bb, $name);
  }

  // optional bool atk = 8;
  let $atk = message.atk;
  if ($atk !== undefined) {
    writeVarint32(bb, 64);
    writeByte(bb, $atk ? 1 : 0);
  }

  // optional bool win = 9;
  let $win = message.win;
  if ($win !== undefined) {
    writeVarint32(bb, 72);
    writeByte(bb, $win ? 1 : 0);
  }

  // optional int64 spower = 10;
  let $spower = message.spower;
  if ($spower !== undefined) {
    writeVarint32(bb, 80);
    writeVarint64(bb, $spower);
  }
}

export function decodepb_cgw_record(binary) {
  return _decodepb_cgw_record(wrapByteBuffer(binary));
}

function _decodepb_cgw_record(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // optional int32 gid = 1;
      case 1: {
        message.gid = readVarint32(bb);
        break;
      }

      // optional int32 logo = 2;
      case 2: {
        message.logo = readVarint32(bb);
        break;
      }

      // optional int32 vid = 3;
      case 3: {
        message.vid = readVarint32(bb);
        break;
      }

      // optional int32 cd = 4;
      case 4: {
        message.cd = readVarint32(bb);
        break;
      }

      // optional int32 flag = 5;
      case 5: {
        message.flag = readVarint32(bb);
        break;
      }

      // optional int64 power = 6;
      case 6: {
        message.power = readVarint64(bb, /* unsigned */ false);
        break;
      }

      // optional string name = 7;
      case 7: {
        message.name = readString(bb, readVarint32(bb));
        break;
      }

      // optional bool atk = 8;
      case 8: {
        message.atk = !!readByte(bb);
        break;
      }

      // optional bool win = 9;
      case 9: {
        message.win = !!readByte(bb);
        break;
      }

      // optional int64 spower = 10;
      case 10: {
        message.spower = readVarint64(bb, /* unsigned */ false);
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  return message;
}

export function encodepb_cgw_log(message) {
  let bb = popByteBuffer();
  _encodepb_cgw_log(message, bb);
  return toUint8Array(bb);
}

function _encodepb_cgw_log(message, bb) {
  // optional pb_cgw_mbr atk = 1;
  let $atk = message.atk;
  if ($atk !== undefined) {
    writeVarint32(bb, 10);
    let nested = popByteBuffer();
    _encodepb_cgw_mbr($atk, nested);
    writeVarint32(bb, nested.limit);
    writeByteBuffer(bb, nested);
    pushByteBuffer(nested);
  }

  // optional pb_cgw_mbr def = 2;
  let $def = message.def;
  if ($def !== undefined) {
    writeVarint32(bb, 18);
    let nested = popByteBuffer();
    _encodepb_cgw_mbr($def, nested);
    writeVarint32(bb, nested.limit);
    writeByteBuffer(bb, nested);
    pushByteBuffer(nested);
  }

  // optional bool win = 3;
  let $win = message.win;
  if ($win !== undefined) {
    writeVarint32(bb, 24);
    writeByte(bb, $win ? 1 : 0);
  }
}

export function decodepb_cgw_log(binary) {
  return _decodepb_cgw_log(wrapByteBuffer(binary));
}

function _decodepb_cgw_log(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // optional pb_cgw_mbr atk = 1;
      case 1: {
        let limit = pushTemporaryLength(bb);
        message.atk = _decodepb_cgw_mbr(bb);
        bb.limit = limit;
        break;
      }

      // optional pb_cgw_mbr def = 2;
      case 2: {
        let limit = pushTemporaryLength(bb);
        message.def = _decodepb_cgw_mbr(bb);
        bb.limit = limit;
        break;
      }

      // optional bool win = 3;
      case 3: {
        message.win = !!readByte(bb);
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  return message;
}

export function encodepb_ngw_sweep(message) {
  let bb = popByteBuffer();
  _encodepb_ngw_sweep(message, bb);
  return toUint8Array(bb);
}

function _encodepb_ngw_sweep(message, bb) {
  // optional int32 status = 1;
  let $status = message.status;
  if ($status !== undefined) {
    writeVarint32(bb, 8);
    writeVarint64(bb, intToLong($status));
  }

  // optional int32 id = 2;
  let $id = message.id;
  if ($id !== undefined) {
    writeVarint32(bb, 16);
    writeVarint64(bb, intToLong($id));
  }

  // optional int32 destroy = 3;
  let $destroy = message.destroy;
  if ($destroy !== undefined) {
    writeVarint32(bb, 24);
    writeVarint64(bb, intToLong($destroy));
  }
}

export function decodepb_ngw_sweep(binary) {
  return _decodepb_ngw_sweep(wrapByteBuffer(binary));
}

function _decodepb_ngw_sweep(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // optional int32 status = 1;
      case 1: {
        message.status = readVarint32(bb);
        break;
      }

      // optional int32 id = 2;
      case 2: {
        message.id = readVarint32(bb);
        break;
      }

      // optional int32 destroy = 3;
      case 3: {
        message.destroy = readVarint32(bb);
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  return message;
}

export function encodepb_cd(message) {
  let bb = popByteBuffer();
  _encodepb_cd(message, bb);
  return toUint8Array(bb);
}

function _encodepb_cd(message, bb) {
  // required int32 id = 1;
  let $id = message.id;
  if ($id !== undefined) {
    writeVarint32(bb, 8);
    writeVarint64(bb, intToLong($id));
  }

  // required int32 cd = 2;
  let $cd = message.cd;
  if ($cd !== undefined) {
    writeVarint32(bb, 16);
    writeVarint64(bb, intToLong($cd));
  }
}

export function decodepb_cd(binary) {
  return _decodepb_cd(wrapByteBuffer(binary));
}

function _decodepb_cd(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // required int32 id = 1;
      case 1: {
        message.id = readVarint32(bb);
        break;
      }

      // required int32 cd = 2;
      case 2: {
        message.cd = readVarint32(bb);
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  if (message.id === undefined)
    throw new Error("Missing required field: id");

  if (message.cd === undefined)
    throw new Error("Missing required field: cd");

  return message;
}

export function encodepb_gpvpteam(message) {
  let bb = popByteBuffer();
  _encodepb_gpvpteam(message, bb);
  return toUint8Array(bb);
}

function _encodepb_gpvpteam(message, bb) {
  // optional int32 leader = 1;
  let $leader = message.leader;
  if ($leader !== undefined) {
    writeVarint32(bb, 8);
    writeVarint64(bb, intToLong($leader));
  }

  // repeated pb_pmbr mbrs = 2;
  let array$mbrs = message.mbrs;
  if (array$mbrs !== undefined) {
    for (let value of array$mbrs) {
      writeVarint32(bb, 18);
      let nested = popByteBuffer();
      _encodepb_pmbr(value, nested);
      writeVarint32(bb, nested.limit);
      writeByteBuffer(bb, nested);
      pushByteBuffer(nested);
    }
  }

  // optional int32 sid = 3;
  let $sid = message.sid;
  if ($sid !== undefined) {
    writeVarint32(bb, 24);
    writeVarint64(bb, intToLong($sid));
  }

  // optional int32 score = 4;
  let $score = message.score;
  if ($score !== undefined) {
    writeVarint32(bb, 32);
    writeVarint64(bb, intToLong($score));
  }

  // optional int32 rank = 5;
  let $rank = message.rank;
  if ($rank !== undefined) {
    writeVarint32(bb, 40);
    writeVarint64(bb, intToLong($rank));
  }

  // optional int64 power = 6;
  let $power = message.power;
  if ($power !== undefined) {
    writeVarint32(bb, 48);
    writeVarint64(bb, $power);
  }

  // optional string name = 7;
  let $name = message.name;
  if ($name !== undefined) {
    writeVarint32(bb, 58);
    writeString(bb, $name);
  }

  // optional int64 need_power = 8;
  let $need_power = message.need_power;
  if ($need_power !== undefined) {
    writeVarint32(bb, 64);
    writeVarint64(bb, $need_power);
  }

  // optional string password = 9;
  let $password = message.password;
  if ($password !== undefined) {
    writeVarint32(bb, 74);
    writeString(bb, $password);
  }

  // optional int32 id = 10;
  let $id = message.id;
  if ($id !== undefined) {
    writeVarint32(bb, 80);
    writeVarint64(bb, intToLong($id));
  }

  // optional bool reg = 11;
  let $reg = message.reg;
  if ($reg !== undefined) {
    writeVarint32(bb, 88);
    writeByte(bb, $reg ? 1 : 0);
  }

  // optional int32 enegy = 12;
  let $enegy = message.enegy;
  if ($enegy !== undefined) {
    writeVarint32(bb, 96);
    writeVarint64(bb, intToLong($enegy));
  }

  // optional int32 enggy_cd = 13;
  let $enggy_cd = message.enggy_cd;
  if ($enggy_cd !== undefined) {
    writeVarint32(bb, 104);
    writeVarint64(bb, intToLong($enggy_cd));
  }
}

export function decodepb_gpvpteam(binary) {
  return _decodepb_gpvpteam(wrapByteBuffer(binary));
}

function _decodepb_gpvpteam(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // optional int32 leader = 1;
      case 1: {
        message.leader = readVarint32(bb);
        break;
      }

      // repeated pb_pmbr mbrs = 2;
      case 2: {
        let limit = pushTemporaryLength(bb);
        let values = message.mbrs || (message.mbrs = []);
        values.push(_decodepb_pmbr(bb));
        bb.limit = limit;
        break;
      }

      // optional int32 sid = 3;
      case 3: {
        message.sid = readVarint32(bb);
        break;
      }

      // optional int32 score = 4;
      case 4: {
        message.score = readVarint32(bb);
        break;
      }

      // optional int32 rank = 5;
      case 5: {
        message.rank = readVarint32(bb);
        break;
      }

      // optional int64 power = 6;
      case 6: {
        message.power = readVarint64(bb, /* unsigned */ false);
        break;
      }

      // optional string name = 7;
      case 7: {
        message.name = readString(bb, readVarint32(bb));
        break;
      }

      // optional int64 need_power = 8;
      case 8: {
        message.need_power = readVarint64(bb, /* unsigned */ false);
        break;
      }

      // optional string password = 9;
      case 9: {
        message.password = readString(bb, readVarint32(bb));
        break;
      }

      // optional int32 id = 10;
      case 10: {
        message.id = readVarint32(bb);
        break;
      }

      // optional bool reg = 11;
      case 11: {
        message.reg = !!readByte(bb);
        break;
      }

      // optional int32 enegy = 12;
      case 12: {
        message.enegy = readVarint32(bb);
        break;
      }

      // optional int32 enggy_cd = 13;
      case 13: {
        message.enggy_cd = readVarint32(bb);
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  return message;
}

export function encodepb_gpvplog(message) {
  let bb = popByteBuffer();
  _encodepb_gpvplog(message, bb);
  return toUint8Array(bb);
}

function _encodepb_gpvplog(message, bb) {
  // required int32 log_id = 1;
  let $log_id = message.log_id;
  if ($log_id !== undefined) {
    writeVarint32(bb, 8);
    writeVarint64(bb, intToLong($log_id));
  }

  // required pb_gpvpteam enemy = 2;
  let $enemy = message.enemy;
  if ($enemy !== undefined) {
    writeVarint32(bb, 18);
    let nested = popByteBuffer();
    _encodepb_gpvpteam($enemy, nested);
    writeVarint32(bb, nested.limit);
    writeByteBuffer(bb, nested);
    pushByteBuffer(nested);
  }

  // optional sint32 score = 3;
  let $score = message.score;
  if ($score !== undefined) {
    writeVarint32(bb, 24);
    writeVarint32ZigZag(bb, $score);
  }

  // optional bool win = 4;
  let $win = message.win;
  if ($win !== undefined) {
    writeVarint32(bb, 32);
    writeByte(bb, $win ? 1 : 0);
  }

  // optional int32 time = 5;
  let $time = message.time;
  if ($time !== undefined) {
    writeVarint32(bb, 40);
    writeVarint64(bb, intToLong($time));
  }
}

export function decodepb_gpvplog(binary) {
  return _decodepb_gpvplog(wrapByteBuffer(binary));
}

function _decodepb_gpvplog(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // required int32 log_id = 1;
      case 1: {
        message.log_id = readVarint32(bb);
        break;
      }

      // required pb_gpvpteam enemy = 2;
      case 2: {
        let limit = pushTemporaryLength(bb);
        message.enemy = _decodepb_gpvpteam(bb);
        bb.limit = limit;
        break;
      }

      // optional sint32 score = 3;
      case 3: {
        message.score = readVarint32ZigZag(bb);
        break;
      }

      // optional bool win = 4;
      case 4: {
        message.win = !!readByte(bb);
        break;
      }

      // optional int32 time = 5;
      case 5: {
        message.time = readVarint32(bb);
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  if (message.log_id === undefined)
    throw new Error("Missing required field: log_id");

  if (message.enemy === undefined)
    throw new Error("Missing required field: enemy");

  return message;
}

export function encodepb_gpvp_wlog(message) {
  let bb = popByteBuffer();
  _encodepb_gpvp_wlog(message, bb);
  return toUint8Array(bb);
}

function _encodepb_gpvp_wlog(message, bb) {
  // required pb_gpvpteam atk = 1;
  let $atk = message.atk;
  if ($atk !== undefined) {
    writeVarint32(bb, 10);
    let nested = popByteBuffer();
    _encodepb_gpvpteam($atk, nested);
    writeVarint32(bb, nested.limit);
    writeByteBuffer(bb, nested);
    pushByteBuffer(nested);
  }

  // required pb_gpvpteam def = 2;
  let $def = message.def;
  if ($def !== undefined) {
    writeVarint32(bb, 18);
    let nested = popByteBuffer();
    _encodepb_gpvpteam($def, nested);
    writeVarint32(bb, nested.limit);
    writeByteBuffer(bb, nested);
    pushByteBuffer(nested);
  }

  // repeated bool wins = 3;
  let array$wins = message.wins;
  if (array$wins !== undefined) {
    let packed = popByteBuffer();
    for (let value of array$wins) {
      writeByte(packed, value ? 1 : 0);
    }
    writeVarint32(bb, 26);
    writeVarint32(bb, packed.offset);
    writeByteBuffer(bb, packed);
    pushByteBuffer(packed);
  }

  // repeated int32 vids = 4;
  let array$vids = message.vids;
  if (array$vids !== undefined) {
    let packed = popByteBuffer();
    for (let value of array$vids) {
      writeVarint64(packed, intToLong(value));
    }
    writeVarint32(bb, 34);
    writeVarint32(bb, packed.offset);
    writeByteBuffer(bb, packed);
    pushByteBuffer(packed);
  }
}

export function decodepb_gpvp_wlog(binary) {
  return _decodepb_gpvp_wlog(wrapByteBuffer(binary));
}

function _decodepb_gpvp_wlog(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // required pb_gpvpteam atk = 1;
      case 1: {
        let limit = pushTemporaryLength(bb);
        message.atk = _decodepb_gpvpteam(bb);
        bb.limit = limit;
        break;
      }

      // required pb_gpvpteam def = 2;
      case 2: {
        let limit = pushTemporaryLength(bb);
        message.def = _decodepb_gpvpteam(bb);
        bb.limit = limit;
        break;
      }

      // repeated bool wins = 3;
      case 3: {
        let values = message.wins || (message.wins = []);
        if ((tag & 7) === 2) {
          let outerLimit = pushTemporaryLength(bb);
          while (!isAtEnd(bb)) {
            values.push(!!readByte(bb));
          }
          bb.limit = outerLimit;
        } else {
          values.push(!!readByte(bb));
        }
        break;
      }

      // repeated int32 vids = 4;
      case 4: {
        let values = message.vids || (message.vids = []);
        if ((tag & 7) === 2) {
          let outerLimit = pushTemporaryLength(bb);
          while (!isAtEnd(bb)) {
            values.push(readVarint32(bb));
          }
          bb.limit = outerLimit;
        } else {
          values.push(readVarint32(bb));
        }
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  if (message.atk === undefined)
    throw new Error("Missing required field: atk");

  if (message.def === undefined)
    throw new Error("Missing required field: def");

  return message;
}

export function encodepb_pet(message) {
  let bb = popByteBuffer();
  _encodepb_pet(message, bb);
  return toUint8Array(bb);
}

function _encodepb_pet(message, bb) {
  // required int32 id = 1;
  let $id = message.id;
  if ($id !== undefined) {
    writeVarint32(bb, 8);
    writeVarint64(bb, intToLong($id));
  }

  // required int32 lv = 2;
  let $lv = message.lv;
  if ($lv !== undefined) {
    writeVarint32(bb, 16);
    writeVarint64(bb, intToLong($lv));
  }

  // required int32 star = 3;
  let $star = message.star;
  if ($star !== undefined) {
    writeVarint32(bb, 24);
    writeVarint64(bb, intToLong($star));
  }

  // repeated int32 skl = 4;
  let array$skl = message.skl;
  if (array$skl !== undefined) {
    let packed = popByteBuffer();
    for (let value of array$skl) {
      writeVarint64(packed, intToLong(value));
    }
    writeVarint32(bb, 34);
    writeVarint32(bb, packed.offset);
    writeByteBuffer(bb, packed);
    pushByteBuffer(packed);
  }
}

export function decodepb_pet(binary) {
  return _decodepb_pet(wrapByteBuffer(binary));
}

function _decodepb_pet(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // required int32 id = 1;
      case 1: {
        message.id = readVarint32(bb);
        break;
      }

      // required int32 lv = 2;
      case 2: {
        message.lv = readVarint32(bb);
        break;
      }

      // required int32 star = 3;
      case 3: {
        message.star = readVarint32(bb);
        break;
      }

      // repeated int32 skl = 4;
      case 4: {
        let values = message.skl || (message.skl = []);
        if ((tag & 7) === 2) {
          let outerLimit = pushTemporaryLength(bb);
          while (!isAtEnd(bb)) {
            values.push(readVarint32(bb));
          }
          bb.limit = outerLimit;
        } else {
          values.push(readVarint32(bb));
        }
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  if (message.id === undefined)
    throw new Error("Missing required field: id");

  if (message.lv === undefined)
    throw new Error("Missing required field: lv");

  if (message.star === undefined)
    throw new Error("Missing required field: star");

  return message;
}

export function encodepb_spkunit(message) {
  let bb = popByteBuffer();
  _encodepb_spkunit(message, bb);
  return toUint8Array(bb);
}

function _encodepb_spkunit(message, bb) {
  // optional pb_unit base = 1;
  let $base = message.base;
  if ($base !== undefined) {
    writeVarint32(bb, 10);
    let nested = popByteBuffer();
    _encodepb_unit($base, nested);
    writeVarint32(bb, nested.limit);
    writeByteBuffer(bb, nested);
    pushByteBuffer(nested);
  }

  // repeated pb_item buf = 2;
  let array$buf = message.buf;
  if (array$buf !== undefined) {
    for (let value of array$buf) {
      writeVarint32(bb, 18);
      let nested = popByteBuffer();
      _encodepb_item(value, nested);
      writeVarint32(bb, nested.limit);
      writeByteBuffer(bb, nested);
      pushByteBuffer(nested);
    }
  }
}

export function decodepb_spkunit(binary) {
  return _decodepb_spkunit(wrapByteBuffer(binary));
}

function _decodepb_spkunit(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // optional pb_unit base = 1;
      case 1: {
        let limit = pushTemporaryLength(bb);
        message.base = _decodepb_unit(bb);
        bb.limit = limit;
        break;
      }

      // repeated pb_item buf = 2;
      case 2: {
        let limit = pushTemporaryLength(bb);
        let values = message.buf || (message.buf = []);
        values.push(_decodepb_item(bb));
        bb.limit = limit;
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  return message;
}

export function encodepb_spkmbr(message) {
  let bb = popByteBuffer();
  _encodepb_spkmbr(message, bb);
  return toUint8Array(bb);
}

function _encodepb_spkmbr(message, bb) {
  // required int32 uid = 1;
  let $uid = message.uid;
  if ($uid !== undefined) {
    writeVarint32(bb, 8);
    writeVarint64(bb, intToLong($uid));
  }

  // required int32 lv = 2;
  let $lv = message.lv;
  if ($lv !== undefined) {
    writeVarint32(bb, 16);
    writeVarint64(bb, intToLong($lv));
  }

  // required int32 wave = 3;
  let $wave = message.wave;
  if ($wave !== undefined) {
    writeVarint32(bb, 24);
    writeVarint64(bb, intToLong($wave));
  }

  // required int32 time = 4;
  let $time = message.time;
  if ($time !== undefined) {
    writeVarint32(bb, 32);
    writeVarint64(bb, intToLong($time));
  }

  // required int32 logo = 5;
  let $logo = message.logo;
  if ($logo !== undefined) {
    writeVarint32(bb, 40);
    writeVarint64(bb, intToLong($logo));
  }

  // required string name = 6;
  let $name = message.name;
  if ($name !== undefined) {
    writeVarint32(bb, 50);
    writeString(bb, $name);
  }

  // optional int32 border = 7;
  let $border = message.border;
  if ($border !== undefined) {
    writeVarint32(bb, 56);
    writeVarint64(bb, intToLong($border));
  }
}

export function decodepb_spkmbr(binary) {
  return _decodepb_spkmbr(wrapByteBuffer(binary));
}

function _decodepb_spkmbr(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // required int32 uid = 1;
      case 1: {
        message.uid = readVarint32(bb);
        break;
      }

      // required int32 lv = 2;
      case 2: {
        message.lv = readVarint32(bb);
        break;
      }

      // required int32 wave = 3;
      case 3: {
        message.wave = readVarint32(bb);
        break;
      }

      // required int32 time = 4;
      case 4: {
        message.time = readVarint32(bb);
        break;
      }

      // required int32 logo = 5;
      case 5: {
        message.logo = readVarint32(bb);
        break;
      }

      // required string name = 6;
      case 6: {
        message.name = readString(bb, readVarint32(bb));
        break;
      }

      // optional int32 border = 7;
      case 7: {
        message.border = readVarint32(bb);
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  if (message.uid === undefined)
    throw new Error("Missing required field: uid");

  if (message.lv === undefined)
    throw new Error("Missing required field: lv");

  if (message.wave === undefined)
    throw new Error("Missing required field: wave");

  if (message.time === undefined)
    throw new Error("Missing required field: time");

  if (message.logo === undefined)
    throw new Error("Missing required field: logo");

  if (message.name === undefined)
    throw new Error("Missing required field: name");

  return message;
}

export function encodepb_holy(message) {
  let bb = popByteBuffer();
  _encodepb_holy(message, bb);
  return toUint8Array(bb);
}

function _encodepb_holy(message, bb) {
  // required int32 id = 1;
  let $id = message.id;
  if ($id !== undefined) {
    writeVarint32(bb, 8);
    writeVarint64(bb, intToLong($id));
  }

  // required int32 pos = 2;
  let $pos = message.pos;
  if ($pos !== undefined) {
    writeVarint32(bb, 16);
    writeVarint64(bb, intToLong($pos));
  }

  // optional int32 val = 3;
  let $val = message.val;
  if ($val !== undefined) {
    writeVarint32(bb, 24);
    writeVarint64(bb, intToLong($val));
  }
}

export function decodepb_holy(binary) {
  return _decodepb_holy(wrapByteBuffer(binary));
}

function _decodepb_holy(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // required int32 id = 1;
      case 1: {
        message.id = readVarint32(bb);
        break;
      }

      // required int32 pos = 2;
      case 2: {
        message.pos = readVarint32(bb);
        break;
      }

      // optional int32 val = 3;
      case 3: {
        message.val = readVarint32(bb);
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  if (message.id === undefined)
    throw new Error("Missing required field: id");

  if (message.pos === undefined)
    throw new Error("Missing required field: pos");

  return message;
}

export function encodepb_mine(message) {
  let bb = popByteBuffer();
  _encodepb_mine(message, bb);
  return toUint8Array(bb);
}

function _encodepb_mine(message, bb) {
  // required int32 id = 1;
  let $id = message.id;
  if ($id !== undefined) {
    writeVarint32(bb, 8);
    writeVarint64(bb, intToLong($id));
  }

  // required int32 pos = 2;
  let $pos = message.pos;
  if ($pos !== undefined) {
    writeVarint32(bb, 16);
    writeVarint64(bb, intToLong($pos));
  }

  // required int32 val = 3;
  let $val = message.val;
  if ($val !== undefined) {
    writeVarint32(bb, 24);
    writeVarint64(bb, intToLong($val));
  }
}

export function decodepb_mine(binary) {
  return _decodepb_mine(wrapByteBuffer(binary));
}

function _decodepb_mine(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // required int32 id = 1;
      case 1: {
        message.id = readVarint32(bb);
        break;
      }

      // required int32 pos = 2;
      case 2: {
        message.pos = readVarint32(bb);
        break;
      }

      // required int32 val = 3;
      case 3: {
        message.val = readVarint32(bb);
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  if (message.id === undefined)
    throw new Error("Missing required field: id");

  if (message.pos === undefined)
    throw new Error("Missing required field: pos");

  if (message.val === undefined)
    throw new Error("Missing required field: val");

  return message;
}

export function encodepb_land(message) {
  let bb = popByteBuffer();
  _encodepb_land(message, bb);
  return toUint8Array(bb);
}

function _encodepb_land(message, bb) {
  // required int32 id = 1;
  let $id = message.id;
  if ($id !== undefined) {
    writeVarint32(bb, 8);
    writeVarint64(bb, intToLong($id));
  }

  // required int32 pos = 2;
  let $pos = message.pos;
  if ($pos !== undefined) {
    writeVarint32(bb, 16);
    writeVarint64(bb, intToLong($pos));
  }

  // optional int32 cd = 3;
  let $cd = message.cd;
  if ($cd !== undefined) {
    writeVarint32(bb, 24);
    writeVarint64(bb, intToLong($cd));
  }

  // optional int32 cdk = 4;
  let $cdk = message.cdk;
  if ($cdk !== undefined) {
    writeVarint32(bb, 32);
    writeVarint64(bb, intToLong($cdk));
  }

  // optional bool dead = 5;
  let $dead = message.dead;
  if ($dead !== undefined) {
    writeVarint32(bb, 40);
    writeByte(bb, $dead ? 1 : 0);
  }
}

export function decodepb_land(binary) {
  return _decodepb_land(wrapByteBuffer(binary));
}

function _decodepb_land(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // required int32 id = 1;
      case 1: {
        message.id = readVarint32(bb);
        break;
      }

      // required int32 pos = 2;
      case 2: {
        message.pos = readVarint32(bb);
        break;
      }

      // optional int32 cd = 3;
      case 3: {
        message.cd = readVarint32(bb);
        break;
      }

      // optional int32 cdk = 4;
      case 4: {
        message.cdk = readVarint32(bb);
        break;
      }

      // optional bool dead = 5;
      case 5: {
        message.dead = !!readByte(bb);
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  if (message.id === undefined)
    throw new Error("Missing required field: id");

  if (message.pos === undefined)
    throw new Error("Missing required field: pos");

  return message;
}

export function encodepb_vit(message) {
  let bb = popByteBuffer();
  _encodepb_vit(message, bb);
  return toUint8Array(bb);
}

function _encodepb_vit(message, bb) {
  // required int32 vit = 1;
  let $vit = message.vit;
  if ($vit !== undefined) {
    writeVarint32(bb, 8);
    writeVarint64(bb, intToLong($vit));
  }

  // optional int32 buy = 2;
  let $buy = message.buy;
  if ($buy !== undefined) {
    writeVarint32(bb, 16);
    writeVarint64(bb, intToLong($buy));
  }
}

export function decodepb_vit(binary) {
  return _decodepb_vit(wrapByteBuffer(binary));
}

function _decodepb_vit(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // required int32 vit = 1;
      case 1: {
        message.vit = readVarint32(bb);
        break;
      }

      // optional int32 buy = 2;
      case 2: {
        message.buy = readVarint32(bb);
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  if (message.vit === undefined)
    throw new Error("Missing required field: vit");

  return message;
}

export function encodepb_ievent(message) {
  let bb = popByteBuffer();
  _encodepb_ievent(message, bb);
  return toUint8Array(bb);
}

function _encodepb_ievent(message, bb) {
  // required int32 id = 1;
  let $id = message.id;
  if ($id !== undefined) {
    writeVarint32(bb, 8);
    writeVarint64(bb, intToLong($id));
  }

  // optional int32 cd = 2;
  let $cd = message.cd;
  if ($cd !== undefined) {
    writeVarint32(bb, 16);
    writeVarint64(bb, intToLong($cd));
  }

  // optional string ext = 3;
  let $ext = message.ext;
  if ($ext !== undefined) {
    writeVarint32(bb, 26);
    writeString(bb, $ext);
  }

  // optional int32 sid = 4;
  let $sid = message.sid;
  if ($sid !== undefined) {
    writeVarint32(bb, 32);
    writeVarint64(bb, intToLong($sid));
  }

  // optional pb_bag reward = 5;
  let $reward = message.reward;
  if ($reward !== undefined) {
    writeVarint32(bb, 42);
    let nested = popByteBuffer();
    _encodepb_bag($reward, nested);
    writeVarint32(bb, nested.limit);
    writeByteBuffer(bb, nested);
    pushByteBuffer(nested);
  }
}

export function decodepb_ievent(binary) {
  return _decodepb_ievent(wrapByteBuffer(binary));
}

function _decodepb_ievent(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // required int32 id = 1;
      case 1: {
        message.id = readVarint32(bb);
        break;
      }

      // optional int32 cd = 2;
      case 2: {
        message.cd = readVarint32(bb);
        break;
      }

      // optional string ext = 3;
      case 3: {
        message.ext = readString(bb, readVarint32(bb));
        break;
      }

      // optional int32 sid = 4;
      case 4: {
        message.sid = readVarint32(bb);
        break;
      }

      // optional pb_bag reward = 5;
      case 5: {
        let limit = pushTemporaryLength(bb);
        message.reward = _decodepb_bag(bb);
        bb.limit = limit;
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  if (message.id === undefined)
    throw new Error("Missing required field: id");

  return message;
}

export function encodepb_iadt(message) {
  let bb = popByteBuffer();
  _encodepb_iadt(message, bb);
  return toUint8Array(bb);
}

function _encodepb_iadt(message, bb) {
  // optional int32 dist = 1;
  let $dist = message.dist;
  if ($dist !== undefined) {
    writeVarint32(bb, 8);
    writeVarint64(bb, intToLong($dist));
  }

  // repeated pb_ievent mevts = 2;
  let array$mevts = message.mevts;
  if (array$mevts !== undefined) {
    for (let value of array$mevts) {
      writeVarint32(bb, 18);
      let nested = popByteBuffer();
      _encodepb_ievent(value, nested);
      writeVarint32(bb, nested.limit);
      writeByteBuffer(bb, nested);
      pushByteBuffer(nested);
    }
  }

  // repeated pb_ievent pevts = 3;
  let array$pevts = message.pevts;
  if (array$pevts !== undefined) {
    for (let value of array$pevts) {
      writeVarint32(bb, 26);
      let nested = popByteBuffer();
      _encodepb_ievent(value, nested);
      writeVarint32(bb, nested.limit);
      writeByteBuffer(bb, nested);
      pushByteBuffer(nested);
    }
  }

  // optional int32 vit = 4;
  let $vit = message.vit;
  if ($vit !== undefined) {
    writeVarint32(bb, 32);
    writeVarint64(bb, intToLong($vit));
  }

  // optional int32 vitcd = 5;
  let $vitcd = message.vitcd;
  if ($vitcd !== undefined) {
    writeVarint32(bb, 40);
    writeVarint64(bb, intToLong($vitcd));
  }

  // optional pb_bag reward = 6;
  let $reward = message.reward;
  if ($reward !== undefined) {
    writeVarint32(bb, 50);
    let nested = popByteBuffer();
    _encodepb_bag($reward, nested);
    writeVarint32(bb, nested.limit);
    writeByteBuffer(bb, nested);
    pushByteBuffer(nested);
  }

  // optional int32 rt = 7;
  let $rt = message.rt;
  if ($rt !== undefined) {
    writeVarint32(bb, 56);
    writeVarint64(bb, intToLong($rt));
  }

  // optional int32 num = 8;
  let $num = message.num;
  if ($num !== undefined) {
    writeVarint32(bb, 64);
    writeVarint64(bb, intToLong($num));
  }
}

export function decodepb_iadt(binary) {
  return _decodepb_iadt(wrapByteBuffer(binary));
}

function _decodepb_iadt(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // optional int32 dist = 1;
      case 1: {
        message.dist = readVarint32(bb);
        break;
      }

      // repeated pb_ievent mevts = 2;
      case 2: {
        let limit = pushTemporaryLength(bb);
        let values = message.mevts || (message.mevts = []);
        values.push(_decodepb_ievent(bb));
        bb.limit = limit;
        break;
      }

      // repeated pb_ievent pevts = 3;
      case 3: {
        let limit = pushTemporaryLength(bb);
        let values = message.pevts || (message.pevts = []);
        values.push(_decodepb_ievent(bb));
        bb.limit = limit;
        break;
      }

      // optional int32 vit = 4;
      case 4: {
        message.vit = readVarint32(bb);
        break;
      }

      // optional int32 vitcd = 5;
      case 5: {
        message.vitcd = readVarint32(bb);
        break;
      }

      // optional pb_bag reward = 6;
      case 6: {
        let limit = pushTemporaryLength(bb);
        message.reward = _decodepb_bag(bb);
        bb.limit = limit;
        break;
      }

      // optional int32 rt = 7;
      case 7: {
        message.rt = readVarint32(bb);
        break;
      }

      // optional int32 num = 8;
      case 8: {
        message.num = readVarint32(bb);
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  return message;
}

export function encodepb_iboat(message) {
  let bb = popByteBuffer();
  _encodepb_iboat(message, bb);
  return toUint8Array(bb);
}

function _encodepb_iboat(message, bb) {
  // optional string name = 1;
  let $name = message.name;
  if ($name !== undefined) {
    writeVarint32(bb, 10);
    writeString(bb, $name);
  }

  // optional int32 exp = 2;
  let $exp = message.exp;
  if ($exp !== undefined) {
    writeVarint32(bb, 16);
    writeVarint64(bb, intToLong($exp));
  }

  // optional int32 arm = 3;
  let $arm = message.arm;
  if ($arm !== undefined) {
    writeVarint32(bb, 24);
    writeVarint64(bb, intToLong($arm));
  }

  // optional int32 spd = 4;
  let $spd = message.spd;
  if ($spd !== undefined) {
    writeVarint32(bb, 32);
    writeVarint64(bb, intToLong($spd));
  }

  // repeated int32 skls = 5;
  let array$skls = message.skls;
  if (array$skls !== undefined) {
    let packed = popByteBuffer();
    for (let value of array$skls) {
      writeVarint64(packed, intToLong(value));
    }
    writeVarint32(bb, 42);
    writeVarint32(bb, packed.offset);
    writeByteBuffer(bb, packed);
    pushByteBuffer(packed);
  }
}

export function decodepb_iboat(binary) {
  return _decodepb_iboat(wrapByteBuffer(binary));
}

function _decodepb_iboat(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // optional string name = 1;
      case 1: {
        message.name = readString(bb, readVarint32(bb));
        break;
      }

      // optional int32 exp = 2;
      case 2: {
        message.exp = readVarint32(bb);
        break;
      }

      // optional int32 arm = 3;
      case 3: {
        message.arm = readVarint32(bb);
        break;
      }

      // optional int32 spd = 4;
      case 4: {
        message.spd = readVarint32(bb);
        break;
      }

      // repeated int32 skls = 5;
      case 5: {
        let values = message.skls || (message.skls = []);
        if ((tag & 7) === 2) {
          let outerLimit = pushTemporaryLength(bb);
          while (!isAtEnd(bb)) {
            values.push(readVarint32(bb));
          }
          bb.limit = outerLimit;
        } else {
          values.push(readVarint32(bb));
        }
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  return message;
}

export function encodepb_ipro(message) {
  let bb = popByteBuffer();
  _encodepb_ipro(message, bb);
  return toUint8Array(bb);
}

function _encodepb_ipro(message, bb) {
  // optional int32 id = 1;
  let $id = message.id;
  if ($id !== undefined) {
    writeVarint32(bb, 8);
    writeVarint64(bb, intToLong($id));
  }

  // optional int32 num = 2;
  let $num = message.num;
  if ($num !== undefined) {
    writeVarint32(bb, 16);
    writeVarint64(bb, intToLong($num));
  }

  // optional int32 cd = 3;
  let $cd = message.cd;
  if ($cd !== undefined) {
    writeVarint32(bb, 24);
    writeVarint64(bb, intToLong($cd));
  }
}

export function decodepb_ipro(binary) {
  return _decodepb_ipro(wrapByteBuffer(binary));
}

function _decodepb_ipro(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // optional int32 id = 1;
      case 1: {
        message.id = readVarint32(bb);
        break;
      }

      // optional int32 num = 2;
      case 2: {
        message.num = readVarint32(bb);
        break;
      }

      // optional int32 cd = 3;
      case 3: {
        message.cd = readVarint32(bb);
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  return message;
}

export function encodepb_identity(message) {
  let bb = popByteBuffer();
  _encodepb_identity(message, bb);
  return toUint8Array(bb);
}

function _encodepb_identity(message, bb) {
  // optional int32 online_time = 1;
  let $online_time = message.online_time;
  if ($online_time !== undefined) {
    writeVarint32(bb, 8);
    writeVarint64(bb, intToLong($online_time));
  }

  // optional int32 adult = 2;
  let $adult = message.adult;
  if ($adult !== undefined) {
    writeVarint32(bb, 16);
    writeVarint64(bb, intToLong($adult));
  }

  // optional string locale = 3;
  let $locale = message.locale;
  if ($locale !== undefined) {
    writeVarint32(bb, 26);
    writeString(bb, $locale);
  }

  // optional int32 age = 4;
  let $age = message.age;
  if ($age !== undefined) {
    writeVarint32(bb, 32);
    writeVarint64(bb, intToLong($age));
  }

  // optional int32 mrecharge = 5;
  let $mrecharge = message.mrecharge;
  if ($mrecharge !== undefined) {
    writeVarint32(bb, 40);
    writeVarint64(bb, intToLong($mrecharge));
  }
}

export function decodepb_identity(binary) {
  return _decodepb_identity(wrapByteBuffer(binary));
}

function _decodepb_identity(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // optional int32 online_time = 1;
      case 1: {
        message.online_time = readVarint32(bb);
        break;
      }

      // optional int32 adult = 2;
      case 2: {
        message.adult = readVarint32(bb);
        break;
      }

      // optional string locale = 3;
      case 3: {
        message.locale = readString(bb, readVarint32(bb));
        break;
      }

      // optional int32 age = 4;
      case 4: {
        message.age = readVarint32(bb);
        break;
      }

      // optional int32 mrecharge = 5;
      case 5: {
        message.mrecharge = readVarint32(bb);
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  return message;
}

export function encodepb_sact(message) {
  let bb = popByteBuffer();
  _encodepb_sact(message, bb);
  return toUint8Array(bb);
}

function _encodepb_sact(message, bb) {
  // repeated pb_sact_item acts = 1;
  let array$acts = message.acts;
  if (array$acts !== undefined) {
    for (let value of array$acts) {
      writeVarint32(bb, 10);
      let nested = popByteBuffer();
      _encodepb_sact_item(value, nested);
      writeVarint32(bb, nested.limit);
      writeByteBuffer(bb, nested);
      pushByteBuffer(nested);
    }
  }
}

export function decodepb_sact(binary) {
  return _decodepb_sact(wrapByteBuffer(binary));
}

function _decodepb_sact(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // repeated pb_sact_item acts = 1;
      case 1: {
        let limit = pushTemporaryLength(bb);
        let values = message.acts || (message.acts = []);
        values.push(_decodepb_sact_item(bb));
        bb.limit = limit;
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  return message;
}

export function encodepb_ract(message) {
  let bb = popByteBuffer();
  _encodepb_ract(message, bb);
  return toUint8Array(bb);
}

function _encodepb_ract(message, bb) {
  // repeated pb_ract_item acts = 1;
  let array$acts = message.acts;
  if (array$acts !== undefined) {
    for (let value of array$acts) {
      writeVarint32(bb, 10);
      let nested = popByteBuffer();
      _encodepb_ract_item(value, nested);
      writeVarint32(bb, nested.limit);
      writeByteBuffer(bb, nested);
      pushByteBuffer(nested);
    }
  }

  // optional int32 show = 2;
  let $show = message.show;
  if ($show !== undefined) {
    writeVarint32(bb, 16);
    writeVarint64(bb, intToLong($show));
  }
}

export function decodepb_ract(binary) {
  return _decodepb_ract(wrapByteBuffer(binary));
}

function _decodepb_ract(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // repeated pb_ract_item acts = 1;
      case 1: {
        let limit = pushTemporaryLength(bb);
        let values = message.acts || (message.acts = []);
        values.push(_decodepb_ract_item(bb));
        bb.limit = limit;
        break;
      }

      // optional int32 show = 2;
      case 2: {
        message.show = readVarint32(bb);
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  return message;
}

export function encodepb_brave_box(message) {
  let bb = popByteBuffer();
  _encodepb_brave_box(message, bb);
  return toUint8Array(bb);
}

function _encodepb_brave_box(message, bb) {
  // required int32 id = 1;
  let $id = message.id;
  if ($id !== undefined) {
    writeVarint32(bb, 8);
    writeVarint64(bb, intToLong($id));
  }
}

export function decodepb_brave_box(binary) {
  return _decodepb_brave_box(wrapByteBuffer(binary));
}

function _decodepb_brave_box(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // required int32 id = 1;
      case 1: {
        message.id = readVarint32(bb);
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  if (message.id === undefined)
    throw new Error("Missing required field: id");

  return message;
}

export function encodepb_brave_buff(message) {
  let bb = popByteBuffer();
  _encodepb_brave_buff(message, bb);
  return toUint8Array(bb);
}

function _encodepb_brave_buff(message, bb) {
  // required int32 id = 1;
  let $id = message.id;
  if ($id !== undefined) {
    writeVarint32(bb, 8);
    writeVarint64(bb, intToLong($id));
  }

  // required int32 num = 2;
  let $num = message.num;
  if ($num !== undefined) {
    writeVarint32(bb, 16);
    writeVarint64(bb, intToLong($num));
  }
}

export function decodepb_brave_buff(binary) {
  return _decodepb_brave_buff(wrapByteBuffer(binary));
}

function _decodepb_brave_buff(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // required int32 id = 1;
      case 1: {
        message.id = readVarint32(bb);
        break;
      }

      // required int32 num = 2;
      case 2: {
        message.num = readVarint32(bb);
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  if (message.id === undefined)
    throw new Error("Missing required field: id");

  if (message.num === undefined)
    throw new Error("Missing required field: num");

  return message;
}

export function encodepb_re_sync(message) {
  let bb = popByteBuffer();
  _encodepb_re_sync(message, bb);
  return toUint8Array(bb);
}

function _encodepb_re_sync(message, bb) {
  // optional int32 role = 1;
  let $role = message.role;
  if ($role !== undefined) {
    writeVarint32(bb, 8);
    writeVarint64(bb, intToLong($role));
  }

  // optional int32 gift_id = 2;
  let $gift_id = message.gift_id;
  if ($gift_id !== undefined) {
    writeVarint32(bb, 16);
    writeVarint64(bb, intToLong($gift_id));
  }

  // optional int32 back_gift = 3;
  let $back_gift = message.back_gift;
  if ($back_gift !== undefined) {
    writeVarint32(bb, 24);
    writeVarint64(bb, intToLong($back_gift));
  }

  // optional int32 bind_times = 4;
  let $bind_times = message.bind_times;
  if ($bind_times !== undefined) {
    writeVarint32(bb, 32);
    writeVarint64(bb, intToLong($bind_times));
  }

  // optional int32 help_times = 5;
  let $help_times = message.help_times;
  if ($help_times !== undefined) {
    writeVarint32(bb, 40);
    writeVarint64(bb, intToLong($help_times));
  }

  // optional int32 back_cd = 6;
  let $back_cd = message.back_cd;
  if ($back_cd !== undefined) {
    writeVarint32(bb, 48);
    writeVarint64(bb, intToLong($back_cd));
  }

  // optional int32 bind = 7;
  let $bind = message.bind;
  if ($bind !== undefined) {
    writeVarint32(bb, 56);
    writeVarint64(bb, intToLong($bind));
  }

  // repeated pb_re_task s_tasks = 8;
  let array$s_tasks = message.s_tasks;
  if (array$s_tasks !== undefined) {
    for (let value of array$s_tasks) {
      writeVarint32(bb, 66);
      let nested = popByteBuffer();
      _encodepb_re_task(value, nested);
      writeVarint32(bb, nested.limit);
      writeByteBuffer(bb, nested);
      pushByteBuffer(nested);
    }
  }

  // repeated pb_re_task h_tasks = 9;
  let array$h_tasks = message.h_tasks;
  if (array$h_tasks !== undefined) {
    for (let value of array$h_tasks) {
      writeVarint32(bb, 74);
      let nested = popByteBuffer();
      _encodepb_re_task(value, nested);
      writeVarint32(bb, nested.limit);
      writeByteBuffer(bb, nested);
      pushByteBuffer(nested);
    }
  }

  // optional int32 cd = 10;
  let $cd = message.cd;
  if ($cd !== undefined) {
    writeVarint32(bb, 80);
    writeVarint64(bb, intToLong($cd));
  }

  // optional int32 cd2 = 11;
  let $cd2 = message.cd2;
  if ($cd2 !== undefined) {
    writeVarint32(bb, 88);
    writeVarint64(bb, intToLong($cd2));
  }

  // repeated pb_re_apply applys = 12;
  let array$applys = message.applys;
  if (array$applys !== undefined) {
    for (let value of array$applys) {
      writeVarint32(bb, 98);
      let nested = popByteBuffer();
      _encodepb_re_apply(value, nested);
      writeVarint32(bb, nested.limit);
      writeByteBuffer(bb, nested);
      pushByteBuffer(nested);
    }
  }

  // optional string code = 13;
  let $code = message.code;
  if ($code !== undefined) {
    writeVarint32(bb, 106);
    writeString(bb, $code);
  }

  // repeated pb_re_bind_player players = 14;
  let array$players = message.players;
  if (array$players !== undefined) {
    for (let value of array$players) {
      writeVarint32(bb, 114);
      let nested = popByteBuffer();
      _encodepb_re_bind_player(value, nested);
      writeVarint32(bb, nested.limit);
      writeByteBuffer(bb, nested);
      pushByteBuffer(nested);
    }
  }
}

export function decodepb_re_sync(binary) {
  return _decodepb_re_sync(wrapByteBuffer(binary));
}

function _decodepb_re_sync(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // optional int32 role = 1;
      case 1: {
        message.role = readVarint32(bb);
        break;
      }

      // optional int32 gift_id = 2;
      case 2: {
        message.gift_id = readVarint32(bb);
        break;
      }

      // optional int32 back_gift = 3;
      case 3: {
        message.back_gift = readVarint32(bb);
        break;
      }

      // optional int32 bind_times = 4;
      case 4: {
        message.bind_times = readVarint32(bb);
        break;
      }

      // optional int32 help_times = 5;
      case 5: {
        message.help_times = readVarint32(bb);
        break;
      }

      // optional int32 back_cd = 6;
      case 6: {
        message.back_cd = readVarint32(bb);
        break;
      }

      // optional int32 bind = 7;
      case 7: {
        message.bind = readVarint32(bb);
        break;
      }

      // repeated pb_re_task s_tasks = 8;
      case 8: {
        let limit = pushTemporaryLength(bb);
        let values = message.s_tasks || (message.s_tasks = []);
        values.push(_decodepb_re_task(bb));
        bb.limit = limit;
        break;
      }

      // repeated pb_re_task h_tasks = 9;
      case 9: {
        let limit = pushTemporaryLength(bb);
        let values = message.h_tasks || (message.h_tasks = []);
        values.push(_decodepb_re_task(bb));
        bb.limit = limit;
        break;
      }

      // optional int32 cd = 10;
      case 10: {
        message.cd = readVarint32(bb);
        break;
      }

      // optional int32 cd2 = 11;
      case 11: {
        message.cd2 = readVarint32(bb);
        break;
      }

      // repeated pb_re_apply applys = 12;
      case 12: {
        let limit = pushTemporaryLength(bb);
        let values = message.applys || (message.applys = []);
        values.push(_decodepb_re_apply(bb));
        bb.limit = limit;
        break;
      }

      // optional string code = 13;
      case 13: {
        message.code = readString(bb, readVarint32(bb));
        break;
      }

      // repeated pb_re_bind_player players = 14;
      case 14: {
        let limit = pushTemporaryLength(bb);
        let values = message.players || (message.players = []);
        values.push(_decodepb_re_bind_player(bb));
        bb.limit = limit;
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  return message;
}

export function encodepb_re_bind_player(message) {
  let bb = popByteBuffer();
  _encodepb_re_bind_player(message, bb);
  return toUint8Array(bb);
}

function _encodepb_re_bind_player(message, bb) {
  // optional int32 logo = 1;
  let $logo = message.logo;
  if ($logo !== undefined) {
    writeVarint32(bb, 8);
    writeVarint64(bb, intToLong($logo));
  }

  // optional int32 uid = 2;
  let $uid = message.uid;
  if ($uid !== undefined) {
    writeVarint32(bb, 16);
    writeVarint64(bb, intToLong($uid));
  }

  // optional string name = 3;
  let $name = message.name;
  if ($name !== undefined) {
    writeVarint32(bb, 26);
    writeString(bb, $name);
  }

  // optional int32 bind = 4;
  let $bind = message.bind;
  if ($bind !== undefined) {
    writeVarint32(bb, 32);
    writeVarint64(bb, intToLong($bind));
  }
}

export function decodepb_re_bind_player(binary) {
  return _decodepb_re_bind_player(wrapByteBuffer(binary));
}

function _decodepb_re_bind_player(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // optional int32 logo = 1;
      case 1: {
        message.logo = readVarint32(bb);
        break;
      }

      // optional int32 uid = 2;
      case 2: {
        message.uid = readVarint32(bb);
        break;
      }

      // optional string name = 3;
      case 3: {
        message.name = readString(bb, readVarint32(bb));
        break;
      }

      // optional int32 bind = 4;
      case 4: {
        message.bind = readVarint32(bb);
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  return message;
}

export function encodepb_re_apply(message) {
  let bb = popByteBuffer();
  _encodepb_re_apply(message, bb);
  return toUint8Array(bb);
}

function _encodepb_re_apply(message, bb) {
  // required int32 logo = 1;
  let $logo = message.logo;
  if ($logo !== undefined) {
    writeVarint32(bb, 8);
    writeVarint64(bb, intToLong($logo));
  }

  // optional int64 uid = 2;
  let $uid = message.uid;
  if ($uid !== undefined) {
    writeVarint32(bb, 16);
    writeVarint64(bb, $uid);
  }

  // optional string name = 3;
  let $name = message.name;
  if ($name !== undefined) {
    writeVarint32(bb, 26);
    writeString(bb, $name);
  }

  // optional int32 cd = 4;
  let $cd = message.cd;
  if ($cd !== undefined) {
    writeVarint32(bb, 32);
    writeVarint64(bb, intToLong($cd));
  }
}

export function decodepb_re_apply(binary) {
  return _decodepb_re_apply(wrapByteBuffer(binary));
}

function _decodepb_re_apply(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // required int32 logo = 1;
      case 1: {
        message.logo = readVarint32(bb);
        break;
      }

      // optional int64 uid = 2;
      case 2: {
        message.uid = readVarint64(bb, /* unsigned */ false);
        break;
      }

      // optional string name = 3;
      case 3: {
        message.name = readString(bb, readVarint32(bb));
        break;
      }

      // optional int32 cd = 4;
      case 4: {
        message.cd = readVarint32(bb);
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  if (message.logo === undefined)
    throw new Error("Missing required field: logo");

  return message;
}

export function encodepb_re_task(message) {
  let bb = popByteBuffer();
  _encodepb_re_task(message, bb);
  return toUint8Array(bb);
}

function _encodepb_re_task(message, bb) {
  // required int32 id = 1;
  let $id = message.id;
  if ($id !== undefined) {
    writeVarint32(bb, 8);
    writeVarint64(bb, intToLong($id));
  }

  // optional int32 num1 = 2;
  let $num1 = message.num1;
  if ($num1 !== undefined) {
    writeVarint32(bb, 16);
    writeVarint64(bb, intToLong($num1));
  }

  // optional int32 num2 = 3;
  let $num2 = message.num2;
  if ($num2 !== undefined) {
    writeVarint32(bb, 24);
    writeVarint64(bb, intToLong($num2));
  }
}

export function decodepb_re_task(binary) {
  return _decodepb_re_task(wrapByteBuffer(binary));
}

function _decodepb_re_task(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // required int32 id = 1;
      case 1: {
        message.id = readVarint32(bb);
        break;
      }

      // optional int32 num1 = 2;
      case 2: {
        message.num1 = readVarint32(bb);
        break;
      }

      // optional int32 num2 = 3;
      case 3: {
        message.num2 = readVarint32(bb);
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  if (message.id === undefined)
    throw new Error("Missing required field: id");

  return message;
}

export function encodepb_vbuff(message) {
  let bb = popByteBuffer();
  _encodepb_vbuff(message, bb);
  return toUint8Array(bb);
}

function _encodepb_vbuff(message, bb) {
  // optional int32 id = 1;
  let $id = message.id;
  if ($id !== undefined) {
    writeVarint32(bb, 8);
    writeVarint64(bb, intToLong($id));
  }

  // optional int32 type = 2;
  let $type = message.type;
  if ($type !== undefined) {
    writeVarint32(bb, 16);
    writeVarint64(bb, intToLong($type));
  }
}

export function decodepb_vbuff(binary) {
  return _decodepb_vbuff(wrapByteBuffer(binary));
}

function _decodepb_vbuff(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // optional int32 id = 1;
      case 1: {
        message.id = readVarint32(bb);
        break;
      }

      // optional int32 type = 2;
      case 2: {
        message.type = readVarint32(bb);
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  return message;
}

export function encodepb_stele(message) {
  let bb = popByteBuffer();
  _encodepb_stele(message, bb);
  return toUint8Array(bb);
}

function _encodepb_stele(message, bb) {
  // optional int32 hook = 1;
  let $hook = message.hook;
  if ($hook !== undefined) {
    writeVarint32(bb, 8);
    writeVarint64(bb, intToLong($hook));
  }

  // optional int32 solo = 2;
  let $solo = message.solo;
  if ($solo !== undefined) {
    writeVarint32(bb, 16);
    writeVarint64(bb, intToLong($solo));
  }

  // optional int32 crush = 3;
  let $crush = message.crush;
  if ($crush !== undefined) {
    writeVarint32(bb, 24);
    writeVarint64(bb, intToLong($crush));
  }

  // optional int32 tower = 4;
  let $tower = message.tower;
  if ($tower !== undefined) {
    writeVarint32(bb, 32);
    writeVarint64(bb, intToLong($tower));
  }

  // repeated int32 sealland = 5;
  let array$sealland = message.sealland;
  if (array$sealland !== undefined) {
    let packed = popByteBuffer();
    for (let value of array$sealland) {
      writeVarint64(packed, intToLong(value));
    }
    writeVarint32(bb, 42);
    writeVarint32(bb, packed.offset);
    writeByteBuffer(bb, packed);
    pushByteBuffer(packed);
  }

  // optional int32 st = 6;
  let $st = message.st;
  if ($st !== undefined) {
    writeVarint32(bb, 48);
    writeVarint64(bb, intToLong($st));
  }
}

export function decodepb_stele(binary) {
  return _decodepb_stele(wrapByteBuffer(binary));
}

function _decodepb_stele(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // optional int32 hook = 1;
      case 1: {
        message.hook = readVarint32(bb);
        break;
      }

      // optional int32 solo = 2;
      case 2: {
        message.solo = readVarint32(bb);
        break;
      }

      // optional int32 crush = 3;
      case 3: {
        message.crush = readVarint32(bb);
        break;
      }

      // optional int32 tower = 4;
      case 4: {
        message.tower = readVarint32(bb);
        break;
      }

      // repeated int32 sealland = 5;
      case 5: {
        let values = message.sealland || (message.sealland = []);
        if ((tag & 7) === 2) {
          let outerLimit = pushTemporaryLength(bb);
          while (!isAtEnd(bb)) {
            values.push(readVarint32(bb));
          }
          bb.limit = outerLimit;
        } else {
          values.push(readVarint32(bb));
        }
        break;
      }

      // optional int32 st = 6;
      case 6: {
        message.st = readVarint32(bb);
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  return message;
}

export function encodepb_midas(message) {
  let bb = popByteBuffer();
  _encodepb_midas(message, bb);
  return toUint8Array(bb);
}

function _encodepb_midas(message, bb) {
  // required int32 type = 1;
  let $type = message.type;
  if ($type !== undefined) {
    writeVarint32(bb, 8);
    writeVarint64(bb, intToLong($type));
  }

  // required int32 cd = 2;
  let $cd = message.cd;
  if ($cd !== undefined) {
    writeVarint32(bb, 16);
    writeVarint64(bb, intToLong($cd));
  }

  // required int32 index = 3;
  let $index = message.index;
  if ($index !== undefined) {
    writeVarint32(bb, 24);
    writeVarint64(bb, intToLong($index));
  }
}

export function decodepb_midas(binary) {
  return _decodepb_midas(wrapByteBuffer(binary));
}

function _decodepb_midas(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // required int32 type = 1;
      case 1: {
        message.type = readVarint32(bb);
        break;
      }

      // required int32 cd = 2;
      case 2: {
        message.cd = readVarint32(bb);
        break;
      }

      // required int32 index = 3;
      case 3: {
        message.index = readVarint32(bb);
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  if (message.type === undefined)
    throw new Error("Missing required field: type");

  if (message.cd === undefined)
    throw new Error("Missing required field: cd");

  if (message.index === undefined)
    throw new Error("Missing required field: index");

  return message;
}

export function encodepb_gve(message) {
  let bb = popByteBuffer();
  _encodepb_gve(message, bb);
  return toUint8Array(bb);
}

function _encodepb_gve(message, bb) {
  // optional int32 id = 1;
  let $id = message.id;
  if ($id !== undefined) {
    writeVarint32(bb, 8);
    writeVarint64(bb, intToLong($id));
  }

  // optional int32 exp = 2;
  let $exp = message.exp;
  if ($exp !== undefined) {
    writeVarint32(bb, 16);
    writeVarint64(bb, intToLong($exp));
  }

  // repeated int32 record = 3;
  let array$record = message.record;
  if (array$record !== undefined) {
    let packed = popByteBuffer();
    for (let value of array$record) {
      writeVarint64(packed, intToLong(value));
    }
    writeVarint32(bb, 26);
    writeVarint32(bb, packed.offset);
    writeByteBuffer(bb, packed);
    pushByteBuffer(packed);
  }

  // optional int32 fight = 4;
  let $fight = message.fight;
  if ($fight !== undefined) {
    writeVarint32(bb, 32);
    writeVarint64(bb, intToLong($fight));
  }
}

export function decodepb_gve(binary) {
  return _decodepb_gve(wrapByteBuffer(binary));
}

function _decodepb_gve(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // optional int32 id = 1;
      case 1: {
        message.id = readVarint32(bb);
        break;
      }

      // optional int32 exp = 2;
      case 2: {
        message.exp = readVarint32(bb);
        break;
      }

      // repeated int32 record = 3;
      case 3: {
        let values = message.record || (message.record = []);
        if ((tag & 7) === 2) {
          let outerLimit = pushTemporaryLength(bb);
          while (!isAtEnd(bb)) {
            values.push(readVarint32(bb));
          }
          bb.limit = outerLimit;
        } else {
          values.push(readVarint32(bb));
        }
        break;
      }

      // optional int32 fight = 4;
      case 4: {
        message.fight = readVarint32(bb);
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  return message;
}

export function encodepb_gve_rank(message) {
  let bb = popByteBuffer();
  _encodepb_gve_rank(message, bb);
  return toUint8Array(bb);
}

function _encodepb_gve_rank(message, bb) {
  // optional int32 id = 1;
  let $id = message.id;
  if ($id !== undefined) {
    writeVarint32(bb, 8);
    writeVarint64(bb, intToLong($id));
  }

  // optional string name = 2;
  let $name = message.name;
  if ($name !== undefined) {
    writeVarint32(bb, 18);
    writeString(bb, $name);
  }

  // optional int32 exp = 3;
  let $exp = message.exp;
  if ($exp !== undefined) {
    writeVarint32(bb, 24);
    writeVarint64(bb, intToLong($exp));
  }

  // optional int32 texp = 4;
  let $texp = message.texp;
  if ($texp !== undefined) {
    writeVarint32(bb, 32);
    writeVarint64(bb, intToLong($texp));
  }
}

export function decodepb_gve_rank(binary) {
  return _decodepb_gve_rank(wrapByteBuffer(binary));
}

function _decodepb_gve_rank(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // optional int32 id = 1;
      case 1: {
        message.id = readVarint32(bb);
        break;
      }

      // optional string name = 2;
      case 2: {
        message.name = readString(bb, readVarint32(bb));
        break;
      }

      // optional int32 exp = 3;
      case 3: {
        message.exp = readVarint32(bb);
        break;
      }

      // optional int32 texp = 4;
      case 4: {
        message.texp = readVarint32(bb);
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  return message;
}

export function encodepb_act_block(message) {
  let bb = popByteBuffer();
  _encodepb_act_block(message, bb);
  return toUint8Array(bb);
}

function _encodepb_act_block(message, bb) {
  // optional int32 pos = 1;
  let $pos = message.pos;
  if ($pos !== undefined) {
    writeVarint32(bb, 8);
    writeVarint64(bb, intToLong($pos));
  }

  // optional sint32 eventid = 2;
  let $eventid = message.eventid;
  if ($eventid !== undefined) {
    writeVarint32(bb, 16);
    writeVarint32ZigZag(bb, $eventid);
  }
}

export function decodepb_act_block(binary) {
  return _decodepb_act_block(wrapByteBuffer(binary));
}

function _decodepb_act_block(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // optional int32 pos = 1;
      case 1: {
        message.pos = readVarint32(bb);
        break;
      }

      // optional sint32 eventid = 2;
      case 2: {
        message.eventid = readVarint32ZigZag(bb);
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  return message;
}

export function encodepb_act_maze(message) {
  let bb = popByteBuffer();
  _encodepb_act_maze(message, bb);
  return toUint8Array(bb);
}

function _encodepb_act_maze(message, bb) {
  // optional int32 floor = 1;
  let $floor = message.floor;
  if ($floor !== undefined) {
    writeVarint32(bb, 8);
    writeVarint64(bb, intToLong($floor));
  }

  // repeated pb_act_block events = 2;
  let array$events = message.events;
  if (array$events !== undefined) {
    for (let value of array$events) {
      writeVarint32(bb, 18);
      let nested = popByteBuffer();
      _encodepb_act_block(value, nested);
      writeVarint32(bb, nested.limit);
      writeByteBuffer(bb, nested);
      pushByteBuffer(nested);
    }
  }

  // optional int32 heroid = 3;
  let $heroid = message.heroid;
  if ($heroid !== undefined) {
    writeVarint32(bb, 24);
    writeVarint64(bb, intToLong($heroid));
  }

  // optional int32 skill = 4;
  let $skill = message.skill;
  if ($skill !== undefined) {
    writeVarint32(bb, 32);
    writeVarint64(bb, intToLong($skill));
  }

  // optional int32 skill_lv = 5;
  let $skill_lv = message.skill_lv;
  if ($skill_lv !== undefined) {
    writeVarint32(bb, 40);
    writeVarint64(bb, intToLong($skill_lv));
  }

  // optional int32 change = 6;
  let $change = message.change;
  if ($change !== undefined) {
    writeVarint32(bb, 48);
    writeVarint64(bb, intToLong($change));
  }

  // optional int32 treasures = 7;
  let $treasures = message.treasures;
  if ($treasures !== undefined) {
    writeVarint32(bb, 56);
    writeVarint64(bb, intToLong($treasures));
  }

  // optional int32 buff = 8;
  let $buff = message.buff;
  if ($buff !== undefined) {
    writeVarint32(bb, 64);
    writeVarint64(bb, intToLong($buff));
  }

  // optional int32 type = 9;
  let $type = message.type;
  if ($type !== undefined) {
    writeVarint32(bb, 72);
    writeVarint64(bb, intToLong($type));
  }

  // optional int32 pos = 10;
  let $pos = message.pos;
  if ($pos !== undefined) {
    writeVarint32(bb, 80);
    writeVarint64(bb, intToLong($pos));
  }

  // optional int32 buy_num = 11;
  let $buy_num = message.buy_num;
  if ($buy_num !== undefined) {
    writeVarint32(bb, 88);
    writeVarint64(bb, intToLong($buy_num));
  }

  // optional bool get_frag = 12;
  let $get_frag = message.get_frag;
  if ($get_frag !== undefined) {
    writeVarint32(bb, 96);
    writeByte(bb, $get_frag ? 1 : 0);
  }
}

export function decodepb_act_maze(binary) {
  return _decodepb_act_maze(wrapByteBuffer(binary));
}

function _decodepb_act_maze(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // optional int32 floor = 1;
      case 1: {
        message.floor = readVarint32(bb);
        break;
      }

      // repeated pb_act_block events = 2;
      case 2: {
        let limit = pushTemporaryLength(bb);
        let values = message.events || (message.events = []);
        values.push(_decodepb_act_block(bb));
        bb.limit = limit;
        break;
      }

      // optional int32 heroid = 3;
      case 3: {
        message.heroid = readVarint32(bb);
        break;
      }

      // optional int32 skill = 4;
      case 4: {
        message.skill = readVarint32(bb);
        break;
      }

      // optional int32 skill_lv = 5;
      case 5: {
        message.skill_lv = readVarint32(bb);
        break;
      }

      // optional int32 change = 6;
      case 6: {
        message.change = readVarint32(bb);
        break;
      }

      // optional int32 treasures = 7;
      case 7: {
        message.treasures = readVarint32(bb);
        break;
      }

      // optional int32 buff = 8;
      case 8: {
        message.buff = readVarint32(bb);
        break;
      }

      // optional int32 type = 9;
      case 9: {
        message.type = readVarint32(bb);
        break;
      }

      // optional int32 pos = 10;
      case 10: {
        message.pos = readVarint32(bb);
        break;
      }

      // optional int32 buy_num = 11;
      case 11: {
        message.buy_num = readVarint32(bb);
        break;
      }

      // optional bool get_frag = 12;
      case 12: {
        message.get_frag = !!readByte(bb);
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  return message;
}

export function encodepb_ntask(message) {
  let bb = popByteBuffer();
  _encodepb_ntask(message, bb);
  return toUint8Array(bb);
}

function _encodepb_ntask(message, bb) {
  // required int32 id = 1;
  let $id = message.id;
  if ($id !== undefined) {
    writeVarint32(bb, 8);
    writeVarint64(bb, intToLong($id));
  }

  // required int64 count = 2;
  let $count = message.count;
  if ($count !== undefined) {
    writeVarint32(bb, 16);
    writeVarint64(bb, $count);
  }

  // required int32 status = 3;
  let $status = message.status;
  if ($status !== undefined) {
    writeVarint32(bb, 24);
    writeVarint64(bb, intToLong($status));
  }

  // repeated pb_nextra extra = 4;
  let array$extra = message.extra;
  if (array$extra !== undefined) {
    for (let value of array$extra) {
      writeVarint32(bb, 34);
      let nested = popByteBuffer();
      _encodepb_nextra(value, nested);
      writeVarint32(bb, nested.limit);
      writeByteBuffer(bb, nested);
      pushByteBuffer(nested);
    }
  }
}

export function decodepb_ntask(binary) {
  return _decodepb_ntask(wrapByteBuffer(binary));
}

function _decodepb_ntask(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // required int32 id = 1;
      case 1: {
        message.id = readVarint32(bb);
        break;
      }

      // required int64 count = 2;
      case 2: {
        message.count = readVarint64(bb, /* unsigned */ false);
        break;
      }

      // required int32 status = 3;
      case 3: {
        message.status = readVarint32(bb);
        break;
      }

      // repeated pb_nextra extra = 4;
      case 4: {
        let limit = pushTemporaryLength(bb);
        let values = message.extra || (message.extra = []);
        values.push(_decodepb_nextra(bb));
        bb.limit = limit;
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  if (message.id === undefined)
    throw new Error("Missing required field: id");

  if (message.count === undefined)
    throw new Error("Missing required field: count");

  if (message.status === undefined)
    throw new Error("Missing required field: status");

  return message;
}

export function encodepb_nextra(message) {
  let bb = popByteBuffer();
  _encodepb_nextra(message, bb);
  return toUint8Array(bb);
}

function _encodepb_nextra(message, bb) {
  // repeated int32 id = 1;
  let array$id = message.id;
  if (array$id !== undefined) {
    let packed = popByteBuffer();
    for (let value of array$id) {
      writeVarint64(packed, intToLong(value));
    }
    writeVarint32(bb, 10);
    writeVarint32(bb, packed.offset);
    writeByteBuffer(bb, packed);
    pushByteBuffer(packed);
  }
}

export function decodepb_nextra(binary) {
  return _decodepb_nextra(wrapByteBuffer(binary));
}

function _decodepb_nextra(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // repeated int32 id = 1;
      case 1: {
        let values = message.id || (message.id = []);
        if ((tag & 7) === 2) {
          let outerLimit = pushTemporaryLength(bb);
          while (!isAtEnd(bb)) {
            values.push(readVarint32(bb));
          }
          bb.limit = outerLimit;
        } else {
          values.push(readVarint32(bb));
        }
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  return message;
}

export function encodepb_nt_sync(message) {
  let bb = popByteBuffer();
  _encodepb_nt_sync(message, bb);
  return toUint8Array(bb);
}

function _encodepb_nt_sync(message, bb) {
  // required sint32 type = 1;
  let $type = message.type;
  if ($type !== undefined) {
    writeVarint32(bb, 8);
    writeVarint32ZigZag(bb, $type);
  }

  // repeated int64 value = 2;
  let array$value = message.value;
  if (array$value !== undefined) {
    let packed = popByteBuffer();
    for (let value of array$value) {
      writeVarint64(packed, value);
    }
    writeVarint32(bb, 18);
    writeVarint32(bb, packed.offset);
    writeByteBuffer(bb, packed);
    pushByteBuffer(packed);
  }
}

export function decodepb_nt_sync(binary) {
  return _decodepb_nt_sync(wrapByteBuffer(binary));
}

function _decodepb_nt_sync(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // required sint32 type = 1;
      case 1: {
        message.type = readVarint32ZigZag(bb);
        break;
      }

      // repeated int64 value = 2;
      case 2: {
        let values = message.value || (message.value = []);
        if ((tag & 7) === 2) {
          let outerLimit = pushTemporaryLength(bb);
          while (!isAtEnd(bb)) {
            values.push(readVarint64(bb, /* unsigned */ false));
          }
          bb.limit = outerLimit;
        } else {
          values.push(readVarint64(bb, /* unsigned */ false));
        }
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  if (message.type === undefined)
    throw new Error("Missing required field: type");

  return message;
}

export function encodepb_room(message) {
  let bb = popByteBuffer();
  _encodepb_room(message, bb);
  return toUint8Array(bb);
}

function _encodepb_room(message, bb) {
  // optional int32 id = 1;
  let $id = message.id;
  if ($id !== undefined) {
    writeVarint32(bb, 8);
    writeVarint64(bb, intToLong($id));
  }

  // optional int32 pos = 2;
  let $pos = message.pos;
  if ($pos !== undefined) {
    writeVarint32(bb, 16);
    writeVarint64(bb, intToLong($pos));
  }

  // optional int32 skinid = 3;
  let $skinid = message.skinid;
  if ($skinid !== undefined) {
    writeVarint32(bb, 24);
    writeVarint64(bb, intToLong($skinid));
  }

  // optional int32 hid = 4;
  let $hid = message.hid;
  if ($hid !== undefined) {
    writeVarint32(bb, 32);
    writeVarint64(bb, intToLong($hid));
  }
}

export function decodepb_room(binary) {
  return _decodepb_room(wrapByteBuffer(binary));
}

function _decodepb_room(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // optional int32 id = 1;
      case 1: {
        message.id = readVarint32(bb);
        break;
      }

      // optional int32 pos = 2;
      case 2: {
        message.pos = readVarint32(bb);
        break;
      }

      // optional int32 skinid = 3;
      case 3: {
        message.skinid = readVarint32(bb);
        break;
      }

      // optional int32 hid = 4;
      case 4: {
        message.hid = readVarint32(bb);
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  return message;
}

export function encodepb_home_land(message) {
  let bb = popByteBuffer();
  _encodepb_home_land(message, bb);
  return toUint8Array(bb);
}

function _encodepb_home_land(message, bb) {
  // optional int32 land_id = 1;
  let $land_id = message.land_id;
  if ($land_id !== undefined) {
    writeVarint32(bb, 8);
    writeVarint64(bb, intToLong($land_id));
  }

  // optional string name = 2;
  let $name = message.name;
  if ($name !== undefined) {
    writeVarint32(bb, 18);
    writeString(bb, $name);
  }

  // repeated pb_room rooms = 3;
  let array$rooms = message.rooms;
  if (array$rooms !== undefined) {
    for (let value of array$rooms) {
      writeVarint32(bb, 26);
      let nested = popByteBuffer();
      _encodepb_room(value, nested);
      writeVarint32(bb, nested.limit);
      writeByteBuffer(bb, nested);
      pushByteBuffer(nested);
    }
  }

  // optional int32 owner = 4;
  let $owner = message.owner;
  if ($owner !== undefined) {
    writeVarint32(bb, 32);
    writeVarint64(bb, intToLong($owner));
  }
}

export function decodepb_home_land(binary) {
  return _decodepb_home_land(wrapByteBuffer(binary));
}

function _decodepb_home_land(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // optional int32 land_id = 1;
      case 1: {
        message.land_id = readVarint32(bb);
        break;
      }

      // optional string name = 2;
      case 2: {
        message.name = readString(bb, readVarint32(bb));
        break;
      }

      // repeated pb_room rooms = 3;
      case 3: {
        let limit = pushTemporaryLength(bb);
        let values = message.rooms || (message.rooms = []);
        values.push(_decodepb_room(bb));
        bb.limit = limit;
        break;
      }

      // optional int32 owner = 4;
      case 4: {
        message.owner = readVarint32(bb);
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  return message;
}

export function encodepb_block(message) {
  let bb = popByteBuffer();
  _encodepb_block(message, bb);
  return toUint8Array(bb);
}

function _encodepb_block(message, bb) {
  // optional int32 type = 1;
  let $type = message.type;
  if ($type !== undefined) {
    writeVarint32(bb, 8);
    writeVarint64(bb, intToLong($type));
  }

  // optional int32 from = 2;
  let $from = message.from;
  if ($from !== undefined) {
    writeVarint32(bb, 16);
    writeVarint64(bb, intToLong($from));
  }

  // optional int32 to = 3;
  let $to = message.to;
  if ($to !== undefined) {
    writeVarint32(bb, 24);
    writeVarint64(bb, intToLong($to));
  }
}

export function decodepb_block(binary) {
  return _decodepb_block(wrapByteBuffer(binary));
}

function _decodepb_block(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // optional int32 type = 1;
      case 1: {
        message.type = readVarint32(bb);
        break;
      }

      // optional int32 from = 2;
      case 2: {
        message.from = readVarint32(bb);
        break;
      }

      // optional int32 to = 3;
      case 3: {
        message.to = readVarint32(bb);
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  return message;
}

export function encodepb_living(message) {
  let bb = popByteBuffer();
  _encodepb_living(message, bb);
  return toUint8Array(bb);
}

function _encodepb_living(message, bb) {
  // optional int32 type = 1;
  let $type = message.type;
  if ($type !== undefined) {
    writeVarint32(bb, 8);
    writeVarint64(bb, intToLong($type));
  }

  // optional int32 hid = 2;
  let $hid = message.hid;
  if ($hid !== undefined) {
    writeVarint32(bb, 16);
    writeVarint64(bb, intToLong($hid));
  }
}

export function decodepb_living(binary) {
  return _decodepb_living(wrapByteBuffer(binary));
}

function _decodepb_living(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // optional int32 type = 1;
      case 1: {
        message.type = readVarint32(bb);
        break;
      }

      // optional int32 hid = 2;
      case 2: {
        message.hid = readVarint32(bb);
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  return message;
}

export function encodepb_buildings(message) {
  let bb = popByteBuffer();
  _encodepb_buildings(message, bb);
  return toUint8Array(bb);
}

function _encodepb_buildings(message, bb) {
  // required int32 id = 1;
  let $id = message.id;
  if ($id !== undefined) {
    writeVarint32(bb, 8);
    writeVarint64(bb, intToLong($id));
  }

  // required int32 pos = 2;
  let $pos = message.pos;
  if ($pos !== undefined) {
    writeVarint32(bb, 16);
    writeVarint64(bb, intToLong($pos));
  }

  // required int32 skinid = 3;
  let $skinid = message.skinid;
  if ($skinid !== undefined) {
    writeVarint32(bb, 24);
    writeVarint64(bb, intToLong($skinid));
  }

  // optional int32 collect_time = 4;
  let $collect_time = message.collect_time;
  if ($collect_time !== undefined) {
    writeVarint32(bb, 32);
    writeVarint64(bb, intToLong($collect_time));
  }

  // optional int32 store = 5;
  let $store = message.store;
  if ($store !== undefined) {
    writeVarint32(bb, 40);
    writeVarint64(bb, intToLong($store));
  }
}

export function decodepb_buildings(binary) {
  return _decodepb_buildings(wrapByteBuffer(binary));
}

function _decodepb_buildings(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // required int32 id = 1;
      case 1: {
        message.id = readVarint32(bb);
        break;
      }

      // required int32 pos = 2;
      case 2: {
        message.pos = readVarint32(bb);
        break;
      }

      // required int32 skinid = 3;
      case 3: {
        message.skinid = readVarint32(bb);
        break;
      }

      // optional int32 collect_time = 4;
      case 4: {
        message.collect_time = readVarint32(bb);
        break;
      }

      // optional int32 store = 5;
      case 5: {
        message.store = readVarint32(bb);
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  if (message.id === undefined)
    throw new Error("Missing required field: id");

  if (message.pos === undefined)
    throw new Error("Missing required field: pos");

  if (message.skinid === undefined)
    throw new Error("Missing required field: skinid");

  return message;
}

export function encodepb_home_roomer(message) {
  let bb = popByteBuffer();
  _encodepb_home_roomer(message, bb);
  return toUint8Array(bb);
}

function _encodepb_home_roomer(message, bb) {
  // optional int32 room_id = 1;
  let $room_id = message.room_id;
  if ($room_id !== undefined) {
    writeVarint32(bb, 8);
    writeVarint64(bb, intToLong($room_id));
  }

  // optional int32 hid = 2;
  let $hid = message.hid;
  if ($hid !== undefined) {
    writeVarint32(bb, 16);
    writeVarint64(bb, intToLong($hid));
  }

  // optional int32 skinid = 3;
  let $skinid = message.skinid;
  if ($skinid !== undefined) {
    writeVarint32(bb, 24);
    writeVarint64(bb, intToLong($skinid));
  }
}

export function decodepb_home_roomer(binary) {
  return _decodepb_home_roomer(wrapByteBuffer(binary));
}

function _decodepb_home_roomer(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // optional int32 room_id = 1;
      case 1: {
        message.room_id = readVarint32(bb);
        break;
      }

      // optional int32 hid = 2;
      case 2: {
        message.hid = readVarint32(bb);
        break;
      }

      // optional int32 skinid = 3;
      case 3: {
        message.skinid = readVarint32(bb);
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  return message;
}

export function encodepb_home_heroes(message) {
  let bb = popByteBuffer();
  _encodepb_home_heroes(message, bb);
  return toUint8Array(bb);
}

function _encodepb_home_heroes(message, bb) {
  // optional int32 hid = 1;
  let $hid = message.hid;
  if ($hid !== undefined) {
    writeVarint32(bb, 8);
    writeVarint64(bb, intToLong($hid));
  }

  // optional int32 land_id = 2;
  let $land_id = message.land_id;
  if ($land_id !== undefined) {
    writeVarint32(bb, 16);
    writeVarint64(bb, intToLong($land_id));
  }

  // repeated pb_home_roomer roomers = 3;
  let array$roomers = message.roomers;
  if (array$roomers !== undefined) {
    for (let value of array$roomers) {
      writeVarint32(bb, 26);
      let nested = popByteBuffer();
      _encodepb_home_roomer(value, nested);
      writeVarint32(bb, nested.limit);
      writeByteBuffer(bb, nested);
      pushByteBuffer(nested);
    }
  }
}

export function decodepb_home_heroes(binary) {
  return _decodepb_home_heroes(wrapByteBuffer(binary));
}

function _decodepb_home_heroes(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // optional int32 hid = 1;
      case 1: {
        message.hid = readVarint32(bb);
        break;
      }

      // optional int32 land_id = 2;
      case 2: {
        message.land_id = readVarint32(bb);
        break;
      }

      // repeated pb_home_roomer roomers = 3;
      case 3: {
        let limit = pushTemporaryLength(bb);
        let values = message.roomers || (message.roomers = []);
        values.push(_decodepb_home_roomer(bb));
        bb.limit = limit;
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  return message;
}

export function encodepb_coll(message) {
  let bb = popByteBuffer();
  _encodepb_coll(message, bb);
  return toUint8Array(bb);
}

function _encodepb_coll(message, bb) {
  // optional int32 type = 1;
  let $type = message.type;
  if ($type !== undefined) {
    writeVarint32(bb, 8);
    writeVarint64(bb, intToLong($type));
  }

  // optional int32 score = 2;
  let $score = message.score;
  if ($score !== undefined) {
    writeVarint32(bb, 16);
    writeVarint64(bb, intToLong($score));
  }

  // optional int32 lv = 3;
  let $lv = message.lv;
  if ($lv !== undefined) {
    writeVarint32(bb, 24);
    writeVarint64(bb, intToLong($lv));
  }
}

export function decodepb_coll(binary) {
  return _decodepb_coll(wrapByteBuffer(binary));
}

function _decodepb_coll(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // optional int32 type = 1;
      case 1: {
        message.type = readVarint32(bb);
        break;
      }

      // optional int32 score = 2;
      case 2: {
        message.score = readVarint32(bb);
        break;
      }

      // optional int32 lv = 3;
      case 3: {
        message.lv = readVarint32(bb);
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  return message;
}

export function encodepb_stove(message) {
  let bb = popByteBuffer();
  _encodepb_stove(message, bb);
  return toUint8Array(bb);
}

function _encodepb_stove(message, bb) {
  // optional int32 id = 1;
  let $id = message.id;
  if ($id !== undefined) {
    writeVarint32(bb, 8);
    writeVarint64(bb, intToLong($id));
  }

  // optional int32 num = 2;
  let $num = message.num;
  if ($num !== undefined) {
    writeVarint32(bb, 16);
    writeVarint64(bb, intToLong($num));
  }

  // optional int32 cd = 3;
  let $cd = message.cd;
  if ($cd !== undefined) {
    writeVarint32(bb, 24);
    writeVarint64(bb, intToLong($cd));
  }

  // optional int32 qid = 4;
  let $qid = message.qid;
  if ($qid !== undefined) {
    writeVarint32(bb, 32);
    writeVarint64(bb, intToLong($qid));
  }
}

export function decodepb_stove(binary) {
  return _decodepb_stove(wrapByteBuffer(binary));
}

function _decodepb_stove(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // optional int32 id = 1;
      case 1: {
        message.id = readVarint32(bb);
        break;
      }

      // optional int32 num = 2;
      case 2: {
        message.num = readVarint32(bb);
        break;
      }

      // optional int32 cd = 3;
      case 3: {
        message.cd = readVarint32(bb);
        break;
      }

      // optional int32 qid = 4;
      case 4: {
        message.qid = readVarint32(bb);
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  return message;
}

export function encodepb_stove_buy(message) {
  let bb = popByteBuffer();
  _encodepb_stove_buy(message, bb);
  return toUint8Array(bb);
}

function _encodepb_stove_buy(message, bb) {
  // required int32 id = 1;
  let $id = message.id;
  if ($id !== undefined) {
    writeVarint32(bb, 8);
    writeVarint64(bb, intToLong($id));
  }

  // required int32 num = 2;
  let $num = message.num;
  if ($num !== undefined) {
    writeVarint32(bb, 16);
    writeVarint64(bb, intToLong($num));
  }
}

export function decodepb_stove_buy(binary) {
  return _decodepb_stove_buy(wrapByteBuffer(binary));
}

function _decodepb_stove_buy(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // required int32 id = 1;
      case 1: {
        message.id = readVarint32(bb);
        break;
      }

      // required int32 num = 2;
      case 2: {
        message.num = readVarint32(bb);
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  if (message.id === undefined)
    throw new Error("Missing required field: id");

  if (message.num === undefined)
    throw new Error("Missing required field: num");

  return message;
}

export function encodepb_gvm_stone(message) {
  let bb = popByteBuffer();
  _encodepb_gvm_stone(message, bb);
  return toUint8Array(bb);
}

function _encodepb_gvm_stone(message, bb) {
  // optional int32 bid = 1;
  let $bid = message.bid;
  if ($bid !== undefined) {
    writeVarint32(bb, 8);
    writeVarint64(bb, intToLong($bid));
  }

  // required int32 id = 2;
  let $id = message.id;
  if ($id !== undefined) {
    writeVarint32(bb, 16);
    writeVarint64(bb, intToLong($id));
  }

  // repeated int32 num = 3;
  let array$num = message.num;
  if (array$num !== undefined) {
    let packed = popByteBuffer();
    for (let value of array$num) {
      writeVarint64(packed, intToLong(value));
    }
    writeVarint32(bb, 26);
    writeVarint32(bb, packed.offset);
    writeByteBuffer(bb, packed);
    pushByteBuffer(packed);
  }

  // optional int32 pos = 4;
  let $pos = message.pos;
  if ($pos !== undefined) {
    writeVarint32(bb, 32);
    writeVarint64(bb, intToLong($pos));
  }
}

export function decodepb_gvm_stone(binary) {
  return _decodepb_gvm_stone(wrapByteBuffer(binary));
}

function _decodepb_gvm_stone(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // optional int32 bid = 1;
      case 1: {
        message.bid = readVarint32(bb);
        break;
      }

      // required int32 id = 2;
      case 2: {
        message.id = readVarint32(bb);
        break;
      }

      // repeated int32 num = 3;
      case 3: {
        let values = message.num || (message.num = []);
        if ((tag & 7) === 2) {
          let outerLimit = pushTemporaryLength(bb);
          while (!isAtEnd(bb)) {
            values.push(readVarint32(bb));
          }
          bb.limit = outerLimit;
        } else {
          values.push(readVarint32(bb));
        }
        break;
      }

      // optional int32 pos = 4;
      case 4: {
        message.pos = readVarint32(bb);
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  if (message.id === undefined)
    throw new Error("Missing required field: id");

  return message;
}

export function encodepb_gvm_map(message) {
  let bb = popByteBuffer();
  _encodepb_gvm_map(message, bb);
  return toUint8Array(bb);
}

function _encodepb_gvm_map(message, bb) {
  // required int32 id = 1;
  let $id = message.id;
  if ($id !== undefined) {
    writeVarint32(bb, 8);
    writeVarint64(bb, intToLong($id));
  }

  // optional int32 buff_num = 3;
  let $buff_num = message.buff_num;
  if ($buff_num !== undefined) {
    writeVarint32(bb, 24);
    writeVarint64(bb, intToLong($buff_num));
  }
}

export function decodepb_gvm_map(binary) {
  return _decodepb_gvm_map(wrapByteBuffer(binary));
}

function _decodepb_gvm_map(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // required int32 id = 1;
      case 1: {
        message.id = readVarint32(bb);
        break;
      }

      // optional int32 buff_num = 3;
      case 3: {
        message.buff_num = readVarint32(bb);
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  if (message.id === undefined)
    throw new Error("Missing required field: id");

  return message;
}

export function encodepb_gvm_map_node(message) {
  let bb = popByteBuffer();
  _encodepb_gvm_map_node(message, bb);
  return toUint8Array(bb);
}

function _encodepb_gvm_map_node(message, bb) {
  // required int32 id = 1;
  let $id = message.id;
  if ($id !== undefined) {
    writeVarint32(bb, 8);
    writeVarint64(bb, intToLong($id));
  }

  // required int32 state = 2;
  let $state = message.state;
  if ($state !== undefined) {
    writeVarint32(bb, 16);
    writeVarint64(bb, intToLong($state));
  }

  // optional int32 cfg_id = 3;
  let $cfg_id = message.cfg_id;
  if ($cfg_id !== undefined) {
    writeVarint32(bb, 24);
    writeVarint64(bb, intToLong($cfg_id));
  }

  // repeated int32 hps = 4;
  let array$hps = message.hps;
  if (array$hps !== undefined) {
    let packed = popByteBuffer();
    for (let value of array$hps) {
      writeVarint64(packed, intToLong(value));
    }
    writeVarint32(bb, 34);
    writeVarint32(bb, packed.offset);
    writeByteBuffer(bb, packed);
    pushByteBuffer(packed);
  }
}

export function decodepb_gvm_map_node(binary) {
  return _decodepb_gvm_map_node(wrapByteBuffer(binary));
}

function _decodepb_gvm_map_node(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // required int32 id = 1;
      case 1: {
        message.id = readVarint32(bb);
        break;
      }

      // required int32 state = 2;
      case 2: {
        message.state = readVarint32(bb);
        break;
      }

      // optional int32 cfg_id = 3;
      case 3: {
        message.cfg_id = readVarint32(bb);
        break;
      }

      // repeated int32 hps = 4;
      case 4: {
        let values = message.hps || (message.hps = []);
        if ((tag & 7) === 2) {
          let outerLimit = pushTemporaryLength(bb);
          while (!isAtEnd(bb)) {
            values.push(readVarint32(bb));
          }
          bb.limit = outerLimit;
        } else {
          values.push(readVarint32(bb));
        }
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  if (message.id === undefined)
    throw new Error("Missing required field: id");

  if (message.state === undefined)
    throw new Error("Missing required field: state");

  return message;
}

export function encodepb_gvm_rank(message) {
  let bb = popByteBuffer();
  _encodepb_gvm_rank(message, bb);
  return toUint8Array(bb);
}

function _encodepb_gvm_rank(message, bb) {
  // optional int32 gid = 1;
  let $gid = message.gid;
  if ($gid !== undefined) {
    writeVarint32(bb, 8);
    writeVarint64(bb, intToLong($gid));
  }

  // optional int64 score = 2;
  let $score = message.score;
  if ($score !== undefined) {
    writeVarint32(bb, 16);
    writeVarint64(bb, $score);
  }

  // optional int32 time = 4;
  let $time = message.time;
  if ($time !== undefined) {
    writeVarint32(bb, 32);
    writeVarint64(bb, intToLong($time));
  }

  // optional int32 logo = 5;
  let $logo = message.logo;
  if ($logo !== undefined) {
    writeVarint32(bb, 40);
    writeVarint64(bb, intToLong($logo));
  }

  // optional string name = 6;
  let $name = message.name;
  if ($name !== undefined) {
    writeVarint32(bb, 50);
    writeString(bb, $name);
  }

  // optional int32 member = 8;
  let $member = message.member;
  if ($member !== undefined) {
    writeVarint32(bb, 64);
    writeVarint64(bb, intToLong($member));
  }

  // optional int64 exp = 9;
  let $exp = message.exp;
  if ($exp !== undefined) {
    writeVarint32(bb, 72);
    writeVarint64(bb, $exp);
  }
}

export function decodepb_gvm_rank(binary) {
  return _decodepb_gvm_rank(wrapByteBuffer(binary));
}

function _decodepb_gvm_rank(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // optional int32 gid = 1;
      case 1: {
        message.gid = readVarint32(bb);
        break;
      }

      // optional int64 score = 2;
      case 2: {
        message.score = readVarint64(bb, /* unsigned */ false);
        break;
      }

      // optional int32 time = 4;
      case 4: {
        message.time = readVarint32(bb);
        break;
      }

      // optional int32 logo = 5;
      case 5: {
        message.logo = readVarint32(bb);
        break;
      }

      // optional string name = 6;
      case 6: {
        message.name = readString(bb, readVarint32(bb));
        break;
      }

      // optional int32 member = 8;
      case 8: {
        message.member = readVarint32(bb);
        break;
      }

      // optional int64 exp = 9;
      case 9: {
        message.exp = readVarint64(bb, /* unsigned */ false);
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  return message;
}

export function encodepb_match(message) {
  let bb = popByteBuffer();
  _encodepb_match(message, bb);
  return toUint8Array(bb);
}

function _encodepb_match(message, bb) {
  // required sint32 idx = 1;
  let $idx = message.idx;
  if ($idx !== undefined) {
    writeVarint32(bb, 8);
    writeVarint32ZigZag(bb, $idx);
  }

  // optional string name = 2;
  let $name = message.name;
  if ($name !== undefined) {
    writeVarint32(bb, 18);
    writeString(bb, $name);
  }

  // optional int64 uid = 3;
  let $uid = message.uid;
  if ($uid !== undefined) {
    writeVarint32(bb, 24);
    writeVarint64(bb, $uid);
  }

  // optional int32 lv = 6;
  let $lv = message.lv;
  if ($lv !== undefined) {
    writeVarint32(bb, 48);
    writeVarint64(bb, intToLong($lv));
  }

  // optional int32 logo = 4;
  let $logo = message.logo;
  if ($logo !== undefined) {
    writeVarint32(bb, 32);
    writeVarint64(bb, intToLong($logo));
  }

  // optional int32 lbox = 5;
  let $lbox = message.lbox;
  if ($lbox !== undefined) {
    writeVarint32(bb, 40);
    writeVarint64(bb, intToLong($lbox));
  }

  // optional int32 win = 7;
  let $win = message.win;
  if ($win !== undefined) {
    writeVarint32(bb, 56);
    writeVarint64(bb, intToLong($win));
  }

  // repeated pb_match_hero heroes = 8;
  let array$heroes = message.heroes;
  if (array$heroes !== undefined) {
    for (let value of array$heroes) {
      writeVarint32(bb, 66);
      let nested = popByteBuffer();
      _encodepb_match_hero(value, nested);
      writeVarint32(bb, nested.limit);
      writeByteBuffer(bb, nested);
      pushByteBuffer(nested);
    }
  }

  // optional int64 power = 9;
  let $power = message.power;
  if ($power !== undefined) {
    writeVarint32(bb, 72);
    writeVarint64(bb, $power);
  }
}

export function decodepb_match(binary) {
  return _decodepb_match(wrapByteBuffer(binary));
}

function _decodepb_match(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // required sint32 idx = 1;
      case 1: {
        message.idx = readVarint32ZigZag(bb);
        break;
      }

      // optional string name = 2;
      case 2: {
        message.name = readString(bb, readVarint32(bb));
        break;
      }

      // optional int64 uid = 3;
      case 3: {
        message.uid = readVarint64(bb, /* unsigned */ false);
        break;
      }

      // optional int32 lv = 6;
      case 6: {
        message.lv = readVarint32(bb);
        break;
      }

      // optional int32 logo = 4;
      case 4: {
        message.logo = readVarint32(bb);
        break;
      }

      // optional int32 lbox = 5;
      case 5: {
        message.lbox = readVarint32(bb);
        break;
      }

      // optional int32 win = 7;
      case 7: {
        message.win = readVarint32(bb);
        break;
      }

      // repeated pb_match_hero heroes = 8;
      case 8: {
        let limit = pushTemporaryLength(bb);
        let values = message.heroes || (message.heroes = []);
        values.push(_decodepb_match_hero(bb));
        bb.limit = limit;
        break;
      }

      // optional int64 power = 9;
      case 9: {
        message.power = readVarint64(bb, /* unsigned */ false);
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  if (message.idx === undefined)
    throw new Error("Missing required field: idx");

  return message;
}

export function encodepb_match_hero(message) {
  let bb = popByteBuffer();
  _encodepb_match_hero(message, bb);
  return toUint8Array(bb);
}

function _encodepb_match_hero(message, bb) {
  // required int32 pos = 1;
  let $pos = message.pos;
  if ($pos !== undefined) {
    writeVarint32(bb, 8);
    writeVarint64(bb, intToLong($pos));
  }

  // required int32 id = 2;
  let $id = message.id;
  if ($id !== undefined) {
    writeVarint32(bb, 16);
    writeVarint64(bb, intToLong($id));
  }

  // optional int32 lv = 3;
  let $lv = message.lv;
  if ($lv !== undefined) {
    writeVarint32(bb, 24);
    writeVarint64(bb, intToLong($lv));
  }

  // optional int32 stl = 4;
  let $stl = message.stl;
  if ($stl !== undefined) {
    writeVarint32(bb, 32);
    writeVarint64(bb, intToLong($stl));
  }

  // optional int32 flag = 5;
  let $flag = message.flag;
  if ($flag !== undefined) {
    writeVarint32(bb, 40);
    writeVarint64(bb, intToLong($flag));
  }

  // repeated pb_equip equips = 6;
  let array$equips = message.equips;
  if (array$equips !== undefined) {
    for (let value of array$equips) {
      writeVarint32(bb, 50);
      let nested = popByteBuffer();
      _encodepb_equip(value, nested);
      writeVarint32(bb, nested.limit);
      writeByteBuffer(bb, nested);
      pushByteBuffer(nested);
    }
  }

  // optional int32 wake = 7;
  let $wake = message.wake;
  if ($wake !== undefined) {
    writeVarint32(bb, 56);
    writeVarint64(bb, intToLong($wake));
  }

  // repeated int32 skill_id = 8;
  let array$skill_id = message.skill_id;
  if (array$skill_id !== undefined) {
    let packed = popByteBuffer();
    for (let value of array$skill_id) {
      writeVarint64(packed, intToLong(value));
    }
    writeVarint32(bb, 66);
    writeVarint32(bb, packed.offset);
    writeByteBuffer(bb, packed);
    pushByteBuffer(packed);
  }

  // optional pb_attr attr = 9;
  let $attr = message.attr;
  if ($attr !== undefined) {
    writeVarint32(bb, 74);
    let nested = popByteBuffer();
    _encodepb_attr($attr, nested);
    writeVarint32(bb, nested.limit);
    writeByteBuffer(bb, nested);
    pushByteBuffer(nested);
  }

  // optional int32 skin = 10;
  let $skin = message.skin;
  if ($skin !== undefined) {
    writeVarint32(bb, 80);
    writeVarint64(bb, intToLong($skin));
  }

  // optional int32 qlv = 11;
  let $qlv = message.qlv;
  if ($qlv !== undefined) {
    writeVarint32(bb, 88);
    writeVarint64(bb, intToLong($qlv));
  }

  // optional int32 tree_flag = 12;
  let $tree_flag = message.tree_flag;
  if ($tree_flag !== undefined) {
    writeVarint32(bb, 96);
    writeVarint64(bb, intToLong($tree_flag));
  }

  // optional int32 core = 13;
  let $core = message.core;
  if ($core !== undefined) {
    writeVarint32(bb, 104);
    writeVarint64(bb, intToLong($core));
  }

  // optional int32 times = 14;
  let $times = message.times;
  if ($times !== undefined) {
    writeVarint32(bb, 112);
    writeVarint64(bb, intToLong($times));
  }

  // optional int32 use = 15;
  let $use = message.use;
  if ($use !== undefined) {
    writeVarint32(bb, 120);
    writeVarint64(bb, intToLong($use));
  }
}

export function decodepb_match_hero(binary) {
  return _decodepb_match_hero(wrapByteBuffer(binary));
}

function _decodepb_match_hero(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // required int32 pos = 1;
      case 1: {
        message.pos = readVarint32(bb);
        break;
      }

      // required int32 id = 2;
      case 2: {
        message.id = readVarint32(bb);
        break;
      }

      // optional int32 lv = 3;
      case 3: {
        message.lv = readVarint32(bb);
        break;
      }

      // optional int32 stl = 4;
      case 4: {
        message.stl = readVarint32(bb);
        break;
      }

      // optional int32 flag = 5;
      case 5: {
        message.flag = readVarint32(bb);
        break;
      }

      // repeated pb_equip equips = 6;
      case 6: {
        let limit = pushTemporaryLength(bb);
        let values = message.equips || (message.equips = []);
        values.push(_decodepb_equip(bb));
        bb.limit = limit;
        break;
      }

      // optional int32 wake = 7;
      case 7: {
        message.wake = readVarint32(bb);
        break;
      }

      // repeated int32 skill_id = 8;
      case 8: {
        let values = message.skill_id || (message.skill_id = []);
        if ((tag & 7) === 2) {
          let outerLimit = pushTemporaryLength(bb);
          while (!isAtEnd(bb)) {
            values.push(readVarint32(bb));
          }
          bb.limit = outerLimit;
        } else {
          values.push(readVarint32(bb));
        }
        break;
      }

      // optional pb_attr attr = 9;
      case 9: {
        let limit = pushTemporaryLength(bb);
        message.attr = _decodepb_attr(bb);
        bb.limit = limit;
        break;
      }

      // optional int32 skin = 10;
      case 10: {
        message.skin = readVarint32(bb);
        break;
      }

      // optional int32 qlv = 11;
      case 11: {
        message.qlv = readVarint32(bb);
        break;
      }

      // optional int32 tree_flag = 12;
      case 12: {
        message.tree_flag = readVarint32(bb);
        break;
      }

      // optional int32 core = 13;
      case 13: {
        message.core = readVarint32(bb);
        break;
      }

      // optional int32 times = 14;
      case 14: {
        message.times = readVarint32(bb);
        break;
      }

      // optional int32 use = 15;
      case 15: {
        message.use = readVarint32(bb);
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  if (message.pos === undefined)
    throw new Error("Missing required field: pos");

  if (message.id === undefined)
    throw new Error("Missing required field: id");

  return message;
}

export function encodepb_pvp_accounts(message) {
  let bb = popByteBuffer();
  _encodepb_pvp_accounts(message, bb);
  return toUint8Array(bb);
}

function _encodepb_pvp_accounts(message, bb) {
  // required int32 score = 1;
  let $score = message.score;
  if ($score !== undefined) {
    writeVarint32(bb, 8);
    writeVarint64(bb, intToLong($score));
  }

  // required int32 win = 2;
  let $win = message.win;
  if ($win !== undefined) {
    writeVarint32(bb, 16);
    writeVarint64(bb, intToLong($win));
  }
}

export function decodepb_pvp_accounts(binary) {
  return _decodepb_pvp_accounts(wrapByteBuffer(binary));
}

function _decodepb_pvp_accounts(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // required int32 score = 1;
      case 1: {
        message.score = readVarint32(bb);
        break;
      }

      // required int32 win = 2;
      case 2: {
        message.win = readVarint32(bb);
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  if (message.score === undefined)
    throw new Error("Missing required field: score");

  if (message.win === undefined)
    throw new Error("Missing required field: win");

  return message;
}

export function encodepb_attr(message) {
  let bb = popByteBuffer();
  _encodepb_attr(message, bb);
  return toUint8Array(bb);
}

function _encodepb_attr(message, bb) {
  // optional int32 atk = 1;
  let $atk = message.atk;
  if ($atk !== undefined) {
    writeVarint32(bb, 8);
    writeVarint64(bb, intToLong($atk));
  }

  // optional int64 hp = 2;
  let $hp = message.hp;
  if ($hp !== undefined) {
    writeVarint32(bb, 16);
    writeVarint64(bb, $hp);
  }

  // optional int32 arm = 3;
  let $arm = message.arm;
  if ($arm !== undefined) {
    writeVarint32(bb, 24);
    writeVarint64(bb, intToLong($arm));
  }

  // optional int32 spd = 4;
  let $spd = message.spd;
  if ($spd !== undefined) {
    writeVarint32(bb, 32);
    writeVarint64(bb, intToLong($spd));
  }

  // optional int32 sklP = 5;
  let $sklP = message.sklP;
  if ($sklP !== undefined) {
    writeVarint32(bb, 40);
    writeVarint64(bb, intToLong($sklP));
  }

  // optional int32 hit = 6;
  let $hit = message.hit;
  if ($hit !== undefined) {
    writeVarint32(bb, 48);
    writeVarint64(bb, intToLong($hit));
  }

  // optional int32 miss = 7;
  let $miss = message.miss;
  if ($miss !== undefined) {
    writeVarint32(bb, 56);
    writeVarint64(bb, intToLong($miss));
  }

  // optional int32 crit = 8;
  let $crit = message.crit;
  if ($crit !== undefined) {
    writeVarint32(bb, 64);
    writeVarint64(bb, intToLong($crit));
  }

  // optional int32 critTime = 9;
  let $critTime = message.critTime;
  if ($critTime !== undefined) {
    writeVarint32(bb, 72);
    writeVarint64(bb, intToLong($critTime));
  }

  // optional int32 brk = 10;
  let $brk = message.brk;
  if ($brk !== undefined) {
    writeVarint32(bb, 80);
    writeVarint64(bb, intToLong($brk));
  }

  // optional int32 free = 11;
  let $free = message.free;
  if ($free !== undefined) {
    writeVarint32(bb, 88);
    writeVarint64(bb, intToLong($free));
  }

  // optional int32 decDmg = 12;
  let $decDmg = message.decDmg;
  if ($decDmg !== undefined) {
    writeVarint32(bb, 96);
    writeVarint64(bb, intToLong($decDmg));
  }

  // optional int32 trueAtk = 13;
  let $trueAtk = message.trueAtk;
  if ($trueAtk !== undefined) {
    writeVarint32(bb, 104);
    writeVarint64(bb, intToLong($trueAtk));
  }
}

export function decodepb_attr(binary) {
  return _decodepb_attr(wrapByteBuffer(binary));
}

function _decodepb_attr(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // optional int32 atk = 1;
      case 1: {
        message.atk = readVarint32(bb);
        break;
      }

      // optional int64 hp = 2;
      case 2: {
        message.hp = readVarint64(bb, /* unsigned */ false);
        break;
      }

      // optional int32 arm = 3;
      case 3: {
        message.arm = readVarint32(bb);
        break;
      }

      // optional int32 spd = 4;
      case 4: {
        message.spd = readVarint32(bb);
        break;
      }

      // optional int32 sklP = 5;
      case 5: {
        message.sklP = readVarint32(bb);
        break;
      }

      // optional int32 hit = 6;
      case 6: {
        message.hit = readVarint32(bb);
        break;
      }

      // optional int32 miss = 7;
      case 7: {
        message.miss = readVarint32(bb);
        break;
      }

      // optional int32 crit = 8;
      case 8: {
        message.crit = readVarint32(bb);
        break;
      }

      // optional int32 critTime = 9;
      case 9: {
        message.critTime = readVarint32(bb);
        break;
      }

      // optional int32 brk = 10;
      case 10: {
        message.brk = readVarint32(bb);
        break;
      }

      // optional int32 free = 11;
      case 11: {
        message.free = readVarint32(bb);
        break;
      }

      // optional int32 decDmg = 12;
      case 12: {
        message.decDmg = readVarint32(bb);
        break;
      }

      // optional int32 trueAtk = 13;
      case 13: {
        message.trueAtk = readVarint32(bb);
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  return message;
}

export function encodepb_gvm_mbr(message) {
  let bb = popByteBuffer();
  _encodepb_gvm_mbr(message, bb);
  return toUint8Array(bb);
}

function _encodepb_gvm_mbr(message, bb) {
  // optional string name = 1;
  let $name = message.name;
  if ($name !== undefined) {
    writeVarint32(bb, 10);
    writeString(bb, $name);
  }

  // optional int64 uid = 2;
  let $uid = message.uid;
  if ($uid !== undefined) {
    writeVarint32(bb, 16);
    writeVarint64(bb, $uid);
  }

  // optional int32 lv = 3;
  let $lv = message.lv;
  if ($lv !== undefined) {
    writeVarint32(bb, 24);
    writeVarint64(bb, intToLong($lv));
  }

  // optional int32 logo = 4;
  let $logo = message.logo;
  if ($logo !== undefined) {
    writeVarint32(bb, 32);
    writeVarint64(bb, intToLong($logo));
  }

  // optional int32 lbox = 5;
  let $lbox = message.lbox;
  if ($lbox !== undefined) {
    writeVarint32(bb, 40);
    writeVarint64(bb, intToLong($lbox));
  }

  // repeated int64 scores = 6;
  let array$scores = message.scores;
  if (array$scores !== undefined) {
    let packed = popByteBuffer();
    for (let value of array$scores) {
      writeVarint64(packed, value);
    }
    writeVarint32(bb, 50);
    writeVarint32(bb, packed.offset);
    writeByteBuffer(bb, packed);
    pushByteBuffer(packed);
  }

  // optional int64 score = 7;
  let $score = message.score;
  if ($score !== undefined) {
    writeVarint32(bb, 56);
    writeVarint64(bb, $score);
  }
}

export function decodepb_gvm_mbr(binary) {
  return _decodepb_gvm_mbr(wrapByteBuffer(binary));
}

function _decodepb_gvm_mbr(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // optional string name = 1;
      case 1: {
        message.name = readString(bb, readVarint32(bb));
        break;
      }

      // optional int64 uid = 2;
      case 2: {
        message.uid = readVarint64(bb, /* unsigned */ false);
        break;
      }

      // optional int32 lv = 3;
      case 3: {
        message.lv = readVarint32(bb);
        break;
      }

      // optional int32 logo = 4;
      case 4: {
        message.logo = readVarint32(bb);
        break;
      }

      // optional int32 lbox = 5;
      case 5: {
        message.lbox = readVarint32(bb);
        break;
      }

      // repeated int64 scores = 6;
      case 6: {
        let values = message.scores || (message.scores = []);
        if ((tag & 7) === 2) {
          let outerLimit = pushTemporaryLength(bb);
          while (!isAtEnd(bb)) {
            values.push(readVarint64(bb, /* unsigned */ false));
          }
          bb.limit = outerLimit;
        } else {
          values.push(readVarint64(bb, /* unsigned */ false));
        }
        break;
      }

      // optional int64 score = 7;
      case 7: {
        message.score = readVarint64(bb, /* unsigned */ false);
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  return message;
}

export function encodepb_up_star(message) {
  let bb = popByteBuffer();
  _encodepb_up_star(message, bb);
  return toUint8Array(bb);
}

function _encodepb_up_star(message, bb) {
  // required int32 id = 1;
  let $id = message.id;
  if ($id !== undefined) {
    writeVarint32(bb, 8);
    writeVarint64(bb, intToLong($id));
  }

  // repeated int32 hid = 2;
  let array$hid = message.hid;
  if (array$hid !== undefined) {
    let packed = popByteBuffer();
    for (let value of array$hid) {
      writeVarint64(packed, intToLong(value));
    }
    writeVarint32(bb, 18);
    writeVarint32(bb, packed.offset);
    writeByteBuffer(bb, packed);
    pushByteBuffer(packed);
  }
}

export function decodepb_up_star(binary) {
  return _decodepb_up_star(wrapByteBuffer(binary));
}

function _decodepb_up_star(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // required int32 id = 1;
      case 1: {
        message.id = readVarint32(bb);
        break;
      }

      // repeated int32 hid = 2;
      case 2: {
        let values = message.hid || (message.hid = []);
        if ((tag & 7) === 2) {
          let outerLimit = pushTemporaryLength(bb);
          while (!isAtEnd(bb)) {
            values.push(readVarint32(bb));
          }
          bb.limit = outerLimit;
        } else {
          values.push(readVarint32(bb));
        }
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  if (message.id === undefined)
    throw new Error("Missing required field: id");

  return message;
}

export function encodepb_fun(message) {
  let bb = popByteBuffer();
  _encodepb_fun(message, bb);
  return toUint8Array(bb);
}

function _encodepb_fun(message, bb) {
  // required int32 open = 1;
  let $open = message.open;
  if ($open !== undefined) {
    writeVarint32(bb, 8);
    writeVarint64(bb, intToLong($open));
  }

  // required int32 cd = 2;
  let $cd = message.cd;
  if ($cd !== undefined) {
    writeVarint32(bb, 16);
    writeVarint64(bb, intToLong($cd));
  }

  // optional int32 id = 3;
  let $id = message.id;
  if ($id !== undefined) {
    writeVarint32(bb, 24);
    writeVarint64(bb, intToLong($id));
  }
}

export function decodepb_fun(binary) {
  return _decodepb_fun(wrapByteBuffer(binary));
}

function _decodepb_fun(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // required int32 open = 1;
      case 1: {
        message.open = readVarint32(bb);
        break;
      }

      // required int32 cd = 2;
      case 2: {
        message.cd = readVarint32(bb);
        break;
      }

      // optional int32 id = 3;
      case 3: {
        message.id = readVarint32(bb);
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  if (message.open === undefined)
    throw new Error("Missing required field: open");

  if (message.cd === undefined)
    throw new Error("Missing required field: cd");

  return message;
}

export function encodehland_change_skin(message) {
  let bb = popByteBuffer();
  _encodehland_change_skin(message, bb);
  return toUint8Array(bb);
}

function _encodehland_change_skin(message, bb) {
  // required int32 skin = 1;
  let $skin = message.skin;
  if ($skin !== undefined) {
    writeVarint32(bb, 8);
    writeVarint64(bb, intToLong($skin));
  }

  // required int32 pos = 2;
  let $pos = message.pos;
  if ($pos !== undefined) {
    writeVarint32(bb, 16);
    writeVarint64(bb, intToLong($pos));
  }
}

export function decodehland_change_skin(binary) {
  return _decodehland_change_skin(wrapByteBuffer(binary));
}

function _decodehland_change_skin(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // required int32 skin = 1;
      case 1: {
        message.skin = readVarint32(bb);
        break;
      }

      // required int32 pos = 2;
      case 2: {
        message.pos = readVarint32(bb);
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  if (message.skin === undefined)
    throw new Error("Missing required field: skin");

  if (message.pos === undefined)
    throw new Error("Missing required field: pos");

  return message;
}

export function encodepb_hland_log(message) {
  let bb = popByteBuffer();
  _encodepb_hland_log(message, bb);
  return toUint8Array(bb);
}

function _encodepb_hland_log(message, bb) {
  // optional string name = 1;
  let $name = message.name;
  if ($name !== undefined) {
    writeVarint32(bb, 10);
    writeString(bb, $name);
  }

  // optional int64 uid = 2;
  let $uid = message.uid;
  if ($uid !== undefined) {
    writeVarint32(bb, 16);
    writeVarint64(bb, $uid);
  }

  // optional int32 lv = 3;
  let $lv = message.lv;
  if ($lv !== undefined) {
    writeVarint32(bb, 24);
    writeVarint64(bb, intToLong($lv));
  }

  // optional int32 logo = 4;
  let $logo = message.logo;
  if ($logo !== undefined) {
    writeVarint32(bb, 32);
    writeVarint64(bb, intToLong($logo));
  }

  // optional int32 lbox = 5;
  let $lbox = message.lbox;
  if ($lbox !== undefined) {
    writeVarint32(bb, 40);
    writeVarint64(bb, intToLong($lbox));
  }

  // optional int32 type = 6;
  let $type = message.type;
  if ($type !== undefined) {
    writeVarint32(bb, 48);
    writeVarint64(bb, intToLong($type));
  }

  // optional int64 time = 7;
  let $time = message.time;
  if ($time !== undefined) {
    writeVarint32(bb, 56);
    writeVarint64(bb, $time);
  }
}

export function decodepb_hland_log(binary) {
  return _decodepb_hland_log(wrapByteBuffer(binary));
}

function _decodepb_hland_log(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // optional string name = 1;
      case 1: {
        message.name = readString(bb, readVarint32(bb));
        break;
      }

      // optional int64 uid = 2;
      case 2: {
        message.uid = readVarint64(bb, /* unsigned */ false);
        break;
      }

      // optional int32 lv = 3;
      case 3: {
        message.lv = readVarint32(bb);
        break;
      }

      // optional int32 logo = 4;
      case 4: {
        message.logo = readVarint32(bb);
        break;
      }

      // optional int32 lbox = 5;
      case 5: {
        message.lbox = readVarint32(bb);
        break;
      }

      // optional int32 type = 6;
      case 6: {
        message.type = readVarint32(bb);
        break;
      }

      // optional int64 time = 7;
      case 7: {
        message.time = readVarint64(bb, /* unsigned */ false);
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  return message;
}

export function encodepb_hmbr(message) {
  let bb = popByteBuffer();
  _encodepb_hmbr(message, bb);
  return toUint8Array(bb);
}

function _encodepb_hmbr(message, bb) {
  // optional string name = 1;
  let $name = message.name;
  if ($name !== undefined) {
    writeVarint32(bb, 10);
    writeString(bb, $name);
  }

  // optional int64 uid = 2;
  let $uid = message.uid;
  if ($uid !== undefined) {
    writeVarint32(bb, 16);
    writeVarint64(bb, $uid);
  }

  // optional int32 lv = 3;
  let $lv = message.lv;
  if ($lv !== undefined) {
    writeVarint32(bb, 24);
    writeVarint64(bb, intToLong($lv));
  }

  // optional int32 logo = 4;
  let $logo = message.logo;
  if ($logo !== undefined) {
    writeVarint32(bb, 32);
    writeVarint64(bb, intToLong($logo));
  }

  // optional int32 lbox = 5;
  let $lbox = message.lbox;
  if ($lbox !== undefined) {
    writeVarint32(bb, 40);
    writeVarint64(bb, intToLong($lbox));
  }

  // repeated int32 item_ids = 6;
  let array$item_ids = message.item_ids;
  if (array$item_ids !== undefined) {
    let packed = popByteBuffer();
    for (let value of array$item_ids) {
      writeVarint64(packed, intToLong(value));
    }
    writeVarint32(bb, 50);
    writeVarint32(bb, packed.offset);
    writeByteBuffer(bb, packed);
    pushByteBuffer(packed);
  }
}

export function decodepb_hmbr(binary) {
  return _decodepb_hmbr(wrapByteBuffer(binary));
}

function _decodepb_hmbr(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // optional string name = 1;
      case 1: {
        message.name = readString(bb, readVarint32(bb));
        break;
      }

      // optional int64 uid = 2;
      case 2: {
        message.uid = readVarint64(bb, /* unsigned */ false);
        break;
      }

      // optional int32 lv = 3;
      case 3: {
        message.lv = readVarint32(bb);
        break;
      }

      // optional int32 logo = 4;
      case 4: {
        message.logo = readVarint32(bb);
        break;
      }

      // optional int32 lbox = 5;
      case 5: {
        message.lbox = readVarint32(bb);
        break;
      }

      // repeated int32 item_ids = 6;
      case 6: {
        let values = message.item_ids || (message.item_ids = []);
        if ((tag & 7) === 2) {
          let outerLimit = pushTemporaryLength(bb);
          while (!isAtEnd(bb)) {
            values.push(readVarint32(bb));
          }
          bb.limit = outerLimit;
        } else {
          values.push(readVarint32(bb));
        }
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  return message;
}

export function encodepb_hteam(message) {
  let bb = popByteBuffer();
  _encodepb_hteam(message, bb);
  return toUint8Array(bb);
}

function _encodepb_hteam(message, bb) {
  // optional string id = 1;
  let $id = message.id;
  if ($id !== undefined) {
    writeVarint32(bb, 10);
    writeString(bb, $id);
  }

  // optional int64 leader = 2;
  let $leader = message.leader;
  if ($leader !== undefined) {
    writeVarint32(bb, 16);
    writeVarint64(bb, $leader);
  }

  // optional int32 type = 3;
  let $type = message.type;
  if ($type !== undefined) {
    writeVarint32(bb, 24);
    writeVarint64(bb, intToLong($type));
  }

  // repeated pb_hmbr mbr = 4;
  let array$mbr = message.mbr;
  if (array$mbr !== undefined) {
    for (let value of array$mbr) {
      writeVarint32(bb, 34);
      let nested = popByteBuffer();
      _encodepb_hmbr(value, nested);
      writeVarint32(bb, nested.limit);
      writeByteBuffer(bb, nested);
      pushByteBuffer(nested);
    }
  }

  // optional int32 cd = 5;
  let $cd = message.cd;
  if ($cd !== undefined) {
    writeVarint32(bb, 40);
    writeVarint64(bb, intToLong($cd));
  }

  // optional bool shape = 6;
  let $shape = message.shape;
  if ($shape !== undefined) {
    writeVarint32(bb, 48);
    writeByte(bb, $shape ? 1 : 0);
  }

  // repeated int64 invites = 7;
  let array$invites = message.invites;
  if (array$invites !== undefined) {
    let packed = popByteBuffer();
    for (let value of array$invites) {
      writeVarint64(packed, value);
    }
    writeVarint32(bb, 58);
    writeVarint32(bb, packed.offset);
    writeByteBuffer(bb, packed);
    pushByteBuffer(packed);
  }
}

export function decodepb_hteam(binary) {
  return _decodepb_hteam(wrapByteBuffer(binary));
}

function _decodepb_hteam(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // optional string id = 1;
      case 1: {
        message.id = readString(bb, readVarint32(bb));
        break;
      }

      // optional int64 leader = 2;
      case 2: {
        message.leader = readVarint64(bb, /* unsigned */ false);
        break;
      }

      // optional int32 type = 3;
      case 3: {
        message.type = readVarint32(bb);
        break;
      }

      // repeated pb_hmbr mbr = 4;
      case 4: {
        let limit = pushTemporaryLength(bb);
        let values = message.mbr || (message.mbr = []);
        values.push(_decodepb_hmbr(bb));
        bb.limit = limit;
        break;
      }

      // optional int32 cd = 5;
      case 5: {
        message.cd = readVarint32(bb);
        break;
      }

      // optional bool shape = 6;
      case 6: {
        message.shape = !!readByte(bb);
        break;
      }

      // repeated int64 invites = 7;
      case 7: {
        let values = message.invites || (message.invites = []);
        if ((tag & 7) === 2) {
          let outerLimit = pushTemporaryLength(bb);
          while (!isAtEnd(bb)) {
            values.push(readVarint64(bb, /* unsigned */ false));
          }
          bb.limit = outerLimit;
        } else {
          values.push(readVarint64(bb, /* unsigned */ false));
        }
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  return message;
}

export function encodepb_team_info(message) {
  let bb = popByteBuffer();
  _encodepb_team_info(message, bb);
  return toUint8Array(bb);
}

function _encodepb_team_info(message, bb) {
  // required int32 id = 1;
  let $id = message.id;
  if ($id !== undefined) {
    writeVarint32(bb, 8);
    writeVarint64(bb, intToLong($id));
  }

  // optional string name = 2;
  let $name = message.name;
  if ($name !== undefined) {
    writeVarint32(bb, 18);
    writeString(bb, $name);
  }

  // repeated pb_team_hero heroes = 3;
  let array$heroes = message.heroes;
  if (array$heroes !== undefined) {
    for (let value of array$heroes) {
      writeVarint32(bb, 26);
      let nested = popByteBuffer();
      _encodepb_team_hero(value, nested);
      writeVarint32(bb, nested.limit);
      writeByteBuffer(bb, nested);
      pushByteBuffer(nested);
    }
  }

  // optional int32 petid = 4;
  let $petid = message.petid;
  if ($petid !== undefined) {
    writeVarint32(bb, 32);
    writeVarint64(bb, intToLong($petid));
  }

  // optional int32 flag = 5;
  let $flag = message.flag;
  if ($flag !== undefined) {
    writeVarint32(bb, 40);
    writeVarint64(bb, intToLong($flag));
  }
}

export function decodepb_team_info(binary) {
  return _decodepb_team_info(wrapByteBuffer(binary));
}

function _decodepb_team_info(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // required int32 id = 1;
      case 1: {
        message.id = readVarint32(bb);
        break;
      }

      // optional string name = 2;
      case 2: {
        message.name = readString(bb, readVarint32(bb));
        break;
      }

      // repeated pb_team_hero heroes = 3;
      case 3: {
        let limit = pushTemporaryLength(bb);
        let values = message.heroes || (message.heroes = []);
        values.push(_decodepb_team_hero(bb));
        bb.limit = limit;
        break;
      }

      // optional int32 petid = 4;
      case 4: {
        message.petid = readVarint32(bb);
        break;
      }

      // optional int32 flag = 5;
      case 5: {
        message.flag = readVarint32(bb);
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  if (message.id === undefined)
    throw new Error("Missing required field: id");

  return message;
}

export function encodepb_team_hero(message) {
  let bb = popByteBuffer();
  _encodepb_team_hero(message, bb);
  return toUint8Array(bb);
}

function _encodepb_team_hero(message, bb) {
  // required int32 pos = 1;
  let $pos = message.pos;
  if ($pos !== undefined) {
    writeVarint32(bb, 8);
    writeVarint64(bb, intToLong($pos));
  }

  // required int32 hid = 2;
  let $hid = message.hid;
  if ($hid !== undefined) {
    writeVarint32(bb, 16);
    writeVarint64(bb, intToLong($hid));
  }

  // repeated pb_equip equips = 3;
  let array$equips = message.equips;
  if (array$equips !== undefined) {
    for (let value of array$equips) {
      writeVarint32(bb, 26);
      let nested = popByteBuffer();
      _encodepb_equip(value, nested);
      writeVarint32(bb, nested.limit);
      writeByteBuffer(bb, nested);
      pushByteBuffer(nested);
    }
  }

  // repeated int32 skill_id = 4;
  let array$skill_id = message.skill_id;
  if (array$skill_id !== undefined) {
    let packed = popByteBuffer();
    for (let value of array$skill_id) {
      writeVarint64(packed, intToLong(value));
    }
    writeVarint32(bb, 34);
    writeVarint32(bb, packed.offset);
    writeByteBuffer(bb, packed);
    pushByteBuffer(packed);
  }

  // repeated pb_sattr sattrs = 5;
  let array$sattrs = message.sattrs;
  if (array$sattrs !== undefined) {
    for (let value of array$sattrs) {
      writeVarint32(bb, 42);
      let nested = popByteBuffer();
      _encodepb_sattr(value, nested);
      writeVarint32(bb, nested.limit);
      writeByteBuffer(bb, nested);
      pushByteBuffer(nested);
    }
  }

  // optional int32 flag = 6;
  let $flag = message.flag;
  if ($flag !== undefined) {
    writeVarint32(bb, 48);
    writeVarint64(bb, intToLong($flag));
  }
}

export function decodepb_team_hero(binary) {
  return _decodepb_team_hero(wrapByteBuffer(binary));
}

function _decodepb_team_hero(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // required int32 pos = 1;
      case 1: {
        message.pos = readVarint32(bb);
        break;
      }

      // required int32 hid = 2;
      case 2: {
        message.hid = readVarint32(bb);
        break;
      }

      // repeated pb_equip equips = 3;
      case 3: {
        let limit = pushTemporaryLength(bb);
        let values = message.equips || (message.equips = []);
        values.push(_decodepb_equip(bb));
        bb.limit = limit;
        break;
      }

      // repeated int32 skill_id = 4;
      case 4: {
        let values = message.skill_id || (message.skill_id = []);
        if ((tag & 7) === 2) {
          let outerLimit = pushTemporaryLength(bb);
          while (!isAtEnd(bb)) {
            values.push(readVarint32(bb));
          }
          bb.limit = outerLimit;
        } else {
          values.push(readVarint32(bb));
        }
        break;
      }

      // repeated pb_sattr sattrs = 5;
      case 5: {
        let limit = pushTemporaryLength(bb);
        let values = message.sattrs || (message.sattrs = []);
        values.push(_decodepb_sattr(bb));
        bb.limit = limit;
        break;
      }

      // optional int32 flag = 6;
      case 6: {
        message.flag = readVarint32(bb);
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  if (message.pos === undefined)
    throw new Error("Missing required field: pos");

  if (message.hid === undefined)
    throw new Error("Missing required field: hid");

  return message;
}

export function encodegood(message) {
  let bb = popByteBuffer();
  _encodegood(message, bb);
  return toUint8Array(bb);
}

function _encodegood(message, bb) {
  // optional int32 good_id = 1;
  let $good_id = message.good_id;
  if ($good_id !== undefined) {
    writeVarint32(bb, 8);
    writeVarint64(bb, intToLong($good_id));
  }

  // optional int32 hero_id = 2;
  let $hero_id = message.hero_id;
  if ($hero_id !== undefined) {
    writeVarint32(bb, 16);
    writeVarint64(bb, intToLong($hero_id));
  }

  // optional pb_hero_qlc qlt = 3;
  let $qlt = message.qlt;
  if ($qlt !== undefined) {
    writeVarint32(bb, 26);
    let nested = popByteBuffer();
    _encodepb_hero_qlc($qlt, nested);
    writeVarint32(bb, nested.limit);
    writeByteBuffer(bb, nested);
    pushByteBuffer(nested);
  }

  // optional int64 price = 4;
  let $price = message.price;
  if ($price !== undefined) {
    writeVarint32(bb, 32);
    writeVarint64(bb, $price);
  }

  // optional int64 del_price = 5;
  let $del_price = message.del_price;
  if ($del_price !== undefined) {
    writeVarint32(bb, 40);
    writeVarint64(bb, $del_price);
  }

  // optional int32 state = 6;
  let $state = message.state;
  if ($state !== undefined) {
    writeVarint32(bb, 48);
    writeVarint64(bb, intToLong($state));
  }

  // optional int32 cd = 7;
  let $cd = message.cd;
  if ($cd !== undefined) {
    writeVarint32(bb, 56);
    writeVarint64(bb, intToLong($cd));
  }

  // optional int32 rprice = 8;
  let $rprice = message.rprice;
  if ($rprice !== undefined) {
    writeVarint32(bb, 64);
    writeVarint64(bb, intToLong($rprice));
  }

  // optional pb_give_role seller = 9;
  let $seller = message.seller;
  if ($seller !== undefined) {
    writeVarint32(bb, 74);
    let nested = popByteBuffer();
    _encodepb_give_role($seller, nested);
    writeVarint32(bb, nested.limit);
    writeByteBuffer(bb, nested);
    pushByteBuffer(nested);
  }

  // optional pb_give_role buyer = 10;
  let $buyer = message.buyer;
  if ($buyer !== undefined) {
    writeVarint32(bb, 82);
    let nested = popByteBuffer();
    _encodepb_give_role($buyer, nested);
    writeVarint32(bb, nested.limit);
    writeByteBuffer(bb, nested);
    pushByteBuffer(nested);
  }
}

export function decodegood(binary) {
  return _decodegood(wrapByteBuffer(binary));
}

function _decodegood(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // optional int32 good_id = 1;
      case 1: {
        message.good_id = readVarint32(bb);
        break;
      }

      // optional int32 hero_id = 2;
      case 2: {
        message.hero_id = readVarint32(bb);
        break;
      }

      // optional pb_hero_qlc qlt = 3;
      case 3: {
        let limit = pushTemporaryLength(bb);
        message.qlt = _decodepb_hero_qlc(bb);
        bb.limit = limit;
        break;
      }

      // optional int64 price = 4;
      case 4: {
        message.price = readVarint64(bb, /* unsigned */ false);
        break;
      }

      // optional int64 del_price = 5;
      case 5: {
        message.del_price = readVarint64(bb, /* unsigned */ false);
        break;
      }

      // optional int32 state = 6;
      case 6: {
        message.state = readVarint32(bb);
        break;
      }

      // optional int32 cd = 7;
      case 7: {
        message.cd = readVarint32(bb);
        break;
      }

      // optional int32 rprice = 8;
      case 8: {
        message.rprice = readVarint32(bb);
        break;
      }

      // optional pb_give_role seller = 9;
      case 9: {
        let limit = pushTemporaryLength(bb);
        message.seller = _decodepb_give_role(bb);
        bb.limit = limit;
        break;
      }

      // optional pb_give_role buyer = 10;
      case 10: {
        let limit = pushTemporaryLength(bb);
        message.buyer = _decodepb_give_role(bb);
        bb.limit = limit;
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  return message;
}

export function encodemall_log(message) {
  let bb = popByteBuffer();
  _encodemall_log(message, bb);
  return toUint8Array(bb);
}

function _encodemall_log(message, bb) {
  // optional int32 time = 1;
  let $time = message.time;
  if ($time !== undefined) {
    writeVarint32(bb, 8);
    writeVarint64(bb, intToLong($time));
  }

  // optional int32 heroid = 2;
  let $heroid = message.heroid;
  if ($heroid !== undefined) {
    writeVarint32(bb, 16);
    writeVarint64(bb, intToLong($heroid));
  }

  // optional pb_hero_qlc qlt = 3;
  let $qlt = message.qlt;
  if ($qlt !== undefined) {
    writeVarint32(bb, 26);
    let nested = popByteBuffer();
    _encodepb_hero_qlc($qlt, nested);
    writeVarint32(bb, nested.limit);
    writeByteBuffer(bb, nested);
    pushByteBuffer(nested);
  }

  // optional int32 price = 4;
  let $price = message.price;
  if ($price !== undefined) {
    writeVarint32(bb, 32);
    writeVarint64(bb, intToLong($price));
  }

  // optional int32 type = 5;
  let $type = message.type;
  if ($type !== undefined) {
    writeVarint32(bb, 40);
    writeVarint64(bb, intToLong($type));
  }

  // optional int32 status = 6;
  let $status = message.status;
  if ($status !== undefined) {
    writeVarint32(bb, 48);
    writeVarint64(bb, intToLong($status));
  }

  // optional int32 goodid = 7;
  let $goodid = message.goodid;
  if ($goodid !== undefined) {
    writeVarint32(bb, 56);
    writeVarint64(bb, intToLong($goodid));
  }

  // optional pb_give_role user = 8;
  let $user = message.user;
  if ($user !== undefined) {
    writeVarint32(bb, 66);
    let nested = popByteBuffer();
    _encodepb_give_role($user, nested);
    writeVarint32(bb, nested.limit);
    writeByteBuffer(bb, nested);
    pushByteBuffer(nested);
  }
}

export function decodemall_log(binary) {
  return _decodemall_log(wrapByteBuffer(binary));
}

function _decodemall_log(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // optional int32 time = 1;
      case 1: {
        message.time = readVarint32(bb);
        break;
      }

      // optional int32 heroid = 2;
      case 2: {
        message.heroid = readVarint32(bb);
        break;
      }

      // optional pb_hero_qlc qlt = 3;
      case 3: {
        let limit = pushTemporaryLength(bb);
        message.qlt = _decodepb_hero_qlc(bb);
        bb.limit = limit;
        break;
      }

      // optional int32 price = 4;
      case 4: {
        message.price = readVarint32(bb);
        break;
      }

      // optional int32 type = 5;
      case 5: {
        message.type = readVarint32(bb);
        break;
      }

      // optional int32 status = 6;
      case 6: {
        message.status = readVarint32(bb);
        break;
      }

      // optional int32 goodid = 7;
      case 7: {
        message.goodid = readVarint32(bb);
        break;
      }

      // optional pb_give_role user = 8;
      case 8: {
        let limit = pushTemporaryLength(bb);
        message.user = _decodepb_give_role(bb);
        bb.limit = limit;
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  return message;
}

export function encodepb_kv(message) {
  let bb = popByteBuffer();
  _encodepb_kv(message, bb);
  return toUint8Array(bb);
}

function _encodepb_kv(message, bb) {
  // optional int32 k = 1;
  let $k = message.k;
  if ($k !== undefined) {
    writeVarint32(bb, 8);
    writeVarint64(bb, intToLong($k));
  }

  // optional int32 v = 2;
  let $v = message.v;
  if ($v !== undefined) {
    writeVarint32(bb, 16);
    writeVarint64(bb, intToLong($v));
  }
}

export function decodepb_kv(binary) {
  return _decodepb_kv(wrapByteBuffer(binary));
}

function _decodepb_kv(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // optional int32 k = 1;
      case 1: {
        message.k = readVarint32(bb);
        break;
      }

      // optional int32 v = 2;
      case 2: {
        message.v = readVarint32(bb);
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  return message;
}

export function encodepb_kvs(message) {
  let bb = popByteBuffer();
  _encodepb_kvs(message, bb);
  return toUint8Array(bb);
}

function _encodepb_kvs(message, bb) {
  // repeated int32 k = 1;
  let array$k = message.k;
  if (array$k !== undefined) {
    let packed = popByteBuffer();
    for (let value of array$k) {
      writeVarint64(packed, intToLong(value));
    }
    writeVarint32(bb, 10);
    writeVarint32(bb, packed.offset);
    writeByteBuffer(bb, packed);
    pushByteBuffer(packed);
  }

  // repeated int32 v = 2;
  let array$v = message.v;
  if (array$v !== undefined) {
    let packed = popByteBuffer();
    for (let value of array$v) {
      writeVarint64(packed, intToLong(value));
    }
    writeVarint32(bb, 18);
    writeVarint32(bb, packed.offset);
    writeByteBuffer(bb, packed);
    pushByteBuffer(packed);
  }

  // repeated int32 v2 = 3;
  let array$v2 = message.v2;
  if (array$v2 !== undefined) {
    let packed = popByteBuffer();
    for (let value of array$v2) {
      writeVarint64(packed, intToLong(value));
    }
    writeVarint32(bb, 26);
    writeVarint32(bb, packed.offset);
    writeByteBuffer(bb, packed);
    pushByteBuffer(packed);
  }
}

export function decodepb_kvs(binary) {
  return _decodepb_kvs(wrapByteBuffer(binary));
}

function _decodepb_kvs(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // repeated int32 k = 1;
      case 1: {
        let values = message.k || (message.k = []);
        if ((tag & 7) === 2) {
          let outerLimit = pushTemporaryLength(bb);
          while (!isAtEnd(bb)) {
            values.push(readVarint32(bb));
          }
          bb.limit = outerLimit;
        } else {
          values.push(readVarint32(bb));
        }
        break;
      }

      // repeated int32 v = 2;
      case 2: {
        let values = message.v || (message.v = []);
        if ((tag & 7) === 2) {
          let outerLimit = pushTemporaryLength(bb);
          while (!isAtEnd(bb)) {
            values.push(readVarint32(bb));
          }
          bb.limit = outerLimit;
        } else {
          values.push(readVarint32(bb));
        }
        break;
      }

      // repeated int32 v2 = 3;
      case 3: {
        let values = message.v2 || (message.v2 = []);
        if ((tag & 7) === 2) {
          let outerLimit = pushTemporaryLength(bb);
          while (!isAtEnd(bb)) {
            values.push(readVarint32(bb));
          }
          bb.limit = outerLimit;
        } else {
          values.push(readVarint32(bb));
        }
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  return message;
}

export function encodepb_kv2(message) {
  let bb = popByteBuffer();
  _encodepb_kv2(message, bb);
  return toUint8Array(bb);
}

function _encodepb_kv2(message, bb) {
  // optional int32 k = 1;
  let $k = message.k;
  if ($k !== undefined) {
    writeVarint32(bb, 8);
    writeVarint64(bb, intToLong($k));
  }

  // optional int32 v = 2;
  let $v = message.v;
  if ($v !== undefined) {
    writeVarint32(bb, 16);
    writeVarint64(bb, intToLong($v));
  }

  // optional int32 v2 = 3;
  let $v2 = message.v2;
  if ($v2 !== undefined) {
    writeVarint32(bb, 24);
    writeVarint64(bb, intToLong($v2));
  }
}

export function decodepb_kv2(binary) {
  return _decodepb_kv2(wrapByteBuffer(binary));
}

function _decodepb_kv2(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // optional int32 k = 1;
      case 1: {
        message.k = readVarint32(bb);
        break;
      }

      // optional int32 v = 2;
      case 2: {
        message.v = readVarint32(bb);
        break;
      }

      // optional int32 v2 = 3;
      case 3: {
        message.v2 = readVarint32(bb);
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  return message;
}

export function encodepb_growup(message) {
  let bb = popByteBuffer();
  _encodepb_growup(message, bb);
  return toUint8Array(bb);
}

function _encodepb_growup(message, bb) {
  // optional int32 id = 1;
  let $id = message.id;
  if ($id !== undefined) {
    writeVarint32(bb, 8);
    writeVarint64(bb, intToLong($id));
  }

  // optional int32 index = 2;
  let $index = message.index;
  if ($index !== undefined) {
    writeVarint32(bb, 16);
    writeVarint64(bb, intToLong($index));
  }

  // optional int32 claim = 3;
  let $claim = message.claim;
  if ($claim !== undefined) {
    writeVarint32(bb, 24);
    writeVarint64(bb, intToLong($claim));
  }
}

export function decodepb_growup(binary) {
  return _decodepb_growup(wrapByteBuffer(binary));
}

function _decodepb_growup(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // optional int32 id = 1;
      case 1: {
        message.id = readVarint32(bb);
        break;
      }

      // optional int32 index = 2;
      case 2: {
        message.index = readVarint32(bb);
        break;
      }

      // optional int32 claim = 3;
      case 3: {
        message.claim = readVarint32(bb);
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  return message;
}

export function encodepb_puzzle(message) {
  let bb = popByteBuffer();
  _encodepb_puzzle(message, bb);
  return toUint8Array(bb);
}

function _encodepb_puzzle(message, bb) {
  // optional int32 id = 1;
  let $id = message.id;
  if ($id !== undefined) {
    writeVarint32(bb, 8);
    writeVarint64(bb, intToLong($id));
  }

  // optional int32 next = 2;
  let $next = message.next;
  if ($next !== undefined) {
    writeVarint32(bb, 16);
    writeVarint64(bb, intToLong($next));
  }

  // optional int32 cur = 3;
  let $cur = message.cur;
  if ($cur !== undefined) {
    writeVarint32(bb, 24);
    writeVarint64(bb, intToLong($cur));
  }

  // repeated pb_kv pos = 4;
  let array$pos = message.pos;
  if (array$pos !== undefined) {
    for (let value of array$pos) {
      writeVarint32(bb, 34);
      let nested = popByteBuffer();
      _encodepb_kv(value, nested);
      writeVarint32(bb, nested.limit);
      writeByteBuffer(bb, nested);
      pushByteBuffer(nested);
    }
  }

  // repeated int32 bag = 5;
  let array$bag = message.bag;
  if (array$bag !== undefined) {
    let packed = popByteBuffer();
    for (let value of array$bag) {
      writeVarint64(packed, intToLong(value));
    }
    writeVarint32(bb, 42);
    writeVarint32(bb, packed.offset);
    writeByteBuffer(bb, packed);
    pushByteBuffer(packed);
  }

  // optional int32 num = 6;
  let $num = message.num;
  if ($num !== undefined) {
    writeVarint32(bb, 48);
    writeVarint64(bb, intToLong($num));
  }

  // optional int32 ring = 7;
  let $ring = message.ring;
  if ($ring !== undefined) {
    writeVarint32(bb, 56);
    writeVarint64(bb, intToLong($ring));
  }

  // optional int32 siz = 8;
  let $siz = message.siz;
  if ($siz !== undefined) {
    writeVarint32(bb, 64);
    writeVarint64(bb, intToLong($siz));
  }
}

export function decodepb_puzzle(binary) {
  return _decodepb_puzzle(wrapByteBuffer(binary));
}

function _decodepb_puzzle(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // optional int32 id = 1;
      case 1: {
        message.id = readVarint32(bb);
        break;
      }

      // optional int32 next = 2;
      case 2: {
        message.next = readVarint32(bb);
        break;
      }

      // optional int32 cur = 3;
      case 3: {
        message.cur = readVarint32(bb);
        break;
      }

      // repeated pb_kv pos = 4;
      case 4: {
        let limit = pushTemporaryLength(bb);
        let values = message.pos || (message.pos = []);
        values.push(_decodepb_kv(bb));
        bb.limit = limit;
        break;
      }

      // repeated int32 bag = 5;
      case 5: {
        let values = message.bag || (message.bag = []);
        if ((tag & 7) === 2) {
          let outerLimit = pushTemporaryLength(bb);
          while (!isAtEnd(bb)) {
            values.push(readVarint32(bb));
          }
          bb.limit = outerLimit;
        } else {
          values.push(readVarint32(bb));
        }
        break;
      }

      // optional int32 num = 6;
      case 6: {
        message.num = readVarint32(bb);
        break;
      }

      // optional int32 ring = 7;
      case 7: {
        message.ring = readVarint32(bb);
        break;
      }

      // optional int32 siz = 8;
      case 8: {
        message.siz = readVarint32(bb);
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  return message;
}

export function encodepb_give_role(message) {
  let bb = popByteBuffer();
  _encodepb_give_role(message, bb);
  return toUint8Array(bb);
}

function _encodepb_give_role(message, bb) {
  // required int64 uid64 = 1;
  let $uid64 = message.uid64;
  if ($uid64 !== undefined) {
    writeVarint32(bb, 8);
    writeVarint64(bb, $uid64);
  }

  // required string channel = 2;
  let $channel = message.channel;
  if ($channel !== undefined) {
    writeVarint32(bb, 18);
    writeString(bb, $channel);
  }

  // required int32 lv = 3;
  let $lv = message.lv;
  if ($lv !== undefined) {
    writeVarint32(bb, 24);
    writeVarint64(bb, intToLong($lv));
  }

  // optional int32 lbox = 4;
  let $lbox = message.lbox;
  if ($lbox !== undefined) {
    writeVarint32(bb, 32);
    writeVarint64(bb, intToLong($lbox));
  }

  // required string name = 5;
  let $name = message.name;
  if ($name !== undefined) {
    writeVarint32(bb, 42);
    writeString(bb, $name);
  }

  // required int32 logo = 6;
  let $logo = message.logo;
  if ($logo !== undefined) {
    writeVarint32(bb, 48);
    writeVarint64(bb, intToLong($logo));
  }
}

export function decodepb_give_role(binary) {
  return _decodepb_give_role(wrapByteBuffer(binary));
}

function _decodepb_give_role(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // required int64 uid64 = 1;
      case 1: {
        message.uid64 = readVarint64(bb, /* unsigned */ false);
        break;
      }

      // required string channel = 2;
      case 2: {
        message.channel = readString(bb, readVarint32(bb));
        break;
      }

      // required int32 lv = 3;
      case 3: {
        message.lv = readVarint32(bb);
        break;
      }

      // optional int32 lbox = 4;
      case 4: {
        message.lbox = readVarint32(bb);
        break;
      }

      // required string name = 5;
      case 5: {
        message.name = readString(bb, readVarint32(bb));
        break;
      }

      // required int32 logo = 6;
      case 6: {
        message.logo = readVarint32(bb);
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  if (message.uid64 === undefined)
    throw new Error("Missing required field: uid64");

  if (message.channel === undefined)
    throw new Error("Missing required field: channel");

  if (message.lv === undefined)
    throw new Error("Missing required field: lv");

  if (message.name === undefined)
    throw new Error("Missing required field: name");

  if (message.logo === undefined)
    throw new Error("Missing required field: logo");

  return message;
}

export function encodepb_give_order(message) {
  let bb = popByteBuffer();
  _encodepb_give_order(message, bb);
  return toUint8Array(bb);
}

function _encodepb_give_order(message, bb) {
  // optional int64 id = 1;
  let $id = message.id;
  if ($id !== undefined) {
    writeVarint32(bb, 8);
    writeVarint64(bb, $id);
  }

  // optional uint32 type = 2;
  let $type = message.type;
  if ($type !== undefined) {
    writeVarint32(bb, 16);
    writeVarint32(bb, $type);
  }

  // optional int32 num = 3;
  let $num = message.num;
  if ($num !== undefined) {
    writeVarint32(bb, 24);
    writeVarint64(bb, intToLong($num));
  }

  // optional uint32 status = 4;
  let $status = message.status;
  if ($status !== undefined) {
    writeVarint32(bb, 32);
    writeVarint32(bb, $status);
  }

  // optional pb_give_role role = 5;
  let $role = message.role;
  if ($role !== undefined) {
    writeVarint32(bb, 42);
    let nested = popByteBuffer();
    _encodepb_give_role($role, nested);
    writeVarint32(bb, nested.limit);
    writeByteBuffer(bb, nested);
    pushByteBuffer(nested);
  }

  // optional int32 cd = 6;
  let $cd = message.cd;
  if ($cd !== undefined) {
    writeVarint32(bb, 48);
    writeVarint64(bb, intToLong($cd));
  }
}

export function decodepb_give_order(binary) {
  return _decodepb_give_order(wrapByteBuffer(binary));
}

function _decodepb_give_order(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // optional int64 id = 1;
      case 1: {
        message.id = readVarint64(bb, /* unsigned */ false);
        break;
      }

      // optional uint32 type = 2;
      case 2: {
        message.type = readVarint32(bb) >>> 0;
        break;
      }

      // optional int32 num = 3;
      case 3: {
        message.num = readVarint32(bb);
        break;
      }

      // optional uint32 status = 4;
      case 4: {
        message.status = readVarint32(bb) >>> 0;
        break;
      }

      // optional pb_give_role role = 5;
      case 5: {
        let limit = pushTemporaryLength(bb);
        message.role = _decodepb_give_role(bb);
        bb.limit = limit;
        break;
      }

      // optional int32 cd = 6;
      case 6: {
        message.cd = readVarint32(bb);
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  return message;
}

export function encodepb_give_log(message) {
  let bb = popByteBuffer();
  _encodepb_give_log(message, bb);
  return toUint8Array(bb);
}

function _encodepb_give_log(message, bb) {
  // optional string name = 1;
  let $name = message.name;
  if ($name !== undefined) {
    writeVarint32(bb, 10);
    writeString(bb, $name);
  }

  // optional int32 num = 2;
  let $num = message.num;
  if ($num !== undefined) {
    writeVarint32(bb, 16);
    writeVarint64(bb, intToLong($num));
  }

  // optional int32 tax = 3;
  let $tax = message.tax;
  if ($tax !== undefined) {
    writeVarint32(bb, 24);
    writeVarint64(bb, intToLong($tax));
  }

  // optional int64 time = 4;
  let $time = message.time;
  if ($time !== undefined) {
    writeVarint32(bb, 32);
    writeVarint64(bb, $time);
  }
}

export function decodepb_give_log(binary) {
  return _decodepb_give_log(wrapByteBuffer(binary));
}

function _decodepb_give_log(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // optional string name = 1;
      case 1: {
        message.name = readString(bb, readVarint32(bb));
        break;
      }

      // optional int32 num = 2;
      case 2: {
        message.num = readVarint32(bb);
        break;
      }

      // optional int32 tax = 3;
      case 3: {
        message.tax = readVarint32(bb);
        break;
      }

      // optional int64 time = 4;
      case 4: {
        message.time = readVarint64(bb, /* unsigned */ false);
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  return message;
}

export function encodepb_qlt_pvp_enemy(message) {
  let bb = popByteBuffer();
  _encodepb_qlt_pvp_enemy(message, bb);
  return toUint8Array(bb);
}

function _encodepb_qlt_pvp_enemy(message, bb) {
  // optional sint32 idx = 1;
  let $idx = message.idx;
  if ($idx !== undefined) {
    writeVarint32(bb, 8);
    writeVarint32ZigZag(bb, $idx);
  }

  // optional int32 logo = 2;
  let $logo = message.logo;
  if ($logo !== undefined) {
    writeVarint32(bb, 16);
    writeVarint64(bb, intToLong($logo));
  }

  // optional string name = 3;
  let $name = message.name;
  if ($name !== undefined) {
    writeVarint32(bb, 26);
    writeString(bb, $name);
  }

  // optional string cluster = 4;
  let $cluster = message.cluster;
  if ($cluster !== undefined) {
    writeVarint32(bb, 34);
    writeString(bb, $cluster);
  }

  // optional int32 lv = 5;
  let $lv = message.lv;
  if ($lv !== undefined) {
    writeVarint32(bb, 40);
    writeVarint64(bb, intToLong($lv));
  }

  // optional int32 lbox = 6;
  let $lbox = message.lbox;
  if ($lbox !== undefined) {
    writeVarint32(bb, 48);
    writeVarint64(bb, intToLong($lbox));
  }

  // repeated pb_unit camp = 7;
  let array$camp = message.camp;
  if (array$camp !== undefined) {
    for (let value of array$camp) {
      writeVarint32(bb, 58);
      let nested = popByteBuffer();
      _encodepb_unit(value, nested);
      writeVarint32(bb, nested.limit);
      writeByteBuffer(bb, nested);
      pushByteBuffer(nested);
    }
  }

  // repeated sint32 skls = 8;
  let array$skls = message.skls;
  if (array$skls !== undefined) {
    let packed = popByteBuffer();
    for (let value of array$skls) {
      writeVarint32ZigZag(packed, value);
    }
    writeVarint32(bb, 66);
    writeVarint32(bb, packed.offset);
    writeByteBuffer(bb, packed);
    pushByteBuffer(packed);
  }

  // repeated sint32 hide = 9;
  let array$hide = message.hide;
  if (array$hide !== undefined) {
    let packed = popByteBuffer();
    for (let value of array$hide) {
      writeVarint32ZigZag(packed, value);
    }
    writeVarint32(bb, 74);
    writeVarint32(bb, packed.offset);
    writeByteBuffer(bb, packed);
    pushByteBuffer(packed);
  }

  // optional int64 uid = 10;
  let $uid = message.uid;
  if ($uid !== undefined) {
    writeVarint32(bb, 80);
    writeVarint64(bb, $uid);
  }

  // optional int64 power = 11;
  let $power = message.power;
  if ($power !== undefined) {
    writeVarint32(bb, 88);
    writeVarint64(bb, $power);
  }

  // optional int32 is_fight = 12;
  let $is_fight = message.is_fight;
  if ($is_fight !== undefined) {
    writeVarint32(bb, 96);
    writeVarint64(bb, intToLong($is_fight));
  }

  // optional string gname = 13;
  let $gname = message.gname;
  if ($gname !== undefined) {
    writeVarint32(bb, 106);
    writeString(bb, $gname);
  }
}

export function decodepb_qlt_pvp_enemy(binary) {
  return _decodepb_qlt_pvp_enemy(wrapByteBuffer(binary));
}

function _decodepb_qlt_pvp_enemy(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // optional sint32 idx = 1;
      case 1: {
        message.idx = readVarint32ZigZag(bb);
        break;
      }

      // optional int32 logo = 2;
      case 2: {
        message.logo = readVarint32(bb);
        break;
      }

      // optional string name = 3;
      case 3: {
        message.name = readString(bb, readVarint32(bb));
        break;
      }

      // optional string cluster = 4;
      case 4: {
        message.cluster = readString(bb, readVarint32(bb));
        break;
      }

      // optional int32 lv = 5;
      case 5: {
        message.lv = readVarint32(bb);
        break;
      }

      // optional int32 lbox = 6;
      case 6: {
        message.lbox = readVarint32(bb);
        break;
      }

      // repeated pb_unit camp = 7;
      case 7: {
        let limit = pushTemporaryLength(bb);
        let values = message.camp || (message.camp = []);
        values.push(_decodepb_unit(bb));
        bb.limit = limit;
        break;
      }

      // repeated sint32 skls = 8;
      case 8: {
        let values = message.skls || (message.skls = []);
        if ((tag & 7) === 2) {
          let outerLimit = pushTemporaryLength(bb);
          while (!isAtEnd(bb)) {
            values.push(readVarint32ZigZag(bb));
          }
          bb.limit = outerLimit;
        } else {
          values.push(readVarint32ZigZag(bb));
        }
        break;
      }

      // repeated sint32 hide = 9;
      case 9: {
        let values = message.hide || (message.hide = []);
        if ((tag & 7) === 2) {
          let outerLimit = pushTemporaryLength(bb);
          while (!isAtEnd(bb)) {
            values.push(readVarint32ZigZag(bb));
          }
          bb.limit = outerLimit;
        } else {
          values.push(readVarint32ZigZag(bb));
        }
        break;
      }

      // optional int64 uid = 10;
      case 10: {
        message.uid = readVarint64(bb, /* unsigned */ false);
        break;
      }

      // optional int64 power = 11;
      case 11: {
        message.power = readVarint64(bb, /* unsigned */ false);
        break;
      }

      // optional int32 is_fight = 12;
      case 12: {
        message.is_fight = readVarint32(bb);
        break;
      }

      // optional string gname = 13;
      case 13: {
        message.gname = readString(bb, readVarint32(bb));
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  return message;
}

export function encodepb_qloger(message) {
  let bb = popByteBuffer();
  _encodepb_qloger(message, bb);
  return toUint8Array(bb);
}

function _encodepb_qloger(message, bb) {
  // required int64 vid = 1;
  let $vid = message.vid;
  if ($vid !== undefined) {
    writeVarint32(bb, 8);
    writeVarint64(bb, $vid);
  }

  // optional pb_smbr a_mbr = 2;
  let $a_mbr = message.a_mbr;
  if ($a_mbr !== undefined) {
    writeVarint32(bb, 18);
    let nested = popByteBuffer();
    _encodepb_smbr($a_mbr, nested);
    writeVarint32(bb, nested.limit);
    writeByteBuffer(bb, nested);
    pushByteBuffer(nested);
  }

  // optional pb_smbr d_mbr = 3;
  let $d_mbr = message.d_mbr;
  if ($d_mbr !== undefined) {
    writeVarint32(bb, 26);
    let nested = popByteBuffer();
    _encodepb_smbr($d_mbr, nested);
    writeVarint32(bb, nested.limit);
    writeByteBuffer(bb, nested);
    pushByteBuffer(nested);
  }

  // optional int32 time = 4;
  let $time = message.time;
  if ($time !== undefined) {
    writeVarint32(bb, 32);
    writeVarint64(bb, intToLong($time));
  }

  // optional bool win = 5;
  let $win = message.win;
  if ($win !== undefined) {
    writeVarint32(bb, 40);
    writeByte(bb, $win ? 1 : 0);
  }

  // optional sint32 delta = 6;
  let $delta = message.delta;
  if ($delta !== undefined) {
    writeVarint32(bb, 48);
    writeVarint32ZigZag(bb, $delta);
  }

  // repeated sint32 a_skls = 7;
  let array$a_skls = message.a_skls;
  if (array$a_skls !== undefined) {
    let packed = popByteBuffer();
    for (let value of array$a_skls) {
      writeVarint32ZigZag(packed, value);
    }
    writeVarint32(bb, 58);
    writeVarint32(bb, packed.offset);
    writeByteBuffer(bb, packed);
    pushByteBuffer(packed);
  }

  // repeated sint32 d_skls = 8;
  let array$d_skls = message.d_skls;
  if (array$d_skls !== undefined) {
    let packed = popByteBuffer();
    for (let value of array$d_skls) {
      writeVarint32ZigZag(packed, value);
    }
    writeVarint32(bb, 66);
    writeVarint32(bb, packed.offset);
    writeByteBuffer(bb, packed);
    pushByteBuffer(packed);
  }
}

export function decodepb_qloger(binary) {
  return _decodepb_qloger(wrapByteBuffer(binary));
}

function _decodepb_qloger(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // required int64 vid = 1;
      case 1: {
        message.vid = readVarint64(bb, /* unsigned */ false);
        break;
      }

      // optional pb_smbr a_mbr = 2;
      case 2: {
        let limit = pushTemporaryLength(bb);
        message.a_mbr = _decodepb_smbr(bb);
        bb.limit = limit;
        break;
      }

      // optional pb_smbr d_mbr = 3;
      case 3: {
        let limit = pushTemporaryLength(bb);
        message.d_mbr = _decodepb_smbr(bb);
        bb.limit = limit;
        break;
      }

      // optional int32 time = 4;
      case 4: {
        message.time = readVarint32(bb);
        break;
      }

      // optional bool win = 5;
      case 5: {
        message.win = !!readByte(bb);
        break;
      }

      // optional sint32 delta = 6;
      case 6: {
        message.delta = readVarint32ZigZag(bb);
        break;
      }

      // repeated sint32 a_skls = 7;
      case 7: {
        let values = message.a_skls || (message.a_skls = []);
        if ((tag & 7) === 2) {
          let outerLimit = pushTemporaryLength(bb);
          while (!isAtEnd(bb)) {
            values.push(readVarint32ZigZag(bb));
          }
          bb.limit = outerLimit;
        } else {
          values.push(readVarint32ZigZag(bb));
        }
        break;
      }

      // repeated sint32 d_skls = 8;
      case 8: {
        let values = message.d_skls || (message.d_skls = []);
        if ((tag & 7) === 2) {
          let outerLimit = pushTemporaryLength(bb);
          while (!isAtEnd(bb)) {
            values.push(readVarint32ZigZag(bb));
          }
          bb.limit = outerLimit;
        } else {
          values.push(readVarint32ZigZag(bb));
        }
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  if (message.vid === undefined)
    throw new Error("Missing required field: vid");

  return message;
}

export function encodepb_qvideo(message) {
  let bb = popByteBuffer();
  _encodepb_qvideo(message, bb);
  return toUint8Array(bb);
}

function _encodepb_qvideo(message, bb) {
  // repeated pb_unit atk = 1;
  let array$atk = message.atk;
  if (array$atk !== undefined) {
    for (let value of array$atk) {
      writeVarint32(bb, 10);
      let nested = popByteBuffer();
      _encodepb_unit(value, nested);
      writeVarint32(bb, nested.limit);
      writeByteBuffer(bb, nested);
      pushByteBuffer(nested);
    }
  }

  // repeated pb_unit def = 2;
  let array$def = message.def;
  if (array$def !== undefined) {
    for (let value of array$def) {
      writeVarint32(bb, 18);
      let nested = popByteBuffer();
      _encodepb_unit(value, nested);
      writeVarint32(bb, nested.limit);
      writeByteBuffer(bb, nested);
      pushByteBuffer(nested);
    }
  }

  // repeated bytes frames = 3;
  let array$frames = message.frames;
  if (array$frames !== undefined) {
    for (let value of array$frames) {
      writeVarint32(bb, 26);
      writeVarint32(bb, value.length), writeBytes(bb, value);
    }
  }

  // repeated pb_hurts hurts = 4;
  let array$hurts = message.hurts;
  if (array$hurts !== undefined) {
    for (let value of array$hurts) {
      writeVarint32(bb, 34);
      let nested = popByteBuffer();
      _encodepb_hurts(value, nested);
      writeVarint32(bb, nested.limit);
      writeByteBuffer(bb, nested);
      pushByteBuffer(nested);
    }
  }

  // required bool win = 5;
  let $win = message.win;
  if ($win !== undefined) {
    writeVarint32(bb, 40);
    writeByte(bb, $win ? 1 : 0);
  }
}

export function decodepb_qvideo(binary) {
  return _decodepb_qvideo(wrapByteBuffer(binary));
}

function _decodepb_qvideo(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // repeated pb_unit atk = 1;
      case 1: {
        let limit = pushTemporaryLength(bb);
        let values = message.atk || (message.atk = []);
        values.push(_decodepb_unit(bb));
        bb.limit = limit;
        break;
      }

      // repeated pb_unit def = 2;
      case 2: {
        let limit = pushTemporaryLength(bb);
        let values = message.def || (message.def = []);
        values.push(_decodepb_unit(bb));
        bb.limit = limit;
        break;
      }

      // repeated bytes frames = 3;
      case 3: {
        let values = message.frames || (message.frames = []);
        values.push(readBytes(bb, readVarint32(bb)));
        break;
      }

      // repeated pb_hurts hurts = 4;
      case 4: {
        let limit = pushTemporaryLength(bb);
        let values = message.hurts || (message.hurts = []);
        values.push(_decodepb_hurts(bb));
        bb.limit = limit;
        break;
      }

      // required bool win = 5;
      case 5: {
        message.win = !!readByte(bb);
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  if (message.win === undefined)
    throw new Error("Missing required field: win");

  return message;
}

export function encodepb_qlog(message) {
  let bb = popByteBuffer();
  _encodepb_qlog(message, bb);
  return toUint8Array(bb);
}

function _encodepb_qlog(message, bb) {
  // repeated pb_qvideo video = 1;
  let array$video = message.video;
  if (array$video !== undefined) {
    for (let value of array$video) {
      writeVarint32(bb, 10);
      let nested = popByteBuffer();
      _encodepb_qvideo(value, nested);
      writeVarint32(bb, nested.limit);
      writeByteBuffer(bb, nested);
      pushByteBuffer(nested);
    }
  }

  // optional pb_smbr a_mbr = 2;
  let $a_mbr = message.a_mbr;
  if ($a_mbr !== undefined) {
    writeVarint32(bb, 18);
    let nested = popByteBuffer();
    _encodepb_smbr($a_mbr, nested);
    writeVarint32(bb, nested.limit);
    writeByteBuffer(bb, nested);
    pushByteBuffer(nested);
  }

  // optional pb_smbr d_mbr = 3;
  let $d_mbr = message.d_mbr;
  if ($d_mbr !== undefined) {
    writeVarint32(bb, 26);
    let nested = popByteBuffer();
    _encodepb_smbr($d_mbr, nested);
    writeVarint32(bb, nested.limit);
    writeByteBuffer(bb, nested);
    pushByteBuffer(nested);
  }

  // optional int32 time = 4;
  let $time = message.time;
  if ($time !== undefined) {
    writeVarint32(bb, 32);
    writeVarint64(bb, intToLong($time));
  }

  // optional bool win = 5;
  let $win = message.win;
  if ($win !== undefined) {
    writeVarint32(bb, 40);
    writeByte(bb, $win ? 1 : 0);
  }

  // optional sint32 delta = 6;
  let $delta = message.delta;
  if ($delta !== undefined) {
    writeVarint32(bb, 48);
    writeVarint32ZigZag(bb, $delta);
  }

  // repeated sint32 a_skls = 7;
  let array$a_skls = message.a_skls;
  if (array$a_skls !== undefined) {
    let packed = popByteBuffer();
    for (let value of array$a_skls) {
      writeVarint32ZigZag(packed, value);
    }
    writeVarint32(bb, 58);
    writeVarint32(bb, packed.offset);
    writeByteBuffer(bb, packed);
    pushByteBuffer(packed);
  }

  // repeated sint32 d_skls = 8;
  let array$d_skls = message.d_skls;
  if (array$d_skls !== undefined) {
    let packed = popByteBuffer();
    for (let value of array$d_skls) {
      writeVarint32ZigZag(packed, value);
    }
    writeVarint32(bb, 66);
    writeVarint32(bb, packed.offset);
    writeByteBuffer(bb, packed);
    pushByteBuffer(packed);
  }
}

export function decodepb_qlog(binary) {
  return _decodepb_qlog(wrapByteBuffer(binary));
}

function _decodepb_qlog(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // repeated pb_qvideo video = 1;
      case 1: {
        let limit = pushTemporaryLength(bb);
        let values = message.video || (message.video = []);
        values.push(_decodepb_qvideo(bb));
        bb.limit = limit;
        break;
      }

      // optional pb_smbr a_mbr = 2;
      case 2: {
        let limit = pushTemporaryLength(bb);
        message.a_mbr = _decodepb_smbr(bb);
        bb.limit = limit;
        break;
      }

      // optional pb_smbr d_mbr = 3;
      case 3: {
        let limit = pushTemporaryLength(bb);
        message.d_mbr = _decodepb_smbr(bb);
        bb.limit = limit;
        break;
      }

      // optional int32 time = 4;
      case 4: {
        message.time = readVarint32(bb);
        break;
      }

      // optional bool win = 5;
      case 5: {
        message.win = !!readByte(bb);
        break;
      }

      // optional sint32 delta = 6;
      case 6: {
        message.delta = readVarint32ZigZag(bb);
        break;
      }

      // repeated sint32 a_skls = 7;
      case 7: {
        let values = message.a_skls || (message.a_skls = []);
        if ((tag & 7) === 2) {
          let outerLimit = pushTemporaryLength(bb);
          while (!isAtEnd(bb)) {
            values.push(readVarint32ZigZag(bb));
          }
          bb.limit = outerLimit;
        } else {
          values.push(readVarint32ZigZag(bb));
        }
        break;
      }

      // repeated sint32 d_skls = 8;
      case 8: {
        let values = message.d_skls || (message.d_skls = []);
        if ((tag & 7) === 2) {
          let outerLimit = pushTemporaryLength(bb);
          while (!isAtEnd(bb)) {
            values.push(readVarint32ZigZag(bb));
          }
          bb.limit = outerLimit;
        } else {
          values.push(readVarint32ZigZag(bb));
        }
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  return message;
}

export function encodepower_rank(message) {
  let bb = popByteBuffer();
  _encodepower_rank(message, bb);
  return toUint8Array(bb);
}

function _encodepower_rank(message, bb) {
  // optional uint32 id = 1;
  let $id = message.id;
  if ($id !== undefined) {
    writeVarint32(bb, 8);
    writeVarint32(bb, $id);
  }

  // optional pb_give_role player = 2;
  let $player = message.player;
  if ($player !== undefined) {
    writeVarint32(bb, 18);
    let nested = popByteBuffer();
    _encodepb_give_role($player, nested);
    writeVarint32(bb, nested.limit);
    writeByteBuffer(bb, nested);
    pushByteBuffer(nested);
  }

  // optional int32 score = 3;
  let $score = message.score;
  if ($score !== undefined) {
    writeVarint32(bb, 24);
    writeVarint64(bb, intToLong($score));
  }
}

export function decodepower_rank(binary) {
  return _decodepower_rank(wrapByteBuffer(binary));
}

function _decodepower_rank(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // optional uint32 id = 1;
      case 1: {
        message.id = readVarint32(bb) >>> 0;
        break;
      }

      // optional pb_give_role player = 2;
      case 2: {
        let limit = pushTemporaryLength(bb);
        message.player = _decodepb_give_role(bb);
        bb.limit = limit;
        break;
      }

      // optional int32 score = 3;
      case 3: {
        message.score = readVarint32(bb);
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  return message;
}

export function encodepower_task(message) {
  let bb = popByteBuffer();
  _encodepower_task(message, bb);
  return toUint8Array(bb);
}

function _encodepower_task(message, bb) {
  // required uint32 id = 1;
  let $id = message.id;
  if ($id !== undefined) {
    writeVarint32(bb, 8);
    writeVarint32(bb, $id);
  }

  // optional uint32 type = 2;
  let $type = message.type;
  if ($type !== undefined) {
    writeVarint32(bb, 16);
    writeVarint32(bb, $type);
  }

  // optional int32 cd = 3;
  let $cd = message.cd;
  if ($cd !== undefined) {
    writeVarint32(bb, 24);
    writeVarint64(bb, intToLong($cd));
  }

  // optional int32 num = 4;
  let $num = message.num;
  if ($num !== undefined) {
    writeVarint32(bb, 32);
    writeVarint64(bb, intToLong($num));
  }

  // optional uint32 dot_id = 5;
  let $dot_id = message.dot_id;
  if ($dot_id !== undefined) {
    writeVarint32(bb, 40);
    writeVarint32(bb, $dot_id);
  }

  // optional uint32 flag = 6;
  let $flag = message.flag;
  if ($flag !== undefined) {
    writeVarint32(bb, 48);
    writeVarint32(bb, $flag);
  }
}

export function decodepower_task(binary) {
  return _decodepower_task(wrapByteBuffer(binary));
}

function _decodepower_task(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // required uint32 id = 1;
      case 1: {
        message.id = readVarint32(bb) >>> 0;
        break;
      }

      // optional uint32 type = 2;
      case 2: {
        message.type = readVarint32(bb) >>> 0;
        break;
      }

      // optional int32 cd = 3;
      case 3: {
        message.cd = readVarint32(bb);
        break;
      }

      // optional int32 num = 4;
      case 4: {
        message.num = readVarint32(bb);
        break;
      }

      // optional uint32 dot_id = 5;
      case 5: {
        message.dot_id = readVarint32(bb) >>> 0;
        break;
      }

      // optional uint32 flag = 6;
      case 6: {
        message.flag = readVarint32(bb) >>> 0;
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  if (message.id === undefined)
    throw new Error("Missing required field: id");

  return message;
}

export function encodedot_info(message) {
  let bb = popByteBuffer();
  _encodedot_info(message, bb);
  return toUint8Array(bb);
}

function _encodedot_info(message, bb) {
  // optional uint32 id = 1;
  let $id = message.id;
  if ($id !== undefined) {
    writeVarint32(bb, 8);
    writeVarint32(bb, $id);
  }

  // optional uint32 power_id = 2;
  let $power_id = message.power_id;
  if ($power_id !== undefined) {
    writeVarint32(bb, 16);
    writeVarint32(bb, $power_id);
  }

  // optional int32 degree = 3;
  let $degree = message.degree;
  if ($degree !== undefined) {
    writeVarint32(bb, 24);
    writeVarint64(bb, intToLong($degree));
  }

  // optional int32 max = 4;
  let $max = message.max;
  if ($max !== undefined) {
    writeVarint32(bb, 32);
    writeVarint64(bb, intToLong($max));
  }

  // optional uint32 status = 5;
  let $status = message.status;
  if ($status !== undefined) {
    writeVarint32(bb, 40);
    writeVarint32(bb, $status);
  }

  // optional int32 item = 6;
  let $item = message.item;
  if ($item !== undefined) {
    writeVarint32(bb, 48);
    writeVarint64(bb, intToLong($item));
  }

  // repeated pb_item buff = 7;
  let array$buff = message.buff;
  if (array$buff !== undefined) {
    for (let value of array$buff) {
      writeVarint32(bb, 58);
      let nested = popByteBuffer();
      _encodepb_item(value, nested);
      writeVarint32(bb, nested.limit);
      writeByteBuffer(bb, nested);
      pushByteBuffer(nested);
    }
  }

  // optional int32 tmp_id = 8;
  let $tmp_id = message.tmp_id;
  if ($tmp_id !== undefined) {
    writeVarint32(bb, 64);
    writeVarint64(bb, intToLong($tmp_id));
  }

  // repeated int32 skill = 9;
  let array$skill = message.skill;
  if (array$skill !== undefined) {
    let packed = popByteBuffer();
    for (let value of array$skill) {
      writeVarint64(packed, intToLong(value));
    }
    writeVarint32(bb, 74);
    writeVarint32(bb, packed.offset);
    writeByteBuffer(bb, packed);
    pushByteBuffer(packed);
  }

  // optional int32 cd = 10;
  let $cd = message.cd;
  if ($cd !== undefined) {
    writeVarint32(bb, 80);
    writeVarint64(bb, intToLong($cd));
  }

  // optional int32 cd2 = 11;
  let $cd2 = message.cd2;
  if ($cd2 !== undefined) {
    writeVarint32(bb, 88);
    writeVarint64(bb, intToLong($cd2));
  }

  // optional int32 cd3 = 12;
  let $cd3 = message.cd3;
  if ($cd3 !== undefined) {
    writeVarint32(bb, 96);
    writeVarint64(bb, intToLong($cd3));
  }

  // optional int32 cd4 = 13;
  let $cd4 = message.cd4;
  if ($cd4 !== undefined) {
    writeVarint32(bb, 104);
    writeVarint64(bb, intToLong($cd4));
  }

  // optional int32 cd5 = 14;
  let $cd5 = message.cd5;
  if ($cd5 !== undefined) {
    writeVarint32(bb, 112);
    writeVarint64(bb, intToLong($cd5));
  }
}

export function decodedot_info(binary) {
  return _decodedot_info(wrapByteBuffer(binary));
}

function _decodedot_info(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // optional uint32 id = 1;
      case 1: {
        message.id = readVarint32(bb) >>> 0;
        break;
      }

      // optional uint32 power_id = 2;
      case 2: {
        message.power_id = readVarint32(bb) >>> 0;
        break;
      }

      // optional int32 degree = 3;
      case 3: {
        message.degree = readVarint32(bb);
        break;
      }

      // optional int32 max = 4;
      case 4: {
        message.max = readVarint32(bb);
        break;
      }

      // optional uint32 status = 5;
      case 5: {
        message.status = readVarint32(bb) >>> 0;
        break;
      }

      // optional int32 item = 6;
      case 6: {
        message.item = readVarint32(bb);
        break;
      }

      // repeated pb_item buff = 7;
      case 7: {
        let limit = pushTemporaryLength(bb);
        let values = message.buff || (message.buff = []);
        values.push(_decodepb_item(bb));
        bb.limit = limit;
        break;
      }

      // optional int32 tmp_id = 8;
      case 8: {
        message.tmp_id = readVarint32(bb);
        break;
      }

      // repeated int32 skill = 9;
      case 9: {
        let values = message.skill || (message.skill = []);
        if ((tag & 7) === 2) {
          let outerLimit = pushTemporaryLength(bb);
          while (!isAtEnd(bb)) {
            values.push(readVarint32(bb));
          }
          bb.limit = outerLimit;
        } else {
          values.push(readVarint32(bb));
        }
        break;
      }

      // optional int32 cd = 10;
      case 10: {
        message.cd = readVarint32(bb);
        break;
      }

      // optional int32 cd2 = 11;
      case 11: {
        message.cd2 = readVarint32(bb);
        break;
      }

      // optional int32 cd3 = 12;
      case 12: {
        message.cd3 = readVarint32(bb);
        break;
      }

      // optional int32 cd4 = 13;
      case 13: {
        message.cd4 = readVarint32(bb);
        break;
      }

      // optional int32 cd5 = 14;
      case 14: {
        message.cd5 = readVarint32(bb);
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  return message;
}

export function encodedot_log(message) {
  let bb = popByteBuffer();
  _encodedot_log(message, bb);
  return toUint8Array(bb);
}

function _encodedot_log(message, bb) {
  // optional uint32 type = 1;
  let $type = message.type;
  if ($type !== undefined) {
    writeVarint32(bb, 8);
    writeVarint32(bb, $type);
  }

  // optional int32 degree = 2;
  let $degree = message.degree;
  if ($degree !== undefined) {
    writeVarint32(bb, 16);
    writeVarint64(bb, intToLong($degree));
  }

  // optional string time = 3;
  let $time = message.time;
  if ($time !== undefined) {
    writeVarint32(bb, 26);
    writeString(bb, $time);
  }

  // optional int32 id = 4;
  let $id = message.id;
  if ($id !== undefined) {
    writeVarint32(bb, 32);
    writeVarint64(bb, intToLong($id));
  }

  // optional int32 add = 5;
  let $add = message.add;
  if ($add !== undefined) {
    writeVarint32(bb, 40);
    writeVarint64(bb, intToLong($add));
  }
}

export function decodedot_log(binary) {
  return _decodedot_log(wrapByteBuffer(binary));
}

function _decodedot_log(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // optional uint32 type = 1;
      case 1: {
        message.type = readVarint32(bb) >>> 0;
        break;
      }

      // optional int32 degree = 2;
      case 2: {
        message.degree = readVarint32(bb);
        break;
      }

      // optional string time = 3;
      case 3: {
        message.time = readString(bb, readVarint32(bb));
        break;
      }

      // optional int32 id = 4;
      case 4: {
        message.id = readVarint32(bb);
        break;
      }

      // optional int32 add = 5;
      case 5: {
        message.add = readVarint32(bb);
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  return message;
}

export function encodepower_monster(message) {
  let bb = popByteBuffer();
  _encodepower_monster(message, bb);
  return toUint8Array(bb);
}

function _encodepower_monster(message, bb) {
  // required int32 id = 1;
  let $id = message.id;
  if ($id !== undefined) {
    writeVarint32(bb, 8);
    writeVarint64(bb, intToLong($id));
  }

  // repeated pb_unit camp = 2;
  let array$camp = message.camp;
  if (array$camp !== undefined) {
    for (let value of array$camp) {
      writeVarint32(bb, 18);
      let nested = popByteBuffer();
      _encodepb_unit(value, nested);
      writeVarint32(bb, nested.limit);
      writeByteBuffer(bb, nested);
      pushByteBuffer(nested);
    }
  }

  // repeated int32 buff = 3;
  let array$buff = message.buff;
  if (array$buff !== undefined) {
    let packed = popByteBuffer();
    for (let value of array$buff) {
      writeVarint64(packed, intToLong(value));
    }
    writeVarint32(bb, 26);
    writeVarint32(bb, packed.offset);
    writeByteBuffer(bb, packed);
    pushByteBuffer(packed);
  }
}

export function decodepower_monster(binary) {
  return _decodepower_monster(wrapByteBuffer(binary));
}

function _decodepower_monster(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // required int32 id = 1;
      case 1: {
        message.id = readVarint32(bb);
        break;
      }

      // repeated pb_unit camp = 2;
      case 2: {
        let limit = pushTemporaryLength(bb);
        let values = message.camp || (message.camp = []);
        values.push(_decodepb_unit(bb));
        bb.limit = limit;
        break;
      }

      // repeated int32 buff = 3;
      case 3: {
        let values = message.buff || (message.buff = []);
        if ((tag & 7) === 2) {
          let outerLimit = pushTemporaryLength(bb);
          while (!isAtEnd(bb)) {
            values.push(readVarint32(bb));
          }
          bb.limit = outerLimit;
        } else {
          values.push(readVarint32(bb));
        }
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  if (message.id === undefined)
    throw new Error("Missing required field: id");

  return message;
}

export function encodepower_skill(message) {
  let bb = popByteBuffer();
  _encodepower_skill(message, bb);
  return toUint8Array(bb);
}

function _encodepower_skill(message, bb) {
  // required int32 id = 1;
  let $id = message.id;
  if ($id !== undefined) {
    writeVarint32(bb, 8);
    writeVarint64(bb, intToLong($id));
  }

  // optional string name = 2;
  let $name = message.name;
  if ($name !== undefined) {
    writeVarint32(bb, 18);
    writeString(bb, $name);
  }

  // repeated int32 skill = 3;
  let array$skill = message.skill;
  if (array$skill !== undefined) {
    let packed = popByteBuffer();
    for (let value of array$skill) {
      writeVarint64(packed, intToLong(value));
    }
    writeVarint32(bb, 26);
    writeVarint32(bb, packed.offset);
    writeByteBuffer(bb, packed);
    pushByteBuffer(packed);
  }

  // optional int32 cd = 4;
  let $cd = message.cd;
  if ($cd !== undefined) {
    writeVarint32(bb, 32);
    writeVarint64(bb, intToLong($cd));
  }
}

export function decodepower_skill(binary) {
  return _decodepower_skill(wrapByteBuffer(binary));
}

function _decodepower_skill(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // required int32 id = 1;
      case 1: {
        message.id = readVarint32(bb);
        break;
      }

      // optional string name = 2;
      case 2: {
        message.name = readString(bb, readVarint32(bb));
        break;
      }

      // repeated int32 skill = 3;
      case 3: {
        let values = message.skill || (message.skill = []);
        if ((tag & 7) === 2) {
          let outerLimit = pushTemporaryLength(bb);
          while (!isAtEnd(bb)) {
            values.push(readVarint32(bb));
          }
          bb.limit = outerLimit;
        } else {
          values.push(readVarint32(bb));
        }
        break;
      }

      // optional int32 cd = 4;
      case 4: {
        message.cd = readVarint32(bb);
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  if (message.id === undefined)
    throw new Error("Missing required field: id");

  return message;
}

export function encodepower_manager(message) {
  let bb = popByteBuffer();
  _encodepower_manager(message, bb);
  return toUint8Array(bb);
}

function _encodepower_manager(message, bb) {
  // optional string udk = 1;
  let $udk = message.udk;
  if ($udk !== undefined) {
    writeVarint32(bb, 10);
    writeString(bb, $udk);
  }

  // optional string cluster = 2;
  let $cluster = message.cluster;
  if ($cluster !== undefined) {
    writeVarint32(bb, 18);
    writeString(bb, $cluster);
  }

  // optional int64 uid = 3;
  let $uid = message.uid;
  if ($uid !== undefined) {
    writeVarint32(bb, 24);
    writeVarint64(bb, $uid);
  }
}

export function decodepower_manager(binary) {
  return _decodepower_manager(wrapByteBuffer(binary));
}

function _decodepower_manager(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // optional string udk = 1;
      case 1: {
        message.udk = readString(bb, readVarint32(bb));
        break;
      }

      // optional string cluster = 2;
      case 2: {
        message.cluster = readString(bb, readVarint32(bb));
        break;
      }

      // optional int64 uid = 3;
      case 3: {
        message.uid = readVarint64(bb, /* unsigned */ false);
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  return message;
}

export function encodestower_breed(message) {
  let bb = popByteBuffer();
  _encodestower_breed(message, bb);
  return toUint8Array(bb);
}

function _encodestower_breed(message, bb) {
  // required sint32 id = 1;
  let $id = message.id;
  if ($id !== undefined) {
    writeVarint32(bb, 8);
    writeVarint32ZigZag(bb, $id);
  }

  // required sint32 pid1 = 2;
  let $pid1 = message.pid1;
  if ($pid1 !== undefined) {
    writeVarint32(bb, 16);
    writeVarint32ZigZag(bb, $pid1);
  }

  // required sint32 pid2 = 3;
  let $pid2 = message.pid2;
  if ($pid2 !== undefined) {
    writeVarint32(bb, 24);
    writeVarint32ZigZag(bb, $pid2);
  }

  // required int32 cd = 4;
  let $cd = message.cd;
  if ($cd !== undefined) {
    writeVarint32(bb, 32);
    writeVarint64(bb, intToLong($cd));
  }

  // required sint32 egg = 5;
  let $egg = message.egg;
  if ($egg !== undefined) {
    writeVarint32(bb, 40);
    writeVarint32ZigZag(bb, $egg);
  }
}

export function decodestower_breed(binary) {
  return _decodestower_breed(wrapByteBuffer(binary));
}

function _decodestower_breed(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // required sint32 id = 1;
      case 1: {
        message.id = readVarint32ZigZag(bb);
        break;
      }

      // required sint32 pid1 = 2;
      case 2: {
        message.pid1 = readVarint32ZigZag(bb);
        break;
      }

      // required sint32 pid2 = 3;
      case 3: {
        message.pid2 = readVarint32ZigZag(bb);
        break;
      }

      // required int32 cd = 4;
      case 4: {
        message.cd = readVarint32(bb);
        break;
      }

      // required sint32 egg = 5;
      case 5: {
        message.egg = readVarint32ZigZag(bb);
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  if (message.id === undefined)
    throw new Error("Missing required field: id");

  if (message.pid1 === undefined)
    throw new Error("Missing required field: pid1");

  if (message.pid2 === undefined)
    throw new Error("Missing required field: pid2");

  if (message.cd === undefined)
    throw new Error("Missing required field: cd");

  if (message.egg === undefined)
    throw new Error("Missing required field: egg");

  return message;
}

export function encodestower_lucky(message) {
  let bb = popByteBuffer();
  _encodestower_lucky(message, bb);
  return toUint8Array(bb);
}

function _encodestower_lucky(message, bb) {
  // required sint32 id = 1;
  let $id = message.id;
  if ($id !== undefined) {
    writeVarint32(bb, 8);
    writeVarint32ZigZag(bb, $id);
  }

  // repeated sint32 ratio = 2;
  let array$ratio = message.ratio;
  if (array$ratio !== undefined) {
    let packed = popByteBuffer();
    for (let value of array$ratio) {
      writeVarint32ZigZag(packed, value);
    }
    writeVarint32(bb, 18);
    writeVarint32(bb, packed.offset);
    writeByteBuffer(bb, packed);
    pushByteBuffer(packed);
  }
}

export function decodestower_lucky(binary) {
  return _decodestower_lucky(wrapByteBuffer(binary));
}

function _decodestower_lucky(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // required sint32 id = 1;
      case 1: {
        message.id = readVarint32ZigZag(bb);
        break;
      }

      // repeated sint32 ratio = 2;
      case 2: {
        let values = message.ratio || (message.ratio = []);
        if ((tag & 7) === 2) {
          let outerLimit = pushTemporaryLength(bb);
          while (!isAtEnd(bb)) {
            values.push(readVarint32ZigZag(bb));
          }
          bb.limit = outerLimit;
        } else {
          values.push(readVarint32ZigZag(bb));
        }
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  if (message.id === undefined)
    throw new Error("Missing required field: id");

  return message;
}

export function encodepower_log(message) {
  let bb = popByteBuffer();
  _encodepower_log(message, bb);
  return toUint8Array(bb);
}

function _encodepower_log(message, bb) {
  // optional uint32 type = 1;
  let $type = message.type;
  if ($type !== undefined) {
    writeVarint32(bb, 8);
    writeVarint32(bb, $type);
  }

  // optional int32 job = 2;
  let $job = message.job;
  if ($job !== undefined) {
    writeVarint32(bb, 16);
    writeVarint64(bb, intToLong($job));
  }

  // optional string time = 3;
  let $time = message.time;
  if ($time !== undefined) {
    writeVarint32(bb, 26);
    writeString(bb, $time);
  }

  // optional string name = 4;
  let $name = message.name;
  if ($name !== undefined) {
    writeVarint32(bb, 34);
    writeString(bb, $name);
  }

  // optional int32 point = 5;
  let $point = message.point;
  if ($point !== undefined) {
    writeVarint32(bb, 40);
    writeVarint64(bb, intToLong($point));
  }

  // optional int32 buff = 6;
  let $buff = message.buff;
  if ($buff !== undefined) {
    writeVarint32(bb, 48);
    writeVarint64(bb, intToLong($buff));
  }
}

export function decodepower_log(binary) {
  return _decodepower_log(wrapByteBuffer(binary));
}

function _decodepower_log(bb) {
  let message = {};

  end_of_message: while (!isAtEnd(bb)) {
    let tag = readVarint32(bb);

    switch (tag >>> 3) {
      case 0:
        break end_of_message;

      // optional uint32 type = 1;
      case 1: {
        message.type = readVarint32(bb) >>> 0;
        break;
      }

      // optional int32 job = 2;
      case 2: {
        message.job = readVarint32(bb);
        break;
      }

      // optional string time = 3;
      case 3: {
        message.time = readString(bb, readVarint32(bb));
        break;
      }

      // optional string name = 4;
      case 4: {
        message.name = readString(bb, readVarint32(bb));
        break;
      }

      // optional int32 point = 5;
      case 5: {
        message.point = readVarint32(bb);
        break;
      }

      // optional int32 buff = 6;
      case 6: {
        message.buff = readVarint32(bb);
        break;
      }

      default:
        skipUnknownField(bb, tag & 7);
    }
  }

  return message;
}

function pushTemporaryLength(bb) {
  let length = readVarint32(bb);
  let limit = bb.limit;
  bb.limit = bb.offset + length;
  return limit;
}

function skipUnknownField(bb, type) {
  switch (type) {
    case 0: while (readByte(bb) & 0x80) { } break;
    case 2: skip(bb, readVarint32(bb)); break;
    case 5: skip(bb, 4); break;
    case 1: skip(bb, 8); break;
    default: throw new Error("Unimplemented type: " + type);
  }
}

function stringToLong(value) {
  return {
    low: value.charCodeAt(0) | (value.charCodeAt(1) << 16),
    high: value.charCodeAt(2) | (value.charCodeAt(3) << 16),
    unsigned: false,
  };
}

function longToString(value) {
  let low = value.low;
  let high = value.high;
  return String.fromCharCode(
    low & 0xFFFF,
    low >>> 16,
    high & 0xFFFF,
    high >>> 16);
}

// The code below was modified from https://github.com/protobufjs/bytebuffer.js
// which is under the Apache License 2.0.

let f32 = new Float32Array(1);
let f32_u8 = new Uint8Array(f32.buffer);

let f64 = new Float64Array(1);
let f64_u8 = new Uint8Array(f64.buffer);

function intToLong(value) {
  value |= 0;
  return {
    low: value,
    high: value >> 31,
    unsigned: value >= 0,
  };
}

let bbStack = [];

function popByteBuffer() {
  const bb = bbStack.pop();
  if (!bb) return { bytes: new Uint8Array(64), offset: 0, limit: 0 };
  bb.offset = bb.limit = 0;
  return bb;
}

function pushByteBuffer(bb) {
  bbStack.push(bb);
}

function wrapByteBuffer(bytes) {
  return { bytes, offset: 0, limit: bytes.length };
}

function toUint8Array(bb) {
  let bytes = bb.bytes;
  let limit = bb.limit;
  return bytes.length === limit ? bytes : bytes.subarray(0, limit);
}

function skip(bb, offset) {
  if (bb.offset + offset > bb.limit) {
    throw new Error('Skip past limit');
  }
  bb.offset += offset;
}

function isAtEnd(bb) {
  return bb.offset >= bb.limit;
}

function grow(bb, count) {
  let bytes = bb.bytes;
  let offset = bb.offset;
  let limit = bb.limit;
  let finalOffset = offset + count;
  if (finalOffset > bytes.length) {
    let newBytes = new Uint8Array(finalOffset * 2);
    newBytes.set(bytes);
    bb.bytes = newBytes;
  }
  bb.offset = finalOffset;
  if (finalOffset > limit) {
    bb.limit = finalOffset;
  }
  return offset;
}

function advance(bb, count) {
  let offset = bb.offset;
  if (offset + count > bb.limit) {
    throw new Error('Read past limit');
  }
  bb.offset += count;
  return offset;
}

function readBytes(bb, count) {
  let offset = advance(bb, count);
  return bb.bytes.subarray(offset, offset + count);
}

function writeBytes(bb, buffer) {
  let offset = grow(bb, buffer.length);
  bb.bytes.set(buffer, offset);
}

function readString(bb, count) {
  // Sadly a hand-coded UTF8 decoder is much faster than subarray+TextDecoder in V8
  let offset = advance(bb, count);
  let fromCharCode = String.fromCharCode;
  let bytes = bb.bytes;
  let invalid = '\uFFFD';
  let text = '';

  for (let i = 0; i < count; i++) {
    let c1 = bytes[i + offset], c2, c3, c4, c;

    // 1 byte
    if ((c1 & 0x80) === 0) {
      text += fromCharCode(c1);
    }

    // 2 bytes
    else if ((c1 & 0xE0) === 0xC0) {
      if (i + 1 >= count) text += invalid;
      else {
        c2 = bytes[i + offset + 1];
        if ((c2 & 0xC0) !== 0x80) text += invalid;
        else {
          c = ((c1 & 0x1F) << 6) | (c2 & 0x3F);
          if (c < 0x80) text += invalid;
          else {
            text += fromCharCode(c);
            i++;
          }
        }
      }
    }

    // 3 bytes
    else if ((c1 & 0xF0) == 0xE0) {
      if (i + 2 >= count) text += invalid;
      else {
        c2 = bytes[i + offset + 1];
        c3 = bytes[i + offset + 2];
        if (((c2 | (c3 << 8)) & 0xC0C0) !== 0x8080) text += invalid;
        else {
          c = ((c1 & 0x0F) << 12) | ((c2 & 0x3F) << 6) | (c3 & 0x3F);
          if (c < 0x0800 || (c >= 0xD800 && c <= 0xDFFF)) text += invalid;
          else {
            text += fromCharCode(c);
            i += 2;
          }
        }
      }
    }

    // 4 bytes
    else if ((c1 & 0xF8) == 0xF0) {
      if (i + 3 >= count) text += invalid;
      else {
        c2 = bytes[i + offset + 1];
        c3 = bytes[i + offset + 2];
        c4 = bytes[i + offset + 3];
        if (((c2 | (c3 << 8) | (c4 << 16)) & 0xC0C0C0) !== 0x808080) text += invalid;
        else {
          c = ((c1 & 0x07) << 0x12) | ((c2 & 0x3F) << 0x0C) | ((c3 & 0x3F) << 0x06) | (c4 & 0x3F);
          if (c < 0x10000 || c > 0x10FFFF) text += invalid;
          else {
            c -= 0x10000;
            text += fromCharCode((c >> 10) + 0xD800, (c & 0x3FF) + 0xDC00);
            i += 3;
          }
        }
      }
    }

    else text += invalid;
  }

  return text;
}

function writeString(bb, text) {
  // Sadly a hand-coded UTF8 encoder is much faster than TextEncoder+set in V8
  let n = text.length;
  let byteCount = 0;

  // Write the byte count first
  for (let i = 0; i < n; i++) {
    let c = text.charCodeAt(i);
    if (c >= 0xD800 && c <= 0xDBFF && i + 1 < n) {
      c = (c << 10) + text.charCodeAt(++i) - 0x35FDC00;
    }
    byteCount += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;
  }
  writeVarint32(bb, byteCount);

  let offset = grow(bb, byteCount);
  let bytes = bb.bytes;

  // Then write the bytes
  for (let i = 0; i < n; i++) {
    let c = text.charCodeAt(i);
    if (c >= 0xD800 && c <= 0xDBFF && i + 1 < n) {
      c = (c << 10) + text.charCodeAt(++i) - 0x35FDC00;
    }
    if (c < 0x80) {
      bytes[offset++] = c;
    } else {
      if (c < 0x800) {
        bytes[offset++] = ((c >> 6) & 0x1F) | 0xC0;
      } else {
        if (c < 0x10000) {
          bytes[offset++] = ((c >> 12) & 0x0F) | 0xE0;
        } else {
          bytes[offset++] = ((c >> 18) & 0x07) | 0xF0;
          bytes[offset++] = ((c >> 12) & 0x3F) | 0x80;
        }
        bytes[offset++] = ((c >> 6) & 0x3F) | 0x80;
      }
      bytes[offset++] = (c & 0x3F) | 0x80;
    }
  }
}

function writeByteBuffer(bb, buffer) {
  let offset = grow(bb, buffer.limit);
  let from = bb.bytes;
  let to = buffer.bytes;

  // This for loop is much faster than subarray+set on V8
  for (let i = 0, n = buffer.limit; i < n; i++) {
    from[i + offset] = to[i];
  }
}

function readByte(bb) {
  return bb.bytes[advance(bb, 1)];
}

function writeByte(bb, value) {
  let offset = grow(bb, 1);
  bb.bytes[offset] = value;
}

function readFloat(bb) {
  let offset = advance(bb, 4);
  let bytes = bb.bytes;

  // Manual copying is much faster than subarray+set in V8
  f32_u8[0] = bytes[offset++];
  f32_u8[1] = bytes[offset++];
  f32_u8[2] = bytes[offset++];
  f32_u8[3] = bytes[offset++];
  return f32[0];
}

function writeFloat(bb, value) {
  let offset = grow(bb, 4);
  let bytes = bb.bytes;
  f32[0] = value;

  // Manual copying is much faster than subarray+set in V8
  bytes[offset++] = f32_u8[0];
  bytes[offset++] = f32_u8[1];
  bytes[offset++] = f32_u8[2];
  bytes[offset++] = f32_u8[3];
}

function readDouble(bb) {
  let offset = advance(bb, 8);
  let bytes = bb.bytes;

  // Manual copying is much faster than subarray+set in V8
  f64_u8[0] = bytes[offset++];
  f64_u8[1] = bytes[offset++];
  f64_u8[2] = bytes[offset++];
  f64_u8[3] = bytes[offset++];
  f64_u8[4] = bytes[offset++];
  f64_u8[5] = bytes[offset++];
  f64_u8[6] = bytes[offset++];
  f64_u8[7] = bytes[offset++];
  return f64[0];
}

function writeDouble(bb, value) {
  let offset = grow(bb, 8);
  let bytes = bb.bytes;
  f64[0] = value;

  // Manual copying is much faster than subarray+set in V8
  bytes[offset++] = f64_u8[0];
  bytes[offset++] = f64_u8[1];
  bytes[offset++] = f64_u8[2];
  bytes[offset++] = f64_u8[3];
  bytes[offset++] = f64_u8[4];
  bytes[offset++] = f64_u8[5];
  bytes[offset++] = f64_u8[6];
  bytes[offset++] = f64_u8[7];
}

function readInt32(bb) {
  let offset = advance(bb, 4);
  let bytes = bb.bytes;
  return (
    bytes[offset] |
    (bytes[offset + 1] << 8) |
    (bytes[offset + 2] << 16) |
    (bytes[offset + 3] << 24)
  );
}

function writeInt32(bb, value) {
  let offset = grow(bb, 4);
  let bytes = bb.bytes;
  bytes[offset] = value;
  bytes[offset + 1] = value >> 8;
  bytes[offset + 2] = value >> 16;
  bytes[offset + 3] = value >> 24;
}

function readInt64(bb, unsigned) {
  return {
    low: readInt32(bb),
    high: readInt32(bb),
    unsigned,
  };
}

function writeInt64(bb, value) {
  writeInt32(bb, value.low);
  writeInt32(bb, value.high);
}

function readVarint32(bb) {
  let c = 0;
  let value = 0;
  let b;
  do {
    b = readByte(bb);
    if (c < 32) value |= (b & 0x7F) << c;
    c += 7;
  } while (b & 0x80);
  return value;
}

function writeVarint32(bb, value) {
  value >>>= 0;
  while (value >= 0x80) {
    writeByte(bb, (value & 0x7f) | 0x80);
    value >>>= 7;
  }
  writeByte(bb, value);
}

function readVarint64(bb, unsigned) {
  let part0 = 0;
  let part1 = 0;
  let part2 = 0;
  let b;

  b = readByte(bb); part0 = (b & 0x7F); if (b & 0x80) {
    b = readByte(bb); part0 |= (b & 0x7F) << 7; if (b & 0x80) {
      b = readByte(bb); part0 |= (b & 0x7F) << 14; if (b & 0x80) {
        b = readByte(bb); part0 |= (b & 0x7F) << 21; if (b & 0x80) {

          b = readByte(bb); part1 = (b & 0x7F); if (b & 0x80) {
            b = readByte(bb); part1 |= (b & 0x7F) << 7; if (b & 0x80) {
              b = readByte(bb); part1 |= (b & 0x7F) << 14; if (b & 0x80) {
                b = readByte(bb); part1 |= (b & 0x7F) << 21; if (b & 0x80) {

                  b = readByte(bb); part2 = (b & 0x7F); if (b & 0x80) {
                    b = readByte(bb); part2 |= (b & 0x7F) << 7;
                  }
                }
              }
            }
          }
        }
      }
    }
  }

  return {
    low: part0 | (part1 << 28),
    high: (part1 >>> 4) | (part2 << 24),
    unsigned,
  };
}

function writeVarint64(bb, value) {
  let part0 = value.low >>> 0;
  let part1 = ((value.low >>> 28) | (value.high << 4)) >>> 0;
  let part2 = value.high >>> 24;

  // ref: src/google/protobuf/io/coded_stream.cc
  let size =
    part2 === 0 ?
      part1 === 0 ?
        part0 < 1 << 14 ?
          part0 < 1 << 7 ? 1 : 2 :
          part0 < 1 << 21 ? 3 : 4 :
        part1 < 1 << 14 ?
          part1 < 1 << 7 ? 5 : 6 :
          part1 < 1 << 21 ? 7 : 8 :
      part2 < 1 << 7 ? 9 : 10;

  let offset = grow(bb, size);
  let bytes = bb.bytes;

  switch (size) {
    case 10: bytes[offset + 9] = (part2 >>> 7) & 0x01;
    case 9: bytes[offset + 8] = size !== 9 ? part2 | 0x80 : part2 & 0x7F;
    case 8: bytes[offset + 7] = size !== 8 ? (part1 >>> 21) | 0x80 : (part1 >>> 21) & 0x7F;
    case 7: bytes[offset + 6] = size !== 7 ? (part1 >>> 14) | 0x80 : (part1 >>> 14) & 0x7F;
    case 6: bytes[offset + 5] = size !== 6 ? (part1 >>> 7) | 0x80 : (part1 >>> 7) & 0x7F;
    case 5: bytes[offset + 4] = size !== 5 ? part1 | 0x80 : part1 & 0x7F;
    case 4: bytes[offset + 3] = size !== 4 ? (part0 >>> 21) | 0x80 : (part0 >>> 21) & 0x7F;
    case 3: bytes[offset + 2] = size !== 3 ? (part0 >>> 14) | 0x80 : (part0 >>> 14) & 0x7F;
    case 2: bytes[offset + 1] = size !== 2 ? (part0 >>> 7) | 0x80 : (part0 >>> 7) & 0x7F;
    case 1: bytes[offset] = size !== 1 ? part0 | 0x80 : part0 & 0x7F;
  }
}

function readVarint32ZigZag(bb) {
  let value = readVarint32(bb);

  // ref: src/google/protobuf/wire_format_lite.h
  return (value >>> 1) ^ -(value & 1);
}

function writeVarint32ZigZag(bb, value) {
  // ref: src/google/protobuf/wire_format_lite.h
  writeVarint32(bb, (value << 1) ^ (value >> 31));
}

function readVarint64ZigZag(bb) {
  let value = readVarint64(bb, /* unsigned */ false);
  let low = value.low;
  let high = value.high;
  let flip = -(low & 1);

  // ref: src/google/protobuf/wire_format_lite.h
  return {
    low: ((low >>> 1) | (high << 31)) ^ flip,
    high: (high >>> 1) ^ flip,
    unsigned: false,
  };
}

function writeVarint64ZigZag(bb, value) {
  let low = value.low;
  let high = value.high;
  let flip = high >> 31;

  // ref: src/google/protobuf/wire_format_lite.h
  writeVarint64(bb, {
    low: (low << 1) ^ flip,
    high: ((high << 1) | (low >>> 31)) ^ flip,
    unsigned: false,
  });
}
